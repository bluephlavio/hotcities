!(function (e) { function t(r) { if (n[r]) return n[r].exports; const i = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(i.exports, i, i.exports, t), i.l = !0, i.exports; } var n = {}; t.m = e, t.c = n, t.d = function (e, n, r) { t.o(e, n) || Object.defineProperty(e, n, { configurable: !1, enumerable: !0, get: r }); }, t.n = function (e) { const n = e && e.__esModule ? function () { return e.default; } : function () { return e; }; return t.d(n, 'a', n), n; }, t.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, t.p = '/', t(t.s = 32); }([function (e, t, n) {
  e.exports = n(40);
}, function (e, t, n) { e.exports = n(49)(); }, function (e, t, n) {
  const r = function () {}; e.exports = r;
}, function (e, t, n) {
  const r = function (e, t, n, r, i, o, a, s) { if (!e) { let l; if (void 0 === t)l = new Error('Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.'); else { const u = [n, r, i, o, a, s]; let c = 0; l = new Error(t.replace(/%s/g, () => u[c++])), l.name = 'Invariant Violation'; } throw l.framesToPop = 1, l; } }; e.exports = r;
}, function (e, t) { let n; n = (function () { return this; }()); try { n = n || Function('return this')() || (0, eval)('this'); } catch (e) { typeof window === 'object' && (n = window); }e.exports = n; }, function (e, t, n) {
  t.__esModule = !0; const r = (t.addLeadingSlash = function (e) { return e.charAt(0) === '/' ? e : `/${e}`; }, t.stripLeadingSlash = function (e) { return e.charAt(0) === '/' ? e.substr(1) : e; }, t.hasBasename = function (e, t) { return new RegExp(`^${t}(\\/|\\?|#|$)`, 'i').test(e); }); t.stripBasename = function (e, t) { return r(e, t) ? e.substr(t.length) : e; }, t.stripTrailingSlash = function (e) { return e.charAt(e.length - 1) === '/' ? e.slice(0, -1) : e; }, t.parsePath = function (e) { let t = e || '/'; let n = ''; let r = ''; const i = t.indexOf('#'); i !== -1 && (r = t.substr(i), t = t.substr(0, i)); const o = t.indexOf('?'); return o !== -1 && (n = t.substr(o), t = t.substr(0, o)), { pathname: t, search: n === '?' ? '' : n, hash: r === '#' ? '' : r }; }, t.createPath = function (e) { const t = e.pathname; const n = e.search; const r = e.hash; let i = t || '/'; return n && n !== '?' && (i += n.charAt(0) === '?' ? n : `?${n}`), r && r !== '#' && (i += r.charAt(0) === '#' ? r : `#${r}`), i; };
}, function (e, t, n) {
  n.d(t, 'a', () => r), n.d(t, 'f', () => i), n.d(t, 'c', () => o), n.d(t, 'e', () => a), n.d(t, 'g', () => s), n.d(t, 'd', () => l), n.d(t, 'b', () => u); var r = function (e) { return e.charAt(0) === '/' ? e : `/${e}`; }; var i = function (e) { return e.charAt(0) === '/' ? e.substr(1) : e; }; var o = function (e, t) { return new RegExp(`^${t}(\\/|\\?|#|$)`, 'i').test(e); }; var a = function (e, t) { return o(e, t) ? e.substr(t.length) : e; }; var s = function (e) { return e.charAt(e.length - 1) === '/' ? e.slice(0, -1) : e; }; var l = function (e) { let t = e || '/'; let n = ''; let r = ''; const i = t.indexOf('#'); i !== -1 && (r = t.substr(i), t = t.substr(0, i)); const o = t.indexOf('?'); return o !== -1 && (n = t.substr(o), t = t.substr(0, o)), { pathname: t, search: n === '?' ? '' : n, hash: r === '#' ? '' : r }; }; var u = function (e) { const t = e.pathname; const n = e.search; const r = e.hash; let i = t || '/'; return n && n !== '?' && (i += n.charAt(0) === '?' ? n : `?${n}`), r && r !== '#' && (i += r.charAt(0) === '#' ? r : `#${r}`), i; };
}, function (e, t, n) {
  function r(e) { if (e === null || void 0 === e) throw new TypeError('Object.assign cannot be called with null or undefined'); return Object(e); } const i = Object.getOwnPropertySymbols; const o = Object.prototype.hasOwnProperty; const a = Object.prototype.propertyIsEnumerable; e.exports = (function () { try { if (!Object.assign) return !1; const e = new String('abc'); if (e[5] = 'de', Object.getOwnPropertyNames(e)[0] === '5') return !1; for (var t = {}, n = 0; n < 10; n++)t[`_${String.fromCharCode(n)}`] = n; if (Object.getOwnPropertyNames(t).map(e => t[e]).join('') !== '0123456789') return !1; const r = {}; return 'abcdefghijklmnopqrst'.split('').forEach((e) => { r[e] = e; }), Object.keys(Object.assign({}, r)).join('') === 'abcdefghijklmnopqrst'; } catch (e) { return !1; } }()) ? Object.assign : function (e, t) { for (var n, s, l = r(e), u = 1; u < arguments.length; u++) { n = Object(arguments[u]); for (const c in n)o.call(n, c) && (l[c] = n[c]); if (i) { s = i(n); for (let p = 0; p < s.length; p++)a.call(n, s[p]) && (l[s[p]] = n[s[p]]); } } return l; };
}, function (e, t, n) {
  function r(e, t, n, r, o, a, s, l) { if (i(t), !e) { let u; if (void 0 === t)u = new Error('Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.'); else { const c = [n, r, o, a, s, l]; let p = 0; u = new Error(t.replace(/%s/g, () => c[p++])), u.name = 'Invariant Violation'; } throw u.framesToPop = 1, u; } } var i = function (e) {}; e.exports = r;
}, function (e, t, n) {
  function r(e) { return function () { return e; }; } const i = function () {}; i.thatReturns = r, i.thatReturnsFalse = r(!1), i.thatReturnsTrue = r(!0), i.thatReturnsNull = r(null), i.thatReturnsThis = function () { return this; }, i.thatReturnsArgument = function (e) { return e; }, e.exports = i;
}, function (e, t, n) {
  const r = n(48); n.d(t, 'a', () => r.a); const i = (n(52), n(24)); n.d(t, 'b', () => i.a); const o = (n(54), n(57), n(60), n(62), n(25)); n.d(t, 'c', () => o.a); const a = (n(15), n(68), n(70)); n.d(t, 'd', () => a.a); n(72), n(73);
}, function (e, t, n) {
  n.d(t, 'a', () => s), n.d(t, 'b', () => l); const r = n(21); const i = n(22); const o = n(6); const a = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; var s = function (e, t, n, i) { let s = void 0; typeof e === 'string' ? (s = Object(o.d)(e), s.state = t) : (s = a({}, e), void 0 === s.pathname && (s.pathname = ''), s.search ? s.search.charAt(0) !== '?' && (s.search = `?${s.search}`) : s.search = '', s.hash ? s.hash.charAt(0) !== '#' && (s.hash = `#${s.hash}`) : s.hash = '', void 0 !== t && void 0 === s.state && (s.state = t)); try { s.pathname = decodeURI(s.pathname); } catch (e) { throw e instanceof URIError ? new URIError(`Pathname "${s.pathname}" could not be decoded. This is likely caused by an invalid percent-encoding.`) : e; } return n && (s.key = n), i ? s.pathname ? s.pathname.charAt(0) !== '/' && (s.pathname = Object(r.default)(s.pathname, i.pathname)) : s.pathname = i.pathname : s.pathname || (s.pathname = '/'), s; }; var l = function (e, t) { return e.pathname === t.pathname && e.search === t.search && e.hash === t.hash && e.key === t.key && Object(i.default)(e.state, t.state); };
}, function (e, t, n) {
  const r = {}; e.exports = r;
}, function (e, t, n) {
  function r(e) { return e && e.__esModule ? e : { default: e }; }t.__esModule = !0, t.locationsAreEqual = t.createLocation = void 0; const i = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const o = n(21); const a = r(o); const s = n(22); const l = r(s); const u = n(5); t.createLocation = function (e, t, n, r) { let o = void 0; typeof e === 'string' ? (o = (0, u.parsePath)(e), o.state = t) : (o = i({}, e), void 0 === o.pathname && (o.pathname = ''), o.search ? o.search.charAt(0) !== '?' && (o.search = `?${o.search}`) : o.search = '', o.hash ? o.hash.charAt(0) !== '#' && (o.hash = `#${o.hash}`) : o.hash = '', void 0 !== t && void 0 === o.state && (o.state = t)); try { o.pathname = decodeURI(o.pathname); } catch (e) { throw e instanceof URIError ? new URIError(`Pathname "${o.pathname}" could not be decoded. This is likely caused by an invalid percent-encoding.`) : e; } return n && (o.key = n), r ? o.pathname ? o.pathname.charAt(0) !== '/' && (o.pathname = (0, a.default)(o.pathname, r.pathname)) : o.pathname = r.pathname : o.pathname || (o.pathname = '/'), o; }, t.locationsAreEqual = function (e, t) { return e.pathname === t.pathname && e.search === t.search && e.hash === t.hash && e.key === t.key && (0, l.default)(e.state, t.state); };
}, function (e, t, n) {
  t.__esModule = !0; const r = n(2); const i = (function (e) { return e && e.__esModule ? e : { default: e }; }(r)); const o = function () {
    let e = null; const t = function (t) { return (0, i.default)(e == null, 'A history supports only one prompt at a time'), e = t, function () { e === t && (e = null); }; }; const n = function (t, n, r, o) { if (e != null) { const a = typeof e === 'function' ? e(t, n) : e; typeof a === 'string' ? typeof r === 'function' ? r(a, o) : ((0, i.default)(!1, 'A history needs a getUserConfirmation function in order to use a prompt message'), o(!0)) : o(!1 !== a); } else o(!0); }; let r = []; return {
      setPrompt: t, confirmTransitionTo: n, appendListener(e) { let t = !0; const n = function () { t && e(...arguments); }; return r.push(n), function () { t = !1, r = r.filter(e => e !== n); }; }, notifyListeners() { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; r.forEach(e => e(...t)); },
    };
  }; t.default = o;
}, function (e, t, n) {
  const r = n(16); t.a = r.a;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(2); const s = n.n(a); const l = n(3); const u = n.n(l); const c = n(0); const p = n.n(c); const f = n(1); const h = n.n(f); const d = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const m = (function (e) {
    function t() { let n; let o; let a; r(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = o = i(this, e.call(...[this].concat(l))), o.state = { match: o.computeMatch(o.props.history.location.pathname) }, a = n, i(o, a); } return o(t, e), t.prototype.getChildContext = function () { return { router: d({}, this.context.router, { history: this.props.history, route: { location: this.props.history.location, match: this.state.match } }) }; }, t.prototype.computeMatch = function (e) {
      return {
        path: '/', url: '/', params: {}, isExact: e === '/',
      };
    }, t.prototype.componentWillMount = function () { const e = this; const t = this.props; const n = t.children; const r = t.history; u()(n == null || p.a.Children.count(n) === 1, 'A <Router> may have only one child element'), this.unlisten = r.listen(() => { e.setState({ match: e.computeMatch(r.location.pathname) }); }); }, t.prototype.componentWillReceiveProps = function (e) { s()(this.props.history === e.history, 'You cannot change <Router history>'); }, t.prototype.componentWillUnmount = function () { this.unlisten(); }, t.prototype.render = function () { const e = this.props.children; return e ? p.a.Children.only(e) : null; }, t;
  }(p.a.Component)); m.propTypes = { history: h.a.object.isRequired, children: h.a.node }, m.contextTypes = { router: h.a.object }, m.childContextTypes = { router: h.a.object.isRequired }, t.a = m;
}, function (e, t, n) {
  const r = n(58); const i = n.n(r); const o = {}; let a = 0; const s = function (e, t) { const n = `${t.end}${t.strict}${t.sensitive}`; const r = o[n] || (o[n] = {}); if (r[e]) return r[e]; const s = []; const l = i()(e, s, t); const u = { re: l, keys: s }; return a < 1e4 && (r[e] = u, a++), u; }; const l = function (e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; typeof t === 'string' && (t = { path: t }); const n = t; const r = n.path; const i = void 0 === r ? '/' : r; const o = n.exact; const a = void 0 !== o && o; const l = n.strict; const u = void 0 !== l && l; const c = n.sensitive; const p = void 0 !== c && c; const f = s(i, { end: a, strict: u, sensitive: p }); const h = f.re; const d = f.keys; const m = h.exec(e); if (!m) return null; const g = m[0]; const y = m.slice(1); const v = e === g; return a && !v ? null : {
      path: i, url: i === '/' && g === '' ? '/' : g, isExact: v, params: d.reduce((e, t, n) => e[t.name] = y[n], e, {}),
    };
  }; t.a = l;
}, function (e, t, n) {
  const r = n(2); const i = n.n(r); const o = function () {
    let e = null; const t = function (t) { return i()(e == null, 'A history supports only one prompt at a time'), e = t, function () { e === t && (e = null); }; }; const n = function (t, n, r, o) { if (e != null) { const a = typeof e === 'function' ? e(t, n) : e; typeof a === 'string' ? typeof r === 'function' ? r(a, o) : (i()(!1, 'A history needs a getUserConfirmation function in order to use a prompt message'), o(!0)) : o(!1 !== a); } else o(!0); }; let r = []; return {
      setPrompt: t, confirmTransitionTo: n, appendListener(e) { let t = !0; const n = function () { t && e(...arguments); }; return r.push(n), function () { t = !1, r = r.filter(e => e !== n); }; }, notifyListeners() { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; r.forEach(e => e(...t)); },
    };
  }; t.a = o;
}, function (e, t, n) {
  function r() {} function i(e) { try { return e.then; } catch (e) { return y = e, v; } } function o(e, t) { try { return e(t); } catch (e) { return y = e, v; } } function a(e, t, n) { try { e(t, n); } catch (e) { return y = e, v; } } function s(e) { if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new'); if (typeof e !== 'function') throw new TypeError("Promise constructor's argument is not a function"); this._75 = 0, this._83 = 0, this._18 = null, this._38 = null, e !== r && m(e, this); } function l(e, t, n) { return new e.constructor(((i, o) => { const a = new s(r); a.then(i, o), u(e, new d(t, n, a)); })); } function u(e, t) { for (;e._83 === 3;)e = e._18; if (s._47 && s._47(e), e._83 === 0) return e._75 === 0 ? (e._75 = 1, void (e._38 = t)) : e._75 === 1 ? (e._75 = 2, void (e._38 = [e._38, t])) : void e._38.push(t); c(e, t); } function c(e, t) { g(() => { const n = e._83 === 1 ? t.onFulfilled : t.onRejected; if (n === null) return void (e._83 === 1 ? p(t.promise, e._18) : f(t.promise, e._18)); const r = o(n, e._18); r === v ? f(t.promise, y) : p(t.promise, r); }); } function p(e, t) { if (t === e) return f(e, new TypeError('A promise cannot be resolved with itself.')); if (t && (typeof t === 'object' || typeof t === 'function')) { const n = i(t); if (n === v) return f(e, y); if (n === e.then && t instanceof s) return e._83 = 3, e._18 = t, void h(e); if (typeof n === 'function') return void m(n.bind(t), e); }e._83 = 1, e._18 = t, h(e); } function f(e, t) { e._83 = 2, e._18 = t, s._71 && s._71(e, t), h(e); } function h(e) { if (e._75 === 1 && (u(e, e._38), e._38 = null), e._75 === 2) { for (let t = 0; t < e._38.length; t++)u(e, e._38[t]); e._38 = null; } } function d(e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n; } function m(e, t) { let n = !1; const r = a(e, (e) => { n || (n = !0, p(t, e)); }, (e) => { n || (n = !0, f(t, e)); }); n || r !== v || (n = !0, f(t, y)); } var g = n(35); var y = null; var v = {}; e.exports = s, s._47 = null, s._71 = null, s._44 = r, s.prototype.then = function (e, t) { if (this.constructor !== s) return l(this, e, t); const n = new s(r); return u(this, new d(e, t, n)), n; };
}, function (e, t, n) {
  function r() { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE === 'function') try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r); } catch (e) { console.error(e); } }r(), e.exports = n(41);
}, function (e, t, n) {
  function r(e) { return e.charAt(0) === '/'; } function i(e, t) { for (let n = t, r = n + 1, i = e.length; r < i; n += 1, r += 1)e[n] = e[r]; e.pop(); } function o(e) {
    const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''; const n = e && e.split('/') || []; let o = t && t.split('/') || [];


    const a = e && r(e);


    const s = t && r(t); const
      l = a || s; if (e && r(e) ? o = n : n.length && (o.pop(), o = o.concat(n)), !o.length) return '/'; let u = void 0; if (o.length) { const c = o[o.length - 1]; u = c === '.' || c === '..' || c === ''; } else u = !1; for (var p = 0, f = o.length; f >= 0; f--) { const h = o[f]; h === '.' ? i(o, f) : h === '..' ? (i(o, f), p++) : p && (i(o, f), p--); } if (!l) for (;p--; p)o.unshift('..'); !l || o[0] === '' || o[0] && r(o[0]) || o.unshift(''); let d = o.join('/'); return u && d.substr(-1) !== '/' && (d += '/'), d;
  }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = o;
}, function (e, t, n) {
  function r(e, t) { if (e === t) return !0; if (e == null || t == null) return !1; if (Array.isArray(e)) return Array.isArray(t) && e.length === t.length && e.every((e, n) => r(e, t[n])); const n = typeof e === 'undefined' ? 'undefined' : i(e); if (n !== (typeof t === 'undefined' ? 'undefined' : i(t))) return !1; if (n === 'object') { const o = e.valueOf(); const a = t.valueOf(); if (o !== e || a !== t) return r(o, a); const s = Object.keys(e); const l = Object.keys(t); return s.length === l.length && s.every(n => r(e[n], t[n])); } return !1; }Object.defineProperty(t, '__esModule', { value: !0 }); var i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; t.default = r;
}, function (e, t, n) {
  t.__esModule = !0; t.canUseDOM = !(typeof window === 'undefined' || !window.document || !window.document.createElement), t.addEventListener = function (e, t, n) { return e.addEventListener ? e.addEventListener(t, n, !1) : e.attachEvent(`on${t}`, n); }, t.removeEventListener = function (e, t, n) { return e.removeEventListener ? e.removeEventListener(t, n, !1) : e.detachEvent(`on${t}`, n); }, t.getConfirmation = function (e, t) { return t(window.confirm(e)); }, t.supportsHistory = function () { const e = window.navigator.userAgent; return (e.indexOf('Android 2.') === -1 && e.indexOf('Android 4.0') === -1 || e.indexOf('Mobile Safari') === -1 || e.indexOf('Chrome') !== -1 || e.indexOf('Windows Phone') !== -1) && (window.history && 'pushState' in window.history); }, t.supportsPopStateOnHashChange = function () { return window.navigator.userAgent.indexOf('Trident') === -1; }, t.supportsGoWithoutReloadUsingHash = function () { return window.navigator.userAgent.indexOf('Firefox') === -1; }, t.isExtraneousPopstateEvent = function (e) { return void 0 === e.state && navigator.userAgent.indexOf('CriOS') === -1; };
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } function i(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function o(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function a(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const s = n(0); const l = n.n(s); const u = n(1); const c = n.n(u); const p = n(3); const f = n.n(p); const h = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const d = function (e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey); }; const m = (function (e) { function t() { let n; let r; let a; i(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = r = o(this, e.call(...[this].concat(l))), r.handleClick = function (e) { if (r.props.onClick && r.props.onClick(e), !e.defaultPrevented && e.button === 0 && !r.props.target && !d(e)) { e.preventDefault(); const t = r.context.router.history; const n = r.props; const i = n.replace; const o = n.to; i ? t.replace(o) : t.push(o); } }, a = n, o(r, a); } return a(t, e), t.prototype.render = function () { const e = this.props; const t = (e.replace, e.to); const n = e.innerRef; const i = r(e, ['replace', 'to', 'innerRef']); f()(this.context.router, 'You should not use <Link> outside a <Router>'); const o = this.context.router.history.createHref(typeof t === 'string' ? { pathname: t } : t); return l.a.createElement('a', h({}, i, { onClick: this.handleClick, href: o, ref: n })); }, t; }(l.a.Component)); m.propTypes = {
    onClick: c.a.func, target: c.a.string, replace: c.a.bool, to: c.a.oneOfType([c.a.string, c.a.object]).isRequired, innerRef: c.a.oneOfType([c.a.string, c.a.func]),
  }, m.defaultProps = { replace: !1 }, m.contextTypes = { router: c.a.shape({ history: c.a.shape({ push: c.a.func.isRequired, replace: c.a.func.isRequired, createHref: c.a.func.isRequired }).isRequired }).isRequired }, t.a = m;
}, function (e, t, n) {
  const r = n(26); t.a = r.a;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(2); const s = n.n(a); const l = n(3); const u = n.n(l); const c = n(0); const p = n.n(c); const f = n(1); const h = n.n(f); const d = n(17); const m = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const g = function (e) { return p.a.Children.count(e) === 0; }; const y = (function (e) {
    function t() { let n; let o; let a; r(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = o = i(this, e.call(...[this].concat(l))), o.state = { match: o.computeMatch(o.props, o.context.router) }, a = n, i(o, a); } return o(t, e), t.prototype.getChildContext = function () { return { router: m({}, this.context.router, { route: { location: this.props.location || this.context.router.route.location, match: this.state.match } }) }; }, t.prototype.computeMatch = function (e, t) {
      const n = e.computedMatch; const r = e.location; const i = e.path; const o = e.strict; const a = e.exact; const s = e.sensitive; if (n) return n; u()(t, 'You should not use <Route> or withRouter() outside a <Router>'); const l = t.route; const c = (r || l.location).pathname; return i ? Object(d.a)(c, {
        path: i, strict: o, exact: a, sensitive: s,
      }) : l.match;
    }, t.prototype.componentWillMount = function () { s()(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored'), s()(!(this.props.component && this.props.children && !g(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored'), s()(!(this.props.render && this.props.children && !g(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored'); }, t.prototype.componentWillReceiveProps = function (e, t) { s()(!(e.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'), s()(!(!e.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'), this.setState({ match: this.computeMatch(e, t.router) }); }, t.prototype.render = function () {
      const e = this.state.match; const t = this.props; const n = t.children; const r = t.component; const i = t.render; const o = this.context.router; const a = o.history; const s = o.route; const l = o.staticContext; const u = this.props.location || s.location; const c = {
        match: e, location: u, history: a, staticContext: l,
      }; return r ? e ? p.a.createElement(r, c) : null : i ? e ? i(c) : null : n ? typeof n === 'function' ? n(c) : g(n) ? null : p.a.Children.only(n) : null;
    }, t;
  }(p.a.Component)); y.propTypes = {
    computedMatch: h.a.object, path: h.a.string, exact: h.a.bool, strict: h.a.bool, sensitive: h.a.bool, component: h.a.func, render: h.a.func, children: h.a.oneOfType([h.a.func, h.a.node]), location: h.a.object,
  }, y.contextTypes = { router: h.a.shape({ history: h.a.object.isRequired, route: h.a.object.isRequired, staticContext: h.a.object }) }, y.childContextTypes = { router: h.a.object.isRequired }, t.a = y;
}, function (e, t, n) {
  n.d(t, 'b', () => r), n.d(t, 'a', () => i), n.d(t, 'e', () => o), n.d(t, 'c', () => a), n.d(t, 'g', () => s), n.d(t, 'h', () => l), n.d(t, 'f', () => u), n.d(t, 'd', () => c); var r = !(typeof window === 'undefined' || !window.document || !window.document.createElement); var i = function (e, t, n) { return e.addEventListener ? e.addEventListener(t, n, !1) : e.attachEvent(`on${t}`, n); }; var o = function (e, t, n) { return e.removeEventListener ? e.removeEventListener(t, n, !1) : e.detachEvent(`on${t}`, n); }; var a = function (e, t) { return t(window.confirm(e)); }; var s = function () { const e = window.navigator.userAgent; return (e.indexOf('Android 2.') === -1 && e.indexOf('Android 4.0') === -1 || e.indexOf('Mobile Safari') === -1 || e.indexOf('Chrome') !== -1 || e.indexOf('Windows Phone') !== -1) && (window.history && 'pushState' in window.history); }; var l = function () { return window.navigator.userAgent.indexOf('Trident') === -1; }; var u = function () { return window.navigator.userAgent.indexOf('Firefox') === -1; }; var c = function (e) { return void 0 === e.state && navigator.userAgent.indexOf('CriOS') === -1; };
}, function (e, t, n) {
  (function (e, n) {
    let r; let i; !(function () {
      const o = typeof self === 'object' && self.self === self && self || typeof e === 'object' && e.global === e && e || this || {}; const a = o._; const s = Array.prototype; const l = Object.prototype; const u = typeof Symbol !== 'undefined' ? Symbol.prototype : null; const c = s.push; const p = s.slice; const f = l.toString; const h = l.hasOwnProperty; const d = Array.isArray; const m = Object.keys; const g = Object.create; const y = function () {}; var v = function (e) { return e instanceof v ? e : this instanceof v ? void (this._wrapped = e) : new v(e); }; typeof t === 'undefined' || t.nodeType ? o._ = v : (typeof n !== 'undefined' && !n.nodeType && n.exports && (t = n.exports = v), t._ = v), v.VERSION = '1.9.1'; let _; const b = function (e, t, n) { if (void 0 === t) return e; switch (n == null ? 3 : n) { case 1: return function (n) { return e.call(t, n); }; case 3: return function (n, r, i) { return e.call(t, n, r, i); }; case 4: return function (n, r, i, o) { return e.call(t, n, r, i, o); }; } return function () { return e.apply(t, arguments); }; }; const x = function (e, t, n) { return v.iteratee !== _ ? v.iteratee(e, t) : e == null ? v.identity : v.isFunction(e) ? b(e, t, n) : v.isObject(e) && !v.isArray(e) ? v.matcher(e) : v.property(e); }; v.iteratee = _ = function (e, t) { return x(e, t, 1 / 0); }; const w = function (e, t) { return t = t == null ? e.length - 1 : +t, function () { for (var n = Math.max(arguments.length - t, 0), r = Array(n), i = 0; i < n; i++)r[i] = arguments[i + t]; switch (t) { case 0: return e.call(this, r); case 1: return e.call(this, arguments[0], r); case 2: return e.call(this, arguments[0], arguments[1], r); } const o = Array(t + 1); for (i = 0; i < t; i++)o[i] = arguments[i]; return o[t] = r, e.apply(this, o); }; }; const E = function (e) { if (!v.isObject(e)) return {}; if (g) return g(e); y.prototype = e; const t = new y(); return y.prototype = null, t; }; const T = function (e) { return function (t) { return t == null ? void 0 : t[e]; }; }; const k = function (e, t) { return e != null && h.call(e, t); }; const C = function (e, t) { for (var n = t.length, r = 0; r < n; r++) { if (e == null) return; e = e[t[r]]; } return n ? e : void 0; }; const S = Math.pow(2, 53) - 1; const A = T('length'); const O = function (e) { const t = A(e); return typeof t === 'number' && t >= 0 && t <= S; }; v.each = v.forEach = function (e, t, n) { t = b(t, n); let r; let i; if (O(e)) for (r = 0, i = e.length; r < i; r++)t(e[r], r, e); else { const o = v.keys(e); for (r = 0, i = o.length; r < i; r++)t(e[o[r]], o[r], e); } return e; }, v.map = v.collect = function (e, t, n) { t = x(t, n); for (var r = !O(e) && v.keys(e), i = (r || e).length, o = Array(i), a = 0; a < i; a++) { const s = r ? r[a] : a; o[a] = t(e[s], s, e); } return o; }; const I = function (e) { const t = function (t, n, r, i) { const o = !O(t) && v.keys(t); const a = (o || t).length; let s = e > 0 ? 0 : a - 1; for (i || (r = t[o ? o[s] : s], s += e); s >= 0 && s < a; s += e) { const l = o ? o[s] : s; r = n(r, t[l], l, t); } return r; }; return function (e, n, r, i) { const o = arguments.length >= 3; return t(e, b(n, i, 4), r, o); }; }; v.reduce = v.foldl = v.inject = I(1), v.reduceRight = v.foldr = I(-1), v.find = v.detect = function (e, t, n) { const r = O(e) ? v.findIndex : v.findKey; const i = r(e, t, n); if (void 0 !== i && i !== -1) return e[i]; }, v.filter = v.select = function (e, t, n) { const r = []; return t = x(t, n), v.each(e, (e, n, i) => { t(e, n, i) && r.push(e); }), r; }, v.reject = function (e, t, n) { return v.filter(e, v.negate(x(t)), n); }, v.every = v.all = function (e, t, n) { t = x(t, n); for (let r = !O(e) && v.keys(e), i = (r || e).length, o = 0; o < i; o++) { const a = r ? r[o] : o; if (!t(e[a], a, e)) return !1; } return !0; }, v.some = v.any = function (e, t, n) { t = x(t, n); for (let r = !O(e) && v.keys(e), i = (r || e).length, o = 0; o < i; o++) { const a = r ? r[o] : o; if (t(e[a], a, e)) return !0; } return !1; }, v.contains = v.includes = v.include = function (e, t, n, r) { return O(e) || (e = v.values(e)), (typeof n !== 'number' || r) && (n = 0), v.indexOf(e, t, n) >= 0; }, v.invoke = w((e, t, n) => { let r; let i; return v.isFunction(t) ? i = t : v.isArray(t) && (r = t.slice(0, -1), t = t[t.length - 1]), v.map(e, (e) => { let o = i; if (!o) { if (r && r.length && (e = C(e, r)), e == null) return; o = e[t]; } return o == null ? o : o.apply(e, n); }); }), v.pluck = function (e, t) { return v.map(e, v.property(t)); }, v.where = function (e, t) { return v.filter(e, v.matcher(t)); }, v.findWhere = function (e, t) { return v.find(e, v.matcher(t)); }, v.max = function (e, t, n) { let r; let i; let o = -1 / 0; let a = -1 / 0; if (t == null || typeof t === 'number' && typeof e[0] !== 'object' && e != null) { e = O(e) ? e : v.values(e); for (let s = 0, l = e.length; s < l; s++)(r = e[s]) != null && r > o && (o = r); } else t = x(t, n), v.each(e, (e, n, r) => { ((i = t(e, n, r)) > a || i === -1 / 0 && o === -1 / 0) && (o = e, a = i); }); return o; }, v.min = function (e, t, n) { let r; let i; let o = 1 / 0; let a = 1 / 0; if (t == null || typeof t === 'number' && typeof e[0] !== 'object' && e != null) { e = O(e) ? e : v.values(e); for (let s = 0, l = e.length; s < l; s++)(r = e[s]) != null && r < o && (o = r); } else t = x(t, n), v.each(e, (e, n, r) => { ((i = t(e, n, r)) < a || i === 1 / 0 && o === 1 / 0) && (o = e, a = i); }); return o; }, v.shuffle = function (e) { return v.sample(e, 1 / 0); }, v.sample = function (e, t, n) { if (t == null || n) return O(e) || (e = v.values(e)), e[v.random(e.length - 1)]; const r = O(e) ? v.clone(e) : v.values(e); const i = A(r); t = Math.max(Math.min(t, i), 0); for (let o = i - 1, a = 0; a < t; a++) { const s = v.random(a, o); const l = r[a]; r[a] = r[s], r[s] = l; } return r.slice(0, t); }, v.sortBy = function (e, t, n) { let r = 0; return t = x(t, n), v.pluck(v.map(e, (e, n, i) => ({ value: e, index: r++, criteria: t(e, n, i) })).sort((e, t) => { const n = e.criteria; const r = t.criteria; if (n !== r) { if (n > r || void 0 === n) return 1; if (n < r || void 0 === r) return -1; } return e.index - t.index; }), 'value'); }; const P = function (e, t) { return function (n, r, i) { const o = t ? [[], []] : {}; return r = x(r, i), v.each(n, (t, i) => { const a = r(t, i, n); e(o, t, a); }), o; }; }; v.groupBy = P((e, t, n) => { k(e, n) ? e[n].push(t) : e[n] = [t]; }), v.indexBy = P((e, t, n) => { e[n] = t; }), v.countBy = P((e, t, n) => { k(e, n) ? e[n]++ : e[n] = 1; }); const M = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g; v.toArray = function (e) { return e ? v.isArray(e) ? p.call(e) : v.isString(e) ? e.match(M) : O(e) ? v.map(e, v.identity) : v.values(e) : []; }, v.size = function (e) { return e == null ? 0 : O(e) ? e.length : v.keys(e).length; }, v.partition = P((e, t, n) => { e[n ? 0 : 1].push(t); }, !0), v.first = v.head = v.take = function (e, t, n) { return e == null || e.length < 1 ? t == null ? void 0 : [] : t == null || n ? e[0] : v.initial(e, e.length - t); }, v.initial = function (e, t, n) { return p.call(e, 0, Math.max(0, e.length - (t == null || n ? 1 : t))); }, v.last = function (e, t, n) { return e == null || e.length < 1 ? t == null ? void 0 : [] : t == null || n ? e[e.length - 1] : v.rest(e, Math.max(0, e.length - t)); }, v.rest = v.tail = v.drop = function (e, t, n) { return p.call(e, t == null || n ? 1 : t); }, v.compact = function (e) { return v.filter(e, Boolean); }; var N = function (e, t, n, r) { r = r || []; for (let i = r.length, o = 0, a = A(e); o < a; o++) { const s = e[o]; if (O(s) && (v.isArray(s) || v.isArguments(s))) if (t) for (let l = 0, u = s.length; l < u;)r[i++] = s[l++]; else N(s, t, n, r), i = r.length; else n || (r[i++] = s); } return r; }; v.flatten = function (e, t) { return N(e, t, !1); }, v.without = w((e, t) => v.difference(e, t)), v.uniq = v.unique = function (e, t, n, r) { v.isBoolean(t) || (r = n, n = t, t = !1), n != null && (n = x(n, r)); for (var i = [], o = [], a = 0, s = A(e); a < s; a++) { const l = e[a]; const u = n ? n(l, a, e) : l; t && !n ? (a && o === u || i.push(l), o = u) : n ? v.contains(o, u) || (o.push(u), i.push(l)) : v.contains(i, l) || i.push(l); } return i; }, v.union = w(e => v.uniq(N(e, !0, !0))), v.intersection = function (e) { for (var t = [], n = arguments.length, r = 0, i = A(e); r < i; r++) { const o = e[r]; if (!v.contains(t, o)) { var a; for (a = 1; a < n && v.contains(arguments[a], o); a++);a === n && t.push(o); } } return t; }, v.difference = w((e, t) => t = N(t, !0, !0), v.filter(e, e => !v.contains(t, e))), v.unzip = function (e) { for (var t = e && v.max(e, A).length || 0, n = Array(t), r = 0; r < t; r++)n[r] = v.pluck(e, r); return n; }, v.zip = w(v.unzip), v.object = function (e, t) { for (var n = {}, r = 0, i = A(e); r < i; r++)t ? n[e[r]] = t[r] : n[e[r][0]] = e[r][1]; return n; }; const D = function (e) { return function (t, n, r) { n = x(n, r); for (let i = A(t), o = e > 0 ? 0 : i - 1; o >= 0 && o < i; o += e) if (n(t[o], o, t)) return o; return -1; }; }; v.findIndex = D(1), v.findLastIndex = D(-1), v.sortedIndex = function (e, t, n, r) { n = x(n, r, 1); for (var i = n(t), o = 0, a = A(e); o < a;) { const s = Math.floor((o + a) / 2); n(e[s]) < i ? o = s + 1 : a = s; } return o; }; const L = function (e, t, n) { return function (r, i, o) { let a = 0; let s = A(r); if (typeof o === 'number')e > 0 ? a = o >= 0 ? o : Math.max(o + s, a) : s = o >= 0 ? Math.min(o + 1, s) : o + s + 1; else if (n && o && s) return o = n(r, i), r[o] === i ? o : -1; if (i !== i) return o = t(p.call(r, a, s), v.isNaN), o >= 0 ? o + a : -1; for (o = e > 0 ? a : s - 1; o >= 0 && o < s; o += e) if (r[o] === i) return o; return -1; }; }; v.indexOf = L(1, v.findIndex, v.sortedIndex), v.lastIndexOf = L(-1, v.findLastIndex), v.range = function (e, t, n) { t == null && (t = e || 0, e = 0), n || (n = t < e ? -1 : 1); for (var r = Math.max(Math.ceil((t - e) / n), 0), i = Array(r), o = 0; o < r; o++, e += n)i[o] = e; return i; }, v.chunk = function (e, t) { if (t == null || t < 1) return []; for (var n = [], r = 0, i = e.length; r < i;)n.push(p.call(e, r, r += t)); return n; }; const z = function (e, t, n, r, i) { if (!(r instanceof t)) return e.apply(n, i); const o = E(e.prototype); const a = e.apply(o, i); return v.isObject(a) ? a : o; }; v.bind = w((e, t, n) => { if (!v.isFunction(e)) throw new TypeError('Bind must be called on a function'); var r = w(function (i) { return z(e, r, t, this, n.concat(i)); }); return r; }), v.partial = w((e, t) => { const n = v.partial.placeholder; var r = function () { for (var i = 0, o = t.length, a = Array(o), s = 0; s < o; s++)a[s] = t[s] === n ? arguments[i++] : t[s]; for (;i < arguments.length;)a.push(arguments[i++]); return z(e, r, this, this, a); }; return r; }), v.partial.placeholder = v, v.bindAll = w((e, t) => { t = N(t, !1, !1); let n = t.length; if (n < 1) throw new Error('bindAll must be passed function names'); for (;n--;) { const r = t[n]; e[r] = v.bind(e[r], e); } }), v.memoize = function (e, t) { var n = function (r) { const i = n.cache; const o = `${t ? t.apply(this, arguments) : r}`; return k(i, o) || (i[o] = e.apply(this, arguments)), i[o]; }; return n.cache = {}, n; }, v.delay = w((e, t, n) => setTimeout(() => e(...n), t)), v.defer = v.partial(v.delay, v, 1), v.throttle = function (e, t, n) { let r; let i; let o; let a; let s = 0; n || (n = {}); const l = function () { s = !1 === n.leading ? 0 : v.now(), r = null, a = e.apply(i, o), r || (i = o = null); }; const u = function () { const u = v.now(); s || !1 !== n.leading || (s = u); const c = t - (u - s); return i = this, o = arguments, c <= 0 || c > t ? (r && (clearTimeout(r), r = null), s = u, a = e.apply(i, o), r || (i = o = null)) : r || !1 === n.trailing || (r = setTimeout(l, c)), a; }; return u.cancel = function () { clearTimeout(r), s = 0, r = i = o = null; }, u; }, v.debounce = function (e, t, n) { let r; let i; const o = function (t, n) { r = null, n && (i = e.apply(t, n)); }; const a = w(function (a) { if (r && clearTimeout(r), n) { const s = !r; r = setTimeout(o, t), s && (i = e.apply(this, a)); } else r = v.delay(o, t, this, a); return i; }); return a.cancel = function () { clearTimeout(r), r = null; }, a; }, v.wrap = function (e, t) { return v.partial(t, e); }, v.negate = function (e) { return function () { return !e.apply(this, arguments); }; }, v.compose = function () { const e = arguments; const t = e.length - 1; return function () { for (var n = t, r = e[t].apply(this, arguments); n--;)r = e[n].call(this, r); return r; }; }, v.after = function (e, t) { return function () { if (--e < 1) return t.apply(this, arguments); }; }, v.before = function (e, t) { let n; return function () { return --e > 0 && (n = t.apply(this, arguments)), e <= 1 && (t = null), n; }; }, v.once = v.partial(v.before, 2), v.restArguments = w; const R = !{ toString: null }.propertyIsEnumerable('toString'); const j = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; const B = function (e, t) { let n = j.length; const r = e.constructor; const i = v.isFunction(r) && r.prototype || l; let o = 'constructor'; for (k(e, o) && !v.contains(t, o) && t.push(o); n--;)(o = j[n]) in e && e[o] !== i[o] && !v.contains(t, o) && t.push(o); }; v.keys = function (e) { if (!v.isObject(e)) return []; if (m) return m(e); const t = []; for (const n in e)k(e, n) && t.push(n); return R && B(e, t), t; }, v.allKeys = function (e) { if (!v.isObject(e)) return []; const t = []; for (const n in e)t.push(n); return R && B(e, t), t; }, v.values = function (e) { for (var t = v.keys(e), n = t.length, r = Array(n), i = 0; i < n; i++)r[i] = e[t[i]]; return r; }, v.mapObject = function (e, t, n) { t = x(t, n); for (var r = v.keys(e), i = r.length, o = {}, a = 0; a < i; a++) { const s = r[a]; o[s] = t(e[s], s, e); } return o; }, v.pairs = function (e) { for (var t = v.keys(e), n = t.length, r = Array(n), i = 0; i < n; i++)r[i] = [t[i], e[t[i]]]; return r; }, v.invert = function (e) { for (var t = {}, n = v.keys(e), r = 0, i = n.length; r < i; r++)t[e[n[r]]] = n[r]; return t; }, v.functions = v.methods = function (e) { const t = []; for (const n in e)v.isFunction(e[n]) && t.push(n); return t.sort(); }; const F = function (e, t) { return function (n) { const r = arguments.length; if (t && (n = Object(n)), r < 2 || n == null) return n; for (let i = 1; i < r; i++) for (let o = arguments[i], a = e(o), s = a.length, l = 0; l < s; l++) { const u = a[l]; t && void 0 !== n[u] || (n[u] = o[u]); } return n; }; }; v.extend = F(v.allKeys), v.extendOwn = v.assign = F(v.keys), v.findKey = function (e, t, n) { t = x(t, n); for (var r, i = v.keys(e), o = 0, a = i.length; o < a; o++) if (r = i[o], t(e[r], r, e)) return r; }; const U = function (e, t, n) { return t in n; }; v.pick = w((e, t) => { const n = {}; let r = t[0]; if (e == null) return n; v.isFunction(r) ? (t.length > 1 && (r = b(r, t[1])), t = v.allKeys(e)) : (r = U, t = N(t, !1, !1), e = Object(e)); for (let i = 0, o = t.length; i < o; i++) { const a = t[i]; const s = e[a]; r(s, a, e) && (n[a] = s); } return n; }), v.omit = w((e, t) => { let n; let r = t[0]; return v.isFunction(r) ? (r = v.negate(r), t.length > 1 && (n = t[1])) : (t = v.map(N(t, !1, !1), String), r = function (e, n) { return !v.contains(t, n); }), v.pick(e, r, n); }), v.defaults = F(v.allKeys, !0), v.create = function (e, t) { const n = E(e); return t && v.extendOwn(n, t), n; }, v.clone = function (e) { return v.isObject(e) ? v.isArray(e) ? e.slice() : v.extend({}, e) : e; }, v.tap = function (e, t) { return t(e), e; }, v.isMatch = function (e, t) { const n = v.keys(t); const r = n.length; if (e == null) return !r; for (let i = Object(e), o = 0; o < r; o++) { const a = n[o]; if (t[a] !== i[a] || !(a in i)) return !1; } return !0; }; let V; let q; V = function (e, t, n, r) { if (e === t) return e !== 0 || 1 / e === 1 / t; if (e == null || t == null) return !1; if (e !== e) return t !== t; const i = typeof e; return (i === 'function' || i === 'object' || typeof t === 'object') && q(e, t, n, r); }, q = function (e, t, n, r) { e instanceof v && (e = e._wrapped), t instanceof v && (t = t._wrapped); const i = f.call(e); if (i !== f.call(t)) return !1; switch (i) { case '[object RegExp]': case '[object String]': return `${e}` === `${t}`; case '[object Number]': return +e !== +e ? +t !== +t : +e === 0 ? 1 / +e === 1 / t : +e === +t; case '[object Date]': case '[object Boolean]': return +e === +t; case '[object Symbol]': return u.valueOf.call(e) === u.valueOf.call(t); } const o = i === '[object Array]'; if (!o) { if (typeof e !== 'object' || typeof t !== 'object') return !1; const a = e.constructor; const s = t.constructor; if (a !== s && !(v.isFunction(a) && a instanceof a && v.isFunction(s) && s instanceof s) && 'constructor' in e && 'constructor' in t) return !1; }n = n || [], r = r || []; for (var l = n.length; l--;) if (n[l] === e) return r[l] === t; if (n.push(e), r.push(t), o) { if ((l = e.length) !== t.length) return !1; for (;l--;) if (!V(e[l], t[l], n, r)) return !1; } else { let c; const p = v.keys(e); if (l = p.length, v.keys(t).length !== l) return !1; for (;l--;) if (c = p[l], !k(t, c) || !V(e[c], t[c], n, r)) return !1; } return n.pop(), r.pop(), !0; }, v.isEqual = function (e, t) { return V(e, t); }, v.isEmpty = function (e) { return e == null || (O(e) && (v.isArray(e) || v.isString(e) || v.isArguments(e)) ? e.length === 0 : v.keys(e).length === 0); }, v.isElement = function (e) { return !(!e || e.nodeType !== 1); }, v.isArray = d || function (e) { return f.call(e) === '[object Array]'; }, v.isObject = function (e) { const t = typeof e; return t === 'function' || t === 'object' && !!e; }, v.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], (e) => { v[`is${e}`] = function (t) { return f.call(t) === `[object ${e}]`; }; }), v.isArguments(arguments) || (v.isArguments = function (e) { return k(e, 'callee'); }); const H = o.document && o.document.childNodes; typeof /./ !== 'function' && typeof Int8Array !== 'object' && typeof H !== 'function' && (v.isFunction = function (e) { return typeof e === 'function' || !1; }), v.isFinite = function (e) { return !v.isSymbol(e) && isFinite(e) && !isNaN(parseFloat(e)); }, v.isNaN = function (e) { return v.isNumber(e) && isNaN(e); }, v.isBoolean = function (e) { return !0 === e || !1 === e || f.call(e) === '[object Boolean]'; }, v.isNull = function (e) { return e === null; }, v.isUndefined = function (e) { return void 0 === e; }, v.has = function (e, t) { if (!v.isArray(t)) return k(e, t); for (var n = t.length, r = 0; r < n; r++) { const i = t[r]; if (e == null || !h.call(e, i)) return !1; e = e[i]; } return !!n; }, v.noConflict = function () { return o._ = a, this; }, v.identity = function (e) { return e; }, v.constant = function (e) { return function () { return e; }; }, v.noop = function () {}, v.property = function (e) { return v.isArray(e) ? function (t) { return C(t, e); } : T(e); }, v.propertyOf = function (e) { return e == null ? function () {} : function (t) { return v.isArray(t) ? C(e, t) : e[t]; }; }, v.matcher = v.matches = function (e) { return e = v.extendOwn({}, e), function (t) { return v.isMatch(t, e); }; }, v.times = function (e, t, n) { const r = Array(Math.max(0, e)); t = b(t, n, 1); for (let i = 0; i < e; i++)r[i] = t(i); return r; }, v.random = function (e, t) { return t == null && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1)); }, v.now = Date.now || function () { return (new Date()).getTime(); }; const W = {
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
      }; const $ = v.invert(W); const G = function (e) { const t = function (t) { return e[t]; }; const n = `(?:${v.keys(e).join('|')})`; const r = RegExp(n); const i = RegExp(n, 'g'); return function (e) { return e = e == null ? '' : `${e}`, r.test(e) ? e.replace(i, t) : e; }; }; v.escape = G(W), v.unescape = G($), v.result = function (e, t, n) { v.isArray(t) || (t = [t]); const r = t.length; if (!r) return v.isFunction(n) ? n.call(e) : n; for (let i = 0; i < r; i++) { let o = e == null ? void 0 : e[t[i]]; void 0 === o && (o = n, i = r), e = v.isFunction(o) ? o.call(e) : o; } return e; }; let Z = 0; v.uniqueId = function (e) { const t = `${++Z}`; return e ? e + t : t; }, v.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }; const K = /(.)^/; const X = {
        "'": "'", '\\': '\\', '\r': 'r', '\n': 'n', '\u2028': 'u2028', '\u2029': 'u2029',
      }; const Y = /\\|'|\r|\n|\u2028|\u2029/g; const J = function (e) { return `\\${X[e]}`; }; v.template = function (e, t, n) { !t && n && (t = n), t = v.defaults({}, t, v.templateSettings); const r = RegExp(`${[(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join('|')}|$`, 'g'); let i = 0; let o = "__p+='"; e.replace(r, (t, n, r, a, s) => o += e.slice(i, s).replace(Y, J), i = s + t.length, n ? o += `'+\n((__t=(${n}))==null?'':_.escape(__t))+\n'` : r ? o += `'+\n((__t=(${r}))==null?'':__t)+\n'` : a && (o += `';\n${a}\n__p+='`), t), o += "';\n", t.variable || (o = `with(obj||{}){\n${o}}\n`), o = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n${o}return __p;\n`; let a; try { a = new Function(t.variable || 'obj', '_', o); } catch (e) { throw e.source = o, e; } const s = function (e) { return a.call(this, e, v); }; return s.source = `function(${t.variable || 'obj'}){\n${o}}`, s; }, v.chain = function (e) { const t = v(e); return t._chain = !0, t; }; const Q = function (e, t) { return e._chain ? v(t).chain() : t; }; v.mixin = function (e) { return v.each(v.functions(e), (t) => { const n = v[t] = e[t]; v.prototype[t] = function () { const e = [this._wrapped]; return c.apply(e, arguments), Q(this, n.apply(v, e)); }; }), v; }, v.mixin(v), v.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], (e) => { const t = s[e]; v.prototype[e] = function () { const n = this._wrapped; return t.apply(n, arguments), e !== 'shift' && e !== 'splice' || n.length !== 0 || delete n[0], Q(this, n); }; }), v.each(['concat', 'join', 'slice'], (e) => { const t = s[e]; v.prototype[e] = function () { return Q(this, t.apply(this._wrapped, arguments)); }; }), v.prototype.value = function () { return this._wrapped; }, v.prototype.valueOf = v.prototype.toJSON = v.prototype.value, v.prototype.toString = function () { return String(this._wrapped); }, r = [], void 0 !== (i = function () { return v; }.apply(t, r)) && (n.exports = i);
    }());
  }).call(t, n(4), n(85)(e));
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }), function (e) {
    function n(e) { let t = !1; return function () { t || (t = !0, window.Promise.resolve().then(() => { t = !1, e(); })); }; } function r(e) { let t = !1; return function () { t || (t = !0, setTimeout(() => { t = !1, e(); }, pe)); }; } function i(e) { const t = {}; return e && t.toString.call(e) === '[object Function]'; } function o(e, t) { if (e.nodeType !== 1) return []; const n = getComputedStyle(e, null); return t ? n[t] : n; } function a(e) { return e.nodeName === 'HTML' ? e : e.parentNode || e.host; } function s(e) { if (!e) return document.body; switch (e.nodeName) { case 'HTML': case 'BODY': return e.ownerDocument.body; case '#document': return e.body; } const t = o(e); const n = t.overflow; const r = t.overflowX; return /(auto|scroll|overlay)/.test(n + t.overflowY + r) ? e : s(a(e)); } function l(e) { return e === 11 ? me : e === 10 ? ge : me || ge; } function u(e) { if (!e) return document.documentElement; for (var t = l(10) ? document.body : null, n = e.offsetParent; n === t && e.nextElementSibling;)n = (e = e.nextElementSibling).offsetParent; const r = n && n.nodeName; return r && r !== 'BODY' && r !== 'HTML' ? ['TD', 'TABLE'].indexOf(n.nodeName) !== -1 && o(n, 'position') === 'static' ? u(n) : n : e ? e.ownerDocument.documentElement : document.documentElement; } function c(e) { const t = e.nodeName; return t !== 'BODY' && (t === 'HTML' || u(e.firstElementChild) === e); } function p(e) { return e.parentNode !== null ? p(e.parentNode) : e; } function f(e, t) { if (!e || !e.nodeType || !t || !t.nodeType) return document.documentElement; const n = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING; const r = n ? e : t; const i = n ? t : e; const o = document.createRange(); o.setStart(r, 0), o.setEnd(i, 0); const a = o.commonAncestorContainer; if (e !== a && t !== a || r.contains(i)) return c(a) ? a : u(a); const s = p(e); return s.host ? f(s.host, t) : f(e, p(t).host); } function h(e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top';


      const n = t === 'top' ? 'scrollTop' : 'scrollLeft';


      const r = e.nodeName; if (r === 'BODY' || r === 'HTML') { const i = e.ownerDocument.documentElement; return (e.ownerDocument.scrollingElement || i)[n]; } return e[n];
    } function d(e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = h(t, 'top'); const i = h(t, 'left'); const o = n ? -1 : 1; return e.top += r * o, e.bottom += r * o, e.left += i * o, e.right += i * o, e; } function m(e, t) {
      const n = t === 'x' ? 'Left' : 'Top'; const
        r = n === 'Left' ? 'Right' : 'Bottom'; return parseFloat(e[`border${n}Width`], 10) + parseFloat(e[`border${r}Width`], 10);
    } function g(e, t, n, r) { return Math.max(t[`offset${e}`], t[`scroll${e}`], n[`client${e}`], n[`offset${e}`], n[`scroll${e}`], l(10) ? n[`offset${e}`] + r[`margin${e === 'Height' ? 'Top' : 'Left'}`] + r[`margin${e === 'Height' ? 'Bottom' : 'Right'}`] : 0); } function y() { const e = document.body; const t = document.documentElement; const n = l(10) && getComputedStyle(t); return { height: g('Height', e, t, n), width: g('Width', e, t, n) }; } function v(e) { return be({}, e, { right: e.left + e.width, bottom: e.top + e.height }); } function _(e) {
      let t = {}; try { if (l(10)) { t = e.getBoundingClientRect(); const n = h(e, 'top'); const r = h(e, 'left'); t.top += n, t.left += r, t.bottom += n, t.right += r; } else t = e.getBoundingClientRect(); } catch (e) {} const i = {
        left: t.left, top: t.top, width: t.right - t.left, height: t.bottom - t.top,
      }; const a = e.nodeName === 'HTML' ? y() : {}; const s = a.width || e.clientWidth || i.right - i.left; const u = a.height || e.clientHeight || i.bottom - i.top; let c = e.offsetWidth - s; let p = e.offsetHeight - u; if (c || p) { const f = o(e); c -= m(f, 'x'), p -= m(f, 'y'), i.width -= c, i.height -= p; } return v(i);
    } function b(e, t) {
      const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = l(10); const i = t.nodeName === 'HTML'; const a = _(e); const u = _(t); const c = s(e); const p = o(t); const f = parseFloat(p.borderTopWidth, 10); const h = parseFloat(p.borderLeftWidth, 10); n && t.nodeName === 'HTML' && (u.top = Math.max(u.top, 0), u.left = Math.max(u.left, 0)); let m = v({
        top: a.top - u.top - f, left: a.left - u.left - h, width: a.width, height: a.height,
      }); if (m.marginTop = 0, m.marginLeft = 0, !r && i) { const g = parseFloat(p.marginTop, 10); const y = parseFloat(p.marginLeft, 10); m.top -= f - g, m.bottom -= f - g, m.left -= h - y, m.right -= h - y, m.marginTop = g, m.marginLeft = y; } return (r && !n ? t.contains(c) : t === c && c.nodeName !== 'BODY') && (m = d(m, t)), m;
    } function x(e) {
      const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = e.ownerDocument.documentElement; const r = b(e, n); const i = Math.max(n.clientWidth, window.innerWidth || 0); const o = Math.max(n.clientHeight, window.innerHeight || 0); const a = t ? 0 : h(n); const s = t ? 0 : h(n, 'left'); return v({
        top: a - r.top + r.marginTop, left: s - r.left + r.marginLeft, width: i, height: o,
      });
    } function w(e) { const t = e.nodeName; return t !== 'BODY' && t !== 'HTML' && (o(e, 'position') === 'fixed' || w(a(e))); } function E(e) { if (!e || !e.parentElement || l()) return document.documentElement; for (var t = e.parentElement; t && o(t, 'transform') === 'none';)t = t.parentElement; return t || document.documentElement; } function T(e, t, n, r) { const i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let o = { top: 0, left: 0 }; const l = i ? E(e) : f(e, t); if (r === 'viewport')o = x(l, i); else { let u = void 0; r === 'scrollParent' ? (u = s(a(t)), u.nodeName === 'BODY' && (u = e.ownerDocument.documentElement)) : u = r === 'window' ? e.ownerDocument.documentElement : r; const c = b(u, l, i); if (u.nodeName !== 'HTML' || w(l))o = c; else { const p = y(); const h = p.height; const d = p.width; o.top += c.top - c.marginTop, o.bottom = h + c.top, o.left += c.left - c.marginLeft, o.right = d + c.left; } } return o.left += n, o.top += n, o.right -= n, o.bottom -= n, o; } function k(e) { return e.width * e.height; } function C(e, t, n, r, i) {
      const o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (e.indexOf('auto') === -1) return e; const a = T(n, r, o, i); const s = {
        top: { width: a.width, height: t.top - a.top }, right: { width: a.right - t.right, height: a.height }, bottom: { width: a.width, height: a.bottom - t.bottom }, left: { width: t.left - a.left, height: a.height },
      }; const l = Object.keys(s).map(e => be({ key: e }, s[e], { area: k(s[e]) })).sort((e, t) => t.area - e.area); const u = l.filter((e) => { const t = e.width; const r = e.height; return t >= n.clientWidth && r >= n.clientHeight; }); const c = u.length > 0 ? u[0].key : l[0].key; const p = e.split('-')[1]; return c + (p ? `-${p}` : '');
    } function S(e, t, n) { const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; return b(n, r ? E(t) : f(t, n), r); } function A(e) { const t = getComputedStyle(e); const n = parseFloat(t.marginTop) + parseFloat(t.marginBottom); const r = parseFloat(t.marginLeft) + parseFloat(t.marginRight); return { width: e.offsetWidth + r, height: e.offsetHeight + n }; } function O(e) {
      const t = {
        left: 'right', right: 'left', bottom: 'top', top: 'bottom',
      }; return e.replace(/left|right|bottom|top/g, e => t[e]);
    } function I(e, t, n) { n = n.split('-')[0]; const r = A(e); const i = { width: r.width, height: r.height }; const o = ['right', 'left'].indexOf(n) !== -1; const a = o ? 'top' : 'left'; const s = o ? 'left' : 'top'; const l = o ? 'height' : 'width'; const u = o ? 'width' : 'height'; return i[a] = t[a] + t[l] / 2 - r[l] / 2, i[s] = n === s ? t[s] - r[u] : t[O(s)], i; } function P(e, t) { return Array.prototype.find ? e.find(t) : e.filter(t)[0]; } function M(e, t, n) { if (Array.prototype.findIndex) return e.findIndex(e => e[t] === n); const r = P(e, e => e[t] === n); return e.indexOf(r); } function N(e, t, n) { return (void 0 === n ? e : e.slice(0, M(e, 'name', n))).forEach((e) => { e.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const n = e.function || e.fn; e.enabled && i(n) && (t.offsets.popper = v(t.offsets.popper), t.offsets.reference = v(t.offsets.reference), t = n(t, e)); }), t; } function D() {
      if (!this.state.isDestroyed) {
        let e = {
          instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {},
        }; e.offsets.reference = S(this.state, this.popper, this.reference, this.options.positionFixed), e.placement = C(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = I(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', e = N(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e));
      }
    } function L(e, t) { return e.some((e) => { const n = e.name; return e.enabled && n === t; }); } function z(e) { for (let t = [!1, 'ms', 'Webkit', 'Moz', 'O'], n = e.charAt(0).toUpperCase() + e.slice(1), r = 0; r < t.length; r++) { const i = t[r]; const o = i ? `${i}${n}` : e; if (typeof document.body.style[o] !== 'undefined') return o; } return null; } function R() { return this.state.isDestroyed = !0, L(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[z('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this; } function j(e) { const t = e.ownerDocument; return t ? t.defaultView : window; } function B(e, t, n, r) { const i = e.nodeName === 'BODY'; const o = i ? e.ownerDocument.defaultView : e; o.addEventListener(t, n, { passive: !0 }), i || B(s(o.parentNode), t, n, r), r.push(o); } function F(e, t, n, r) { n.updateBound = r, j(e).addEventListener('resize', n.updateBound, { passive: !0 }); const i = s(e); return B(i, 'scroll', n.updateBound, n.scrollParents), n.scrollElement = i, n.eventsEnabled = !0, n; } function U() { this.state.eventsEnabled || (this.state = F(this.reference, this.options, this.state, this.scheduleUpdate)); } function V(e, t) { return j(e).removeEventListener('resize', t.updateBound), t.scrollParents.forEach((e) => { e.removeEventListener('scroll', t.updateBound); }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t; } function q() { this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = V(this.reference, this.state)); } function H(e) { return e !== '' && !isNaN(parseFloat(e)) && isFinite(e); } function W(e, t) { Object.keys(t).forEach((n) => { let r = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(n) !== -1 && H(t[n]) && (r = 'px'), e.style[n] = t[n] + r; }); } function $(e, t) { Object.keys(t).forEach((n) => { !1 !== t[n] ? e.setAttribute(n, t[n]) : e.removeAttribute(n); }); } function G(e) { return W(e.instance.popper, e.styles), $(e.instance.popper, e.attributes), e.arrowElement && Object.keys(e.arrowStyles).length && W(e.arrowElement, e.arrowStyles), e; } function Z(e, t, n, r, i) { const o = S(i, t, e, n.positionFixed); const a = C(n.placement, o, t, e, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding); return t.setAttribute('x-placement', a), W(t, { position: n.positionFixed ? 'fixed' : 'absolute' }), n; } function K(e, t) {
      const n = t.x; const r = t.y; const i = e.offsets.popper; const o = P(e.instance.modifiers, e => e.name === 'applyStyle').gpuAcceleration; void 0 !== o && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); const a = void 0 !== o ? o : t.gpuAcceleration; const s = u(e.instance.popper); const l = _(s); const c = { position: i.position }; const p = {
        left: Math.floor(i.left), top: Math.round(i.top), bottom: Math.round(i.bottom), right: Math.floor(i.right),
      }; const f = n === 'bottom' ? 'top' : 'bottom'; const h = r === 'right' ? 'left' : 'right'; const d = z('transform'); let m = void 0; let g = void 0; if (g = f === 'bottom' ? -l.height + p.bottom : p.top, m = h === 'right' ? -l.width + p.right : p.left, a && d)c[d] = `translate3d(${m}px, ${g}px, 0)`, c[f] = 0, c[h] = 0, c.willChange = 'transform'; else { const y = f === 'bottom' ? -1 : 1; const v = h === 'right' ? -1 : 1; c[f] = g * y, c[h] = m * v, c.willChange = `${f}, ${h}`; } const b = { 'x-placement': e.placement }; return e.attributes = be({}, b, e.attributes), e.styles = be({}, c, e.styles), e.arrowStyles = be({}, e.offsets.arrow, e.arrowStyles), e;
    } function X(e, t, n) { const r = P(e, e => e.name === t); const i = !!r && e.some(e => e.name === n && e.enabled && e.order < r.order); if (!i) { const o = `\`${t}\``; const a = `\`${n}\``; console.warn(`${a} modifier is required by ${o} modifier in order to work, be sure to include it before ${o}!`); } return i; } function Y(e, t) { let n; if (!X(e.instance.modifiers, 'arrow', 'keepTogether')) return e; let r = t.element; if (typeof r === 'string') { if (!(r = e.instance.popper.querySelector(r))) return e; } else if (!e.instance.popper.contains(r)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e; const i = e.placement.split('-')[0]; const a = e.offsets; const s = a.popper; const l = a.reference; const u = ['left', 'right'].indexOf(i) !== -1; const c = u ? 'height' : 'width'; const p = u ? 'Top' : 'Left'; const f = p.toLowerCase(); const h = u ? 'left' : 'top'; const d = u ? 'bottom' : 'right'; const m = A(r)[c]; l[d] - m < s[f] && (e.offsets.popper[f] -= s[f] - (l[d] - m)), l[f] + m > s[d] && (e.offsets.popper[f] += l[f] + m - s[d]), e.offsets.popper = v(e.offsets.popper); const g = l[f] + l[c] / 2 - m / 2; const y = o(e.instance.popper); const _ = parseFloat(y[`margin${p}`], 10); const b = parseFloat(y[`border${p}Width`], 10); let x = g - e.offsets.popper[f] - _ - b; return x = Math.max(Math.min(s[c] - m, x), 0), e.arrowElement = r, e.offsets.arrow = (n = {}, _e(n, f, Math.round(x)), _e(n, h, ''), n), e; } function J(e) { return e === 'end' ? 'start' : e === 'start' ? 'end' : e; } function Q(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = we.indexOf(e); const r = we.slice(n + 1).concat(we.slice(0, n)); return t ? r.reverse() : r; } function ee(e, t) { if (L(e.instance.modifiers, 'inner')) return e; if (e.flipped && e.placement === e.originalPlacement) return e; const n = T(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed); let r = e.placement.split('-')[0]; let i = O(r); let o = e.placement.split('-')[1] || ''; let a = []; switch (t.behavior) { case Ee.FLIP: a = [r, i]; break; case Ee.CLOCKWISE: a = Q(r); break; case Ee.COUNTERCLOCKWISE: a = Q(r, !0); break; default: a = t.behavior; } return a.forEach((s, l) => { if (r !== s || a.length === l + 1) return e; r = e.placement.split('-')[0], i = O(r); const u = e.offsets.popper; const c = e.offsets.reference; const p = Math.floor; const f = r === 'left' && p(u.right) > p(c.left) || r === 'right' && p(u.left) < p(c.right) || r === 'top' && p(u.bottom) > p(c.top) || r === 'bottom' && p(u.top) < p(c.bottom); const h = p(u.left) < p(n.left); const d = p(u.right) > p(n.right); const m = p(u.top) < p(n.top); const g = p(u.bottom) > p(n.bottom); const y = r === 'left' && h || r === 'right' && d || r === 'top' && m || r === 'bottom' && g; const v = ['top', 'bottom'].indexOf(r) !== -1; const _ = !!t.flipVariations && (v && o === 'start' && h || v && o === 'end' && d || !v && o === 'start' && m || !v && o === 'end' && g); (f || y || _) && (e.flipped = !0, (f || y) && (r = a[l + 1]), _ && (o = J(o)), e.placement = r + (o ? `-${o}` : ''), e.offsets.popper = be({}, e.offsets.popper, I(e.instance.popper, e.offsets.reference, e.placement)), e = N(e.instance.modifiers, e, 'flip')); }), e; } function te(e) { const t = e.offsets; const n = t.popper; const r = t.reference; const i = e.placement.split('-')[0]; const o = Math.floor; const a = ['top', 'bottom'].indexOf(i) !== -1; const s = a ? 'right' : 'bottom'; const l = a ? 'left' : 'top'; const u = a ? 'width' : 'height'; return n[s] < o(r[l]) && (e.offsets.popper[l] = o(r[l]) - n[u]), n[l] > o(r[s]) && (e.offsets.popper[l] = o(r[s])), e; } function ne(e, t, n, r) { const i = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const o = +i[1]; const a = i[2]; if (!o) return e; if (a.indexOf('%') === 0) { let s = void 0; switch (a) { case '%p': s = n; break; case '%': case '%r': default: s = r; } return v(s)[t] / 100 * o; } if (a === 'vh' || a === 'vw') { return (a === 'vh' ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * o; } return o; } function re(e, t, n, r) {
      const i = [0, 0]; const o = ['right', 'left'].indexOf(r) !== -1; const a = e.split(/(\+|\-)/).map(e => e.trim()); const s = a.indexOf(P(a, e => e.search(/,|\s/) !== -1)); a[s] && a[s].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const l = /\s*,\s*|\s+/; let u = s !== -1 ? [a.slice(0, s).concat([a[s].split(l)[0]]), [a[s].split(l)[1]].concat(a.slice(s + 1))] : [a]; return u = u.map((e, r) => {
        const i = (r === 1 ? !o : o) ? 'height' : 'width';


        let a = !1; return e.reduce((e, t) => (e[e.length - 1] === '' && ['+', '-'].indexOf(t) !== -1 ? (e[e.length - 1] = t, a = !0, e) : a ? (e[e.length - 1] += t, a = !1, e) : e.concat(t)), []).map(e => ne(e, i, t, n));
      }), u.forEach((e, t) => { e.forEach((n, r) => { H(n) && (i[t] += n * (e[r - 1] === '-' ? -1 : 1)); }); }), i;
    } function ie(e, t) { const n = t.offset; const r = e.placement; const i = e.offsets; const o = i.popper; const a = i.reference; const s = r.split('-')[0]; let l = void 0; return l = H(+n) ? [+n, 0] : re(n, o, a, s), s === 'left' ? (o.top += l[0], o.left -= l[1]) : s === 'right' ? (o.top += l[0], o.left += l[1]) : s === 'top' ? (o.left += l[0], o.top -= l[1]) : s === 'bottom' && (o.left += l[0], o.top += l[1]), e.popper = o, e; } function oe(e, t) {
      let n = t.boundariesElement || u(e.instance.popper); e.instance.reference === n && (n = u(n)); const r = z('transform'); const i = e.instance.popper.style; const o = i.top; const a = i.left; const s = i[r]; i.top = '', i.left = '', i[r] = ''; const l = T(e.instance.popper, e.instance.reference, t.padding, n, e.positionFixed); i.top = o, i.left = a, i[r] = s, t.boundaries = l; const c = t.priority; let p = e.offsets.popper; const f = {
        primary(e) { let n = p[e]; return p[e] < l[e] && !t.escapeWithReference && (n = Math.max(p[e], l[e])), _e({}, e, n); },
        secondary(e) {
          const n = e === 'right' ? 'left' : 'top'; let
            r = p[n]; return p[e] > l[e] && !t.escapeWithReference && (r = Math.min(p[n], l[e] - (e === 'right' ? p.width : p.height))), _e({}, n, r);
        },
      }; return c.forEach((e) => { const t = ['left', 'top'].indexOf(e) !== -1 ? 'primary' : 'secondary'; p = be({}, p, f[t](e)); }), e.offsets.popper = p, e;
    } function ae(e) { const t = e.placement; const n = t.split('-')[0]; const r = t.split('-')[1]; if (r) { const i = e.offsets; const o = i.reference; const a = i.popper; const s = ['bottom', 'top'].indexOf(n) !== -1; const l = s ? 'left' : 'top'; const u = s ? 'width' : 'height'; const c = { start: _e({}, l, o[l]), end: _e({}, l, o[l] + o[u] - a[u]) }; e.offsets.popper = be({}, a, c[r]); } return e; } function se(e) { if (!X(e.instance.modifiers, 'hide', 'preventOverflow')) return e; const t = e.offsets.reference; const n = P(e.instance.modifiers, e => e.name === 'preventOverflow').boundaries; if (t.bottom < n.top || t.left > n.right || t.top > n.bottom || t.right < n.left) { if (!0 === e.hide) return e; e.hide = !0, e.attributes['x-out-of-boundaries'] = ''; } else { if (!1 === e.hide) return e; e.hide = !1, e.attributes['x-out-of-boundaries'] = !1; } return e; } function le(e) { const t = e.placement; const n = t.split('-')[0]; const r = e.offsets; const i = r.popper; const o = r.reference; const a = ['left', 'right'].indexOf(n) !== -1; const s = ['top', 'left'].indexOf(n) === -1; return i[a ? 'left' : 'top'] = o[n] - (s ? i[a ? 'width' : 'height'] : 0), e.placement = O(t), e.offsets.popper = v(i), e; } for (var ue = typeof window !== 'undefined' && typeof document !== 'undefined', ce = ['Edge', 'Trident', 'Firefox'], pe = 0, fe = 0; fe < ce.length; fe += 1) if (ue && navigator.userAgent.indexOf(ce[fe]) >= 0) { pe = 1; break; } const he = ue && window.Promise; const de = he ? n : r; var me = ue && !(!window.MSInputMethodContext || !document.documentMode); var ge = ue && /MSIE 10/.test(navigator.userAgent); const ye = function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }; const ve = (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }()); var _e = function (e, t, n) {
      return t in e ? Object.defineProperty(e, t, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : e[t] = n, e;
    }; var be = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const xe = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; var we = xe.slice(3); var Ee = { FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise' }; const Te = {
      shift: { order: 100, enabled: !0, fn: ae },
      offset: {
        order: 200, enabled: !0, fn: ie, offset: 0,
      },
      preventOverflow: {
        order: 300, enabled: !0, fn: oe, priority: ['left', 'right', 'top', 'bottom'], padding: 5, boundariesElement: 'scrollParent',
      },
      keepTogether: { order: 400, enabled: !0, fn: te },
      arrow: {
        order: 500, enabled: !0, fn: Y, element: '[x-arrow]',
      },
      flip: {
        order: 600, enabled: !0, fn: ee, behavior: 'flip', padding: 5, boundariesElement: 'viewport',
      },
      inner: { order: 700, enabled: !1, fn: le },
      hide: { order: 800, enabled: !0, fn: se },
      computeStyle: {
        order: 850, enabled: !0, fn: K, gpuAcceleration: !0, x: 'bottom', y: 'right',
      },
      applyStyle: {
        order: 900, enabled: !0, fn: G, onLoad: Z, gpuAcceleration: void 0,
      },
    }; const ke = {
      placement: 'bottom', positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate() {}, onUpdate() {}, modifiers: Te,
    }; const Ce = (function () { function e(t, n) { const r = this; const o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; ye(this, e), this.scheduleUpdate = function () { return requestAnimationFrame(r.update); }, this.update = de(this.update.bind(this)), this.options = be({}, e.Defaults, o), this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = t && t.jquery ? t[0] : t, this.popper = n && n.jquery ? n[0] : n, this.options.modifiers = {}, Object.keys(be({}, e.Defaults.modifiers, o.modifiers)).forEach((t) => { r.options.modifiers[t] = be({}, e.Defaults.modifiers[t] || {}, o.modifiers ? o.modifiers[t] : {}); }), this.modifiers = Object.keys(this.options.modifiers).map(e => be({ name: e }, r.options.modifiers[e])).sort((e, t) => e.order - t.order), this.modifiers.forEach((e) => { e.enabled && i(e.onLoad) && e.onLoad(r.reference, r.popper, r.options, e, r.state); }), this.update(); const a = this.options.eventsEnabled; a && this.enableEventListeners(), this.state.eventsEnabled = a; } return ve(e, [{ key: 'update', value() { return D.call(this); } }, { key: 'destroy', value() { return R.call(this); } }, { key: 'enableEventListeners', value() { return U.call(this); } }, { key: 'disableEventListeners', value() { return q.call(this); } }]), e; }()); Ce.Utils = (typeof window !== 'undefined' ? window : e).PopperUtils, Ce.placements = xe, Ce.Defaults = ke, t.default = Ce;
  }.call(t, n(4));
}, function (e, t, n) {
  function r(e) { return `${Math.round(e)} \xb0C`; } function i(e, t) { return u()(e, t).format('DD MM X', { latLonSeparator: ' ', decimalPlaces: 0 }); } function o(e, t) { return `${e} (${t})`; } function a(e, t) { return t && t !== e ? `${e} | ${t}` : e; } function s(e) { return `${Math.round(100 * e)} %`; } const l = n(99); var u = n.n(l); t.a = {
    temp: r, coords: i, country: o, names: a, fracToPerc: s,
  };
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(100); const u = (n.n(l), (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }())); const c = function (e) { return s.a.createElement('div', { className: 'info-panel-title', style: { alignItems: e.alignment } }, s.a.createElement('h1', null, e.title), s.a.createElement('button', { onClick: e.toggle, 'data-toggle': 'collapse', 'data-target': '#collapse-id' }, s.a.createElement('span', { className: e.icon }))); }; const p = function (e) { return s.a.createElement('div', { className: 'info-panel-details' }, s.a.createElement('div', { className: 'collapse', id: 'collapse-id' }, e.children)); }; const f = (function (e) {
    function t(e) { r(this, t); const n = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { isExpanded: !1 }, n.toggle = n.toggle.bind(n), n; } return o(t, e), u(t, [{ key: 'toggle', value() { const e = this; this.setState(t => ({ isExpanded: !e.state.isExpanded })); } }, { key: 'alignment', value() { return this.props.isLoading ? 'center' : (this.state.isExpanded, 'center'); } }, { key: 'icon', value() { return this.props.isLoading ? 'fa fa-spinner fa-spin' : this.state.isExpanded ? 'fa fa-angle-down' : 'fa fa-angle-up'; } }, {
      key: 'render',
      value() {
        return s.a.createElement('div', { className: 'info-panel' }, s.a.createElement(c, {
          icon: this.icon(), title: this.props.title, toggle: this.toggle, alignment: this.alignment(),
        }), s.a.createElement(p, { children: this.props.children }));
      },
    }]), t;
  }(a.Component)); t.a = f;
}, function (e, t, n) { n(33), e.exports = n(38); }, function (e, t, n) {
  typeof Promise === 'undefined' && (n(34).enable(), window.Promise = n(36)), n(37), Object.assign = n(7);
}, function (e, t, n) {
  function r() { u = !1, s._47 = null, s._71 = null; } function i(e) {
    function t(t) { (e.allRejections || a(p[t].error, e.whitelist || l)) && (p[t].displayId = c++, e.onUnhandled ? (p[t].logged = !0, e.onUnhandled(p[t].displayId, p[t].error)) : (p[t].logged = !0, o(p[t].displayId, p[t].error))); } function n(t) { p[t].logged && (e.onHandled ? e.onHandled(p[t].displayId, p[t].error) : p[t].onUnhandled || (console.warn(`Promise Rejection Handled (id: ${p[t].displayId}):`), console.warn(`  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id ${p[t].displayId}.`))); }e = e || {}, u && r(), u = !0; let i = 0; var c = 0; var p = {}; s._47 = function (e) { e._83 === 2 && p[e._56] && (p[e._56].logged ? n(e._56) : clearTimeout(p[e._56].timeout), delete p[e._56]); }, s._71 = function (e, n) {
      e._75 === 0 && (e._56 = i++, p[e._56] = {
        displayId: null, error: n, timeout: setTimeout(t.bind(null, e._56), a(n, l) ? 100 : 2e3), logged: !1,
      });
    };
  } function o(e, t) { console.warn(`Possible Unhandled Promise Rejection (id: ${e}):`), (`${t && (t.stack || t)}`).split('\n').forEach((e) => { console.warn(`  ${e}`); }); } function a(e, t) { return t.some(t => e instanceof t); } var s = n(19); var l = [ReferenceError, TypeError, RangeError]; var u = !1; t.disable = r, t.enable = i;
}, function (e, t, n) {
  (function (t) { function n(e) { a.length || (o(), s = !0), a[a.length] = e; } function r() { for (;l < a.length;) { const e = l; if (l += 1, a[e].call(), l > u) { for (let t = 0, n = a.length - l; t < n; t++)a[t] = a[t + l]; a.length -= l, l = 0; } }a.length = 0, l = 0, s = !1; } function i(e) { return function () { function t() { clearTimeout(n), clearInterval(r), e(); } var n = setTimeout(t, 0); var r = setInterval(t, 50); }; }e.exports = n; let o; var a = []; var s = !1; var l = 0; var u = 1024; const c = typeof t !== 'undefined' ? t : self; const p = c.MutationObserver || c.WebKitMutationObserver; o = typeof p === 'function' ? (function (e) { let t = 1; const n = new p(e); const r = document.createTextNode(''); return n.observe(r, { characterData: !0 }), function () { t = -t, r.data = t; }; }(r)) : i(r), n.requestFlush = o, n.makeRequestCallFromTimer = i; }).call(t, n(4));
}, function (e, t, n) {
  function r(e) { const t = new i(i._44); return t._83 = 1, t._18 = e, t; } var i = n(19); e.exports = i; const o = r(!0); const a = r(!1); const s = r(null); const l = r(void 0); const u = r(0); const c = r(''); i.resolve = function (e) { if (e instanceof i) return e; if (e === null) return s; if (void 0 === e) return l; if (!0 === e) return o; if (!1 === e) return a; if (e === 0) return u; if (e === '') return c; if (typeof e === 'object' || typeof e === 'function') try { const t = e.then; if (typeof t === 'function') return new i(t.bind(e)); } catch (e) { return new i(((t, n) => { n(e); })); } return r(e); }, i.all = function (e) { const t = Array.prototype.slice.call(e); return new i(((e, n) => { function r(a, s) { if (s && (typeof s === 'object' || typeof s === 'function')) { if (s instanceof i && s.then === i.prototype.then) { for (;s._83 === 3;)s = s._18; return s._83 === 1 ? r(a, s._18) : (s._83 === 2 && n(s._18), void s.then((e) => { r(a, e); }, n)); } const l = s.then; if (typeof l === 'function') { return void new i(l.bind(s)).then((e) => { r(a, e); }, n); } }t[a] = s, --o === 0 && e(t); } if (t.length === 0) return e([]); for (var o = t.length, a = 0; a < t.length; a++)r(a, t[a]); })); }, i.reject = function (e) { return new i(((t, n) => { n(e); })); }, i.race = function (e) { return new i(((t, n) => { e.forEach((e) => { i.resolve(e).then(t, n); }); })); }, i.prototype.catch = function (e) { return this.then(null, e); };
}, function (e, t) {
  !(function (e) {
    function t(e) { if (typeof e !== 'string' && (e = String(e)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e)) throw new TypeError('Invalid character in header field name'); return e.toLowerCase(); } function n(e) { return typeof e !== 'string' && (e = String(e)), e; } function r(e) { const t = { next() { const t = e.shift(); return { done: void 0 === t, value: t }; } }; return y.iterable && (t[Symbol.iterator] = function () { return t; }), t; } function i(e) { this.map = {}, e instanceof i ? e.forEach(function (e, t) { this.append(t, e); }, this) : Array.isArray(e) ? e.forEach(function (e) { this.append(e[0], e[1]); }, this) : e && Object.getOwnPropertyNames(e).forEach(function (t) { this.append(t, e[t]); }, this); } function o(e) { if (e.bodyUsed) return Promise.reject(new TypeError('Already read')); e.bodyUsed = !0; } function a(e) { return new Promise(((t, n) => { e.onload = function () { t(e.result); }, e.onerror = function () { n(e.error); }; })); } function s(e) {
      const t = new FileReader();


      const n = a(t); return t.readAsArrayBuffer(e), n;
    } function l(e) {
      const t = new FileReader(); const
        n = a(t); return t.readAsText(e), n;
    } function u(e) { for (var t = new Uint8Array(e), n = new Array(t.length), r = 0; r < t.length; r++)n[r] = String.fromCharCode(t[r]); return n.join(''); } function c(e) { if (e.slice) return e.slice(0); const t = new Uint8Array(e.byteLength); return t.set(new Uint8Array(e)), t.buffer; } function p() { return this.bodyUsed = !1, this._initBody = function (e) { if (this._bodyInit = e, e) if (typeof e === 'string') this._bodyText = e; else if (y.blob && Blob.prototype.isPrototypeOf(e)) this._bodyBlob = e; else if (y.formData && FormData.prototype.isPrototypeOf(e)) this._bodyFormData = e; else if (y.searchParams && URLSearchParams.prototype.isPrototypeOf(e)) this._bodyText = e.toString(); else if (y.arrayBuffer && y.blob && _(e)) this._bodyArrayBuffer = c(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]); else { if (!y.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(e) && !b(e)) throw new Error('unsupported BodyInit type'); this._bodyArrayBuffer = c(e); } else this._bodyText = ''; this.headers.get('content-type') || (typeof e === 'string' ? this.headers.set('content-type', 'text/plain;charset=UTF-8') : this._bodyBlob && this._bodyBlob.type ? this.headers.set('content-type', this._bodyBlob.type) : y.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')); }, y.blob && (this.blob = function () { const e = o(this); if (e) return e; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error('could not read FormData body as blob'); return Promise.resolve(new Blob([this._bodyText])); }, this.arrayBuffer = function () { return this._bodyArrayBuffer ? o(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(s); }), this.text = function () { const e = o(this); if (e) return e; if (this._bodyBlob) return l(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(u(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error('could not read FormData body as text'); return Promise.resolve(this._bodyText); }, y.formData && (this.formData = function () { return this.text().then(d); }), this.json = function () { return this.text().then(JSON.parse); }, this; } function f(e) { const t = e.toUpperCase(); return x.indexOf(t) > -1 ? t : e; } function h(e, t) { t = t || {}; let n = t.body; if (e instanceof h) { if (e.bodyUsed) throw new TypeError('Already read'); this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new i(e.headers)), this.method = e.method, this.mode = e.mode, n || e._bodyInit == null || (n = e._bodyInit, e.bodyUsed = !0); } else this.url = String(e); if (this.credentials = t.credentials || this.credentials || 'omit', !t.headers && this.headers || (this.headers = new i(t.headers)), this.method = f(t.method || this.method || 'GET'), this.mode = t.mode || this.mode || null, this.referrer = null, (this.method === 'GET' || this.method === 'HEAD') && n) throw new TypeError('Body not allowed for GET or HEAD requests'); this._initBody(n); } function d(e) { const t = new FormData(); return e.trim().split('&').forEach((e) => { if (e) { const n = e.split('='); const r = n.shift().replace(/\+/g, ' '); const i = n.join('=').replace(/\+/g, ' '); t.append(decodeURIComponent(r), decodeURIComponent(i)); } }), t; } function m(e) { const t = new i(); return e.split(/\r?\n/).forEach((e) => { const n = e.split(':'); const r = n.shift().trim(); if (r) { const i = n.join(':').trim(); t.append(r, i); } }), t; } function g(e, t) { t || (t = {}), this.type = 'default', this.status = 'status' in t ? t.status : 200, this.ok = this.status >= 200 && this.status < 300, this.statusText = 'statusText' in t ? t.statusText : 'OK', this.headers = new i(t.headers), this.url = t.url || '', this._initBody(e); } if (!e.fetch) {
      var y = {
        searchParams: 'URLSearchParams' in e, iterable: 'Symbol' in e && 'iterator' in Symbol, blob: 'FileReader' in e && 'Blob' in e && (function () { try { return new Blob(), !0; } catch (e) { return !1; } }()), formData: 'FormData' in e, arrayBuffer: 'ArrayBuffer' in e,
      }; if (y.arrayBuffer) var v = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']; var _ = function (e) { return e && DataView.prototype.isPrototypeOf(e); }; var b = ArrayBuffer.isView || function (e) { return e && v.indexOf(Object.prototype.toString.call(e)) > -1; }; i.prototype.append = function (e, r) { e = t(e), r = n(r); const i = this.map[e]; this.map[e] = i ? `${i},${r}` : r; }, i.prototype.delete = function (e) { delete this.map[t(e)]; }, i.prototype.get = function (e) { return e = t(e), this.has(e) ? this.map[e] : null; }, i.prototype.has = function (e) { return this.map.hasOwnProperty(t(e)); }, i.prototype.set = function (e, r) { this.map[t(e)] = n(r); }, i.prototype.forEach = function (e, t) { for (const n in this.map) this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this); }, i.prototype.keys = function () { const e = []; return this.forEach((t, n) => { e.push(n); }), r(e); }, i.prototype.values = function () { const e = []; return this.forEach((t) => { e.push(t); }), r(e); }, i.prototype.entries = function () { const e = []; return this.forEach((t, n) => { e.push([n, t]); }), r(e); }, y.iterable && (i.prototype[Symbol.iterator] = i.prototype.entries); var x = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']; h.prototype.clone = function () { return new h(this, { body: this._bodyInit }); }, p.call(h.prototype), p.call(g.prototype), g.prototype.clone = function () {
        return new g(this._bodyInit, {
          status: this.status, statusText: this.statusText, headers: new i(this.headers), url: this.url,
        });
      }, g.error = function () { const e = new g(null, { status: 0, statusText: '' }); return e.type = 'error', e; }; const w = [301, 302, 303, 307, 308]; g.redirect = function (e, t) { if (w.indexOf(t) === -1) throw new RangeError('Invalid status code'); return new g(null, { status: t, headers: { location: e } }); }, e.Headers = i, e.Request = h, e.Response = g, e.fetch = function (e, t) { return new Promise(((n, r) => { const i = new h(e, t); const o = new XMLHttpRequest(); o.onload = function () { const e = { status: o.status, statusText: o.statusText, headers: m(o.getAllResponseHeaders() || '') }; e.url = 'responseURL' in o ? o.responseURL : e.headers.get('X-Request-URL'); const t = 'response' in o ? o.response : o.responseText; n(new g(t, e)); }, o.onerror = function () { r(new TypeError('Network request failed')); }, o.ontimeout = function () { r(new TypeError('Network request failed')); }, o.open(i.method, i.url, !0), i.credentials === 'include' && (o.withCredentials = !0), 'responseType' in o && y.blob && (o.responseType = 'blob'), i.headers.forEach((e, t) => { o.setRequestHeader(t, e); }), o.send(typeof i._bodyInit === 'undefined' ? null : i._bodyInit); })); }, e.fetch.polyfill = !0;
    }
  }(typeof self !== 'undefined' ? self : this));
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(39); const i = n(0); const o = n.n(i); const a = n(20); const s = n.n(a); const l = n(10); const u = n(76); const c = n(117); const p = (n.n(c), n(119)); const f = (n.n(p), n(121)); const h = (n.n(f), n(122)); const d = (n.n(h), n(123)); n.n(d); s.a.render(o.a.createElement(l.a, null, o.a.createElement(u.a, null)), document.getElementById('root')), Object(r.a)();
}, function (e, t, n) {
  function r() { if ('serviceWorker' in navigator) { if (new URL('', window.location).origin !== window.location.origin) return; window.addEventListener('load', () => { const e = '/service-worker.js'; a ? (o(e), navigator.serviceWorker.ready.then(() => { console.log('This web app is being served cache-first by a service worker. To learn more, visit https://goo.gl/SC7cgQ'); })) : i(e); }); } } function i(e) { navigator.serviceWorker.register(e).then((e) => { e.onupdatefound = function () { const t = e.installing; t.onstatechange = function () { t.state === 'installed' && (navigator.serviceWorker.controller ? console.log('New content is available; please refresh.') : console.log('Content is cached for offline use.')); }; }; }).catch((e) => { console.error('Error during service worker registration:', e); }); } function o(e) { fetch(e).then((t) => { t.status === 404 || t.headers.get('content-type').indexOf('javascript') === -1 ? navigator.serviceWorker.ready.then((e) => { e.unregister().then(() => { window.location.reload(); }); }) : i(e); }).catch(() => { console.log('No internet connection found. App is running in offline mode.'); }); }t.a = r; var a = Boolean(window.location.hostname === 'localhost' || window.location.hostname === '[::1]' || window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));
}, function (e, t, n) {
  function r(e) { for (var t = arguments.length - 1, n = `https://reactjs.org/docs/error-decoder.html?invariant=${e}`, r = 0; r < t; r++)n += `&args[]=${encodeURIComponent(arguments[r + 1])}`; v(!1, `Minified React error #${e}; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. `, n); } function i(e, t, n) { this.props = e, this.context = t, this.refs = _, this.updater = n || M; } function o() {} function a(e, t, n) { this.props = e, this.context = t, this.refs = _, this.updater = n || M; } function s(e, t, n) {
    let r = void 0; const i = {}; let o = null; let a = null; if (t != null) for (r in void 0 !== t.ref && (a = t.ref), void 0 !== t.key && (o = `${t.key}`), t)L.call(t, r) && !z.hasOwnProperty(r) && (i[r] = t[r]); let s = arguments.length - 2; if (s === 1)i.children = n; else if (s > 1) { for (var l = Array(s), u = 0; u < s; u++)l[u] = arguments[u + 2]; i.children = l; } if (e && e.defaultProps) for (r in s = e.defaultProps) void 0 === i[r] && (i[r] = s[r]); return {
      $$typeof: w, type: e, key: o, ref: a, props: i, _owner: D.current,
    };
  } function l(e) { return typeof e === 'object' && e !== null && e.$$typeof === w; } function u(e) { const t = { '=': '=0', ':': '=2' }; return `$${(`${e}`).replace(/[=:]/g, e => t[e])}`; } function c(e, t, n, r) {
    if (j.length) { const i = j.pop(); return i.result = e, i.keyPrefix = t, i.func = n, i.context = r, i.count = 0, i; } return {
      result: e, keyPrefix: t, func: n, context: r, count: 0,
    };
  } function p(e) { e.result = null, e.keyPrefix = null, e.func = null, e.context = null, e.count = 0, j.length < 10 && j.push(e); } function f(e, t, n, i) { let o = typeof e; o !== 'undefined' && o !== 'boolean' || (e = null); let a = !1; if (e === null)a = !0; else switch (o) { case 'string': case 'number': a = !0; break; case 'object': switch (e.$$typeof) { case w: case E: a = !0; } } if (a) return n(i, e, t === '' ? `.${h(e, 0)}` : t), 1; if (a = 0, t = t === '' ? '.' : `${t}:`, Array.isArray(e)) for (var s = 0; s < e.length; s++) { o = e[s]; var l = t + h(o, s); a += f(o, l, n, i); } else if (e === null || typeof e === 'undefined' ? l = null : (l = P && e[P] || e['@@iterator'], l = typeof l === 'function' ? l : null), typeof l === 'function') for (e = l.call(e), s = 0; !(o = e.next()).done;)o = o.value, l = t + h(o, s++), a += f(o, l, n, i); else o === 'object' && (n = `${e}`, r('31', n === '[object Object]' ? `object with keys {${Object.keys(e).join(', ')}}` : n, '')); return a; } function h(e, t) { return typeof e === 'object' && e !== null && e.key != null ? u(e.key) : t.toString(36); } function d(e, t) { e.func.call(e.context, t, e.count++); } function m(e, t, n) {
    const r = e.result; const i = e.keyPrefix; e = e.func.call(e.context, t, e.count++), Array.isArray(e) ? g(e, r, n, b.thatReturnsArgument) : e != null && (l(e) && (t = i + (!e.key || t && t.key === e.key ? '' : `${(`${e.key}`).replace(R, '$&/')}/`) + n, e = {
      $$typeof: w, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner,
    }), r.push(e));
  } function g(e, t, n, r, i) { let o = ''; n != null && (o = `${(`${n}`).replace(R, '$&/')}/`), t = c(t, o, r, i), e == null || f(e, '', m, t), p(t); } const y = n(7); var v = n(8); var _ = n(12); var b = n(9); const x = typeof Symbol === 'function' && Symbol.for; var w = x ? Symbol.for('react.element') : 60103; var E = x ? Symbol.for('react.portal') : 60106; const T = x ? Symbol.for('react.fragment') : 60107; const k = x ? Symbol.for('react.strict_mode') : 60108; const C = x ? Symbol.for('react.profiler') : 60114; const S = x ? Symbol.for('react.provider') : 60109; const A = x ? Symbol.for('react.context') : 60110; const O = x ? Symbol.for('react.async_mode') : 60111; const I = x ? Symbol.for('react.forward_ref') : 60112; x && Symbol.for('react.timeout'); var P = typeof Symbol === 'function' && Symbol.iterator; var M = {
    isMounted() { return !1; }, enqueueForceUpdate() {}, enqueueReplaceState() {}, enqueueSetState() {},
  }; i.prototype.isReactComponent = {}, i.prototype.setState = function (e, t) { typeof e !== 'object' && typeof e !== 'function' && e != null && r('85'), this.updater.enqueueSetState(this, e, t, 'setState'); }, i.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, 'forceUpdate'); }, o.prototype = i.prototype; const N = a.prototype = new o(); N.constructor = a, y(N, i.prototype), N.isPureReactComponent = !0; var D = { current: null }; var L = Object.prototype.hasOwnProperty; var z = {
    key: !0, ref: !0, __self: !0, __source: !0,
  }; var R = /\/+/g; var j = []; const B = {
    Children: {
      map(e, t, n) { if (e == null) return e; const r = []; return g(e, r, null, t, n), r; }, forEach(e, t, n) { if (e == null) return e; t = c(null, null, t, n), e == null || f(e, '', d, t), p(t); }, count(e) { return e == null ? 0 : f(e, '', b.thatReturnsNull, null); }, toArray(e) { const t = []; return g(e, t, null, b.thatReturnsArgument), t; }, only(e) { return l(e) || r('143'), e; },
    },
    createRef() { return { current: null }; },
    Component: i,
    PureComponent: a,
    createContext(e, t) {
      return void 0 === t && (t = null), e = {
        $$typeof: A, _calculateChangedBits: t, _defaultValue: e, _currentValue: e, _currentValue2: e, _changedBits: 0, _changedBits2: 0, Provider: null, Consumer: null,
      }, e.Provider = { $$typeof: S, _context: e }, e.Consumer = e;
    },
    forwardRef(e) { return { $$typeof: I, render: e }; },
    Fragment: T,
    StrictMode: k,
    unstable_AsyncMode: O,
    unstable_Profiler: C,
    createElement: s,
    cloneElement(e, t, n) {
      (e === null || void 0 === e) && r('267', e); let i = void 0; const o = y({}, e.props); let a = e.key; let s = e.ref; let l = e._owner; if (t != null) { void 0 !== t.ref && (s = t.ref, l = D.current), void 0 !== t.key && (a = `${t.key}`); var u = void 0; e.type && e.type.defaultProps && (u = e.type.defaultProps); for (i in t)L.call(t, i) && !z.hasOwnProperty(i) && (o[i] = void 0 === t[i] && void 0 !== u ? u[i] : t[i]); } if ((i = arguments.length - 2) === 1)o.children = n; else if (i > 1) { u = Array(i); for (let c = 0; c < i; c++)u[c] = arguments[c + 2]; o.children = u; } return {
        $$typeof: w, type: e.type, key: a, ref: s, props: o, _owner: l,
      };
    },
    createFactory(e) { const t = s.bind(null, e); return t.type = e, t; },
    isValidElement: l,
    version: '16.4.0',
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: D, assign: y },
  }; const F = { default: B }; const U = F && B || F; e.exports = U.default ? U.default : U;
}, function (e, t, n) {
  function r(e) { for (var t = arguments.length - 1, n = `https://reactjs.org/docs/error-decoder.html?invariant=${e}`, r = 0; r < t; r++)n += `&args[]=${encodeURIComponent(arguments[r + 1])}`; Nr(!1, `Minified React error #${e}; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. `, n); } function i(e, t, n, r, i, o, a, s, l) { this._hasCaughtError = !1, this._caughtError = null; const u = Array.prototype.slice.call(arguments, 3); try { t.apply(n, u); } catch (e) { this._caughtError = e, this._hasCaughtError = !0; } } function o() { if (Vr._hasRethrowError) { const e = Vr._rethrowError; throw Vr._rethrowError = null, Vr._hasRethrowError = !1, e; } } function a() { if (qr) for (const e in Hr) { const t = Hr[e]; let n = qr.indexOf(e); if (n > -1 || r('96', e), !Wr[n]) { t.extractEvents || r('97', e), Wr[n] = t, n = t.eventTypes; for (const i in n) { let o = void 0; const a = n[i]; const l = t; const u = i; $r.hasOwnProperty(u) && r('99', u), $r[u] = a; const c = a.phasedRegistrationNames; if (c) { for (o in c)c.hasOwnProperty(o) && s(c[o], l, u); o = !0; } else a.registrationName ? (s(a.registrationName, l, u), o = !0) : o = !1; o || r('98', i, e); } } } } function s(e, t, n) { Gr[e] && r('100', e), Gr[e] = t, Zr[e] = t.eventTypes[n].dependencies; } function l(e) { qr && r('101'), qr = Array.prototype.slice.call(e), a(); } function u(e) { let t; let n = !1; for (t in e) if (e.hasOwnProperty(t)) { const i = e[t]; Hr.hasOwnProperty(t) && Hr[t] === i || (Hr[t] && r('102', t), Hr[t] = i, n = !0); }n && a(); } function c(e, t, n, r) { t = e.type || 'unknown-event', e.currentTarget = Jr(r), Vr.invokeGuardedCallbackAndCatchFirstError(t, n, void 0, e), e.currentTarget = null; } function p(e, t) { return t == null && r('30'), e == null ? t : Array.isArray(e) ? Array.isArray(t) ? (e.push(...t), e) : (e.push(t), e) : Array.isArray(t) ? [e].concat(t) : [e, t]; } function f(e, t, n) { Array.isArray(e) ? e.forEach(t, n) : e && t.call(n, e); } function h(e, t) { if (e) { const n = e._dispatchListeners; const r = e._dispatchInstances; if (Array.isArray(n)) for (let i = 0; i < n.length && !e.isPropagationStopped(); i++)c(e, t, n[i], r[i]); else n && c(e, t, n, r); e._dispatchListeners = null, e._dispatchInstances = null, e.isPersistent() || e.constructor.release(e); } } function d(e) { return h(e, !0); } function m(e) { return h(e, !1); } function g(e, t) { let n = e.stateNode; if (!n) return null; let i = Xr(n); if (!i) return null; n = i[t]; switch (t) { case 'onClick': case 'onClickCapture': case 'onDoubleClick': case 'onDoubleClickCapture': case 'onMouseDown': case 'onMouseDownCapture': case 'onMouseMove': case 'onMouseMoveCapture': case 'onMouseUp': case 'onMouseUpCapture': (i = !i.disabled) || (e = e.type, i = !(e === 'button' || e === 'input' || e === 'select' || e === 'textarea')), e = !i; break; default: e = !1; } return e ? null : (n && typeof n !== 'function' && r('231', t, typeof n), n); } function y(e, t) { e !== null && (Qr = p(Qr, e)), e = Qr, Qr = null, e && (t ? f(e, d) : f(e, m), Qr && r('95'), Vr.rethrowCaughtError()); } function v(e, t, n, r) { for (var i = null, o = 0; o < Wr.length; o++) { let a = Wr[o]; a && (a = a.extractEvents(e, t, n, r)) && (i = p(i, a)); }y(i, !1); } function _(e) { if (e[ri]) return e[ri]; for (;!e[ri];) { if (!e.parentNode) return null; e = e.parentNode; } return e = e[ri], e.tag === 5 || e.tag === 6 ? e : null; } function b(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; r('33'); } function x(e) { return e[ii] || null; } function w(e) { do { e = e.return; } while (e && e.tag !== 5);return e || null; } function E(e, t, n) { for (var r = []; e;)r.push(e), e = w(e); for (e = r.length; e-- > 0;)t(r[e], 'captured', n); for (e = 0; e < r.length; e++)t(r[e], 'bubbled', n); } function T(e, t, n) { (t = g(e, n.dispatchConfig.phasedRegistrationNames[t])) && (n._dispatchListeners = p(n._dispatchListeners, t), n._dispatchInstances = p(n._dispatchInstances, e)); } function k(e) { e && e.dispatchConfig.phasedRegistrationNames && E(e._targetInst, T, e); } function C(e) { if (e && e.dispatchConfig.phasedRegistrationNames) { let t = e._targetInst; t = t ? w(t) : null, E(t, T, e); } } function S(e, t, n) { e && n && n.dispatchConfig.registrationName && (t = g(e, n.dispatchConfig.registrationName)) && (n._dispatchListeners = p(n._dispatchListeners, t), n._dispatchInstances = p(n._dispatchInstances, e)); } function A(e) { e && e.dispatchConfig.registrationName && S(e._targetInst, null, e); } function O(e) { f(e, k); } function I(e, t, n, r) { if (n && r)e: { for (var i = n, o = r, a = 0, s = i; s; s = w(s))a++; s = 0; for (let l = o; l; l = w(l))s++; for (;a - s > 0;)i = w(i), a--; for (;s - a > 0;)o = w(o), s--; for (;a--;) { if (i === o || i === o.alternate) break e; i = w(i), o = w(o); }i = null; } else i = null; for (o = i, i = []; n && n !== o && ((a = n.alternate) === null || a !== o);)i.push(n), n = w(n); for (n = []; r && r !== o && ((a = r.alternate) === null || a !== o);)n.push(r), r = w(r); for (r = 0; r < i.length; r++)S(i[r], 'bubbled', e); for (e = n.length; e-- > 0;)S(n[e], 'captured', t); } function P(e, t) { const n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n[`Webkit${e}`] = `webkit${t}`, n[`Moz${e}`] = `moz${t}`, n[`ms${e}`] = `MS${t}`, n[`O${e}`] = `o${t.toLowerCase()}`, n; } function M(e) { if (li[e]) return li[e]; if (!si[e]) return e; let t; const n = si[e]; for (t in n) if (n.hasOwnProperty(t) && t in ui) return li[e] = n[t]; return e; } function N() { return !mi && Lr.canUseDOM && (mi = 'textContent' in document.documentElement ? 'textContent' : 'innerText'), mi; } function D() { if (gi._fallbackText) return gi._fallbackText; let e; let t; const n = gi._startText; const r = n.length; const i = L(); const o = i.length; for (e = 0; e < r && n[e] === i[e]; e++);const a = r - e; for (t = 1; t <= a && n[r - t] === i[o - t]; t++);return gi._fallbackText = i.slice(e, t > 1 ? 1 - t : void 0), gi._fallbackText; } function L() { return 'value' in gi._root ? gi._root.value : gi._root[N()]; } function z(e, t, n, r) { this.dispatchConfig = e, this._targetInst = t, this.nativeEvent = n, e = this.constructor.Interface; for (const i in e)e.hasOwnProperty(i) && ((t = e[i]) ? this[i] = t(n) : i === 'target' ? this.target = r : this[i] = n[i]); return this.isDefaultPrevented = (n.defaultPrevented != null ? n.defaultPrevented : !1 === n.returnValue) ? Rr.thatReturnsTrue : Rr.thatReturnsFalse, this.isPropagationStopped = Rr.thatReturnsFalse, this; } function R(e, t, n, r) { if (this.eventPool.length) { const i = this.eventPool.pop(); return this.call(i, e, t, n, r), i; } return new this(e, t, n, r); } function j(e) { e instanceof this || r('223'), e.destructor(), this.eventPool.length < 10 && this.eventPool.push(e); } function B(e) { e.eventPool = [], e.getPooled = R, e.release = j; } function F(e, t) { switch (e) { case 'keyup': return xi.indexOf(t.keyCode) !== -1; case 'keydown': return t.keyCode !== 229; case 'keypress': case 'mousedown': case 'blur': return !0; default: return !1; } } function U(e) { return e = e.detail, typeof e === 'object' && 'data' in e ? e.data : null; } function V(e, t) { switch (e) { case 'compositionend': return U(t); case 'keypress': return t.which !== 32 ? null : (Ai = !0, Ci); case 'textInput': return e = t.data, e === Ci && Ai ? null : e; default: return null; } } function q(e, t) { if (Oi) return e === 'compositionend' || !wi && F(e, t) ? (e = D(), gi._root = null, gi._startText = null, gi._fallbackText = null, Oi = !1, e) : null; switch (e) { case 'paste': return null; case 'keypress': if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && t.char.length > 1) return t.char; if (t.which) return String.fromCharCode(t.which); } return null; case 'compositionend': return ki ? null : t.data; default: return null; } } function H(e) { if (e = Yr(e)) { Pi && typeof Pi.restoreControlledState === 'function' || r('194'); const t = Xr(e.stateNode); Pi.restoreControlledState(e.stateNode, e.type, t); } } function W(e) { Ni ? Di ? Di.push(e) : Di = [e] : Ni = e; } function $() { return Ni !== null || Di !== null; } function G() { if (Ni) { let e = Ni; const t = Di; if (Di = Ni = null, H(e), t) for (e = 0; e < t.length; e++)H(t[e]); } } function Z(e, t) { return e(t); } function K(e, t, n) { return e(t, n); } function X() {} function Y(e, t) { if (zi) return e(t); zi = !0; try { return Z(e, t); } finally { zi = !1, $() && (X(), G()); } } function J(e) { const t = e && e.nodeName && e.nodeName.toLowerCase(); return t === 'input' ? !!Ri[e.type] : t === 'textarea'; } function Q(e) { return e = e.target || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e; } function ee(e, t) { return !(!Lr.canUseDOM || t && !('addEventListener' in document)) && (e = `on${e}`, t = e in document, t || (t = document.createElement('div'), t.setAttribute(e, 'return;'), t = typeof t[e] === 'function'), t); } function te(e) { const t = e.type; return (e = e.nodeName) && e.toLowerCase() === 'input' && (t === 'checkbox' || t === 'radio'); } function ne(e) {
    const t = te(e) ? 'checked' : 'value';


    const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t); let
      r = `${e[t]}`; if (!e.hasOwnProperty(t) && typeof n !== 'undefined' && typeof n.get === 'function' && typeof n.set === 'function') { const i = n.get; const o = n.set; return Object.defineProperty(e, t, { configurable: !0, get() { return i.call(this); }, set(e) { r = `${e}`, o.call(this, e); } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue() { return r; }, setValue(e) { r = `${e}`; }, stopTracking() { e._valueTracker = null, delete e[t]; } }; }
  } function re(e) { e._valueTracker || (e._valueTracker = ne(e)); } function ie(e) { if (!e) return !1; const t = e._valueTracker; if (!t) return !0; const n = t.getValue(); let r = ''; return e && (r = te(e) ? e.checked ? 'true' : 'false' : e.value), (e = r) !== n && (t.setValue(e), !0); } function oe(e) { return e === null || typeof e === 'undefined' ? null : (e = Xi && e[Xi] || e['@@iterator'], typeof e === 'function' ? e : null); } function ae(e) { const t = e.type; if (typeof t === 'function') return t.displayName || t.name; if (typeof t === 'string') return t; switch (t) { case Gi: return 'AsyncMode'; case $i: return 'Context.Consumer'; case Vi: return 'ReactFragment'; case Ui: return 'ReactPortal'; case Hi: return `Profiler(${e.pendingProps.id})`; case Wi: return 'Context.Provider'; case qi: return 'StrictMode'; case Ki: return 'Timeout'; } if (typeof t === 'object' && t !== null) switch (t.$$typeof) { case Zi: return e = t.render.displayName || t.render.name || '', e !== '' ? `ForwardRef(${e})` : 'ForwardRef'; } return null; } function se(e) { let t = ''; do { switch (e.tag) { case 0: case 1: case 2: case 5: var n = e._debugOwner; var r = e._debugSource; var i = ae(e); var o = null; n && (o = ae(n)), n = r, i = `\n    in ${i || 'Unknown'}${n ? ` (at ${n.fileName.replace(/^.*[\\\/]/, '')}:${n.lineNumber})` : o ? ` (created by ${o})` : ''}`; break; default: i = ''; }t += i, e = e.return; } while (e);return t; } function le(e) { return !!Qi.hasOwnProperty(e) || !Ji.hasOwnProperty(e) && (Yi.test(e) ? Qi[e] = !0 : (Ji[e] = !0, !1)); } function ue(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case 'function': case 'symbol': return !0; case 'boolean': return !r && (n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5)) !== 'data-' && e !== 'aria-'); default: return !1; } } function ce(e, t, n, r) { if (t === null || typeof t === 'undefined' || ue(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || t < 1; } return !1; } function pe(e, t, n, r, i) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t; } function fe(e) { return e[1].toUpperCase(); } function he(e, t, n, r) { let i = eo.hasOwnProperty(t) ? eo[t] : null; (i !== null ? i.type === 0 : !r && (t.length > 2 && (t[0] === 'o' || t[0] === 'O') && (t[1] === 'n' || t[1] === 'N'))) || (ce(t, n, i, r) && (n = null), r || i === null ? le(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, `${n}`)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type !== 3 && '' : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && !0 === n ? '' : `${n}`, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))); } function de(e, t) {
    const n = t.checked; return zr({}, t, {
      defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n != null ? n : e._wrapperState.initialChecked,
    });
  } function me(e, t) { let n = t.defaultValue == null ? '' : t.defaultValue; const r = t.checked != null ? t.checked : t.defaultChecked; n = be(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === 'checkbox' || t.type === 'radio' ? t.checked != null : t.value != null }; } function ge(e, t) { (t = t.checked) != null && he(e, 'checked', t, !1); } function ye(e, t) { ge(e, t); const n = be(t.value); n != null && (t.type === 'number' ? (n === 0 && e.value === '' || e.value != n) && (e.value = `${n}`) : e.value !== `${n}` && (e.value = `${n}`)), t.hasOwnProperty('value') ? _e(e, t.type, n) : t.hasOwnProperty('defaultValue') && _e(e, t.type, be(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked); } function ve(e, t) { (t.hasOwnProperty('value') || t.hasOwnProperty('defaultValue')) && (e.value === '' && (e.value = `${e._wrapperState.initialValue}`), e.defaultValue = `${e._wrapperState.initialValue}`), t = e.name, t !== '' && (e.name = ''), e.defaultChecked = !e.defaultChecked, e.defaultChecked = !e.defaultChecked, t !== '' && (e.name = t); } function _e(e, t, n) { t === 'number' && e.ownerDocument.activeElement === e || (n == null ? e.defaultValue = `${e._wrapperState.initialValue}` : e.defaultValue !== `${n}` && (e.defaultValue = `${n}`)); } function be(e) { switch (typeof e) { case 'boolean': case 'number': case 'object': case 'string': case 'undefined': return e; default: return ''; } } function xe(e, t, n) { return e = z.getPooled(no.change, e, t, n), e.type = 'change', W(n), O(e), e; } function we(e) { y(e, !1); } function Ee(e) { if (ie(b(e))) return e; } function Te(e, t) { if (e === 'change') return t; } function ke() { ro && (ro.detachEvent('onpropertychange', Ce), io = ro = null); } function Ce(e) { e.propertyName === 'value' && Ee(io) && (e = xe(io, e, Q(e)), Y(we, e)); } function Se(e, t, n) { e === 'focus' ? (ke(), ro = t, io = n, ro.attachEvent('onpropertychange', Ce)) : e === 'blur' && ke(); } function Ae(e) { if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return Ee(io); } function Oe(e, t) { if (e === 'click') return Ee(t); } function Ie(e, t) { if (e === 'input' || e === 'change') return Ee(t); } function Pe(e) { const t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = lo[e]) && !!t[e]; } function Me() { return Pe; } function Ne(e) { let t = e; if (e.alternate) for (;t.return;)t = t.return; else { if ((2 & t.effectTag) !== 0) return 1; for (;t.return;) if (t = t.return, (2 & t.effectTag) !== 0) return 1; } return t.tag === 3 ? 2 : 3; } function De(e) { Ne(e) !== 2 && r('188'); } function Le(e) { let t = e.alternate; if (!t) return t = Ne(e), t === 3 && r('188'), t === 1 ? null : e; for (var n = e, i = t; ;) { const o = n.return; const a = o ? o.alternate : null; if (!o || !a) break; if (o.child === a.child) { for (var s = o.child; s;) { if (s === n) return De(o), e; if (s === i) return De(o), t; s = s.sibling; }r('188'); } if (n.return !== i.return)n = o, i = a; else { s = !1; for (var l = o.child; l;) { if (l === n) { s = !0, n = o, i = a; break; } if (l === i) { s = !0, i = o, n = a; break; }l = l.sibling; } if (!s) { for (l = a.child; l;) { if (l === n) { s = !0, n = a, i = o; break; } if (l === i) { s = !0, i = a, n = o; break; }l = l.sibling; }s || r('189'); } }n.alternate !== i && r('190'); } return n.tag !== 3 && r('188'), n.stateNode.current === n ? e : t; } function ze(e) { if (!(e = Le(e))) return null; for (let t = e; ;) { if (t.tag === 5 || t.tag === 6) return t; if (t.child)t.child.return = t, t = t.child; else { if (t === e) break; for (;!t.sibling;) { if (!t.return || t.return === e) return null; t = t.return; }t.sibling.return = t.return, t = t.sibling; } } return null; } function Re(e) { if (!(e = Le(e))) return null; for (let t = e; ;) { if (t.tag === 5 || t.tag === 6) return t; if (t.child && t.tag !== 4)t.child.return = t, t = t.child; else { if (t === e) break; for (;!t.sibling;) { if (!t.return || t.return === e) return null; t = t.return; }t.sibling.return = t.return, t = t.sibling; } } return null; } function je(e) { const t = e.keyCode; return 'charCode' in e ? (e = e.charCode) === 0 && t === 13 && (e = 13) : e = t, e === 10 && (e = 13), e >= 32 || e === 13 ? e : 0; } function Be(e, t) { const n = e[0]; e = e[1]; const r = `on${e[0].toUpperCase() + e.slice(1)}`; t = { phasedRegistrationNames: { bubbled: r, captured: `${r}Capture` }, dependencies: [n], isInteractive: t }, ko[e] = t, Co[n] = t; } function Fe(e) { let t = e.targetInst; do { if (!t) { e.ancestors.push(t); break; } var n; for (n = t; n.return;)n = n.return; if (!(n = n.tag !== 3 ? null : n.stateNode.containerInfo)) break; e.ancestors.push(t), t = _(n); } while (t);for (n = 0; n < e.ancestors.length; n++)t = e.ancestors[n], v(e.topLevelType, t, e.nativeEvent, Q(e.nativeEvent)); } function Ue(e) { Io = !!e; } function Ve(e, t) { if (!t) return null; const n = (Ao(e) ? He : We).bind(null, e); t.addEventListener(e, n, !1); } function qe(e, t) { if (!t) return null; const n = (Ao(e) ? He : We).bind(null, e); t.addEventListener(e, n, !0); } function He(e, t) { K(We, e, t); } function We(e, t) {
    if (Io) {
      let n = Q(t); if (n = _(n), n === null || typeof n.tag !== 'number' || Ne(n) === 2 || (n = null), Oo.length) { const r = Oo.pop(); r.topLevelType = e, r.nativeEvent = t, r.targetInst = n, e = r; } else {
        e = {
          topLevelType: e, nativeEvent: t, targetInst: n, ancestors: [],
        };
      } try { Y(Fe, e); } finally { e.topLevelType = null, e.nativeEvent = null, e.targetInst = null, e.ancestors.length = 0, Oo.length < 10 && Oo.push(e); }
    }
  } function $e(e) { return Object.prototype.hasOwnProperty.call(e, Do) || (e[Do] = No++, Mo[e[Do]] = {}), Mo[e[Do]]; } function Ge(e) { for (;e && e.firstChild;)e = e.firstChild; return e; } function Ze(e, t) { let n = Ge(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r; }e: { for (;n;) { if (n.nextSibling) { n = n.nextSibling; break e; }n = n.parentNode; }n = void 0; }n = Ge(n); } } function Ke(e) { const t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === 'input' && e.type === 'text' || t === 'textarea' || e.contentEditable === 'true'); } function Xe(e, t) {
    if (Fo || Ro == null || Ro !== jr()) return null; let n = Ro; return 'selectionStart' in n && Ke(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : window.getSelection ? (n = window.getSelection(), n = {
      anchorNode: n.anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset,
    }) : n = void 0, Bo && Br(Bo, n) ? null : (Bo = n, e = z.getPooled(zo.select, jo, e, t), e.type = 'select', e.target = Ro, O(e), e);
  } function Ye(e) { let t = ''; return Dr.Children.forEach(e, (e) => { e == null || typeof e !== 'string' && typeof e !== 'number' || (t += e); }), t; } function Je(e, t) { return e = zr({ children: void 0 }, t), (t = Ye(t.children)) && (e.children = t), e; } function Qe(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t[`$${n[i]}`] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty(`$${e[n].value}`), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0); } else { for (n = `${n}`, t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); t !== null || e[i].disabled || (t = e[i]); }t !== null && (t.selected = !0); } } function et(e, t) { const n = t.value; e._wrapperState = { initialValue: n != null ? n : t.defaultValue, wasMultiple: !!t.multiple }; } function tt(e, t) { return t.dangerouslySetInnerHTML != null && r('91'), zr({}, t, { value: void 0, defaultValue: void 0, children: `${e._wrapperState.initialValue}` }); } function nt(e, t) { let n = t.value; n == null && (n = t.defaultValue, t = t.children, t != null && (n != null && r('92'), Array.isArray(t) && (t.length <= 1 || r('93'), t = t[0]), n = `${t}`), n == null && (n = '')), e._wrapperState = { initialValue: `${n}` }; } function rt(e, t) { let n = t.value; n != null && (n = `${n}`, n !== e.value && (e.value = n), t.defaultValue == null && (e.defaultValue = n)), t.defaultValue != null && (e.defaultValue = t.defaultValue); } function it(e) { const t = e.textContent; t === e._wrapperState.initialValue && (e.value = t); } function ot(e) { switch (e) { case 'svg': return 'http://www.w3.org/2000/svg'; case 'math': return 'http://www.w3.org/1998/Math/MathML'; default: return 'http://www.w3.org/1999/xhtml'; } } function at(e, t) { return e == null || e === 'http://www.w3.org/1999/xhtml' ? ot(t) : e === 'http://www.w3.org/2000/svg' && t === 'foreignObject' ? 'http://www.w3.org/1999/xhtml' : e; } function st(e, t) { if (t) { const n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) return void (n.nodeValue = t); }e.textContent = t; } function lt(e, t) { e = e.style; for (let n in t) if (t.hasOwnProperty(n)) { const r = n.indexOf('--') === 0; let i = n; const o = t[n]; i = o == null || typeof o === 'boolean' || o === '' ? '' : r || typeof o !== 'number' || o === 0 || ua.hasOwnProperty(i) && ua[i] ? (`${o}`).trim() : `${o}px`, n === 'float' && (n = 'cssFloat'), r ? e.setProperty(n, i) : e[n] = i; } } function ut(e, t, n) { t && (pa[e] && (t.children != null || t.dangerouslySetInnerHTML != null) && r('137', e, n()), t.dangerouslySetInnerHTML != null && (t.children != null && r('60'), typeof t.dangerouslySetInnerHTML === 'object' && '__html' in t.dangerouslySetInnerHTML || r('61')), t.style != null && typeof t.style !== 'object' && r('62', n())); } function ct(e, t) { if (e.indexOf('-') === -1) return typeof t.is === 'string'; switch (e) { case 'annotation-xml': case 'color-profile': case 'font-face': case 'font-face-src': case 'font-face-uri': case 'font-face-format': case 'font-face-name': case 'missing-glyph': return !1; default: return !0; } } function pt(e, t) { e = e.nodeType === 9 || e.nodeType === 11 ? e : e.ownerDocument; const n = $e(e); t = Zr[t]; for (let r = 0; r < t.length; r++) { const i = t[r]; if (!n.hasOwnProperty(i) || !n[i]) { switch (i) { case 'scroll': qe('scroll', e); break; case 'focus': case 'blur': qe('focus', e), qe('blur', e), n.blur = !0, n.focus = !0; break; case 'cancel': case 'close': ee(i, !0) && qe(i, e); break; case 'invalid': case 'submit': case 'reset': break; default: di.indexOf(i) === -1 && Ve(i, e); }n[i] = !0; } } } function ft(e, t, n, r) { return n = n.nodeType === 9 ? n : n.ownerDocument, r === aa.html && (r = ot(e)), r === aa.html ? e === 'script' ? (e = n.createElement('div'), e.innerHTML = '<script><\/script>', e = e.removeChild(e.firstChild)) : e = typeof t.is === 'string' ? n.createElement(e, { is: t.is }) : n.createElement(e) : e = n.createElementNS(r, e), e; } function ht(e, t) { return (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(e); } function dt(e, t, n, r) { const i = ct(t, n); switch (t) { case 'iframe': case 'object': Ve('load', e); var o = n; break; case 'video': case 'audio': for (o = 0; o < di.length; o++)Ve(di[o], e); o = n; break; case 'source': Ve('error', e), o = n; break; case 'img': case 'image': case 'link': Ve('error', e), Ve('load', e), o = n; break; case 'form': Ve('reset', e), Ve('submit', e), o = n; break; case 'details': Ve('toggle', e), o = n; break; case 'input': me(e, n), o = de(e, n), Ve('invalid', e), pt(r, 'onChange'); break; case 'option': o = Je(e, n); break; case 'select': et(e, n), o = zr({}, n, { value: void 0 }), Ve('invalid', e), pt(r, 'onChange'); break; case 'textarea': nt(e, n), o = tt(e, n), Ve('invalid', e), pt(r, 'onChange'); break; default: o = n; }ut(t, o, fa); let a; const s = o; for (a in s) if (s.hasOwnProperty(a)) { let l = s[a]; a === 'style' ? lt(e, l, fa) : a === 'dangerouslySetInnerHTML' ? (l = l ? l.__html : void 0) != null && la(e, l) : a === 'children' ? typeof l === 'string' ? (t !== 'textarea' || l !== '') && st(e, l) : typeof l === 'number' && st(e, `${l}`) : a !== 'suppressContentEditableWarning' && a !== 'suppressHydrationWarning' && a !== 'autoFocus' && (Gr.hasOwnProperty(a) ? l != null && pt(r, a) : l != null && he(e, a, l, i)); } switch (t) { case 'input': re(e), ve(e, n); break; case 'textarea': re(e), it(e, n); break; case 'option': n.value != null && e.setAttribute('value', n.value); break; case 'select': e.multiple = !!n.multiple, t = n.value, t != null ? Qe(e, !!n.multiple, t, !1) : n.defaultValue != null && Qe(e, !!n.multiple, n.defaultValue, !0); break; default: typeof o.onClick === 'function' && (e.onclick = Rr); } } function mt(e, t, n, r, i) { let o = null; switch (t) { case 'input': n = de(e, n), r = de(e, r), o = []; break; case 'option': n = Je(e, n), r = Je(e, r), o = []; break; case 'select': n = zr({}, n, { value: void 0 }), r = zr({}, r, { value: void 0 }), o = []; break; case 'textarea': n = tt(e, n), r = tt(e, r), o = []; break; default: typeof n.onClick !== 'function' && typeof r.onClick === 'function' && (e.onclick = Rr); }ut(t, r, fa), t = e = void 0; let a = null; for (e in n) if (!r.hasOwnProperty(e) && n.hasOwnProperty(e) && n[e] != null) if (e === 'style') { var s = n[e]; for (t in s)s.hasOwnProperty(t) && (a || (a = {}), a[t] = ''); } else e !== 'dangerouslySetInnerHTML' && e !== 'children' && e !== 'suppressContentEditableWarning' && e !== 'suppressHydrationWarning' && e !== 'autoFocus' && (Gr.hasOwnProperty(e) ? o || (o = []) : (o = o || []).push(e, null)); for (e in r) { let l = r[e]; if (s = n != null ? n[e] : void 0, r.hasOwnProperty(e) && l !== s && (l != null || s != null)) if (e === 'style') if (s) { for (t in s)!s.hasOwnProperty(t) || l && l.hasOwnProperty(t) || (a || (a = {}), a[t] = ''); for (t in l)l.hasOwnProperty(t) && s[t] !== l[t] && (a || (a = {}), a[t] = l[t]); } else a || (o || (o = []), o.push(e, a)), a = l; else e === 'dangerouslySetInnerHTML' ? (l = l ? l.__html : void 0, s = s ? s.__html : void 0, l != null && s !== l && (o = o || []).push(e, `${l}`)) : e === 'children' ? s === l || typeof l !== 'string' && typeof l !== 'number' || (o = o || []).push(e, `${l}`) : e !== 'suppressContentEditableWarning' && e !== 'suppressHydrationWarning' && (Gr.hasOwnProperty(e) ? (l != null && pt(i, e), o || s === l || (o = [])) : (o = o || []).push(e, l)); } return a && (o = o || []).push('style', a), o; } function gt(e, t, n, r, i) { n === 'input' && i.type === 'radio' && i.name != null && ge(e, i), ct(n, r), r = ct(n, i); for (let o = 0; o < t.length; o += 2) { const a = t[o]; const s = t[o + 1]; a === 'style' ? lt(e, s, fa) : a === 'dangerouslySetInnerHTML' ? la(e, s) : a === 'children' ? st(e, s) : he(e, a, s, r); } switch (n) { case 'input': ye(e, i); break; case 'textarea': rt(e, i); break; case 'select': e._wrapperState.initialValue = void 0, t = e._wrapperState.wasMultiple, e._wrapperState.wasMultiple = !!i.multiple, n = i.value, n != null ? Qe(e, !!i.multiple, n, !1) : t !== !!i.multiple && (i.defaultValue != null ? Qe(e, !!i.multiple, i.defaultValue, !0) : Qe(e, !!i.multiple, i.multiple ? [] : '', !1)); } } function yt(e, t, n, r, i) { switch (t) { case 'iframe': case 'object': Ve('load', e); break; case 'video': case 'audio': for (r = 0; r < di.length; r++)Ve(di[r], e); break; case 'source': Ve('error', e); break; case 'img': case 'image': case 'link': Ve('error', e), Ve('load', e); break; case 'form': Ve('reset', e), Ve('submit', e); break; case 'details': Ve('toggle', e); break; case 'input': me(e, n), Ve('invalid', e), pt(i, 'onChange'); break; case 'select': et(e, n), Ve('invalid', e), pt(i, 'onChange'); break; case 'textarea': nt(e, n), Ve('invalid', e), pt(i, 'onChange'); }ut(t, n, fa), r = null; for (const o in n) if (n.hasOwnProperty(o)) { const a = n[o]; o === 'children' ? typeof a === 'string' ? e.textContent !== a && (r = ['children', a]) : typeof a === 'number' && e.textContent !== `${a}` && (r = ['children', `${a}`]) : Gr.hasOwnProperty(o) && a != null && pt(i, o); } switch (t) { case 'input': re(e), ve(e, n); break; case 'textarea': re(e), it(e, n); break; case 'select': case 'option': break; default: typeof n.onClick === 'function' && (e.onclick = Rr); } return r; } function vt(e, t) { return e.nodeValue !== t; } function _t(e, t) { switch (e) { case 'button': case 'input': case 'select': case 'textarea': return !!t.autoFocus; } return !1; } function bt(e, t) { return e === 'textarea' || typeof t.children === 'string' || typeof t.children === 'number' || typeof t.dangerouslySetInnerHTML === 'object' && t.dangerouslySetInnerHTML !== null && typeof t.dangerouslySetInnerHTML.__html === 'string'; } function xt(e) { for (e = e.nextSibling; e && e.nodeType !== 1 && e.nodeType !== 3;)e = e.nextSibling; return e; } function wt(e) { for (e = e.firstChild; e && e.nodeType !== 1 && e.nodeType !== 3;)e = e.nextSibling; return e; } function Et(e) { return { current: e }; } function Tt(e) { ba < 0 || (e.current = _a[ba], _a[ba] = null, ba--); } function kt(e, t) { ba++, _a[ba] = e.current, e.current = t; } function Ct(e) { return At(e) ? Ea : xa.current; } function St(e, t) { const n = e.type.contextTypes; if (!n) return Ur; const r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; let i; const o = {}; for (i in n)o[i] = t[i]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o; } function At(e) { return e.tag === 2 && e.type.childContextTypes != null; } function Ot(e) { At(e) && (Tt(wa, e), Tt(xa, e)); } function It(e) { Tt(wa, e), Tt(xa, e); } function Pt(e, t, n) { xa.current !== Ur && r('168'), kt(xa, t, e), kt(wa, n, e); } function Mt(e, t) { let n = e.stateNode; const i = e.type.childContextTypes; if (typeof n.getChildContext !== 'function') return t; n = n.getChildContext(); for (const o in n)o in i || r('108', ae(e) || 'Unknown', o); return zr({}, t, n); } function Nt(e) { if (!At(e)) return !1; let t = e.stateNode; return t = t && t.__reactInternalMemoizedMergedChildContext || Ur, Ea = xa.current, kt(xa, t, e), kt(wa, wa.current, e), !0; } function Dt(e, t) { const n = e.stateNode; if (n || r('169'), t) { const i = Mt(e, Ea); n.__reactInternalMemoizedMergedChildContext = i, Tt(wa, e), Tt(xa, e), kt(xa, i, e); } else Tt(wa, e); kt(wa, t, e); } function Lt(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = null, this.index = 0, this.ref = null, this.pendingProps = t, this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.expirationTime = 0, this.alternate = null; } function zt(e, t, n) { let r = e.alternate; return r === null ? (r = new Lt(e.tag, t, e.key, e.mode), r.type = e.type, r.stateNode = e.stateNode, r.alternate = e, e.alternate = r) : (r.pendingProps = t, r.effectTag = 0, r.nextEffect = null, r.firstEffect = null, r.lastEffect = null), r.expirationTime = n, r.child = e.child, r.memoizedProps = e.memoizedProps, r.memoizedState = e.memoizedState, r.updateQueue = e.updateQueue, r.sibling = e.sibling, r.index = e.index, r.ref = e.ref, r; } function Rt(e, t, n) { let i = e.type; const o = e.key; if (e = e.props, typeof i === 'function') var a = i.prototype && i.prototype.isReactComponent ? 2 : 0; else if (typeof i === 'string')a = 5; else switch (i) { case Vi: return jt(e.children, t, n, o); case Gi: a = 11, t |= 3; break; case qi: a = 11, t |= 2; break; case Hi: return i = new Lt(15, e, o, 4 | t), i.type = Hi, i.expirationTime = n, i; case Ki: a = 16, t |= 2; break; default: e: { switch (typeof i === 'object' && i !== null ? i.$$typeof : null) { case Wi: a = 13; break e; case $i: a = 12; break e; case Zi: a = 14; break e; default: r('130', i == null ? i : typeof i, ''); }a = void 0; } } return t = new Lt(a, e, o, t), t.type = i, t.expirationTime = n, t; } function jt(e, t, n, r) { return e = new Lt(10, e, r, t), e.expirationTime = n, e; } function Bt(e, t, n) { return e = new Lt(6, e, null, t), e.expirationTime = n, e; } function Ft(e, t, n) { return t = new Lt(4, e.children !== null ? e.children : [], e.key, t), t.expirationTime = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t; } function Ut(e, t, n) {
    return t = new Lt(3, null, null, t ? 3 : 0), e = {
      current: t, containerInfo: e, pendingChildren: null, earliestPendingTime: 0, latestPendingTime: 0, earliestSuspendedTime: 0, latestSuspendedTime: 0, latestPingedTime: 0, pendingCommitExpirationTime: 0, finishedWork: null, context: null, pendingContext: null, hydrate: n, remainingExpirationTime: 0, firstBatch: null, nextScheduledRoot: null,
    }, t.stateNode = e;
  } function Vt(e) { return function (t) { try { return e(t); } catch (e) {} }; } function qt(e) { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') return !1; const t = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (t.isDisabled || !t.supportsFiber) return !0; try { const n = t.inject(e); Ta = Vt(e => t.onCommitFiberRoot(n, e)), ka = Vt(e => t.onCommitFiberUnmount(n, e)); } catch (e) {} return !0; } function Ht(e) { typeof Ta === 'function' && Ta(e); } function Wt(e) { typeof ka === 'function' && ka(e); } function $t(e) {
    return {
      expirationTime: 0, baseState: e, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null,
    };
  } function Gt(e) {
    return {
      expirationTime: e.expirationTime, baseState: e.baseState, firstUpdate: e.firstUpdate, lastUpdate: e.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null,
    };
  } function Zt(e) {
    return {
      expirationTime: e, tag: 0, payload: null, callback: null, next: null, nextEffect: null,
    };
  } function Kt(e, t, n) { e.lastUpdate === null ? e.firstUpdate = e.lastUpdate = t : (e.lastUpdate.next = t, e.lastUpdate = t), (e.expirationTime === 0 || e.expirationTime > n) && (e.expirationTime = n); } function Xt(e, t, n) { const r = e.alternate; if (r === null) { var i = e.updateQueue; var o = null; i === null && (i = e.updateQueue = $t(e.memoizedState)); } else i = e.updateQueue, o = r.updateQueue, i === null ? o === null ? (i = e.updateQueue = $t(e.memoizedState), o = r.updateQueue = $t(r.memoizedState)) : i = e.updateQueue = Gt(o) : o === null && (o = r.updateQueue = Gt(i)); o === null || i === o ? Kt(i, t, n) : i.lastUpdate === null || o.lastUpdate === null ? (Kt(i, t, n), Kt(o, t, n)) : (Kt(i, t, n), o.lastUpdate = t); } function Yt(e, t, n) { let r = e.updateQueue; r = r === null ? e.updateQueue = $t(e.memoizedState) : Jt(e, r), r.lastCapturedUpdate === null ? r.firstCapturedUpdate = r.lastCapturedUpdate = t : (r.lastCapturedUpdate.next = t, r.lastCapturedUpdate = t), (r.expirationTime === 0 || r.expirationTime > n) && (r.expirationTime = n); } function Jt(e, t) { const n = e.alternate; return n !== null && t === n.updateQueue && (t = e.updateQueue = Gt(t)), t; } function Qt(e, t, n, r, i, o) { switch (n.tag) { case 1: return e = n.payload, typeof e === 'function' ? e.call(o, r, i) : e; case 3: e.effectTag = -1025 & e.effectTag | 64; case 0: if (e = n.payload, (i = typeof e === 'function' ? e.call(o, r, i) : e) === null || void 0 === i) break; return zr({}, r, i); case 2: Ca = !0; } return r; } function en(e, t, n, r, i) { if (Ca = !1, !(t.expirationTime === 0 || t.expirationTime > i)) { t = Jt(e, t); for (var o = t.baseState, a = null, s = 0, l = t.firstUpdate, u = o; l !== null;) { var c = l.expirationTime; c > i ? (a === null && (a = l, o = u), (s === 0 || s > c) && (s = c)) : (u = Qt(e, t, l, u, n, r), l.callback !== null && (e.effectTag |= 32, l.nextEffect = null, t.lastEffect === null ? t.firstEffect = t.lastEffect = l : (t.lastEffect.nextEffect = l, t.lastEffect = l))), l = l.next; } for (c = null, l = t.firstCapturedUpdate; l !== null;) { const p = l.expirationTime; p > i ? (c === null && (c = l, a === null && (o = u)), (s === 0 || s > p) && (s = p)) : (u = Qt(e, t, l, u, n, r), l.callback !== null && (e.effectTag |= 32, l.nextEffect = null, t.lastCapturedEffect === null ? t.firstCapturedEffect = t.lastCapturedEffect = l : (t.lastCapturedEffect.nextEffect = l, t.lastCapturedEffect = l))), l = l.next; }a === null && (t.lastUpdate = null), c === null ? t.lastCapturedUpdate = null : e.effectTag |= 32, a === null && c === null && (o = u), t.baseState = o, t.firstUpdate = a, t.firstCapturedUpdate = c, t.expirationTime = s, e.memoizedState = u; } } function tn(e, t) { typeof e !== 'function' && r('191', e), e.call(t); } function nn(e, t, n) { for (t.firstCapturedUpdate !== null && (t.lastUpdate !== null && (t.lastUpdate.next = t.firstCapturedUpdate, t.lastUpdate = t.lastCapturedUpdate), t.firstCapturedUpdate = t.lastCapturedUpdate = null), e = t.firstEffect, t.firstEffect = t.lastEffect = null; e !== null;) { const r = e.callback; r !== null && (e.callback = null, tn(r, n)), e = e.nextEffect; } for (e = t.firstCapturedEffect, t.firstCapturedEffect = t.lastCapturedEffect = null; e !== null;)t = e.callback, t !== null && (e.callback = null, tn(t, n)), e = e.nextEffect; } function rn(e, t) { return { value: e, source: t, stack: se(t) }; } function on(e) { const t = e.type._context; kt(Oa, t._changedBits, e), kt(Aa, t._currentValue, e), kt(Sa, e, e), t._currentValue = e.pendingProps.value, t._changedBits = e.stateNode; } function an(e) { const t = Oa.current; const n = Aa.current; Tt(Sa, e), Tt(Aa, e), Tt(Oa, e), e = e.type._context, e._currentValue = n, e._changedBits = t; } function sn(e) { return e === Ia && r('174'), e; } function ln(e, t) { kt(Na, t, e), kt(Ma, e, e), kt(Pa, Ia, e); let n = t.nodeType; switch (n) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : at(null, ''); break; default: n = n === 8 ? t.parentNode : t, t = n.namespaceURI || null, n = n.tagName, t = at(t, n); }Tt(Pa, e), kt(Pa, t, e); } function un(e) { Tt(Pa, e), Tt(Ma, e), Tt(Na, e); } function cn(e) { Ma.current === e && (Tt(Pa, e), Tt(Ma, e)); } function pn(e, t, n) { let r = e.memoizedState; t = t(n, r), r = t === null || void 0 === t ? r : zr({}, r, t), e.memoizedState = r, (e = e.updateQueue) !== null && e.expirationTime === 0 && (e.baseState = r); } function fn(e, t, n, r, i, o) { const a = e.stateNode; return e = e.type, typeof a.shouldComponentUpdate === 'function' ? a.shouldComponentUpdate(n, i, o) : !e.prototype || !e.prototype.isPureReactComponent || (!Br(t, n) || !Br(r, i)); } function hn(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps === 'function' && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps === 'function' && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Da.enqueueReplaceState(t, t.state, null); } function dn(e, t) { let n = e.type; const r = e.stateNode; const i = e.pendingProps; let o = Ct(e); r.props = i, r.state = e.memoizedState, r.refs = Ur, r.context = St(e, o), o = e.updateQueue, o !== null && (en(e, o, i, r, t), r.state = e.memoizedState), o = e.type.getDerivedStateFromProps, typeof o === 'function' && (pn(e, o, i), r.state = e.memoizedState), typeof n.getDerivedStateFromProps === 'function' || typeof r.getSnapshotBeforeUpdate === 'function' || typeof r.UNSAFE_componentWillMount !== 'function' && typeof r.componentWillMount !== 'function' || (n = r.state, typeof r.componentWillMount === 'function' && r.componentWillMount(), typeof r.UNSAFE_componentWillMount === 'function' && r.UNSAFE_componentWillMount(), n !== r.state && Da.enqueueReplaceState(r, r.state, null), (o = e.updateQueue) !== null && (en(e, o, i, r, t), r.state = e.memoizedState)), typeof r.componentDidMount === 'function' && (e.effectTag |= 4); } function mn(e, t, n) { if ((e = n.ref) !== null && typeof e !== 'function' && typeof e !== 'object') { if (n._owner) { n = n._owner; let i = void 0; n && (n.tag !== 2 && r('110'), i = n.stateNode), i || r('147', e); const o = `${e}`; return t !== null && t.ref !== null && typeof t.ref === 'function' && t.ref._stringRef === o ? t.ref : (t = function (e) { const t = i.refs === Ur ? i.refs = {} : i.refs; e === null ? delete t[o] : t[o] = e; }, t._stringRef = o, t); } typeof e !== 'string' && r('148'), n._owner || r('254', e); } return e; } function gn(e, t) { e.type !== 'textarea' && r('31', Object.prototype.toString.call(t) === '[object Object]' ? `object with keys {${Object.keys(t).join(', ')}}` : t, ''); } function yn(e) { function t(t, n) { if (e) { const r = t.lastEffect; r !== null ? (r.nextEffect = n, t.lastEffect = n) : t.firstEffect = t.lastEffect = n, n.nextEffect = null, n.effectTag = 8; } } function n(n, r) { if (!e) return null; for (;r !== null;)t(n, r), r = r.sibling; return null; } function i(e, t) { for (e = new Map(); t !== null;)t.key !== null ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e; } function o(e, t, n) { return e = zt(e, t, n), e.index = 0, e.sibling = null, e; } function a(t, n, r) { return t.index = r, e ? (r = t.alternate) !== null ? (r = r.index, r < n ? (t.effectTag = 2, n) : r) : (t.effectTag = 2, n) : n; } function s(t) { return e && t.alternate === null && (t.effectTag = 2), t; } function l(e, t, n, r) { return t === null || t.tag !== 6 ? (t = Bt(n, e.mode, r), t.return = e, t) : (t = o(t, n, r), t.return = e, t); } function u(e, t, n, r) { return t !== null && t.type === n.type ? (r = o(t, n.props, r), r.ref = mn(e, t, n), r.return = e, r) : (r = Rt(n, e.mode, r), r.ref = mn(e, t, n), r.return = e, r); } function c(e, t, n, r) { return t === null || t.tag !== 4 || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? (t = Ft(n, e.mode, r), t.return = e, t) : (t = o(t, n.children || [], r), t.return = e, t); } function p(e, t, n, r, i) { return t === null || t.tag !== 10 ? (t = jt(n, e.mode, r, i), t.return = e, t) : (t = o(t, n, r), t.return = e, t); } function f(e, t, n) { if (typeof t === 'string' || typeof t === 'number') return t = Bt(`${t}`, e.mode, n), t.return = e, t; if (typeof t === 'object' && t !== null) { switch (t.$$typeof) { case Fi: return n = Rt(t, e.mode, n), n.ref = mn(e, null, t), n.return = e, n; case Ui: return t = Ft(t, e.mode, n), t.return = e, t; } if (La(t) || oe(t)) return t = jt(t, e.mode, n, null), t.return = e, t; gn(e, t); } return null; } function h(e, t, n, r) { const i = t !== null ? t.key : null; if (typeof n === 'string' || typeof n === 'number') return i !== null ? null : l(e, t, `${n}`, r); if (typeof n === 'object' && n !== null) { switch (n.$$typeof) { case Fi: return n.key === i ? n.type === Vi ? p(e, t, n.props.children, r, i) : u(e, t, n, r) : null; case Ui: return n.key === i ? c(e, t, n, r) : null; } if (La(n) || oe(n)) return i !== null ? null : p(e, t, n, r, null); gn(e, n); } return null; } function d(e, t, n, r, i) { if (typeof r === 'string' || typeof r === 'number') return e = e.get(n) || null, l(t, e, `${r}`, i); if (typeof r === 'object' && r !== null) { switch (r.$$typeof) { case Fi: return e = e.get(r.key === null ? n : r.key) || null, r.type === Vi ? p(t, e, r.props.children, i, r.key) : u(t, e, r, i); case Ui: return e = e.get(r.key === null ? n : r.key) || null, c(t, e, r, i); } if (La(r) || oe(r)) return e = e.get(n) || null, p(t, e, r, i, null); gn(t, r); } return null; } function m(r, o, s, l) { for (var u = null, c = null, p = o, m = o = 0, g = null; p !== null && m < s.length; m++) { p.index > m ? (g = p, p = null) : g = p.sibling; const y = h(r, p, s[m], l); if (y === null) { p === null && (p = g); break; }e && p && y.alternate === null && t(r, p), o = a(y, o, m), c === null ? u = y : c.sibling = y, c = y, p = g; } if (m === s.length) return n(r, p), u; if (p === null) { for (;m < s.length; m++)(p = f(r, s[m], l)) && (o = a(p, o, m), c === null ? u = p : c.sibling = p, c = p); return u; } for (p = i(r, p); m < s.length; m++)(g = d(p, r, m, s[m], l)) && (e && g.alternate !== null && p.delete(g.key === null ? m : g.key), o = a(g, o, m), c === null ? u = g : c.sibling = g, c = g); return e && p.forEach(e => t(r, e)), u; } function g(o, s, l, u) { let c = oe(l); typeof c !== 'function' && r('150'), (l = c.call(l)) == null && r('151'); for (var p = c = null, m = s, g = s = 0, y = null, v = l.next(); m !== null && !v.done; g++, v = l.next()) { m.index > g ? (y = m, m = null) : y = m.sibling; const _ = h(o, m, v.value, u); if (_ === null) { m || (m = y); break; }e && m && _.alternate === null && t(o, m), s = a(_, s, g), p === null ? c = _ : p.sibling = _, p = _, m = y; } if (v.done) return n(o, m), c; if (m === null) { for (;!v.done; g++, v = l.next())(v = f(o, v.value, u)) !== null && (s = a(v, s, g), p === null ? c = v : p.sibling = v, p = v); return c; } for (m = i(o, m); !v.done; g++, v = l.next())(v = d(m, o, g, v.value, u)) !== null && (e && v.alternate !== null && m.delete(v.key === null ? g : v.key), s = a(v, s, g), p === null ? c = v : p.sibling = v, p = v); return e && m.forEach(e => t(o, e)), c; } return function (e, i, a, l) { typeof a === 'object' && a !== null && a.type === Vi && a.key === null && (a = a.props.children); let u = typeof a === 'object' && a !== null; if (u) switch (a.$$typeof) { case Fi: e: { const c = a.key; for (u = i; u !== null;) { if (u.key === c) { if (u.tag === 10 ? a.type === Vi : u.type === a.type) { n(e, u.sibling), i = o(u, a.type === Vi ? a.props.children : a.props, l), i.ref = mn(e, u, a), i.return = e, e = i; break e; }n(e, u); break; }t(e, u), u = u.sibling; }a.type === Vi ? (i = jt(a.props.children, e.mode, l, a.key), i.return = e, e = i) : (l = Rt(a, e.mode, l), l.ref = mn(e, i, a), l.return = e, e = l); } return s(e); case Ui: e: { for (u = a.key; i !== null;) { if (i.key === u) { if (i.tag === 4 && i.stateNode.containerInfo === a.containerInfo && i.stateNode.implementation === a.implementation) { n(e, i.sibling), i = o(i, a.children || [], l), i.return = e, e = i; break e; }n(e, i); break; }t(e, i), i = i.sibling; }i = Ft(a, e.mode, l), i.return = e, e = i; } return s(e); } if (typeof a === 'string' || typeof a === 'number') return a = `${a}`, i !== null && i.tag === 6 ? (n(e, i.sibling), i = o(i, a, l), i.return = e, e = i) : (n(e, i), i = Bt(a, e.mode, l), i.return = e, e = i), s(e); if (La(a)) return m(e, i, a, l); if (oe(a)) return g(e, i, a, l); if (u && gn(e, a), typeof a === 'undefined') switch (e.tag) { case 2: case 1: l = e.type, r('152', l.displayName || l.name || 'Component'); } return n(e, i); }; } function vn(e, t) { const n = new Lt(5, null, null, 0); n.type = 'DELETED', n.stateNode = t, n.return = e, n.effectTag = 8, e.lastEffect !== null ? (e.lastEffect.nextEffect = n, e.lastEffect = n) : e.firstEffect = e.lastEffect = n; } function _n(e, t) { switch (e.tag) { case 5: var n = e.type; return (t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) !== null && (e.stateNode = t, !0); case 6: return (t = e.pendingProps === '' || t.nodeType !== 3 ? null : t) !== null && (e.stateNode = t, !0); default: return !1; } } function bn(e) { if (Fa) { let t = Ba; if (t) { const n = t; if (!_n(e, t)) { if (!(t = xt(n)) || !_n(e, t)) return e.effectTag |= 2, Fa = !1, void (ja = e); vn(ja, n); }ja = e, Ba = wt(t); } else e.effectTag |= 2, Fa = !1, ja = e; } } function xn(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3;)e = e.return; ja = e; } function wn(e) { if (e !== ja) return !1; if (!Fa) return xn(e), Fa = !0, !1; let t = e.type; if (e.tag !== 5 || t !== 'head' && t !== 'body' && !bt(t, e.memoizedProps)) for (t = Ba; t;)vn(e, t), t = xt(t); return xn(e), Ba = ja ? xt(e.stateNode) : null, !0; } function En() { Ba = ja = null, Fa = !1; } function Tn(e, t, n) { kn(e, t, n, t.expirationTime); } function kn(e, t, n, r) { t.child = e === null ? Ra(t, null, n, r) : za(t, e.child, n, r); } function Cn(e, t) { const n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.effectTag |= 128); } function Sn(e, t, n, r, i) { Cn(e, t); const o = (64 & t.effectTag) !== 0; if (!n && !o) return r && Dt(t, !1), Pn(e, t); n = t.stateNode, ji.current = t; const a = o ? null : n.render(); return t.effectTag |= 1, o && (kn(e, t, null, i), t.child = null), kn(e, t, a, i), t.memoizedState = n.state, t.memoizedProps = n.props, r && Dt(t, !0), t.child; } function An(e) { const t = e.stateNode; t.pendingContext ? Pt(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Pt(e, t.context, !1), ln(e, t.containerInfo); } function On(e, t, n, r) { let i = e.child; for (i !== null && (i.return = e); i !== null;) { switch (i.tag) { case 12: var o = 0 | i.stateNode; if (i.type === t && (o & n) !== 0) { for (o = i; o !== null;) { const a = o.alternate; if (o.expirationTime === 0 || o.expirationTime > r)o.expirationTime = r, a !== null && (a.expirationTime === 0 || a.expirationTime > r) && (a.expirationTime = r); else { if (a === null || !(a.expirationTime === 0 || a.expirationTime > r)) break; a.expirationTime = r; }o = o.return; }o = null; } else o = i.child; break; case 13: o = i.type === e.type ? null : i.child; break; default: o = i.child; } if (o !== null)o.return = i; else for (o = i; o !== null;) { if (o === e) { o = null; break; } if ((i = o.sibling) !== null) { i.return = o.return, o = i; break; }o = o.return; }i = o; } } function In(e, t, n) { const r = t.type._context; const i = t.pendingProps; const o = t.memoizedProps; let a = !0; if (wa.current)a = !1; else if (o === i) return t.stateNode = 0, on(t), Pn(e, t); let s = i.value; if (t.memoizedProps = i, o === null)s = 1073741823; else if (o.value === i.value) { if (o.children === i.children && a) return t.stateNode = 0, on(t), Pn(e, t); s = 0; } else { const l = o.value; if (l === s && (l !== 0 || 1 / l === 1 / s) || l !== l && s !== s) { if (o.children === i.children && a) return t.stateNode = 0, on(t), Pn(e, t); s = 0; } else if (s = typeof r._calculateChangedBits === 'function' ? r._calculateChangedBits(l, s) : 1073741823, (s |= 0) === 0) { if (o.children === i.children && a) return t.stateNode = 0, on(t), Pn(e, t); } else On(t, r, s, n); } return t.stateNode = s, on(t), Tn(e, t, i.children), t.child; } function Pn(e, t) { if (e !== null && t.child !== e.child && r('153'), t.child !== null) { e = t.child; let n = zt(e, e.pendingProps, e.expirationTime); for (t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = zt(e, e.pendingProps, e.expirationTime), n.return = t; n.sibling = null; } return t.child; } function Mn(e, t, n) { if (t.expirationTime === 0 || t.expirationTime > n) { switch (t.tag) { case 3: An(t); break; case 2: Nt(t); break; case 4: ln(t, t.stateNode.containerInfo); break; case 13: on(t); } return null; } switch (t.tag) { case 0: e !== null && r('155'); var i = t.type; var o = t.pendingProps; var a = Ct(t); return a = St(t, a), i = i(o, a), t.effectTag |= 1, typeof i === 'object' && i !== null && typeof i.render === 'function' && void 0 === i.$$typeof ? (a = t.type, t.tag = 2, t.memoizedState = i.state !== null && void 0 !== i.state ? i.state : null, a = a.getDerivedStateFromProps, typeof a === 'function' && pn(t, a, o), o = Nt(t), i.updater = Da, t.stateNode = i, i._reactInternalFiber = t, dn(t, n), e = Sn(e, t, !0, o, n)) : (t.tag = 1, Tn(e, t, i), t.memoizedProps = o, e = t.child), e; case 1: return o = t.type, n = t.pendingProps, wa.current || t.memoizedProps !== n ? (i = Ct(t), i = St(t, i), o = o(n, i), t.effectTag |= 1, Tn(e, t, o), t.memoizedProps = n, e = t.child) : e = Pn(e, t), e; case 2: if (o = Nt(t), e === null) if (t.stateNode === null) { var s = t.pendingProps; var l = t.type; i = Ct(t); var u = t.tag === 2 && t.type.contextTypes != null; a = u ? St(t, i) : Ur, s = new l(s, a), t.memoizedState = s.state !== null && void 0 !== s.state ? s.state : null, s.updater = Da, t.stateNode = s, s._reactInternalFiber = t, u && (u = t.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = i, u.__reactInternalMemoizedMaskedChildContext = a), dn(t, n), i = !0; } else { l = t.type, i = t.stateNode, u = t.memoizedProps, a = t.pendingProps, i.props = u; var c = i.context; s = Ct(t), s = St(t, s); var p = l.getDerivedStateFromProps; (l = typeof p === 'function' || typeof i.getSnapshotBeforeUpdate === 'function') || typeof i.UNSAFE_componentWillReceiveProps !== 'function' && typeof i.componentWillReceiveProps !== 'function' || (u !== a || c !== s) && hn(t, i, a, s), Ca = !1; var f = t.memoizedState; c = i.state = f; var h = t.updateQueue; h !== null && (en(t, h, a, i, n), c = t.memoizedState), u !== a || f !== c || wa.current || Ca ? (typeof p === 'function' && (pn(t, p, a), c = t.memoizedState), (u = Ca || fn(t, u, a, f, c, s)) ? (l || typeof i.UNSAFE_componentWillMount !== 'function' && typeof i.componentWillMount !== 'function' || (typeof i.componentWillMount === 'function' && i.componentWillMount(), typeof i.UNSAFE_componentWillMount === 'function' && i.UNSAFE_componentWillMount()), typeof i.componentDidMount === 'function' && (t.effectTag |= 4)) : (typeof i.componentDidMount === 'function' && (t.effectTag |= 4), t.memoizedProps = a, t.memoizedState = c), i.props = a, i.state = c, i.context = s, i = u) : (typeof i.componentDidMount === 'function' && (t.effectTag |= 4), i = !1); } else l = t.type, i = t.stateNode, a = t.memoizedProps, u = t.pendingProps, i.props = a, c = i.context, s = Ct(t), s = St(t, s), p = l.getDerivedStateFromProps, (l = typeof p === 'function' || typeof i.getSnapshotBeforeUpdate === 'function') || typeof i.UNSAFE_componentWillReceiveProps !== 'function' && typeof i.componentWillReceiveProps !== 'function' || (a !== u || c !== s) && hn(t, i, u, s), Ca = !1, c = t.memoizedState, f = i.state = c, h = t.updateQueue, h !== null && (en(t, h, u, i, n), f = t.memoizedState), a !== u || c !== f || wa.current || Ca ? (typeof p === 'function' && (pn(t, p, u), f = t.memoizedState), (p = Ca || fn(t, a, u, c, f, s)) ? (l || typeof i.UNSAFE_componentWillUpdate !== 'function' && typeof i.componentWillUpdate !== 'function' || (typeof i.componentWillUpdate === 'function' && i.componentWillUpdate(u, f, s), typeof i.UNSAFE_componentWillUpdate === 'function' && i.UNSAFE_componentWillUpdate(u, f, s)), typeof i.componentDidUpdate === 'function' && (t.effectTag |= 4), typeof i.getSnapshotBeforeUpdate === 'function' && (t.effectTag |= 256)) : (typeof i.componentDidUpdate !== 'function' || a === e.memoizedProps && c === e.memoizedState || (t.effectTag |= 4), typeof i.getSnapshotBeforeUpdate !== 'function' || a === e.memoizedProps && c === e.memoizedState || (t.effectTag |= 256), t.memoizedProps = u, t.memoizedState = f), i.props = u, i.state = f, i.context = s, i = p) : (typeof i.componentDidUpdate !== 'function' || a === e.memoizedProps && c === e.memoizedState || (t.effectTag |= 4), typeof i.getSnapshotBeforeUpdate !== 'function' || a === e.memoizedProps && c === e.memoizedState || (t.effectTag |= 256), i = !1); return Sn(e, t, i, o, n); case 3: return An(t), o = t.updateQueue, o !== null ? (i = t.memoizedState, i = i !== null ? i.element : null, en(t, o, t.pendingProps, null, n), (o = t.memoizedState.element) === i ? (En(), e = Pn(e, t)) : (i = t.stateNode, (i = (e === null || e.child === null) && i.hydrate) && (Ba = wt(t.stateNode.containerInfo), ja = t, i = Fa = !0), i ? (t.effectTag |= 2, t.child = Ra(t, null, o, n)) : (En(), Tn(e, t, o)), e = t.child)) : (En(), e = Pn(e, t)), e; case 5: return sn(Na.current), o = sn(Pa.current), i = at(o, t.type), o !== i && (kt(Ma, t, t), kt(Pa, i, t)), e === null && bn(t), o = t.type, u = t.memoizedProps, i = t.pendingProps, a = e !== null ? e.memoizedProps : null, wa.current || u !== i || ((u = 1 & t.mode && !!i.hidden) && (t.expirationTime = 1073741823), u && n === 1073741823) ? (u = i.children, bt(o, i) ? u = null : a && bt(o, a) && (t.effectTag |= 16), Cn(e, t), n !== 1073741823 && 1 & t.mode && i.hidden ? (t.expirationTime = 1073741823, t.memoizedProps = i, e = null) : (Tn(e, t, u), t.memoizedProps = i, e = t.child)) : e = Pn(e, t), e; case 6: return e === null && bn(t), t.memoizedProps = t.pendingProps, null; case 16: return null; case 4: return ln(t, t.stateNode.containerInfo), o = t.pendingProps, wa.current || t.memoizedProps !== o ? (e === null ? t.child = za(t, null, o, n) : Tn(e, t, o), t.memoizedProps = o, e = t.child) : e = Pn(e, t), e; case 14: return o = t.type.render, n = t.pendingProps, i = t.ref, wa.current || t.memoizedProps !== n || i !== (e !== null ? e.ref : null) ? (o = o(n, i), Tn(e, t, o), t.memoizedProps = n, e = t.child) : e = Pn(e, t), e; case 10: return n = t.pendingProps, wa.current || t.memoizedProps !== n ? (Tn(e, t, n), t.memoizedProps = n, e = t.child) : e = Pn(e, t), e; case 11: return n = t.pendingProps.children, wa.current || n !== null && t.memoizedProps !== n ? (Tn(e, t, n), t.memoizedProps = n, e = t.child) : e = Pn(e, t), e; case 15: return n = t.pendingProps, t.memoizedProps === n ? e = Pn(e, t) : (Tn(e, t, n.children), t.memoizedProps = n, e = t.child), e; case 13: return In(e, t, n); case 12: e:if (i = t.type, a = t.pendingProps, u = t.memoizedProps, o = i._currentValue, s = i._changedBits, wa.current || s !== 0 || u !== a) { if (t.memoizedProps = a, l = a.unstable_observedBits, void 0 !== l && l !== null || (l = 1073741823), t.stateNode = l, (s & l) !== 0)On(t, i, s, n); else if (u === a) { e = Pn(e, t); break e; }n = a.children, n = n(o), t.effectTag |= 1, Tn(e, t, n), e = t.child; } else e = Pn(e, t); return e; default: r('156'); } } function Nn(e) { e.effectTag |= 4; } function Dn(e, t) { let n = t.pendingProps; switch (t.tag) { case 1: return null; case 2: return Ot(t), null; case 3: un(t), It(t); var i = t.stateNode; return i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), e !== null && e.child !== null || (wn(t), t.effectTag &= -3), Ua(t), null; case 5: cn(t), i = sn(Na.current); var o = t.type; if (e !== null && t.stateNode != null) { var a = e.memoizedProps; let s = t.stateNode; const l = sn(Pa.current); s = mt(s, o, a, n, i), Va(e, t, s, o, a, n, i, l), e.ref !== t.ref && (t.effectTag |= 128); } else { if (!n) return t.stateNode === null && r('166'), null; if (e = sn(Pa.current), wn(t))n = t.stateNode, o = t.type, a = t.memoizedProps, n[ri] = t, n[ii] = a, i = yt(n, o, a, e, i), t.updateQueue = i, i !== null && Nn(t); else { e = ft(o, n, i, e), e[ri] = t, e[ii] = n; e:for (a = t.child; a !== null;) { if (a.tag === 5 || a.tag === 6)e.appendChild(a.stateNode); else if (a.tag !== 4 && a.child !== null) { a.child.return = a, a = a.child; continue; } if (a === t) break; for (;a.sibling === null;) { if (a.return === null || a.return === t) break e; a = a.return; }a.sibling.return = a.return, a = a.sibling; }dt(e, o, n, i), _t(o, n) && Nn(t), t.stateNode = e; }t.ref !== null && (t.effectTag |= 128); } return null; case 6: if (e && t.stateNode != null)qa(e, t, e.memoizedProps, n); else { if (typeof n !== 'string') return t.stateNode === null && r('166'), null; i = sn(Na.current), sn(Pa.current), wn(t) ? (i = t.stateNode, n = t.memoizedProps, i[ri] = t, vt(i, n) && Nn(t)) : (i = ht(n, i), i[ri] = t, t.stateNode = i); } return null; case 14: case 16: case 10: case 11: case 15: return null; case 4: return un(t), Ua(t), null; case 13: return an(t), null; case 12: return null; case 0: r('167'); default: r('156'); } } function Ln(e, t) { const n = t.source; t.stack === null && n !== null && se(n), n !== null && ae(n), t = t.value, e !== null && e.tag === 2 && ae(e); try { t && t.suppressReactErrorLogging || console.error(t); } catch (e) { e && e.suppressReactErrorLogging || console.error(e); } } function zn(e) { const t = e.ref; if (t !== null) if (typeof t === 'function') try { t(null); } catch (t) { Xn(e, t); } else t.current = null; } function Rn(e) { switch (typeof Wt === 'function' && Wt(e), e.tag) { case 2: zn(e); var t = e.stateNode; if (typeof t.componentWillUnmount === 'function') try { t.props = e.memoizedProps, t.state = e.memoizedState, t.componentWillUnmount(); } catch (t) { Xn(e, t); } break; case 5: zn(e); break; case 4: Fn(e); } } function jn(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4; } function Bn(e) { e: { for (var t = e.return; t !== null;) { if (jn(t)) { var n = t; break e; }t = t.return; }r('160'), n = void 0; } let i = t = void 0; switch (n.tag) { case 5: t = n.stateNode, i = !1; break; case 3: case 4: t = n.stateNode.containerInfo, i = !0; break; default: r('161'); }16 & n.effectTag && (st(t, ''), n.effectTag &= -17); e:t:for (n = e; ;) { for (;n.sibling === null;) { if (n.return === null || jn(n.return)) { n = null; break e; }n = n.return; } for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6;) { if (2 & n.effectTag) continue t; if (n.child === null || n.tag === 4) continue t; n.child.return = n, n = n.child; } if (!(2 & n.effectTag)) { n = n.stateNode; break e; } } for (let o = e; ;) { if (o.tag === 5 || o.tag === 6) if (n) if (i) { var a = t; var s = o.stateNode; const l = n; a.nodeType === 8 ? a.parentNode.insertBefore(s, l) : a.insertBefore(s, l); } else t.insertBefore(o.stateNode, n); else i ? (a = t, s = o.stateNode, a.nodeType === 8 ? a.parentNode.insertBefore(s, a) : a.appendChild(s)) : t.appendChild(o.stateNode); else if (o.tag !== 4 && o.child !== null) { o.child.return = o, o = o.child; continue; } if (o === e) break; for (;o.sibling === null;) { if (o.return === null || o.return === e) return; o = o.return; }o.sibling.return = o.return, o = o.sibling; } } function Fn(e) { for (let t = e, n = !1, i = void 0, o = void 0; ;) { if (!n) { n = t.return; e:for (;;) { switch (n === null && r('160'), n.tag) { case 5: i = n.stateNode, o = !1; break e; case 3: case 4: i = n.stateNode.containerInfo, o = !0; break e; }n = n.return; }n = !0; } if (t.tag === 5 || t.tag === 6) { e:for (var a = t, s = a; ;) if (Rn(s), s.child !== null && s.tag !== 4)s.child.return = s, s = s.child; else { if (s === a) break; for (;s.sibling === null;) { if (s.return === null || s.return === a) break e; s = s.return; }s.sibling.return = s.return, s = s.sibling; }o ? (a = i, s = t.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(s) : a.removeChild(s)) : i.removeChild(t.stateNode); } else if (t.tag === 4 ? i = t.stateNode.containerInfo : Rn(t), t.child !== null) { t.child.return = t, t = t.child; continue; } if (t === e) break; for (;t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return, t.tag === 4 && (n = !1); }t.sibling.return = t.return, t = t.sibling; } } function Un(e, t) { switch (t.tag) { case 2: break; case 5: var n = t.stateNode; if (n != null) { const i = t.memoizedProps; e = e !== null ? e.memoizedProps : i; const o = t.type; const a = t.updateQueue; t.updateQueue = null, a !== null && (n[ii] = i, gt(n, a, o, e, i)); } break; case 6: t.stateNode === null && r('162'), t.stateNode.nodeValue = t.memoizedProps; break; case 3: case 15: case 16: break; default: r('163'); } } function Vn(e, t, n) { n = Zt(n), n.tag = 3, n.payload = { element: null }; const r = t.value; return n.callback = function () { dr(r), Ln(e, t); }, n; } function qn(e, t, n) { n = Zt(n), n.tag = 3; const r = e.stateNode; return r !== null && typeof r.componentDidCatch === 'function' && (n.callback = function () { is === null ? is = new Set([this]) : is.add(this); const n = t.value; const r = t.stack; Ln(e, t), this.componentDidCatch(n, { componentStack: r !== null ? r : '' }); }), n; } function Hn(e, t, n, r, i, o) { n.effectTag |= 512, n.firstEffect = n.lastEffect = null, r = rn(r, n), e = t; do { switch (e.tag) { case 3: return e.effectTag |= 1024, r = Vn(e, r, o), void Yt(e, r, o); case 2: if (t = r, n = e.stateNode, (64 & e.effectTag) === 0 && n !== null && typeof n.componentDidCatch === 'function' && (is === null || !is.has(n))) return e.effectTag |= 1024, r = qn(e, t, o), void Yt(e, r, o); }e = e.return; } while (e !== null); } function Wn(e) { switch (e.tag) { case 2: Ot(e); var t = e.effectTag; return 1024 & t ? (e.effectTag = -1025 & t | 64, e) : null; case 3: return un(e), It(e), t = e.effectTag, 1024 & t ? (e.effectTag = -1025 & t | 64, e) : null; case 5: return cn(e), null; case 16: return t = e.effectTag, 1024 & t ? (e.effectTag = -1025 & t | 64, e) : null; case 4: return un(e), null; case 13: return an(e), null; default: return null; } } function $n() { if (Xa !== null) for (let e = Xa.return; e !== null;) { const t = e; switch (t.tag) { case 2: Ot(t); break; case 3: un(t), It(t); break; case 5: cn(t); break; case 4: un(t); break; case 13: an(t); }e = e.return; }Ya = null, Ja = 0, Qa = -1, es = !1, Xa = null, rs = !1; } function Gn(e) { for (;;) { let t = e.alternate; const n = e.return; const r = e.sibling; if ((512 & e.effectTag) === 0) { t = Dn(t, e, Ja); const i = e; if (Ja === 1073741823 || i.expirationTime !== 1073741823) { let o = 0; switch (i.tag) { case 3: case 2: var a = i.updateQueue; a !== null && (o = a.expirationTime); } for (a = i.child; a !== null;)a.expirationTime !== 0 && (o === 0 || o > a.expirationTime) && (o = a.expirationTime), a = a.sibling; i.expirationTime = o; } if (t !== null) return t; if (n !== null && (512 & n.effectTag) === 0 && (n.firstEffect === null && (n.firstEffect = e.firstEffect), e.lastEffect !== null && (n.lastEffect !== null && (n.lastEffect.nextEffect = e.firstEffect), n.lastEffect = e.lastEffect), e.effectTag > 1 && (n.lastEffect !== null ? n.lastEffect.nextEffect = e : n.firstEffect = e, n.lastEffect = e)), r !== null) return r; if (n === null) { rs = !0; break; }e = n; } else { if ((e = Wn(e, es, Ja)) !== null) return e.effectTag &= 511, e; if (n !== null && (n.firstEffect = n.lastEffect = null, n.effectTag |= 512), r !== null) return r; if (n === null) break; e = n; } } return null; } function Zn(e) { let t = Mn(e.alternate, e, Ja); return t === null && (t = Gn(e)), ji.current = null, t; } function Kn(e, t, n) { Ka && r('243'), Ka = !0, t === Ja && e === Ya && Xa !== null || ($n(), Ya = e, Ja = t, Qa = -1, Xa = zt(Ya.current, null, Ja), e.pendingCommitExpirationTime = 0); let i = !1; for (es = !n || Ja <= Wa; ;) { try { if (n) for (;Xa !== null && !hr();)Xa = Zn(Xa); else for (;Xa !== null;)Xa = Zn(Xa); } catch (t) { if (Xa === null)i = !0, dr(t); else { Xa === null && r('271'), n = Xa; const o = n.return; if (o === null) { i = !0, dr(t); break; }Hn(e, o, n, t, es, Ja, $a), Xa = Gn(n); } } break; } if (Ka = !1, i) return null; if (Xa === null) { if (rs) return e.pendingCommitExpirationTime = t, e.current.alternate; es && r('262'), Qa >= 0 && setTimeout(() => { const t = e.current.expirationTime; t !== 0 && (e.remainingExpirationTime === 0 || e.remainingExpirationTime < t) && ir(e, t); }, Qa), mr(e.current.expirationTime); } return null; } function Xn(e, t) { let n; e: { for (Ka && !ns && r('263'), n = e.return; n !== null;) { switch (n.tag) { case 2: var i = n.stateNode; if (typeof n.type.getDerivedStateFromCatch === 'function' || typeof i.componentDidCatch === 'function' && (is === null || !is.has(i))) { e = rn(t, e), e = qn(n, e, 1), Xt(n, e, 1), Qn(n, 1), n = void 0; break e; } break; case 3: e = rn(t, e), e = Vn(n, e, 1), Xt(n, e, 1), Qn(n, 1), n = void 0; break e; }n = n.return; }e.tag === 3 && (n = rn(t, e), n = Vn(e, n, 1), Xt(e, n, 1), Qn(e, 1)), n = void 0; } return n; } function Yn() { let e = 2 + 25 * (1 + ((er() - 2 + 500) / 25 | 0)); return e <= Ga && (e = Ga + 1), Ga = e; } function Jn(e, t) { return e = Za !== 0 ? Za : Ka ? ns ? 1 : Ja : 1 & t.mode ? _s ? 2 + 10 * (1 + ((e - 2 + 15) / 10 | 0)) : 2 + 25 * (1 + ((e - 2 + 500) / 25 | 0)) : 1, _s && (fs === 0 || e > fs) && (fs = e), e; } function Qn(e, t) { for (;e !== null;) { if ((e.expirationTime === 0 || e.expirationTime > t) && (e.expirationTime = t), e.alternate !== null && (e.alternate.expirationTime === 0 || e.alternate.expirationTime > t) && (e.alternate.expirationTime = t), e.return === null) { if (e.tag !== 3) break; const n = e.stateNode; !Ka && Ja !== 0 && t < Ja && $n(); const i = n.current.expirationTime; Ka && !ns && Ya === n || ir(n, i), ws > xs && r('185'); }e = e.return; } } function er() { return $a = ga() - Ha, Wa = 2 + ($a / 10 | 0); } function tr(e) { const t = Za; Za = 2 + 25 * (1 + ((er() - 2 + 500) / 25 | 0)); try { return e(); } finally { Za = t; } } function nr(e, t, n, r, i) { const o = Za; Za = 1; try { return e(t, n, r, i); } finally { Za = o; } } function rr(e) { if (ss !== 0) { if (e > ss) return; va(ls); } const t = ga() - Ha; ss = e, ls = ya(ar, { timeout: 10 * (e - 2) - t }); } function ir(e, t) { if (e.nextScheduledRoot === null)e.remainingExpirationTime = t, as === null ? (os = as = e, e.nextScheduledRoot = e) : (as = as.nextScheduledRoot = e, as.nextScheduledRoot = os); else { const n = e.remainingExpirationTime; (n === 0 || t < n) && (e.remainingExpirationTime = t); }us || (ys ? vs && (cs = e, ps = 1, pr(e, 1, !1)) : t === 1 ? sr() : rr(t)); } function or() { let e = 0; let t = null; if (as !== null) for (var n = as, i = os; i !== null;) { let o = i.remainingExpirationTime; if (o === 0) { if ((n === null || as === null) && r('244'), i === i.nextScheduledRoot) { os = as = i.nextScheduledRoot = null; break; } if (i === os)os = o = i.nextScheduledRoot, as.nextScheduledRoot = o, i.nextScheduledRoot = null; else { if (i === as) { as = n, as.nextScheduledRoot = os, i.nextScheduledRoot = null; break; }n.nextScheduledRoot = i.nextScheduledRoot, i.nextScheduledRoot = null; }i = n.nextScheduledRoot; } else { if ((e === 0 || o < e) && (e = o, t = i), i === as) break; n = i, i = i.nextScheduledRoot; } }n = cs, n !== null && n === t && e === 1 ? ws++ : ws = 0, cs = t, ps = e; } function ar(e) { lr(0, !0, e); } function sr() { lr(1, !1, null); } function lr(e, t, n) { if (gs = n, or(), t) for (;cs !== null && ps !== 0 && (e === 0 || e >= ps) && (!hs || er() >= ps);)er(), pr(cs, ps, !hs), or(); else for (;cs !== null && ps !== 0 && (e === 0 || e >= ps);)pr(cs, ps, !1), or(); gs !== null && (ss = 0, ls = -1), ps !== 0 && rr(ps), gs = null, hs = !1, cr(); } function ur(e, t) { us && r('253'), cs = e, ps = t, pr(e, t, !1), sr(), cr(); } function cr() { if (ws = 0, bs !== null) { var e = bs; bs = null; for (let t = 0; t < e.length; t++) { const n = e[t]; try { n._onComplete(); } catch (e) { ds || (ds = !0, ms = e); } } } if (ds) throw e = ms, ms = null, ds = !1, e; } function pr(e, t, n) { us && r('245'), us = !0, n ? (n = e.finishedWork, n !== null ? fr(e, n, t) : (e.finishedWork = null, (n = Kn(e, t, !0)) !== null && (hr() ? e.finishedWork = n : fr(e, n, t)))) : (n = e.finishedWork, n !== null ? fr(e, n, t) : (e.finishedWork = null, (n = Kn(e, t, !1)) !== null && fr(e, n, t))), us = !1; } function fr(e, t, n) { let i = e.firstBatch; if (i !== null && i._expirationTime <= n && (bs === null ? bs = [i] : bs.push(i), i._defer)) return e.finishedWork = t, void (e.remainingExpirationTime = 0); if (e.finishedWork = null, ns = Ka = !0, n = t.stateNode, n.current === t && r('177'), i = n.pendingCommitExpirationTime, i === 0 && r('261'), n.pendingCommitExpirationTime = 0, er(), ji.current = null, t.effectTag > 1) if (t.lastEffect !== null) { t.lastEffect.nextEffect = t; var o = t.firstEffect; } else o = t; else o = t.firstEffect; da = Io; let a = jr(); if (Ke(a)) { if ('selectionStart' in a) var s = { start: a.selectionStart, end: a.selectionEnd }; else e: { let l = window.getSelection && window.getSelection(); if (l && l.rangeCount !== 0) { s = l.anchorNode; var u = l.anchorOffset; const c = l.focusNode; l = l.focusOffset; try { s.nodeType, c.nodeType; } catch (e) { s = null; break e; } let p = 0; let f = -1; let h = -1; let d = 0; let m = 0; let g = a; let y = null; t:for (;;) { for (var v; g !== s || u !== 0 && g.nodeType !== 3 || (f = p + u), g !== c || l !== 0 && g.nodeType !== 3 || (h = p + l), g.nodeType === 3 && (p += g.nodeValue.length), (v = g.firstChild) !== null;)y = g, g = v; for (;;) { if (g === a) break t; if (y === s && ++d === u && (f = p), y === c && ++m === l && (h = p), (v = g.nextSibling) !== null) break; g = y, y = g.parentNode; }g = v; }s = f === -1 || h === -1 ? null : { start: f, end: h }; } else s = null; }s = s || { start: 0, end: 0 }; } else s = null; for (ma = { focusedElem: a, selectionRange: s }, Ue(!1), ts = o; ts !== null;) { a = !1, s = void 0; try { for (;ts !== null;) { if (256 & ts.effectTag) { var _ = ts.alternate; switch (u = ts, u.tag) { case 2: if (256 & u.effectTag && _ !== null) { var b = _.memoizedProps; var x = _.memoizedState; var w = u.stateNode; w.props = u.memoizedProps, w.state = u.memoizedState; const E = w.getSnapshotBeforeUpdate(b, x); w.__reactInternalSnapshotBeforeUpdate = E; } break; case 3: case 5: case 6: case 4: break; default: r('163'); } }ts = ts.nextEffect; } } catch (e) { a = !0, s = e; }a && (ts === null && r('178'), Xn(ts, s), ts !== null && (ts = ts.nextEffect)); } for (ts = o; ts !== null;) { _ = !1, b = void 0; try { for (;ts !== null;) { var T = ts.effectTag; if (16 & T && st(ts.stateNode, ''), 128 & T) { var k = ts.alternate; if (k !== null) { var C = k.ref; C !== null && (typeof C === 'function' ? C(null) : C.current = null); } } switch (14 & T) { case 2: Bn(ts), ts.effectTag &= -3; break; case 6: Bn(ts), ts.effectTag &= -3, Un(ts.alternate, ts); break; case 4: Un(ts.alternate, ts); break; case 8: x = ts, Fn(x), x.return = null, x.child = null, x.alternate && (x.alternate.child = null, x.alternate.return = null); }ts = ts.nextEffect; } } catch (e) { _ = !0, b = e; }_ && (ts === null && r('178'), Xn(ts, b), ts !== null && (ts = ts.nextEffect)); } if (C = ma, k = jr(), T = C.focusedElem, _ = C.selectionRange, k !== T && Fr(document.documentElement, T)) { Ke(T) && (k = _.start, C = _.end, void 0 === C && (C = k), 'selectionStart' in T ? (T.selectionStart = k, T.selectionEnd = Math.min(C, T.value.length)) : window.getSelection && (k = window.getSelection(), b = T[N()].length, C = Math.min(_.start, b), _ = void 0 === _.end ? C : Math.min(_.end, b), !k.extend && C > _ && (b = _, _ = C, C = b), b = Ze(T, C), x = Ze(T, _), b && x && (k.rangeCount !== 1 || k.anchorNode !== b.node || k.anchorOffset !== b.offset || k.focusNode !== x.node || k.focusOffset !== x.offset) && (w = document.createRange(), w.setStart(b.node, b.offset), k.removeAllRanges(), C > _ ? (k.addRange(w), k.extend(x.node, x.offset)) : (w.setEnd(x.node, x.offset), k.addRange(w))))), k = []; for (C = T; C = C.parentNode;)C.nodeType === 1 && k.push({ element: C, left: C.scrollLeft, top: C.scrollTop }); for (T.focus(), T = 0; T < k.length; T++)C = k[T], C.element.scrollLeft = C.left, C.element.scrollTop = C.top; } for (ma = null, Ue(da), da = null, n.current = t, ts = o; ts !== null;) { o = !1, T = void 0; try { for (k = i; ts !== null;) { const S = ts.effectTag; if (36 & S) { const A = ts.alternate; switch (C = ts, _ = k, C.tag) { case 2: var O = C.stateNode; if (4 & C.effectTag) if (A === null)O.props = C.memoizedProps, O.state = C.memoizedState, O.componentDidMount(); else { const I = A.memoizedProps; const P = A.memoizedState; O.props = C.memoizedProps, O.state = C.memoizedState, O.componentDidUpdate(I, P, O.__reactInternalSnapshotBeforeUpdate); } var M = C.updateQueue; M !== null && (O.props = C.memoizedProps, O.state = C.memoizedState, nn(C, M, O, _)); break; case 3: var D = C.updateQueue; if (D !== null) { if (b = null, C.child !== null) switch (C.child.tag) { case 5: b = C.child.stateNode; break; case 2: b = C.child.stateNode; }nn(C, D, b, _); } break; case 5: var L = C.stateNode; A === null && 4 & C.effectTag && _t(C.type, C.memoizedProps) && L.focus(); break; case 6: case 4: case 15: case 16: break; default: r('163'); } } if (128 & S) { C = void 0; const z = ts.ref; if (z !== null) { const R = ts.stateNode; switch (ts.tag) { case 5: C = R; break; default: C = R; } typeof z === 'function' ? z(C) : z.current = C; } } const j = ts.nextEffect; ts.nextEffect = null, ts = j; } } catch (e) { o = !0, T = e; }o && (ts === null && r('178'), Xn(ts, T), ts !== null && (ts = ts.nextEffect)); }Ka = ns = !1, typeof Ht === 'function' && Ht(t.stateNode), t = n.current.expirationTime, t === 0 && (is = null), e.remainingExpirationTime = t; } function hr() { return !(gs === null || gs.timeRemaining() > Es) && (hs = !0); } function dr(e) { cs === null && r('246'), cs.remainingExpirationTime = 0, ds || (ds = !0, ms = e); } function mr(e) { cs === null && r('246'), cs.remainingExpirationTime = e; } function gr(e, t) { const n = ys; ys = !0; try { return e(t); } finally { (ys = n) || us || sr(); } } function yr(e, t) { if (ys && !vs) { vs = !0; try { return e(t); } finally { vs = !1; } } return e(t); } function vr(e, t) { us && r('187'); const n = ys; ys = !0; try { return nr(e, t); } finally { ys = n, sr(); } } function _r(e) { const t = ys; ys = !0; try { nr(e); } finally { (ys = t) || us || lr(1, !1, null); } } function br(e, t, n, i, o) { const a = t.current; if (n) { n = n._reactInternalFiber; let s; e: { for (Ne(n) === 2 && n.tag === 2 || r('170'), s = n; s.tag !== 3;) { if (At(s)) { s = s.stateNode.__reactInternalMemoizedMergedChildContext; break e; }(s = s.return) || r('171'); }s = s.stateNode.context; }n = At(n) ? Mt(n, s) : s; } else n = Ur; return t.context === null ? t.context = n : t.pendingContext = n, t = o, o = Zt(i), o.payload = { element: e }, t = void 0 === t ? null : t, t !== null && (o.callback = t), Xt(a, o, i), Qn(a, i), i; } function xr(e) { const t = e._reactInternalFiber; return void 0 === t && (typeof e.render === 'function' ? r('188') : r('268', Object.keys(e))), e = ze(t), e === null ? null : e.stateNode; } function wr(e, t, n, r) { let i = t.current; return i = Jn(er(), i), br(e, t, n, i, r); } function Er(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: default: return e.child.stateNode; } } function Tr(e) { const t = e.findFiberByHostInstance; return qt(zr({}, e, { findHostInstanceByFiber(e) { return e = ze(e), e === null ? null : e.stateNode; }, findFiberByHostInstance(e) { return t ? t(e) : null; } })); } function kr(e, t, n) {
    const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; return {
      $$typeof: Ui, key: r == null ? null : `${r}`, children: e, containerInfo: t, implementation: n,
    };
  } function Cr(e) { this._expirationTime = Yn(), this._root = e, this._callbacks = this._next = null, this._hasChildren = this._didComplete = !1, this._children = null, this._defer = !0; } function Sr() { this._callbacks = null, this._didCommit = !1, this._onCommit = this._onCommit.bind(this); } function Ar(e, t, n) { this._internalRoot = Ut(e, t, n); } function Or(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable ')); } function Ir(e, t) { if (t || (t = e ? e.nodeType === 9 ? e.documentElement : e.firstChild : null, t = !(!t || t.nodeType !== 1 || !t.hasAttribute('data-reactroot'))), !t) for (var n; n = e.lastChild;)e.removeChild(n); return new Ar(e, !1, t); } function Pr(e, t, n, i, o) { Or(n) || r('200'); let a = n._reactRootContainer; if (a) { if (typeof o === 'function') { const s = o; o = function () { const e = Er(a._internalRoot); s.call(e); }; }e != null ? a.legacy_renderSubtreeIntoContainer(e, t, o) : a.render(t, o); } else { if (a = n._reactRootContainer = Ir(n, i), typeof o === 'function') { const l = o; o = function () { const e = Er(a._internalRoot); l.call(e); }; }yr(() => { e != null ? a.legacy_renderSubtreeIntoContainer(e, t, o) : a.render(t, o); }); } return Er(a._internalRoot); } function Mr(e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; return Or(t) || r('200'), kr(e, t, null, n); } var Nr = n(8); var Dr = n(0); var Lr = n(42); var zr = n(7); var Rr = n(9); var jr = n(43); var Br = n(44); var Fr = n(45); var Ur = n(12); Dr || r('227'); var Vr = {
    _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, invokeGuardedCallback(e, t, n, r, o, a, s, l, u) { i.apply(Vr, arguments); }, invokeGuardedCallbackAndCatchFirstError(e, t, n, r, i, o, a, s, l) { if (Vr.invokeGuardedCallback.apply(this, arguments), Vr.hasCaughtError()) { const u = Vr.clearCaughtError(); Vr._hasRethrowError || (Vr._hasRethrowError = !0, Vr._rethrowError = u); } }, rethrowCaughtError() { return o.apply(Vr, arguments); }, hasCaughtError() { return Vr._hasCaughtError; }, clearCaughtError() { if (Vr._hasCaughtError) { const e = Vr._caughtError; return Vr._caughtError = null, Vr._hasCaughtError = !1, e; }r('198'); },
  }; var qr = null; var Hr = {}; var Wr = []; var $r = {}; var Gr = {}; var Zr = {}; const Kr = {
    plugins: Wr, eventNameDispatchConfigs: $r, registrationNameModules: Gr, registrationNameDependencies: Zr, possibleRegistrationNames: null, injectEventPluginOrder: l, injectEventPluginsByName: u,
  }; var Xr = null; var Yr = null; var Jr = null; var Qr = null; const ei = { injectEventPluginOrder: l, injectEventPluginsByName: u }; const ti = {
    injection: ei, getListener: g, runEventsInBatch: y, runExtractedEventsInBatch: v,
  }; const ni = Math.random().toString(36).slice(2); var ri = `__reactInternalInstance$${ni}`; var ii = `__reactEventHandlers$${ni}`; const oi = {
    precacheFiberNode(e, t) { t[ri] = e; }, getClosestInstanceFromNode: _, getInstanceFromNode(e) { return e = e[ri], !e || e.tag !== 5 && e.tag !== 6 ? null : e; }, getNodeFromInstance: b, getFiberCurrentPropsFromNode: x, updateFiberProps(e, t) { e[ii] = t; },
  }; const ai = {
    accumulateTwoPhaseDispatches: O, accumulateTwoPhaseDispatchesSkipTarget(e) { f(e, C); }, accumulateEnterLeaveDispatches: I, accumulateDirectDispatches(e) { f(e, A); },
  }; var si = {
    animationend: P('Animation', 'AnimationEnd'), animationiteration: P('Animation', 'AnimationIteration'), animationstart: P('Animation', 'AnimationStart'), transitionend: P('Transition', 'TransitionEnd'),
  }; var li = {}; var ui = {}; Lr.canUseDOM && (ui = document.createElement('div').style, 'AnimationEvent' in window || (delete si.animationend.animation, delete si.animationiteration.animation, delete si.animationstart.animation), 'TransitionEvent' in window || delete si.transitionend.transition); const ci = M('animationend'); const pi = M('animationiteration'); const fi = M('animationstart'); const hi = M('transitionend'); var di = 'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting'.split(' '); var mi = null; var gi = { _root: null, _startText: null, _fallbackText: null }; const yi = 'dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances'.split(' '); const vi = {
    type: null, target: null, currentTarget: Rr.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp(e) { return e.timeStamp || Date.now(); }, defaultPrevented: null, isTrusted: null,
  }; zr(z.prototype, {
    preventDefault() { this.defaultPrevented = !0; const e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : typeof e.returnValue !== 'unknown' && (e.returnValue = !1), this.isDefaultPrevented = Rr.thatReturnsTrue); }, stopPropagation() { const e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : typeof e.cancelBubble !== 'unknown' && (e.cancelBubble = !0), this.isPropagationStopped = Rr.thatReturnsTrue); }, persist() { this.isPersistent = Rr.thatReturnsTrue; }, isPersistent: Rr.thatReturnsFalse, destructor() { let e; let t = this.constructor.Interface; for (e in t) this[e] = null; for (t = 0; t < yi.length; t++) this[yi[t]] = null; },
  }), z.Interface = vi, z.extend = function (e) { function t() {} function n() { return r.apply(this, arguments); } var r = this; t.prototype = r.prototype; const i = new t(); return zr(i, n.prototype), n.prototype = i, n.prototype.constructor = n, n.Interface = zr({}, r.Interface, e), n.extend = r.extend, B(n), n; }, B(z); const _i = z.extend({ data: null }); const bi = z.extend({ data: null }); var xi = [9, 13, 27, 32]; var wi = Lr.canUseDOM && 'CompositionEvent' in window; let Ei = null; Lr.canUseDOM && 'documentMode' in document && (Ei = document.documentMode); const Ti = Lr.canUseDOM && 'TextEvent' in window && !Ei; var ki = Lr.canUseDOM && (!wi || Ei && Ei > 8 && Ei <= 11); var Ci = String.fromCharCode(32); const Si = {
    beforeInput: { phasedRegistrationNames: { bubbled: 'onBeforeInput', captured: 'onBeforeInputCapture' }, dependencies: ['compositionend', 'keypress', 'textInput', 'paste'] }, compositionEnd: { phasedRegistrationNames: { bubbled: 'onCompositionEnd', captured: 'onCompositionEndCapture' }, dependencies: 'blur compositionend keydown keypress keyup mousedown'.split(' ') }, compositionStart: { phasedRegistrationNames: { bubbled: 'onCompositionStart', captured: 'onCompositionStartCapture' }, dependencies: 'blur compositionstart keydown keypress keyup mousedown'.split(' ') }, compositionUpdate: { phasedRegistrationNames: { bubbled: 'onCompositionUpdate', captured: 'onCompositionUpdateCapture' }, dependencies: 'blur compositionupdate keydown keypress keyup mousedown'.split(' ') },
  }; var Ai = !1; var Oi = !1; const Ii = { eventTypes: Si, extractEvents(e, t, n, r) { let i = void 0; let o = void 0; if (wi)e: { switch (e) { case 'compositionstart': i = Si.compositionStart; break e; case 'compositionend': i = Si.compositionEnd; break e; case 'compositionupdate': i = Si.compositionUpdate; break e; }i = void 0; } else Oi ? F(e, n) && (i = Si.compositionEnd) : e === 'keydown' && n.keyCode === 229 && (i = Si.compositionStart); return i ? (ki && (Oi || i !== Si.compositionStart ? i === Si.compositionEnd && Oi && (o = D()) : (gi._root = r, gi._startText = L(), Oi = !0)), i = _i.getPooled(i, t, n, r), o ? i.data = o : (o = U(n)) !== null && (i.data = o), O(i), o = i) : o = null, (e = Ti ? V(e, n) : q(e, n)) ? (t = bi.getPooled(Si.beforeInput, t, n, r), t.data = e, O(t)) : t = null, o === null ? t : t === null ? o : [o, t]; } }; var Pi = null; const Mi = { injectFiberControlledHostComponent(e) { Pi = e; } }; var Ni = null; var Di = null; const Li = {
    injection: Mi, enqueueStateRestore: W, needsStateRestore: $, restoreStateIfNeeded: G,
  }; var zi = !1; var Ri = {
    color: !0, date: !0, datetime: !0, 'datetime-local': !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0,
  }; var ji = Dr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner; const Bi = typeof Symbol === 'function' && Symbol.for; var Fi = Bi ? Symbol.for('react.element') : 60103; var Ui = Bi ? Symbol.for('react.portal') : 60106; var Vi = Bi ? Symbol.for('react.fragment') : 60107; var qi = Bi ? Symbol.for('react.strict_mode') : 60108; var Hi = Bi ? Symbol.for('react.profiler') : 60114; var Wi = Bi ? Symbol.for('react.provider') : 60109; var $i = Bi ? Symbol.for('react.context') : 60110; var Gi = Bi ? Symbol.for('react.async_mode') : 60111; var Zi = Bi ? Symbol.for('react.forward_ref') : 60112; var Ki = Bi ? Symbol.for('react.timeout') : 60113; var Xi = typeof Symbol === 'function' && Symbol.iterator; var Yi = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/; var Ji = {}; var Qi = {}; var eo = {}; 'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach((e) => { eo[e] = new pe(e, 0, !1, e, null); }), [['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach((e) => { const t = e[0]; eo[t] = new pe(t, 1, !1, e[1], null); }), ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach((e) => { eo[e] = new pe(e, 2, !1, e.toLowerCase(), null); }), ['autoReverse', 'externalResourcesRequired', 'preserveAlpha'].forEach((e) => { eo[e] = new pe(e, 2, !1, e, null); }), 'allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach((e) => { eo[e] = new pe(e, 3, !1, e.toLowerCase(), null); }), ['checked', 'multiple', 'muted', 'selected'].forEach((e) => { eo[e] = new pe(e, 3, !0, e.toLowerCase(), null); }), ['capture', 'download'].forEach((e) => { eo[e] = new pe(e, 4, !1, e.toLowerCase(), null); }), ['cols', 'rows', 'size', 'span'].forEach((e) => { eo[e] = new pe(e, 6, !1, e.toLowerCase(), null); }), ['rowSpan', 'start'].forEach((e) => { eo[e] = new pe(e, 5, !1, e.toLowerCase(), null); }); const to = /[\-:]([a-z])/g; 'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach((e) => { const t = e.replace(to, fe); eo[t] = new pe(t, 1, !1, e, null); }), 'xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach((e) => { const t = e.replace(to, fe); eo[t] = new pe(t, 1, !1, e, 'http://www.w3.org/1999/xlink'); }), ['xml:base', 'xml:lang', 'xml:space'].forEach((e) => { const t = e.replace(to, fe); eo[t] = new pe(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace'); }), eo.tabIndex = new pe('tabIndex', 1, !1, 'tabindex', null); var no = { change: { phasedRegistrationNames: { bubbled: 'onChange', captured: 'onChangeCapture' }, dependencies: 'blur change click focus input keydown keyup selectionchange'.split(' ') } }; var ro = null; var io = null; let oo = !1; Lr.canUseDOM && (oo = ee('input') && (!document.documentMode || document.documentMode > 9)); const ao = { eventTypes: no, _isInputEventSupported: oo, extractEvents(e, t, n, r) { const i = t ? b(t) : window; let o = void 0; let a = void 0; let s = i.nodeName && i.nodeName.toLowerCase(); if (s === 'select' || s === 'input' && i.type === 'file' ? o = Te : J(i) ? oo ? o = Ie : (o = Ae, a = Se) : (s = i.nodeName) && s.toLowerCase() === 'input' && (i.type === 'checkbox' || i.type === 'radio') && (o = Oe), o && (o = o(e, t))) return xe(o, n, r); a && a(e, i, t), e === 'blur' && t != null && (e = t._wrapperState || i._wrapperState) && e.controlled && i.type === 'number' && _e(i, 'number', i.value); } }; const so = z.extend({ view: null, detail: null }); var lo = {
    Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey',
  }; const uo = so.extend({
    screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: Me, button: null, buttons: null, relatedTarget(e) { return e.relatedTarget || (e.fromElement === e.srcElement ? e.toElement : e.fromElement); },
  }); const co = uo.extend({
    pointerId: null, width: null, height: null, pressure: null, tiltX: null, tiltY: null, pointerType: null, isPrimary: null,
  }); const po = {
    mouseEnter: { registrationName: 'onMouseEnter', dependencies: ['mouseout', 'mouseover'] }, mouseLeave: { registrationName: 'onMouseLeave', dependencies: ['mouseout', 'mouseover'] }, pointerEnter: { registrationName: 'onPointerEnter', dependencies: ['pointerout', 'pointerover'] }, pointerLeave: { registrationName: 'onPointerLeave', dependencies: ['pointerout', 'pointerover'] },
  }; const fo = { eventTypes: po, extractEvents(e, t, n, r) { let i = e === 'mouseover' || e === 'pointerover'; let o = e === 'mouseout' || e === 'pointerout'; if (i && (n.relatedTarget || n.fromElement) || !o && !i) return null; if (i = r.window === r ? r : (i = r.ownerDocument) ? i.defaultView || i.parentWindow : window, o ? (o = t, t = (t = n.relatedTarget || n.toElement) ? _(t) : null) : o = null, o === t) return null; let a = void 0; let s = void 0; let l = void 0; let u = void 0; return e === 'mouseout' || e === 'mouseover' ? (a = uo, s = po.mouseLeave, l = po.mouseEnter, u = 'mouse') : e !== 'pointerout' && e !== 'pointerover' || (a = co, s = po.pointerLeave, l = po.pointerEnter, u = 'pointer'), e = o == null ? i : b(o), i = t == null ? i : b(t), s = a.getPooled(s, o, n, r), s.type = `${u}leave`, s.target = e, s.relatedTarget = i, n = a.getPooled(l, t, n, r), n.type = `${u}enter`, n.target = i, n.relatedTarget = e, I(s, n, o, t), [s, n]; } }; const ho = z.extend({ animationName: null, elapsedTime: null, pseudoElement: null }); const mo = z.extend({ clipboardData(e) { return 'clipboardData' in e ? e.clipboardData : window.clipboardData; } }); const go = so.extend({ relatedTarget: null }); const yo = {
    Esc: 'Escape', Spacebar: ' ', Left: 'ArrowLeft', Up: 'ArrowUp', Right: 'ArrowRight', Down: 'ArrowDown', Del: 'Delete', Win: 'OS', Menu: 'ContextMenu', Apps: 'ContextMenu', Scroll: 'ScrollLock', MozPrintableKey: 'Unidentified',
  }; const vo = {
    8: 'Backspace', 9: 'Tab', 12: 'Clear', 13: 'Enter', 16: 'Shift', 17: 'Control', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Escape', 32: ' ', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'ArrowLeft', 38: 'ArrowUp', 39: 'ArrowRight', 40: 'ArrowDown', 45: 'Insert', 46: 'Delete', 112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6', 118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12', 144: 'NumLock', 145: 'ScrollLock', 224: 'Meta',
  }; const _o = so.extend({
    key(e) { if (e.key) { const t = yo[e.key] || e.key; if (t !== 'Unidentified') return t; } return e.type === 'keypress' ? (e = je(e), e === 13 ? 'Enter' : String.fromCharCode(e)) : e.type === 'keydown' || e.type === 'keyup' ? vo[e.keyCode] || 'Unidentified' : ''; }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: Me, charCode(e) { return e.type === 'keypress' ? je(e) : 0; }, keyCode(e) { return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0; }, which(e) { return e.type === 'keypress' ? je(e) : e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0; },
  }); const bo = uo.extend({ dataTransfer: null }); const xo = so.extend({
    touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: Me,
  }); const wo = z.extend({ propertyName: null, elapsedTime: null, pseudoElement: null }); const Eo = uo.extend({
    deltaX(e) { return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0; }, deltaY(e) { return 'deltaY' in e ? e.deltaY : 'wheelDeltaY' in e ? -e.wheelDeltaY : 'wheelDelta' in e ? -e.wheelDelta : 0; }, deltaZ: null, deltaMode: null,
  }); const To = [['abort', 'abort'], [ci, 'animationEnd'], [pi, 'animationIteration'], [fi, 'animationStart'], ['canplay', 'canPlay'], ['canplaythrough', 'canPlayThrough'], ['drag', 'drag'], ['dragenter', 'dragEnter'], ['dragexit', 'dragExit'], ['dragleave', 'dragLeave'], ['dragover', 'dragOver'], ['durationchange', 'durationChange'], ['emptied', 'emptied'], ['encrypted', 'encrypted'], ['ended', 'ended'], ['error', 'error'], ['gotpointercapture', 'gotPointerCapture'], ['load', 'load'], ['loadeddata', 'loadedData'], ['loadedmetadata', 'loadedMetadata'], ['loadstart', 'loadStart'], ['lostpointercapture', 'lostPointerCapture'], ['mousemove', 'mouseMove'], ['mouseout', 'mouseOut'], ['mouseover', 'mouseOver'], ['playing', 'playing'], ['pointermove', 'pointerMove'], ['pointerout', 'pointerOut'], ['pointerover', 'pointerOver'], ['progress', 'progress'], ['scroll', 'scroll'], ['seeking', 'seeking'], ['stalled', 'stalled'], ['suspend', 'suspend'], ['timeupdate', 'timeUpdate'], ['toggle', 'toggle'], ['touchmove', 'touchMove'], [hi, 'transitionEnd'], ['waiting', 'waiting'], ['wheel', 'wheel']]; var ko = {}; var Co = {}; [['blur', 'blur'], ['cancel', 'cancel'], ['click', 'click'], ['close', 'close'], ['contextmenu', 'contextMenu'], ['copy', 'copy'], ['cut', 'cut'], ['dblclick', 'doubleClick'], ['dragend', 'dragEnd'], ['dragstart', 'dragStart'], ['drop', 'drop'], ['focus', 'focus'], ['input', 'input'], ['invalid', 'invalid'], ['keydown', 'keyDown'], ['keypress', 'keyPress'], ['keyup', 'keyUp'], ['mousedown', 'mouseDown'], ['mouseup', 'mouseUp'], ['paste', 'paste'], ['pause', 'pause'], ['play', 'play'], ['pointercancel', 'pointerCancel'], ['pointerdown', 'pointerDown'], ['pointerup', 'pointerUp'], ['ratechange', 'rateChange'], ['reset', 'reset'], ['seeked', 'seeked'], ['submit', 'submit'], ['touchcancel', 'touchCancel'], ['touchend', 'touchEnd'], ['touchstart', 'touchStart'], ['volumechange', 'volumeChange']].forEach((e) => { Be(e, !0); }), To.forEach((e) => { Be(e, !1); }); const So = { eventTypes: ko, isInteractiveTopLevelEventType(e) { return void 0 !== (e = Co[e]) && !0 === e.isInteractive; }, extractEvents(e, t, n, r) { const i = Co[e]; if (!i) return null; switch (e) { case 'keypress': if (je(n) === 0) return null; case 'keydown': case 'keyup': e = _o; break; case 'blur': case 'focus': e = go; break; case 'click': if (n.button === 2) return null; case 'dblclick': case 'mousedown': case 'mousemove': case 'mouseup': case 'mouseout': case 'mouseover': case 'contextmenu': e = uo; break; case 'drag': case 'dragend': case 'dragenter': case 'dragexit': case 'dragleave': case 'dragover': case 'dragstart': case 'drop': e = bo; break; case 'touchcancel': case 'touchend': case 'touchmove': case 'touchstart': e = xo; break; case ci: case pi: case fi: e = ho; break; case hi: e = wo; break; case 'scroll': e = so; break; case 'wheel': e = Eo; break; case 'copy': case 'cut': case 'paste': e = mo; break; case 'gotpointercapture': case 'lostpointercapture': case 'pointercancel': case 'pointerdown': case 'pointermove': case 'pointerout': case 'pointerover': case 'pointerup': e = co; break; default: e = z; } return t = e.getPooled(i, t, n, r), O(t), t; } }; var Ao = So.isInteractiveTopLevelEventType; var Oo = []; var Io = !0; const Po = {
    get _enabled() { return Io; }, setEnabled: Ue, isEnabled() { return Io; }, trapBubbledEvent: Ve, trapCapturedEvent: qe, dispatchEvent: We,
  }; var Mo = {}; var No = 0; var Do = `_reactListenersID${(`${Math.random()}`).slice(2)}`; const Lo = Lr.canUseDOM && 'documentMode' in document && document.documentMode <= 11; var zo = { select: { phasedRegistrationNames: { bubbled: 'onSelect', captured: 'onSelectCapture' }, dependencies: 'blur contextmenu focus keydown keyup mousedown mouseup selectionchange'.split(' ') } }; var Ro = null; var jo = null; var Bo = null; var Fo = !1; const Uo = { eventTypes: zo, extractEvents(e, t, n, r) { let i; let o = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument; if (!(i = !o)) { e: { o = $e(o), i = Zr.onSelect; for (let a = 0; a < i.length; a++) { const s = i[a]; if (!o.hasOwnProperty(s) || !o[s]) { o = !1; break e; } }o = !0; }i = !o; } if (i) return null; switch (o = t ? b(t) : window, e) { case 'focus': (J(o) || o.contentEditable === 'true') && (Ro = o, jo = t, Bo = null); break; case 'blur': Bo = jo = Ro = null; break; case 'mousedown': Fo = !0; break; case 'contextmenu': case 'mouseup': return Fo = !1, Xe(n, r); case 'selectionchange': if (Lo) break; case 'keydown': case 'keyup': return Xe(n, r); } return null; } }; ei.injectEventPluginOrder('ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin'.split(' ')), Xr = oi.getFiberCurrentPropsFromNode, Yr = oi.getInstanceFromNode, Jr = oi.getNodeFromInstance, ei.injectEventPluginsByName({
    SimpleEventPlugin: So, EnterLeaveEventPlugin: fo, ChangeEventPlugin: ao, SelectEventPlugin: Uo, BeforeInputEventPlugin: Ii,
  }); let Vo = void 0; Vo = typeof performance === 'object' && typeof performance.now === 'function' ? function () { return performance.now(); } : function () { return Date.now(); }; let qo = void 0; let Ho = void 0; if (Lr.canUseDOM) { const Wo = []; let $o = 0; const Go = {}; let Zo = -1; let Ko = !1; let Xo = !1; let Yo = 0; let Jo = 33; let Qo = 33; const ea = { didTimeout: !1, timeRemaining() { const e = Yo - Vo(); return e > 0 ? e : 0; } }; const ta = function (e, t) { if (Go[t]) try { e(ea); } finally { delete Go[t]; } }; const na = `__reactIdleCallback$${Math.random().toString(36).slice(2)}`; window.addEventListener('message', (e) => { if (e.source === window && e.data === na && (Ko = !1, Wo.length !== 0)) { if (Wo.length !== 0 && (e = Vo(), !(Zo === -1 || Zo > e))) { Zo = -1, ea.didTimeout = !0; for (let t = 0, n = Wo.length; t < n; t++) { const r = Wo[t]; const i = r.timeoutTime; i !== -1 && i <= e ? ta(r.scheduledCallback, r.callbackId) : i !== -1 && (Zo === -1 || i < Zo) && (Zo = i); } } for (e = Vo(); Yo - e > 0 && Wo.length > 0;)e = Wo.shift(), ea.didTimeout = !1, ta(e.scheduledCallback, e.callbackId), e = Vo(); Wo.length > 0 && !Xo && (Xo = !0, requestAnimationFrame(ra)); } }, !1); var ra = function (e) { Xo = !1; let t = e - Yo + Qo; t < Qo && Jo < Qo ? (t < 8 && (t = 8), Qo = t < Jo ? Jo : t) : Jo = t, Yo = e + Qo, Ko || (Ko = !0, window.postMessage(na, '*')); }; qo = function (e, t) { let n = -1; return t != null && typeof t.timeout === 'number' && (n = Vo() + t.timeout), (Zo === -1 || n !== -1 && n < Zo) && (Zo = n), $o++, t = $o, Wo.push({ scheduledCallback: e, callbackId: t, timeoutTime: n }), Go[t] = !0, Xo || (Xo = !0, requestAnimationFrame(ra)), t; }, Ho = function (e) { delete Go[e]; }; } else { let ia = 0; const oa = {}; qo = function (e) { const t = ia++; const n = setTimeout(() => { e({ timeRemaining() { return 1 / 0; }, didTimeout: !1 }); }); return oa[t] = n, t; }, Ho = function (e) { const t = oa[e]; delete oa[e], clearTimeout(t); }; } var aa = { html: 'http://www.w3.org/1999/xhtml', mathml: 'http://www.w3.org/1998/Math/MathML', svg: 'http://www.w3.org/2000/svg' }; let sa = void 0; var la = (function (e) { return typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(() => e(t, n)); } : e; }((e, t) => { if (e.namespaceURI !== aa.svg || 'innerHTML' in e)e.innerHTML = t; else { for (sa = sa || document.createElement('div'), sa.innerHTML = `<svg>${t}</svg>`, t = sa.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (;t.firstChild;)e.appendChild(t.firstChild); } })); var ua = {
    animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0,
  }; const ca = ['Webkit', 'ms', 'Moz', 'O']; Object.keys(ua).forEach((e) => { ca.forEach((t) => { t = t + e.charAt(0).toUpperCase() + e.substring(1), ua[t] = ua[e]; }); }); var pa = zr({ menuitem: !0 }, {
    area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0,
  }); var fa = Rr.thatReturns(''); const ha = {
    createElement: ft, createTextNode: ht, setInitialProperties: dt, diffProperties: mt, updateProperties: gt, diffHydratedProperties: yt, diffHydratedText: vt, warnForUnmatchedText() {}, warnForDeletedHydratableElement() {}, warnForDeletedHydratableText() {}, warnForInsertedHydratedElement() {}, warnForInsertedHydratedText() {}, restoreControlledState(e, t, n) { switch (t) { case 'input': if (ye(e, n), t = n.name, n.type === 'radio' && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll(`input[name=${JSON.stringify(`${t}`)}][type="radio"]`), t = 0; t < n.length; t++) { const i = n[t]; if (i !== e && i.form === e.form) { const o = x(i); o || r('90'), ie(i), ye(i, o); } } } break; case 'textarea': rt(e, n); break; case 'select': (t = n.value) != null && Qe(e, !!n.multiple, t, !1); } },
  }; var da = null; var ma = null; var ga = Vo; var ya = qo; var va = Ho; new Set(); var _a = []; var ba = -1; var xa = Et(Ur); var wa = Et(!1); var Ea = Ur; var Ta = null; var ka = null; var Ca = !1; var Sa = Et(null); var Aa = Et(null); var Oa = Et(0); var Ia = {}; var Pa = Et(Ia); var Ma = Et(Ia); var Na = Et(Ia); var Da = {
    isMounted(e) { return !!(e = e._reactInternalFiber) && Ne(e) === 2; }, enqueueSetState(e, t, n) { e = e._reactInternalFiber; let r = er(); r = Jn(r, e); const i = Zt(r); i.payload = t, void 0 !== n && n !== null && (i.callback = n), Xt(e, i, r), Qn(e, r); }, enqueueReplaceState(e, t, n) { e = e._reactInternalFiber; let r = er(); r = Jn(r, e); const i = Zt(r); i.tag = 1, i.payload = t, void 0 !== n && n !== null && (i.callback = n), Xt(e, i, r), Qn(e, r); }, enqueueForceUpdate(e, t) { e = e._reactInternalFiber; let n = er(); n = Jn(n, e); const r = Zt(n); r.tag = 2, void 0 !== t && t !== null && (r.callback = t), Xt(e, r, n), Qn(e, n); },
  }; var La = Array.isArray; var za = yn(!0); var Ra = yn(!1); var ja = null; var Ba = null; var Fa = !1; var Ua = void 0; var Va = void 0; var qa = void 0; Ua = function () {}, Va = function (e, t, n) { (t.updateQueue = n) && Nn(t); }, qa = function (e, t, n, r) { n !== r && Nn(t); }; var Ha = ga(); var Wa = 2; var $a = Ha; var Ga = 0; var Za = 0; var Ka = !1; var Xa = null; var Ya = null; var Ja = 0; var Qa = -1; var es = !1; var ts = null; var ns = !1; var rs = !1; var is = null; var os = null; var as = null; var ss = 0; var ls = -1; var us = !1; var cs = null; var ps = 0; var fs = 0; var hs = !1; var ds = !1; var ms = null; var gs = null; var ys = !1; var vs = !1; var _s = !1; var bs = null; var xs = 1e3; var ws = 0; var Es = 1; const Ts = {
    updateContainerAtExpirationTime: br, createContainer(e, t, n) { return Ut(e, t, n); }, updateContainer: wr, flushRoot: ur, requestWork: ir, computeUniqueAsyncExpiration: Yn, batchedUpdates: gr, unbatchedUpdates: yr, deferredUpdates: tr, syncUpdates: nr, interactiveUpdates(e, t, n) { if (_s) return e(t, n); ys || us || fs === 0 || (lr(fs, !1, null), fs = 0); const r = _s; const i = ys; ys = _s = !0; try { return e(t, n); } finally { _s = r, (ys = i) || us || sr(); } }, flushInteractiveUpdates() { us || fs === 0 || (lr(fs, !1, null), fs = 0); }, flushControlled: _r, flushSync: vr, getPublicRootInstance: Er, findHostInstance: xr, findHostInstanceWithNoPortals(e) { return e = Re(e), e === null ? null : e.stateNode; }, injectIntoDevTools: Tr,
  }; Mi.injectFiberControlledHostComponent(ha), Cr.prototype.render = function (e) { this._defer || r('250'), this._hasChildren = !0, this._children = e; const t = this._root._internalRoot; const n = this._expirationTime; const i = new Sr(); return br(e, t, null, n, i._onCommit), i; }, Cr.prototype.then = function (e) { if (this._didComplete)e(); else { let t = this._callbacks; t === null && (t = this._callbacks = []), t.push(e); } }, Cr.prototype.commit = function () { const e = this._root._internalRoot; let t = e.firstBatch; if (this._defer && t !== null || r('251'), this._hasChildren) { let n = this._expirationTime; if (t !== this) { this._hasChildren && (n = this._expirationTime = t._expirationTime, this.render(this._children)); for (var i = null, o = t; o !== this;)i = o, o = o._next; i === null && r('251'), i._next = o._next, this._next = t, e.firstBatch = this; } this._defer = !1, ur(e, n), t = this._next, this._next = null, t = e.firstBatch = t, t !== null && t._hasChildren && t.render(t._children); } else this._next = null, this._defer = !1; }, Cr.prototype._onComplete = function () { if (!this._didComplete) { this._didComplete = !0; const e = this._callbacks; if (e !== null) for (let t = 0; t < e.length; t++)(0, e[t])(); } }, Sr.prototype.then = function (e) { if (this._didCommit)e(); else { let t = this._callbacks; t === null && (t = this._callbacks = []), t.push(e); } }, Sr.prototype._onCommit = function () { if (!this._didCommit) { this._didCommit = !0; const e = this._callbacks; if (e !== null) for (let t = 0; t < e.length; t++) { const n = e[t]; typeof n !== 'function' && r('191', n), n(); } } }, Ar.prototype.render = function (e, t) { const n = this._internalRoot; const r = new Sr(); return t = void 0 === t ? null : t, t !== null && r.then(t), wr(e, n, null, r._onCommit), r; }, Ar.prototype.unmount = function (e) { const t = this._internalRoot; const n = new Sr(); return e = void 0 === e ? null : e, e !== null && n.then(e), wr(null, t, null, n._onCommit), n; }, Ar.prototype.legacy_renderSubtreeIntoContainer = function (e, t, n) { const r = this._internalRoot; const i = new Sr(); return n = void 0 === n ? null : n, n !== null && i.then(n), wr(t, r, e, i._onCommit), i; }, Ar.prototype.createBatch = function () { const e = new Cr(this); const t = e._expirationTime; let n = this._internalRoot; let r = n.firstBatch; if (r === null)n.firstBatch = e, e._next = null; else { for (n = null; r !== null && r._expirationTime <= t;)n = r, r = r._next; e._next = r, n !== null && (n._next = e); } return e; }, Z = Ts.batchedUpdates, K = Ts.interactiveUpdates, X = Ts.flushInteractiveUpdates; const ks = {
    createPortal: Mr,
    findDOMNode(e) { return e == null ? null : e.nodeType === 1 ? e : xr(e); },
    hydrate(e, t, n) { return Pr(null, e, t, !0, n); },
    render(e, t, n) { return Pr(null, e, t, !1, n); },
    unstable_renderSubtreeIntoContainer(e, t, n, i) { return (e == null || void 0 === e._reactInternalFiber) && r('38'), Pr(e, t, n, !1, i); },
    unmountComponentAtNode(e) { return Or(e) || r('40'), !!e._reactRootContainer && (yr(() => { Pr(null, null, e, !1, () => { e._reactRootContainer = null; }); }), !0); },
    unstable_createPortal() { return Mr(...arguments); },
    unstable_batchedUpdates: gr,
    unstable_deferredUpdates: tr,
    flushSync: vr,
    unstable_flushControlled: _r,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      EventPluginHub: ti, EventPluginRegistry: Kr, EventPropagators: ai, ReactControlledComponent: Li, ReactDOMComponentTree: oi, ReactDOMEventListener: Po,
    },
    unstable_createRoot(e, t) { return new Ar(e, !0, t != null && !0 === t.hydrate); },
  }; Tr({
    findFiberByHostInstance: _, bundleType: 0, version: '16.4.0', rendererPackageName: 'react-dom',
  }); const Cs = { default: ks }; const Ss = Cs && ks || Cs; e.exports = Ss.default ? Ss.default : Ss;
}, function (e, t, n) {
  const r = !(typeof window === 'undefined' || !window.document || !window.document.createElement); const i = {
    canUseDOM: r, canUseWorkers: typeof Worker !== 'undefined', canUseEventListeners: r && !(!window.addEventListener && !window.attachEvent), canUseViewport: r && !!window.screen, isInWorker: !r,
  }; e.exports = i;
}, function (e, t, n) {
  function r(e) { if (typeof (e = e || (typeof document !== 'undefined' ? document : void 0)) === 'undefined') return null; try { return e.activeElement || e.body; } catch (t) { return e.body; } }e.exports = r;
}, function (e, t, n) {
  function r(e, t) { return e === t ? e !== 0 || t !== 0 || 1 / e === 1 / t : e !== e && t !== t; } function i(e, t) { if (r(e, t)) return !0; if (typeof e !== 'object' || e === null || typeof t !== 'object' || t === null) return !1; const n = Object.keys(e); const i = Object.keys(t); if (n.length !== i.length) return !1; for (let a = 0; a < n.length; a++) if (!o.call(t, n[a]) || !r(e[n[a]], t[n[a]])) return !1; return !0; } var o = Object.prototype.hasOwnProperty; e.exports = i;
}, function (e, t, n) {
  function r(e, t) { return !(!e || !t) && (e === t || !i(e) && (i(t) ? r(e, t.parentNode) : 'contains' in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))); } var i = n(46); e.exports = r;
}, function (e, t, n) {
  function r(e) { return i(e) && e.nodeType == 3; } var i = n(47); e.exports = r;
}, function (e, t, n) {
  function r(e) { const t = e ? e.ownerDocument || e : document; const n = t.defaultView || window; return !(!e || !(typeof n.Node === 'function' ? e instanceof n.Node : typeof e === 'object' && typeof e.nodeType === 'number' && typeof e.nodeName === 'string')); }e.exports = r;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(2); const s = n.n(a); const l = n(0); const u = n.n(l); const c = n(1); const p = n.n(c); const f = n(51); const h = n.n(f); const d = n(15); const m = (function (e) { function t() { let n; let o; let a; r(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = o = i(this, e.call(...[this].concat(l))), o.history = h()(o.props), a = n, i(o, a); } return o(t, e), t.prototype.componentWillMount = function () { s()(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.'); }, t.prototype.render = function () { return u.a.createElement(d.a, { history: this.history, children: this.props.children }); }, t; }(u.a.Component)); m.propTypes = {
    basename: p.a.string, forceRefresh: p.a.bool, getUserConfirmation: p.a.func, keyLength: p.a.number, children: p.a.node,
  }, t.a = m;
}, function (e, t, n) {
  const r = n(9); const i = n(8); const o = n(50); e.exports = function () {
    function e(e, t, n, r, a, s) { s !== o && i(!1, 'Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types'); } function t() { return e; }e.isRequired = e; const n = {
      array: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t,
    }; return n.checkPropTypes = r, n.PropTypes = n, n;
  };
}, function (e, t, n) {
  e.exports = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
}, function (e, t, n) {
  function r(e) { return e && e.__esModule ? e : { default: e }; }t.__esModule = !0; const i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const o = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const a = n(2); const s = r(a); const l = n(3); const u = r(l); const c = n(13); const p = n(5); const f = n(14); const h = r(f); const d = n(23); const m = function () { try { return window.history.state || {}; } catch (e) { return {}; } }; const g = function () {
    const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; (0, u.default)(d.canUseDOM, 'Browser history needs a DOM'); const t = window.history; const n = (0, d.supportsHistory)(); const r = !(0, d.supportsPopStateOnHashChange)(); const a = e.forceRefresh; const l = void 0 !== a && a; const f = e.getUserConfirmation; const g = void 0 === f ? d.getConfirmation : f; const y = e.keyLength; const v = void 0 === y ? 6 : y; const _ = e.basename ? (0, p.stripTrailingSlash)((0, p.addLeadingSlash)(e.basename)) : ''; const b = function (e) { const t = e || {}; const n = t.key; const r = t.state; const i = window.location; const o = i.pathname; const a = i.search; const l = i.hash; let u = o + a + l; return (0, s.default)(!_ || (0, p.hasBasename)(u, _), `You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "${u}" to begin with "${_}".`), _ && (u = (0, p.stripBasename)(u, _)), (0, c.createLocation)(u, r, n); }; const x = function () { return Math.random().toString(36).substr(2, v); }; const w = (0, h.default)(); const E = function (e) { o(V, e), V.length = t.length, w.notifyListeners(V.location, V.action); }; const T = function (e) { (0, d.isExtraneousPopstateEvent)(e) || S(b(e.state)); }; const k = function () { S(b(m())); }; let C = !1; var S = function (e) { if (C)C = !1, E(); else { w.confirmTransitionTo(e, 'POP', g, (t) => { t ? E({ action: 'POP', location: e }) : A(e); }); } }; var A = function (e) { const t = V.location; let n = I.indexOf(t.key); n === -1 && (n = 0); let r = I.indexOf(e.key); r === -1 && (r = 0); const i = n - r; i && (C = !0, D(i)); }; const O = b(m()); var I = [O.key]; const P = function (e) { return _ + (0, p.createPath)(e); }; const M = function (e, r) { (0, s.default)(!((typeof e === 'undefined' ? 'undefined' : i(e)) === 'object' && void 0 !== e.state && void 0 !== r), 'You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored'); const o = (0, c.createLocation)(e, r, x(), V.location); w.confirmTransitionTo(o, 'PUSH', g, (e) => { if (e) { const r = P(o); const i = o.key; const a = o.state; if (n) if (t.pushState({ key: i, state: a }, null, r), l)window.location.href = r; else { const u = I.indexOf(V.location.key); const c = I.slice(0, u === -1 ? 0 : u + 1); c.push(o.key), I = c, E({ action: 'PUSH', location: o }); } else (0, s.default)(void 0 === a, 'Browser history cannot push state in browsers that do not support HTML5 history'), window.location.href = r; } }); }; const N = function (e, r) { (0, s.default)(!((typeof e === 'undefined' ? 'undefined' : i(e)) === 'object' && void 0 !== e.state && void 0 !== r), 'You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored'); const o = (0, c.createLocation)(e, r, x(), V.location); w.confirmTransitionTo(o, 'REPLACE', g, (e) => { if (e) { const r = P(o); const i = o.key; const a = o.state; if (n) if (t.replaceState({ key: i, state: a }, null, r), l)window.location.replace(r); else { const u = I.indexOf(V.location.key); u !== -1 && (I[u] = o.key), E({ action: 'REPLACE', location: o }); } else (0, s.default)(void 0 === a, 'Browser history cannot replace state in browsers that do not support HTML5 history'), window.location.replace(r); } }); }; var D = function (e) { t.go(e); }; const L = function () { return D(-1); }; const z = function () { return D(1); }; let R = 0; const j = function (e) { R += e, R === 1 ? ((0, d.addEventListener)(window, 'popstate', T), r && (0, d.addEventListener)(window, 'hashchange', k)) : R === 0 && ((0, d.removeEventListener)(window, 'popstate', T), r && (0, d.removeEventListener)(window, 'hashchange', k)); }; let B = !1; const F = function () { const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; const t = w.setPrompt(e); return B || (j(1), B = !0), function () { return B && (B = !1, j(-1)), t(); }; }; const U = function (e) { const t = w.appendListener(e); return j(1), function () { j(-1), t(); }; }; var V = {
      length: t.length, action: 'POP', location: O, createHref: P, push: M, replace: N, go: D, goBack: L, goForward: z, block: F, listen: U,
    }; return V;
  }; t.default = g;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(2); const s = n.n(a); const l = n(0); const u = n.n(l); const c = n(1); const p = n.n(c); const f = n(53); const h = n.n(f); const d = n(15); const m = (function (e) { function t() { let n; let o; let a; r(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = o = i(this, e.call(...[this].concat(l))), o.history = h()(o.props), a = n, i(o, a); } return o(t, e), t.prototype.componentWillMount = function () { s()(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.'); }, t.prototype.render = function () { return u.a.createElement(d.a, { history: this.history, children: this.props.children }); }, t; }(u.a.Component)); m.propTypes = {
    basename: p.a.string, getUserConfirmation: p.a.func, hashType: p.a.oneOf(['hashbang', 'noslash', 'slash']), children: p.a.node,
  };
}, function (e, t, n) {
  function r(e) { return e && e.__esModule ? e : { default: e }; }t.__esModule = !0; const i = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const o = n(2); const a = r(o); const s = n(3); const l = r(s); const u = n(13); const c = n(5); const p = n(14); const f = r(p); const h = n(23); const d = { hashbang: { encodePath(e) { return e.charAt(0) === '!' ? e : `!/${(0, c.stripLeadingSlash)(e)}`; }, decodePath(e) { return e.charAt(0) === '!' ? e.substr(1) : e; } }, noslash: { encodePath: c.stripLeadingSlash, decodePath: c.addLeadingSlash }, slash: { encodePath: c.addLeadingSlash, decodePath: c.addLeadingSlash } }; const m = function () { const e = window.location.href; const t = e.indexOf('#'); return t === -1 ? '' : e.substring(t + 1); }; const g = function (e) { return window.location.hash = e; }; const y = function (e) { const t = window.location.href.indexOf('#'); window.location.replace(`${window.location.href.slice(0, t >= 0 ? t : 0)}#${e}`); }; const v = function () {
    const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; (0, l.default)(h.canUseDOM, 'Hash history needs a DOM'); const t = window.history; const n = (0, h.supportsGoWithoutReloadUsingHash)(); const r = e.getUserConfirmation; const o = void 0 === r ? h.getConfirmation : r; const s = e.hashType; const p = void 0 === s ? 'slash' : s; const v = e.basename ? (0, c.stripTrailingSlash)((0, c.addLeadingSlash)(e.basename)) : ''; const _ = d[p]; const b = _.encodePath; const x = _.decodePath; const w = function () { let e = x(m()); return (0, a.default)(!v || (0, c.hasBasename)(e, v), `You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "${e}" to begin with "${v}".`), v && (e = (0, c.stripBasename)(e, v)), (0, u.createLocation)(e); }; const E = (0, f.default)(); const T = function (e) { i(W, e), W.length = t.length, E.notifyListeners(W.location, W.action); }; let k = !1; let C = null; const S = function () { const e = m(); const t = b(e); if (e !== t)y(t); else { const n = w(); const r = W.location; if (!k && (0, u.locationsAreEqual)(r, n)) return; if (C === (0, c.createPath)(n)) return; C = null, A(n); } }; var A = function (e) { if (k)k = !1, T(); else { E.confirmTransitionTo(e, 'POP', o, (t) => { t ? T({ action: 'POP', location: e }) : O(e); }); } }; var O = function (e) { const t = W.location; let n = N.lastIndexOf((0, c.createPath)(t)); n === -1 && (n = 0); let r = N.lastIndexOf((0, c.createPath)(e)); r === -1 && (r = 0); const i = n - r; i && (k = !0, R(i)); }; const I = m(); const P = b(I); I !== P && y(P); const M = w(); var N = [(0, c.createPath)(M)]; const D = function (e) { return `#${b(v + (0, c.createPath)(e))}`; }; const L = function (e, t) { (0, a.default)(void 0 === t, 'Hash history cannot push state; it is ignored'); const n = (0, u.createLocation)(e, void 0, void 0, W.location); E.confirmTransitionTo(n, 'PUSH', o, (e) => { if (e) { const t = (0, c.createPath)(n); const r = b(v + t); if (m() !== r) { C = t, g(r); const i = N.lastIndexOf((0, c.createPath)(W.location)); const o = N.slice(0, i === -1 ? 0 : i + 1); o.push(t), N = o, T({ action: 'PUSH', location: n }); } else (0, a.default)(!1, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack'), T(); } }); }; const z = function (e, t) { (0, a.default)(void 0 === t, 'Hash history cannot replace state; it is ignored'); const n = (0, u.createLocation)(e, void 0, void 0, W.location); E.confirmTransitionTo(n, 'REPLACE', o, (e) => { if (e) { const t = (0, c.createPath)(n); const r = b(v + t); m() !== r && (C = t, y(r)); const i = N.indexOf((0, c.createPath)(W.location)); i !== -1 && (N[i] = t), T({ action: 'REPLACE', location: n }); } }); }; var R = function (e) { (0, a.default)(n, 'Hash history go(n) causes a full page reload in this browser'), t.go(e); }; const j = function () { return R(-1); }; const B = function () { return R(1); }; let F = 0; const U = function (e) { F += e, F === 1 ? (0, h.addEventListener)(window, 'hashchange', S) : F === 0 && (0, h.removeEventListener)(window, 'hashchange', S); }; let V = !1; const q = function () { const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; const t = E.setPrompt(e); return V || (U(1), V = !0), function () { return V && (V = !1, U(-1)), t(); }; }; const H = function (e) { const t = E.appendListener(e); return U(1), function () { U(-1), t(); }; }; var W = {
      length: t.length, action: 'POP', location: M, createHref: D, push: L, replace: z, go: R, goBack: j, goForward: B, block: q, listen: H,
    }; return W;
  }; t.default = v;
}, function (e, t, n) {
  const r = n(55); r.a;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(2); const s = n.n(a); const l = n(0); const u = n.n(l); const c = n(1); const p = n.n(c); const f = n(56); const h = n.n(f); const d = n(16); const m = (function (e) { function t() { let n; let o; let a; r(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = o = i(this, e.call(...[this].concat(l))), o.history = h()(o.props), a = n, i(o, a); } return o(t, e), t.prototype.componentWillMount = function () { s()(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.'); }, t.prototype.render = function () { return u.a.createElement(d.a, { history: this.history, children: this.props.children }); }, t; }(u.a.Component)); m.propTypes = {
    initialEntries: p.a.array, initialIndex: p.a.number, getUserConfirmation: p.a.func, keyLength: p.a.number, children: p.a.node,
  }, t.a = m;
}, function (e, t, n) {
  function r(e) { return e && e.__esModule ? e : { default: e }; }t.__esModule = !0; const i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const o = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const a = n(2); const s = r(a); const l = n(5); const u = n(13); const c = n(14); const p = r(c); const f = function (e, t, n) { return Math.min(Math.max(e, t), n); }; const h = function () {
    const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.getUserConfirmation; const n = e.initialEntries; const r = void 0 === n ? ['/'] : n; const a = e.initialIndex; const c = void 0 === a ? 0 : a; const h = e.keyLength; const d = void 0 === h ? 6 : h; const m = (0, p.default)(); const g = function (e) { o(O, e), O.length = O.entries.length, m.notifyListeners(O.location, O.action); }; const y = function () { return Math.random().toString(36).substr(2, d); }; const v = f(c, 0, r.length - 1); const _ = r.map(e => (typeof e === 'string' ? (0, u.createLocation)(e, void 0, y()) : (0, u.createLocation)(e, void 0, e.key || y()))); const b = l.createPath; const x = function (e, n) {
      (0, s.default)(!((typeof e === 'undefined' ? 'undefined' : i(e)) === 'object' && void 0 !== e.state && void 0 !== n), 'You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored'); const r = (0, u.createLocation)(e, n, y(), O.location); m.confirmTransitionTo(r, 'PUSH', t, (e) => {
        if (e) {
          const t = O.index; const n = t + 1; const i = O.entries.slice(0); i.length > n ? i.splice(n, i.length - n, r) : i.push(r), g({
            action: 'PUSH', location: r, index: n, entries: i,
          });
        }
      });
    }; const w = function (e, n) { (0, s.default)(!((typeof e === 'undefined' ? 'undefined' : i(e)) === 'object' && void 0 !== e.state && void 0 !== n), 'You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored'); const r = (0, u.createLocation)(e, n, y(), O.location); m.confirmTransitionTo(r, 'REPLACE', t, (e) => { e && (O.entries[O.index] = r, g({ action: 'REPLACE', location: r })); }); }; const E = function (e) { const n = f(O.index + e, 0, O.entries.length - 1); const r = O.entries[n]; m.confirmTransitionTo(r, 'POP', t, (e) => { e ? g({ action: 'POP', location: r, index: n }) : g(); }); }; const T = function () { return E(-1); }; const k = function () { return E(1); }; const C = function (e) { const t = O.index + e; return t >= 0 && t < O.entries.length; }; const S = function () { const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; return m.setPrompt(e); }; const A = function (e) { return m.appendListener(e); }; var O = {
      length: _.length, action: 'POP', location: _[v], index: v, entries: _, createHref: b, push: x, replace: w, go: E, goBack: T, goForward: k, canGo: C, block: S, listen: A,
    }; return O;
  }; t.default = h;
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } const i = n(0); const o = n.n(i); const a = n(1); const s = n.n(a); const l = n(25); const u = n(24); const c = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const p = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const f = function (e) {
    const t = e.to; const n = e.exact; const i = e.strict; const a = e.location; const s = e.activeClassName; const f = e.className; const h = e.activeStyle; const d = e.style; const m = e.isActive; const g = e.ariaCurrent; const y = r(e, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']); return o.a.createElement(l.a, {
      path: (typeof t === 'undefined' ? 'undefined' : p(t)) === 'object' ? t.pathname : t,
      exact: n,
      strict: i,
      location: a,
      children(e) {
        const n = e.location; const r = e.match; const i = !!(m ? m(r, n) : r); return o.a.createElement(u.a, c({
          to: t, className: i ? [f, s].filter(e => e).join(' ') : f, style: i ? c({}, d, h) : d, 'aria-current': i && g,
        }, y));
      },
    });
  }; f.propTypes = {
    to: u.a.propTypes.to, exact: s.a.bool, strict: s.a.bool, location: s.a.object, activeClassName: s.a.string, className: s.a.string, activeStyle: s.a.object, style: s.a.object, isActive: s.a.func, ariaCurrent: s.a.oneOf(['page', 'step', 'location', 'true']),
  }, f.defaultProps = { activeClassName: 'active', ariaCurrent: 'true' };
}, function (e, t, n) {
  function r(e, t) {
    for (var n, r = [], i = 0, o = 0, a = '', s = t && t.delimiter || '/'; (n = v.exec(e)) != null;) {
      const c = n[0]; const p = n[1]; const f = n.index; if (a += e.slice(o, f), o = f + c.length, p)a += p[1]; else {
        const h = e[o]; const d = n[2]; const m = n[3]; const g = n[4]; const y = n[5]; const _ = n[6]; const b = n[7]; a && (r.push(a), a = ''); const x = d != null && h != null && h !== d; const w = _ === '+' || _ === '*'; const E = _ === '?' || _ === '*'; const T = n[2] || s; const k = g || y; r.push({
          name: m || i++, prefix: d || '', delimiter: T, optional: E, repeat: w, partial: x, asterisk: !!b, pattern: k ? u(k) : b ? '.*' : `[^${l(T)}]+?`,
        });
      }
    } return o < e.length && (a += e.substr(o)), a && r.push(a), r;
  } function i(e, t) { return s(r(e, t)); } function o(e) { return encodeURI(e).replace(/[\/?#]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`); } function a(e) { return encodeURI(e).replace(/[?#]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`); } function s(e) { for (var t = new Array(e.length), n = 0; n < e.length; n++) typeof e[n] === 'object' && (t[n] = new RegExp(`^(?:${e[n].pattern})$`)); return function (n, r) { for (var i = '', s = n || {}, l = r || {}, u = l.pretty ? o : encodeURIComponent, c = 0; c < e.length; c++) { const p = e[c]; if (typeof p !== 'string') { var f; const h = s[p.name]; if (h == null) { if (p.optional) { p.partial && (i += p.prefix); continue; } throw new TypeError(`Expected "${p.name}" to be defined`); } if (y(h)) { if (!p.repeat) throw new TypeError(`Expected "${p.name}" to not repeat, but received \`${JSON.stringify(h)}\``); if (h.length === 0) { if (p.optional) continue; throw new TypeError(`Expected "${p.name}" to not be empty`); } for (let d = 0; d < h.length; d++) { if (f = u(h[d]), !t[c].test(f)) throw new TypeError(`Expected all "${p.name}" to match "${p.pattern}", but received \`${JSON.stringify(f)}\``); i += (d === 0 ? p.prefix : p.delimiter) + f; } } else { if (f = p.asterisk ? a(h) : u(h), !t[c].test(f)) throw new TypeError(`Expected "${p.name}" to match "${p.pattern}", but received "${f}"`); i += p.prefix + f; } } else i += p; } return i; }; } function l(e) { return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1'); } function u(e) { return e.replace(/([=!:$\/()])/g, '\\$1'); } function c(e, t) { return e.keys = t, e; } function p(e) { return e.sensitive ? '' : 'i'; } function f(e, t) {
    const n = e.source.match(/\((?!\?)/g); if (n) {
      for (let r = 0; r < n.length; r++) {
        t.push({
          name: r, prefix: null, delimiter: null, optional: !1, repeat: !1, partial: !1, asterisk: !1, pattern: null,
        });
      }
    } return c(e, t);
  } function h(e, t, n) { for (var r = [], i = 0; i < e.length; i++)r.push(g(e[i], t, n).source); return c(new RegExp(`(?:${r.join('|')})`, p(n)), t); } function d(e, t, n) { return m(r(e, n), t, n); } function m(e, t, n) { y(t) || (n = t || n, t = []), n = n || {}; for (var r = n.strict, i = !1 !== n.end, o = '', a = 0; a < e.length; a++) { const s = e[a]; if (typeof s === 'string')o += l(s); else { const u = l(s.prefix); let f = `(?:${s.pattern})`; t.push(s), s.repeat && (f += `(?:${u}${f})*`), f = s.optional ? s.partial ? `${u}(${f})?` : `(?:${u}(${f}))?` : `${u}(${f})`, o += f; } } const h = l(n.delimiter || '/'); const d = o.slice(-h.length) === h; return r || (o = `${d ? o.slice(0, -h.length) : o}(?:${h}(?=$))?`), o += i ? '$' : r && d ? '' : `(?=${h}|$)`, c(new RegExp(`^${o}`, p(n)), t); } function g(e, t, n) { return y(t) || (n = t || n, t = []), n = n || {}, e instanceof RegExp ? f(e, t) : y(e) ? h(e, t, n) : d(e, t, n); } var y = n(59); e.exports = g, e.exports.parse = r, e.exports.compile = i, e.exports.tokensToFunction = s, e.exports.tokensToRegExp = m; var v = new RegExp(['(\\\\.)', '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
}, function (e, t) { e.exports = Array.isArray || function (e) { return Object.prototype.toString.call(e) == '[object Array]'; }; }, function (e, t, n) {
  const r = n(61); r.a;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(1); const u = n.n(l); const c = n(3); const p = n.n(c); const f = (function (e) { function t() { return r(this, t), i(this, e.apply(this, arguments)); } return o(t, e), t.prototype.enable = function (e) { this.unblock && this.unblock(), this.unblock = this.context.router.history.block(e); }, t.prototype.disable = function () { this.unblock && (this.unblock(), this.unblock = null); }, t.prototype.componentWillMount = function () { p()(this.context.router, 'You should not use <Prompt> outside a <Router>'), this.props.when && this.enable(this.props.message); }, t.prototype.componentWillReceiveProps = function (e) { e.when ? this.props.when && this.props.message === e.message || this.enable(e.message) : this.disable(); }, t.prototype.componentWillUnmount = function () { this.disable(); }, t.prototype.render = function () { return null; }, t; }(s.a.Component)); f.propTypes = { when: u.a.bool, message: u.a.oneOfType([u.a.func, u.a.string]).isRequired }, f.defaultProps = { when: !0 }, f.contextTypes = { router: u.a.shape({ history: u.a.shape({ block: u.a.func.isRequired }).isRequired }).isRequired }, t.a = f;
}, function (e, t, n) {
  const r = n(63); r.a;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(1); const u = n.n(l); const c = n(2); const p = n.n(c); const f = n(3); const h = n.n(f); const d = n(64); const m = (function (e) { function t() { return r(this, t), i(this, e.apply(this, arguments)); } return o(t, e), t.prototype.isStatic = function () { return this.context.router && this.context.router.staticContext; }, t.prototype.componentWillMount = function () { h()(this.context.router, 'You should not use <Redirect> outside a <Router>'), this.isStatic() && this.perform(); }, t.prototype.componentDidMount = function () { this.isStatic() || this.perform(); }, t.prototype.componentDidUpdate = function (e) { const t = Object(d.a)(e.to); const n = Object(d.a)(this.props.to); if (Object(d.b)(t, n)) return void p()(!1, `You tried to redirect to the same route you're currently on: "${n.pathname}${n.search}"`); this.perform(); }, t.prototype.perform = function () { const e = this.context.router.history; const t = this.props; const n = t.push; const r = t.to; n ? e.push(r) : e.replace(r); }, t.prototype.render = function () { return null; }, t; }(s.a.Component)); m.propTypes = { push: u.a.bool, from: u.a.string, to: u.a.oneOfType([u.a.string, u.a.object]).isRequired }, m.defaultProps = { push: !1 }, m.contextTypes = { router: u.a.shape({ history: u.a.shape({ push: u.a.func.isRequired, replace: u.a.func.isRequired }).isRequired, staticContext: u.a.object }).isRequired }, t.a = m;
}, function (e, t, n) {
  const r = (n(65), n(66), n(67), n(11)); n.d(t, 'a', () => r.a), n.d(t, 'b', () => r.b); n(6);
}, function (e, t, n) {
  const r = n(2); const i = (n.n(r), n(3)); n.n(i), n(11), n(6), n(18), n(27), typeof Symbol === 'function' && Symbol.iterator, Object.assign;
}, function (e, t, n) {
  const r = n(2); const i = (n.n(r), n(3)); const o = (n.n(i), n(11), n(6)); n(18), n(27), Object.assign, o.f, o.a, o.a, o.a;
}, function (e, t, n) {
  const r = n(2); n.n(r), n(6), n(11), n(18), typeof Symbol === 'function' && Symbol.iterator, Object.assign;
}, function (e, t, n) {
  const r = n(69); r.a;
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } function i(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function o(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function a(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const s = n(2); const l = n.n(s); const u = n(3); const c = n.n(u); const p = n(0); const f = n.n(p); const h = n(1); const d = n.n(h); const m = n(5); const g = (n.n(m), n(16)); const y = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const v = function (e) { const t = e.pathname; const n = void 0 === t ? '/' : t; const r = e.search; const i = void 0 === r ? '' : r; const o = e.hash; const a = void 0 === o ? '' : o; return { pathname: n, search: i === '?' ? '' : i, hash: a === '#' ? '' : a }; }; const _ = function (e, t) { return e ? y({}, t, { pathname: Object(m.addLeadingSlash)(e) + t.pathname }) : t; }; const b = function (e, t) { if (!e) return t; const n = Object(m.addLeadingSlash)(e); return t.pathname.indexOf(n) !== 0 ? t : y({}, t, { pathname: t.pathname.substr(n.length) }); }; const x = function (e) { return typeof e === 'string' ? Object(m.parsePath)(e) : v(e); }; const w = function (e) { return typeof e === 'string' ? e : Object(m.createPath)(e); }; const E = function (e) { return function () { c()(!1, 'You cannot %s with <StaticRouter>', e); }; }; const T = function () {}; const k = (function (e) {
    function t() { let n; let r; let a; i(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = r = o(this, e.call(...[this].concat(l))), r.createHref = function (e) { return Object(m.addLeadingSlash)(r.props.basename + w(e)); }, r.handlePush = function (e) { const t = r.props; const n = t.basename; const i = t.context; i.action = 'PUSH', i.location = _(n, x(e)), i.url = w(i.location); }, r.handleReplace = function (e) { const t = r.props; const n = t.basename; const i = t.context; i.action = 'REPLACE', i.location = _(n, x(e)), i.url = w(i.location); }, r.handleListen = function () { return T; }, r.handleBlock = function () { return T; }, a = n, o(r, a); } return a(t, e), t.prototype.getChildContext = function () { return { router: { staticContext: this.props.context } }; }, t.prototype.componentWillMount = function () { l()(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.'); }, t.prototype.render = function () {
      const e = this.props; const t = e.basename; const n = (e.context, e.location); const i = r(e, ['basename', 'context', 'location']); const o = {
        createHref: this.createHref, action: 'POP', location: b(t, x(n)), push: this.handlePush, replace: this.handleReplace, go: E('go'), goBack: E('goBack'), goForward: E('goForward'), listen: this.handleListen, block: this.handleBlock,
      }; return f.a.createElement(g.a, y({}, i, { history: o }));
    }, t;
  }(f.a.Component)); k.propTypes = { basename: d.a.string, context: d.a.object.isRequired, location: d.a.oneOfType([d.a.string, d.a.object]) }, k.defaultProps = { basename: '', location: '/' }, k.childContextTypes = { router: d.a.object.isRequired }, t.a = k;
}, function (e, t, n) {
  const r = n(71); t.a = r.a;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(1); const u = n.n(l); const c = n(2); const p = n.n(c); const f = n(3); const h = n.n(f); const d = n(17); const m = (function (e) {
    function t() { return r(this, t), i(this, e.apply(this, arguments)); } return o(t, e), t.prototype.componentWillMount = function () { h()(this.context.router, 'You should not use <Switch> outside a <Router>'); }, t.prototype.componentWillReceiveProps = function (e) { p()(!(e.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'), p()(!(!e.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'); }, t.prototype.render = function () {
      const e = this.context.router.route; const t = this.props.children; const n = this.props.location || e.location; let r = void 0; let i = void 0; return s.a.Children.forEach(t, (t) => {
        if (s.a.isValidElement(t)) {
          const o = t.props; const a = o.path; const l = o.exact; const u = o.strict; const c = o.sensitive; const p = o.from; const f = a || p; r == null && (i = t, r = f ? Object(d.a)(n.pathname, {
            path: f, exact: l, strict: u, sensitive: c,
          }) : e.match);
        }
      }), r ? s.a.cloneElement(i, { location: n, computedMatch: r }) : null;
    }, t;
  }(s.a.Component)); m.contextTypes = { router: u.a.shape({ route: u.a.object.isRequired }).isRequired }, m.propTypes = { children: u.a.node, location: u.a.object }, t.a = m;
}, function (e, t, n) {
  const r = n(17); r.a;
}, function (e, t, n) {
  const r = n(74); r.a;
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } const i = n(0); const o = n.n(i); const a = n(1); const s = n.n(a); const l = n(75); const u = n.n(l); const c = n(26); const p = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const f = function (e) { const t = function (t) { const n = t.wrappedComponentRef; const i = r(t, ['wrappedComponentRef']); return o.a.createElement(c.a, { render(t) { return o.a.createElement(e, p({}, i, t, { ref: n })); } }); }; return t.displayName = `withRouter(${e.displayName || e.name})`, t.WrappedComponent = e, t.propTypes = { wrappedComponentRef: s.a.func }, u()(t, e); }; t.a = f;
}, function (e, t, n) {
  !(function (t, n) { e.exports = n(); }(0, () => {
    const e = {
      childContextTypes: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0,
    }; const t = {
      name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0,
    }; const n = Object.defineProperty; const r = Object.getOwnPropertyNames; const i = Object.getOwnPropertySymbols; const o = Object.getOwnPropertyDescriptor; const a = Object.getPrototypeOf; const s = a && a(Object); return function l(u, c, p) { if (typeof c !== 'string') { if (s) { const f = a(c); f && f !== s && l(u, f, p); } let h = r(c); i && (h = h.concat(i(c))); for (let d = 0; d < h.length; ++d) { const m = h[d]; if (!e[m] && !t[m] && (!p || !p[m])) { const g = o(c, m); try { n(u, m, g); } catch (e) {} } } return u; } return u; };
  }));
}, function (e, t, n) {
  const r = n(0); const i = n.n(r); const o = n(77); const a = n(79); const s = n(114); const l = n(116); const u = (n.n(l), function (e) { return i.a.createElement('div', { className: 'app' }, i.a.createElement(o.a, null), i.a.createElement(a.a, null), i.a.createElement(s.a, null)); }); t.a = u;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(10); const u = n(78); const c = (n.n(u), (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }())); const p = function (e) { return s.a.createElement('div', { className: 'header-menu' }, s.a.createElement('ul', { className: 'navbar-nav' }, s.a.createElement('li', { className: 'nav-item', 'data-toggle': 'collapse', 'data-target': '.navbar-collapse.show' }, s.a.createElement(l.b, { className: 'nav-link', to: '/' }, 'Live')), s.a.createElement('li', { className: 'nav-item', 'data-toggle': 'collapse', 'data-target': '.navbar-collapse.show' }, s.a.createElement(l.b, { className: 'nav-link', to: '/stats' }, 'Stats')), s.a.createElement('li', { className: 'nav-item', 'data-toggle': 'collapse', 'data-target': '.navbar-collapse.show' }, s.a.createElement(l.b, { className: 'nav-link', to: '/apidocs' }, 'API')), s.a.createElement('li', { className: 'nav-item', 'data-toggle': 'collapse', 'data-target': '.navbar-collapse.show' }, s.a.createElement(l.b, { className: 'nav-link', to: '/about' }, 'About')))); }; const f = (function (e) {
    function t() { return r(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments)); } return o(t, e), c(t, [{
      key: 'render',
      value() {
        return s.a.createElement('header', { className: 'header' }, s.a.createElement('nav', { className: 'navbar navbar-expand-md' }, s.a.createElement('div', { className: 'navbar-header' }, s.a.createElement('a', { href: '/', className: 'navbar-brand' }, s.a.createElement('h1', { className: 'title' }, 'HOT CITIES'), s.a.createElement('h2', { className: 'motto' }, "world's hottest city, now."))), s.a.createElement('button', {
          className: 'navbar-toggler', type: 'button', 'data-toggle': 'collapse', 'data-target': '#nav-id', 'aria-controls': '#navId', 'aria-expanded': 'false', 'aria-label': 'Toggle navigation',
        }, s.a.createElement('span', { className: 'fa fa-bars' })), s.a.createElement('div', { className: 'collapse navbar-collapse justify-content-end', id: 'nav-id' }, s.a.createElement(p, null))), s.a.createElement('hr', null));
      },
    }]), t;
  }(a.Component)); t.a = f;
}, function (e, t) {}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(10); const u = n(80); const c = n(84); const p = n(102); const f = n(109); const h = n(111); const d = n(113); const m = (n.n(d), (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }())); const g = (function (e) { function t() { return r(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments)); } return o(t, e), m(t, [{ key: 'render', value() { return s.a.createElement('div', { className: 'main' }, u.a.init() && s.a.createElement(u.a.RouteTracker, null), s.a.createElement(l.d, null, s.a.createElement(l.c, { exact: !0, path: '/', component: c.a }), s.a.createElement(l.c, { exact: !0, path: '/stats', component: p.a }), s.a.createElement(l.c, { exact: !0, path: '/apidocs', component: f.a }), s.a.createElement(l.c, { exact: !0, path: '/about', component: h.a }))); } }]), t; }(a.Component)); t.a = g;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(81); const u = n.n(l); const c = n(10); const p = (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }()); const f = (function (e) { function t() { return r(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments)); } return o(t, e), p(t, [{ key: 'componentDidMount', value() { this.logView(this.props.location.pathname); } }, { key: 'componentDidUpdate', value(e) { const t = e.location; const n = this.props.location.pathname; n !== t.pathname && this.logView(n); } }, { key: 'logView', value(e) { const t = e; const n = window; const r = n.location; u.a.set({ page: t, location: `${r.origin}${t}` }), u.a.pageview(t); } }, { key: 'render', value() { return null; } }]), t; }(a.Component)); const h = function () { return s.a.createElement(c.c, { component: f }); }; const d = function () { return u.a.initialize('UA-55404180-2', { debug: !1 }), !0; }; t.a = { GoogleAnalytics: f, RouteTracker: h, init: d };
}, function (e, t, n) {
  !(function (t, r) { e.exports = r(n(82), n(1)); }(typeof self !== 'undefined' && self, (e, t) => (function (e) { function t(r) { if (n[r]) return n[r].exports; const i = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(i.exports, i, i.exports, t), i.l = !0, i.exports; } var n = {}; return t.m = e, t.c = n, t.d = function (e, n, r) { t.o(e, n) || Object.defineProperty(e, n, { configurable: !1, enumerable: !0, get: r }); }, t.n = function (e) { const n = e && e.__esModule ? function () { return e.default; } : function () { return e; }; return t.d(n, 'a', n), n; }, t.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, t.p = '', t(t.s = 2); }([function (e, t, n) {
    function r(e) { console.warn('[react-ga]', e); }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = r;
  }, function (e, t, n) {
    function r(e) { return e.replace(/^\s+|\s+$/g, ''); }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = r;
  }, function (e, t, n) {
    function r(e) { return e && e.__esModule ? e : { default: e }; } function i(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } function o(e) { if (Array.isArray(e)) { for (var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t]; return n; } return Array.from(e); } function a(e) { return (0, w.default)(e, j); } function s(e) { for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; const i = n[0]; if (typeof U === 'function') { if (typeof i !== 'string') return void (0, I.default)('ga command must be a string'); !F && Array.isArray(e) || U(...n), Array.isArray(e) && e.forEach((e) => { U(...o([`${e}.${i}`].concat(n.slice(1)))); }); } } function l(e, t) { if (!e) return void (0, I.default)('gaTrackingID is required in initialize()'); t && (t.debug && !0 === t.debug && (R = !0), !1 === t.titleCase && (j = !1)), t && t.gaOptions ? U('create', e, t.gaOptions) : U('create', e, 'auto'); } function u(e, t) { if (t && !0 === t.testMode)B = !0; else { if (typeof window === 'undefined') return !1; (0, A.default)(t); } return F = !t || typeof t.alwaysSendToDefaultTracker !== 'boolean' || t.alwaysSendToDefaultTracker, Array.isArray(e) ? e.forEach((e) => { if ((typeof e === 'undefined' ? 'undefined' : b(e)) !== 'object') return void (0, I.default)('All configs must be an object'); l(e.trackingId, e); }) : l(e, t), !0; } function c() { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.length > 0 && (U(...t), R && ((0, M.default)("called ga('arguments');"), (0, M.default)(`with arguments: ${JSON.stringify(t)}`))), window.ga; } function p(e, t) { return e ? (typeof e === 'undefined' ? 'undefined' : b(e)) !== 'object' ? void (0, I.default)('Expected `fieldsObject` arg to be an Object') : (Object.keys(e).length === 0 && (0, I.default)('empty `fieldsObject` given to .set()'), s(t, 'set', e), void (R && ((0, M.default)("called ga('set', fieldsObject);"), (0, M.default)(`with fieldsObject: ${JSON.stringify(e)}`)))) : void (0, I.default)('`fieldsObject` is required in .set()'); } function f(e, t) { s(t, 'send', e), R && ((0, M.default)("called ga('send', fieldObject);"), (0, M.default)(`with fieldObject: ${JSON.stringify(e)}`), (0, M.default)(`with trackers: ${JSON.stringify(t)}`)); } function h(e, t, n) { if (!e) return void (0, I.default)('path is required in .pageview()'); const r = (0, C.default)(e); if (r === '') return void (0, I.default)('path cannot be an empty string in .pageview()'); const i = {}; if (n && (i.title = n), typeof c === 'function' && (s(t, 'send', _({ hitType: 'pageview', page: r }, i)), R)) { (0, M.default)("called ga('send', 'pageview', path);"); let o = ''; n && (o = ` and title: ${n}`), (0, M.default)(`with path: ${r}${o}`); } } function d(e, t) { if (!e) return void (0, I.default)('modalName is required in .modalview(modalName)'); const n = (0, T.default)((0, C.default)(e)); if (n === '') return void (0, I.default)('modalName cannot be an empty string or a single / in .modalview()'); if (typeof c === 'function') { const r = `/modal/${n}`; s(t, 'send', 'pageview', r), R && ((0, M.default)("called ga('send', 'pageview', path);"), (0, M.default)(`with path: ${r}`)); } } function m() {
      const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.category; const n = e.variable; const r = e.value; const i = e.label; const o = arguments[1]; if (typeof c === 'function') {
        if (!t || !n || !r || typeof r !== 'number') return void (0, I.default)('args.category, args.variable AND args.value are required in timing() AND args.value has to be a number'); const s = {
          hitType: 'timing', timingCategory: a(t), timingVar: a(n), timingValue: r,
        }; i && (s.timingLabel = a(i)), f(s, o);
      }
    } function g() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = arguments[1]; const n = e.category; const r = e.action; const o = e.label; const s = e.value; const l = e.nonInteraction; const u = e.transport; const p = i(e, ['category', 'action', 'label', 'value', 'nonInteraction', 'transport']); if (typeof c === 'function') { if (!n || !r) return void (0, I.default)('args.category AND args.action are required in event()'); const h = { hitType: 'event', eventCategory: a(n), eventAction: a(r) }; o && (h.eventLabel = a(o)), typeof s !== 'undefined' && (typeof s !== 'number' ? (0, I.default)('Expected `args.value` arg to be a Number.') : h.eventValue = s), typeof l !== 'undefined' && (typeof l !== 'boolean' ? (0, I.default)('`args.nonInteraction` must be a boolean.') : h.nonInteraction = l), typeof u !== 'undefined' && (typeof u !== 'string' ? (0, I.default)('`args.transport` must be a string.') : (['beacon', 'xhr', 'image'].indexOf(u) === -1 && (0, I.default)('`args.transport` must be either one of these values: `beacon`, `xhr` or `image`'), h.transport = u)), Object.keys(p).filter(e => e.substr(0, 'dimension'.length) === 'dimension').forEach((e) => { h[e] = p[e]; }), Object.keys(p).filter(e => e.substr(0, 'metric'.length) === 'metric').forEach((e) => { h[e] = p[e]; }), f(h, t); } } function y(e, t) { const n = e.description; const r = e.fatal; if (typeof c === 'function') { const i = { hitType: 'exception' }; n && (i.exDescription = a(n)), typeof r !== 'undefined' && (typeof r !== 'boolean' ? (0, I.default)('`args.fatal` must be a boolean.') : i.exFatal = r), f(i, t); } } function v(e, t, n) {
      if (typeof t !== 'function') return void (0, I.default)('hitCallback function is required'); if (typeof c === 'function') {
        if (!e || !e.label) return void (0, I.default)('args.label is required in outboundLink()'); const r = {
          hitType: 'event', eventCategory: 'Outbound', eventAction: 'Click', eventLabel: a(e.label),
        }; let i = !1; const o = function () { i = !0, t(); }; const s = setTimeout(o, 250); const l = function () { clearTimeout(s), i || t(); }; r.hitCallback = l, f(r, n);
      } else setTimeout(t, 0);
    }Object.defineProperty(t, '__esModule', { value: !0 }), t.testModeAPI = t.OutboundLink = t.plugin = void 0; var _ = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; var b = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; t.initialize = u, t.ga = c, t.set = p, t.send = f, t.pageview = h, t.modalview = d, t.timing = m, t.event = g, t.exception = y, t.outboundLink = v; const x = n(3); var w = r(x); const E = n(6); var T = r(E); const k = n(1); var C = r(k); const S = n(7); var A = r(S); const O = n(0); var I = r(O); const P = n(8); var M = r(P); const N = n(9); const D = r(N); const L = n(10); const z = r(L); var R = !1; var j = !0; var B = !1; var F = !0; var U = function () { let e; return B ? D.default.ga.apply(D.default, arguments) : window.ga ? (e = window).ga.apply(e, arguments) : (0, I.default)('ReactGA.initialize must be called first or GoogleAnalytics should be loaded manually'); }; const V = t.plugin = { require(e, t) { if (typeof c === 'function') { if (!e) return void (0, I.default)('`name` is required in .require()'); const n = (0, C.default)(e); if (n === '') return void (0, I.default)('`name` cannot be an empty string in .require()'); if (t) { if ((typeof t === 'undefined' ? 'undefined' : b(t)) !== 'object') return void (0, I.default)('Expected `options` arg to be an Object'); Object.keys(t).length === 0 && (0, I.default)('Empty `options` given to .require()'), c('require', n, t), R && (0, M.default)(`called ga('require', '${n}', ${JSON.stringify(t)}`); } else c('require', n), R && (0, M.default)(`called ga('require', '${n}');`); } }, execute(e, t) { let n = void 0; let r = void 0; if ((arguments.length <= 2 ? 0 : arguments.length - 2) === 1 ? n = arguments.length <= 2 ? void 0 : arguments[2] : (r = arguments.length <= 2 ? void 0 : arguments[2], n = arguments.length <= 3 ? void 0 : arguments[3]), typeof c === 'function') if (typeof e !== 'string')(0, I.default)('Expected `pluginName` arg to be a String.'); else if (typeof t !== 'string')(0, I.default)('Expected `action` arg to be a String.'); else { const i = `${e}:${t}`; n = n || null, r && n ? (c(i, r, n), R && ((0, M.default)(`called ga('${i}');`), (0, M.default)(`actionType: "${r}" with payload: ${JSON.stringify(n)}`))) : n ? (c(i, n), R && ((0, M.default)(`called ga('${i}');`), (0, M.default)(`with payload: ${JSON.stringify(n)}`))) : (c(i), R && (0, M.default)(`called ga('${i}');`)); } } }; z.default.origTrackLink = z.default.trackLink, z.default.trackLink = v; const q = t.OutboundLink = z.default; t.testModeAPI = D.default; t.default = {
      initialize: u, ga: c, set: p, send: f, pageview: h, modalview: d, timing: m, event: g, exception: y, plugin: V, outboundLink: v, OutboundLink: q, testModeAPI: D.default,
    };
  }, function (e, t, n) {
    function r(e) { return e && e.__esModule ? e : { default: e }; } function i(e, t) { return (0, a.default)(e) ? ((0, c.default)('This arg looks like an email address, redacting.'), p) : t ? (0, l.default)(e) : e; }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = i; const o = n(4); var a = r(o); const s = n(5); var l = r(s); const u = n(0); var c = r(u); var p = 'REDACTED (Potential Email Address)';
  }, function (e, t, n) {
    function r(e) { return /[^@]+@[^@]+/.test(e); }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = r;
  }, function (e, t, n) {
    function r(e) { return (0, o.default)(e).replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, (e, t, n) => (t > 0 && t + e.length !== n.length && e.search(a) > -1 && ':' !== n.charAt(t - 2) && (n.charAt(t + e.length)!=='-' || '-' === n.charAt(t - 1)) && n.charAt(t - 1).search(/[^\s-]/) < 0 ? e.toLowerCase() : e.substr(1).search(/[A-Z]|\../) > -1 ? e : e.charAt(0).toUpperCase() + e.substr(1))); }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = r; const i = n(1); var o = (function (e) { return e && e.__esModule ? e : { default: e }; }(i)); var a = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i;
  }, function (e, t, n) {
    function r(e) { return e.substring(0, 1) === '/' ? e.substring(1) : e; }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = r;
  }, function (e, t, n) {
    Object.defineProperty(t, '__esModule', { value: !0 }), t.default = function (e) { !(function (e, t, n, r, i, o, a) { e.GoogleAnalyticsObject = i, e[i] = e[i] || function () { (e[i].q = e[i].q || []).push(arguments); }, e[i].l = 1 * new Date(), o = t.createElement(n), a = t.getElementsByTagName(n)[0], o.async = 1, o.src = r, a.parentNode.insertBefore(o, a); }(window, document, 'script', e && e.gaAddress ? e.gaAddress : 'https://www.google-analytics.com/analytics.js', 'ga')); };
  }, function (e, t, n) {
    function r(e) { console.info('[react-ga]', e); }Object.defineProperty(t, '__esModule', { value: !0 }), t.default = r;
  }, function (e, t, n) {
    Object.defineProperty(t, '__esModule', { value: !0 }); const r = t.gaCalls = []; t.default = { calls: r, ga() { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; r.push([].concat(t)); } };
  }, function (e, t, n) {
    function r(e) { return e && e.__esModule ? e : { default: e }; } function i(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function o(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function a(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    }Object.defineProperty(t, '__esModule', { value: !0 }); const s = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const l = (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }()); const u = n(11); const c = r(u); const p = n(12); const f = r(p); const h = n(0); const d = r(h); const m = '_blank'; const g = 1; const y = (function (e) { function t() { let e; let n; let r; let a; i(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = r = o(this, (e = t.__proto__ || Object.getPrototypeOf(t)).call.apply(e, [this].concat(l))), r.handleClick = function (e) { const n = r.props; const i = n.target; const o = n.eventLabel; const a = n.to; const s = n.onClick; const l = { label: o }; const u = i !== m; const c = !(e.ctrlKey || e.shiftKey || e.metaKey || e.button === g); u && c ? (e.preventDefault(), t.trackLink(l, () => { window.location.href = a; })) : t.trackLink(l, () => {}), s && s(e); }, a = n, o(r, a); } return a(t, e), l(t, [{ key: 'render', value() { const e = s({}, this.props, { href: this.props.to, onClick: this.handleClick }); return delete e.eventLabel, c.default.createElement('a', e); } }]), t; }(u.Component)); y.propTypes = {
      eventLabel: f.default.string.isRequired, target: f.default.string, to: f.default.string, onClick: f.default.func,
    }, y.defaultProps = { target: null, to: null, onClick: null }, y.trackLink = function () { (0, d.default)('ga tracking not enabled'); }, t.default = y;
  }, function (t, n) { t.exports = e; }, function (e, n) { e.exports = t; }]))));
}, function (e, t, n) {
  e.exports = n(83);
}, function (e, t, n) {
  function r(e) { for (var t = arguments.length - 1, n = `https://reactjs.org/docs/error-decoder.html?invariant=${e}`, r = 0; r < t; r++)n += `&args[]=${encodeURIComponent(arguments[r + 1])}`; v(!1, `Minified React error #${e}; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. `, n); } function i(e, t, n) { this.props = e, this.context = t, this.refs = _, this.updater = n || M; } function o() {} function a(e, t, n) { this.props = e, this.context = t, this.refs = _, this.updater = n || M; } function s(e, t, n) {
    let r = void 0; const i = {}; let o = null; let a = null; if (t != null) for (r in void 0 !== t.ref && (a = t.ref), void 0 !== t.key && (o = `${t.key}`), t)L.call(t, r) && !z.hasOwnProperty(r) && (i[r] = t[r]); let s = arguments.length - 2; if (s === 1)i.children = n; else if (s > 1) { for (var l = Array(s), u = 0; u < s; u++)l[u] = arguments[u + 2]; i.children = l; } if (e && e.defaultProps) for (r in s = e.defaultProps) void 0 === i[r] && (i[r] = s[r]); return {
      $$typeof: w, type: e, key: o, ref: a, props: i, _owner: D.current,
    };
  } function l(e) { return typeof e === 'object' && e !== null && e.$$typeof === w; } function u(e) { const t = { '=': '=0', ':': '=2' }; return `$${(`${e}`).replace(/[=:]/g, e => t[e])}`; } function c(e, t, n, r) {
    if (j.length) { const i = j.pop(); return i.result = e, i.keyPrefix = t, i.func = n, i.context = r, i.count = 0, i; } return {
      result: e, keyPrefix: t, func: n, context: r, count: 0,
    };
  } function p(e) { e.result = null, e.keyPrefix = null, e.func = null, e.context = null, e.count = 0, j.length < 10 && j.push(e); } function f(e, t, n, i) { let o = typeof e; o !== 'undefined' && o !== 'boolean' || (e = null); let a = !1; if (e === null)a = !0; else switch (o) { case 'string': case 'number': a = !0; break; case 'object': switch (e.$$typeof) { case w: case E: a = !0; } } if (a) return n(i, e, t === '' ? `.${h(e, 0)}` : t), 1; if (a = 0, t = t === '' ? '.' : `${t}:`, Array.isArray(e)) for (var s = 0; s < e.length; s++) { o = e[s]; var l = t + h(o, s); a += f(o, l, n, i); } else if (e === null || typeof e === 'undefined' ? l = null : (l = P && e[P] || e['@@iterator'], l = typeof l === 'function' ? l : null), typeof l === 'function') for (e = l.call(e), s = 0; !(o = e.next()).done;)o = o.value, l = t + h(o, s++), a += f(o, l, n, i); else o === 'object' && (n = `${e}`, r('31', n === '[object Object]' ? `object with keys {${Object.keys(e).join(', ')}}` : n, '')); return a; } function h(e, t) { return typeof e === 'object' && e !== null && e.key != null ? u(e.key) : t.toString(36); } function d(e, t) { e.func.call(e.context, t, e.count++); } function m(e, t, n) {
    const r = e.result; const i = e.keyPrefix; e = e.func.call(e.context, t, e.count++), Array.isArray(e) ? g(e, r, n, b.thatReturnsArgument) : e != null && (l(e) && (t = i + (!e.key || t && t.key === e.key ? '' : `${(`${e.key}`).replace(R, '$&/')}/`) + n, e = {
      $$typeof: w, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner,
    }), r.push(e));
  } function g(e, t, n, r, i) { let o = ''; n != null && (o = `${(`${n}`).replace(R, '$&/')}/`), t = c(t, o, r, i), e == null || f(e, '', m, t), p(t); } const y = n(7); var v = n(8); var _ = n(12); var b = n(9); const x = typeof Symbol === 'function' && Symbol.for; var w = x ? Symbol.for('react.element') : 60103; var E = x ? Symbol.for('react.portal') : 60106; const T = x ? Symbol.for('react.fragment') : 60107; const k = x ? Symbol.for('react.strict_mode') : 60108; const C = x ? Symbol.for('react.profiler') : 60114; const S = x ? Symbol.for('react.provider') : 60109; const A = x ? Symbol.for('react.context') : 60110; const O = x ? Symbol.for('react.async_mode') : 60111; const I = x ? Symbol.for('react.forward_ref') : 60112; x && Symbol.for('react.timeout'); var P = typeof Symbol === 'function' && Symbol.iterator; var M = {
    isMounted() { return !1; }, enqueueForceUpdate() {}, enqueueReplaceState() {}, enqueueSetState() {},
  }; i.prototype.isReactComponent = {}, i.prototype.setState = function (e, t) { typeof e !== 'object' && typeof e !== 'function' && e != null && r('85'), this.updater.enqueueSetState(this, e, t, 'setState'); }, i.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, 'forceUpdate'); }, o.prototype = i.prototype; const N = a.prototype = new o(); N.constructor = a, y(N, i.prototype), N.isPureReactComponent = !0; var D = { current: null }; var L = Object.prototype.hasOwnProperty; var z = {
    key: !0, ref: !0, __self: !0, __source: !0,
  }; var R = /\/+/g; var j = []; const B = {
    Children: {
      map(e, t, n) { if (e == null) return e; const r = []; return g(e, r, null, t, n), r; }, forEach(e, t, n) { if (e == null) return e; t = c(null, null, t, n), e == null || f(e, '', d, t), p(t); }, count(e) { return e == null ? 0 : f(e, '', b.thatReturnsNull, null); }, toArray(e) { const t = []; return g(e, t, null, b.thatReturnsArgument), t; }, only(e) { return l(e) || r('143'), e; },
    },
    createRef() { return { current: null }; },
    Component: i,
    PureComponent: a,
    createContext(e, t) {
      return void 0 === t && (t = null), e = {
        $$typeof: A, _calculateChangedBits: t, _defaultValue: e, _currentValue: e, _currentValue2: e, _changedBits: 0, _changedBits2: 0, Provider: null, Consumer: null,
      }, e.Provider = { $$typeof: S, _context: e }, e.Consumer = e;
    },
    forwardRef(e) { return { $$typeof: I, render: e }; },
    Fragment: T,
    StrictMode: k,
    unstable_AsyncMode: O,
    unstable_Profiler: C,
    createElement: s,
    cloneElement(e, t, n) {
      (e === null || void 0 === e) && r('267', e); let i = void 0; const o = y({}, e.props); let a = e.key; let s = e.ref; let l = e._owner; if (t != null) { void 0 !== t.ref && (s = t.ref, l = D.current), void 0 !== t.key && (a = `${t.key}`); var u = void 0; e.type && e.type.defaultProps && (u = e.type.defaultProps); for (i in t)L.call(t, i) && !z.hasOwnProperty(i) && (o[i] = void 0 === t[i] && void 0 !== u ? u[i] : t[i]); } if ((i = arguments.length - 2) === 1)o.children = n; else if (i > 1) { u = Array(i); for (let c = 0; c < i; c++)u[c] = arguments[c + 2]; o.children = u; } return {
        $$typeof: w, type: e.type, key: a, ref: s, props: o, _owner: l,
      };
    },
    createFactory(e) { const t = s.bind(null, e); return t.type = e, t; },
    isValidElement: l,
    version: '16.4.1',
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: D, assign: y },
  }; const F = { default: B }; const U = F && B || F; e.exports = U.default ? U.default : U;
}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(28); const u = n.n(l); const c = n(86); const p = n(30); const f = n(31); const h = n(101); const d = (n.n(h), (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }())); const m = function (e) { return s.a.createElement('li', { className: 'live-item' }, s.a.createElement('span', { className: 'live-item-value' }, e.value), s.a.createElement('span', { className: 'live-item-icon' }, s.a.createElement('span', { className: e.icon }))); }; const g = function (e) { return s.a.createElement('div', { className: 'live-details' }, s.a.createElement('ul', null, e.children)); }; const y = function (e) { return s.a.createElement('div', { className: 'live-attribution' }, s.a.createElement('a', { href: e.view.page, target: '_blank' }, e.view.title), ' by ', s.a.createElement('a', { href: e.view.owner.page, target: '_blank' }, e.view.owner.realname), ', ', s.a.createElement('a', { href: e.view.license.link, target: '_blank' }, e.view.license.abbr)); }; const v = (function (e) { function t(e) { r(this, t); const n = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { activeIndex: 0 }, n.next = n.next.bind(n), n.previous = n.previous.bind(n), n.goToIndex = n.goToIndex.bind(n), n.onExiting = n.onExiting.bind(n), n.onExited = n.onExited.bind(n), n; } return o(t, e), d(t, [{ key: 'onExiting', value() { this.animating = !0; } }, { key: 'onExited', value() { this.animating = !1; } }, { key: 'next', value() { if (!this.animating) { const e = this.state.activeIndex === this.props.views.length - 1 ? 0 : this.state.activeIndex + 1; this.setState({ activeIndex: e }); } } }, { key: 'previous', value() { if (!this.animating) { const e = this.state.activeIndex === 0 ? this.props.views.length - 1 : this.state.activeIndex - 1; this.setState({ activeIndex: e }); } } }, { key: 'goToIndex', value(e) { this.animating || this.setState({ activeIndex: e }); } }, { key: 'views', value() { const e = this; return u.a.map(this.props.views, (t, n) => s.a.createElement(c.d, { onExiting: e.onExiting, onExited: e.onExited, key: n }, s.a.createElement('div', { className: 'carousel-view', style: { backgroundImage: `url(${t.src})` } }))); } }, { key: 'render', value() { const e = this.state.activeIndex; const t = this.props.views; const n = t[e]; return s.a.createElement('div', { className: 'live-view' }, s.a.createElement(c.a, { activeIndex: this.state.activeIndex, next: this.next, previous: this.previous }, s.a.createElement(c.c, { items: t, activeIndex: e, onClickHandler: this.goToIndex }), this.views(), s.a.createElement(c.b, { direction: 'prev', directionText: 'Previous', onClickHandler: this.previous }), s.a.createElement(c.b, { direction: 'next', directionText: 'Next', onClickHandler: this.next })), n && s.a.createElement(y, { view: n })); } }]), t; }(a.Component)); const _ = (function (e) {
    function t() { r(this, t); const e = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return e.state = { isLoading: !0 }, e; } return o(t, e), d(t, [{
      key: 'componentDidMount',
      value() {
        const e = this; fetch('/api/records/current').then(e => e.json()).then(e => Promise.all([e, fetch(`/api/cities/${e.geonameid}`).then(e => e.json()), fetch(`/api/views/${e.geonameid}`).then(e => e.json())])).then((t) => {
          const n = t[0]; const r = t[1]; const i = t[2]; e.setState({
            data: {
              name: r.name, localname: r.localname, country: r.country, countrycode: r.countrycode, lat: r.lat, lng: r.lng, temp: n.temp, views: i,
            },
            isLoading: !1,
          });
        });
      },
    }, { key: 'caption', value() { return this.state.isLoading ? 'Loading...' : p.a.names(this.state.data.name, this.state.data.localname); } }, { key: 'render', value() { return s.a.createElement('div', { className: 'live' }, s.a.createElement(v, { views: this.state.data ? u.a.first(this.state.data.views, 3) : [] }), s.a.createElement(f.a, { title: this.caption(), isLoading: this.state.isLoading }, !this.state.isLoading && s.a.createElement(g, null, s.a.createElement(m, { value: p.a.temp(this.state.data.temp), icon: 'fa fa-thermometer-full' }), s.a.createElement(m, { value: p.a.country(this.state.data.country, this.state.data.countrycode), icon: 'fa fa-globe' }), s.a.createElement(m, { value: p.a.coords(this.state.data.lat, this.state.data.lng), icon: 'fa fa-map-marker' })))); } }]), t;
  }(a.Component)); t.a = _;
}, function (e, t) { e.exports = function (e) { return e.webpackPolyfill || (e.deprecate = function () {}, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, 'loaded', { enumerable: !0, get() { return e.l; } }), Object.defineProperty(e, 'id', { enumerable: !0, get() { return e.i; } }), e.webpackPolyfill = 1), e; }; }, function (e, t, n) {
  function r() { const e = document.createElement('div'); e.style.position = 'absolute', e.style.top = '-9999px', e.style.width = '50px', e.style.height = '50px', e.style.overflow = 'scroll', document.body.appendChild(e); const t = e.offsetWidth - e.clientWidth; return document.body.removeChild(e), t; } function i(e) { document.body.style.paddingRight = e > 0 ? `${e}px` : null; } function o() { return document.body.clientWidth < window.innerWidth; } function a() { const e = window.getComputedStyle(document.body, null); return parseInt(e && e.getPropertyValue('padding-right') || 0, 10); } function s() { const e = r(); const t = document.querySelectorAll('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')[0]; const n = t ? parseInt(t.style.paddingRight || 0, 10) : 0; o() && i(n + e); } function l(e) { q = e; } function u() {
    const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '';


    const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : q; return t ? e.split(' ').map(e => t[e] || e).join(' ') : e;
  } function c(e, t) { const n = {}; return Object.keys(e).forEach((r) => { t.indexOf(r) === -1 && (n[r] = e[r]); }), n; } function p(e, t) { for (var n = Array.isArray(t) ? t : [t], r = n.length, i = void 0, o = {}; r > 0;)r -= 1, i = n[r], o[i] = e[i]; return o; } function f(e) { H[e] || (typeof console !== 'undefined' && console.error(e), H[e] = !0); } function h(e, t) { return function (n, r, i) { n[r] !== null && typeof n[r] !== 'undefined' && f(`"${r}" property of "${i}" has been deprecated.\n${t}`); for (var o = arguments.length, a = Array(o > 3 ? o - 3 : 0), s = 3; s < o; s++)a[s - 3] = arguments[s]; return e(...[n, r, i].concat(a)); }; } function d(e, t, n) { if (!(e[t] instanceof Element)) return new Error(`Invalid prop \`${t}\` supplied to \`${n}\`. Expected prop to be an instance of Element. Validation failed.`); } function m(e) { if (L()(e)) return e(); if (typeof e === 'string' && X) { let t = document.querySelectorAll(e); if (t.length || (t = document.querySelectorAll(`#${e}`)), !t.length) throw new Error(`The target '${e}' could not be identified in the dom, tip: check spelling`); return t; } return e; } function g(e) { return Array.isArray(e) || X && typeof e.length === 'number'; } function y(e) { const t = m(e); return g(t) ? t[0] : t; } function v(e, t, n) { let r = e; g(r) || (r = [r]); let i = n; if (typeof i === 'string' && (i = i.split(/\s+/)), !g(r) || typeof t !== 'function' || !Array.isArray(i)) throw new Error('\n      The first argument of this function must be DOM node or an array on DOM nodes or NodeList.\n      The second must be a function.\n      The third is a string or an array of strings that represents DOM events\n    '); return i.forEach((e) => { r.forEach((n) => { n.addEventListener(e, t); }); }), function () { i.forEach((e) => { r.forEach((n) => { n.removeEventListener(e, t); }); }); }; } function _(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e; } function b(e, t) { return t = { exports: {} }, e(t, t.exports), t.exports; } function x(e) { const t = e.tag; const n = e.baseClass; const r = e.baseClassActive; const i = e.className; const o = e.cssModule; const a = e.children; const s = ie(e, ['tag', 'baseClass', 'baseClassActive', 'className', 'cssModule', 'children']); const l = p(s, $); const f = c(s, $); return O.a.createElement(Tt, l, (e) => { const s = e === 'entered'; const l = u(N()(i, n, s && r), o); return O.a.createElement(t, ne({ className: l }, f), a); }); } function w(e) { const t = e.className; const n = e.label; const r = e.inline; const i = e.valid; const o = e.invalid; const a = e.cssModule; const s = e.children; const l = e.bsSize; const c = ie(e, ['className', 'label', 'inline', 'valid', 'invalid', 'cssModule', 'children', 'bsSize']); const p = c.type; const f = u(N()(t, `custom-${p}`, !!l && `custom-${p}-${l}`), a); const h = u(N()(o && 'is-invalid', i && 'is-valid'), a); if (p === 'select') return O.a.createElement('select', ne({}, c, { className: N()(h, f) }), s); if (p === 'file') return O.a.createElement('div', { className: f }, O.a.createElement('input', ne({}, c, { className: N()(h, u('custom-file-input', a)) })), O.a.createElement('label', { className: u('custom-file-label', a), htmlFor: c.id }, n || 'Choose file')); if (p !== 'checkbox' && p !== 'radio') return O.a.createElement('input', ne({}, c, { className: N()(h, f) })); const d = N()(f, u(N()('custom-control', { 'custom-control-inline': r }), a)); return O.a.createElement('div', { className: d }, O.a.createElement('input', ne({}, c, { className: N()(h, u('custom-control-input', a)) })), O.a.createElement('label', { className: u('custom-control-label', a), htmlFor: c.id }, n), s); } function E() {} function T(e, t) { const n = e.className; const r = e.cssModule; const i = e.tabId; const o = e.tag; const a = ie(e, ['className', 'cssModule', 'tabId', 'tag']); const s = u(N()('tab-pane', n, { active: i === t.activeTabId }), r); return O.a.createElement(o, ne({}, a, { className: s })); } function k(e) {
    const t = e.className; const n = e.closeClassName; const r = e.closeAriaLabel; const i = e.cssModule; const o = e.tag; const a = e.color; const s = e.isOpen; const l = e.toggle; const c = e.children; const p = e.transition; const f = ie(e, ['className', 'closeClassName', 'closeAriaLabel', 'cssModule', 'tag', 'color', 'isOpen', 'toggle', 'children', 'transition']); const h = u(N()(t, 'alert', `alert-${a}`, { 'alert-dismissible': l }), i); const d = u(N()('close', n), i); return O.a.createElement(x, ne({}, f, p, {
      tag: o, className: h, in: s, role: 'alert',
    }), l ? O.a.createElement('button', {
      type: 'button', className: d, 'aria-label': r, onClick: l,
    }, O.a.createElement('span', { 'aria-hidden': 'true' }, '\xd7')) : null, c);
  } function C(e) { return vi[e] || 'collapse'; } function S(e) { return e.scrollHeight; }n.d(t, 'a', () => ln), n.d(t, 'b', () => un), n.d(t, 'd', () => sn), n.d(t, 'c', () => cn); const A = n(0); var O = n.n(A); const I = n(87); const P = n.n(I); const M = n(90); var N = n.n(M); const D = n(91); var L = n.n(D); const z = n(92); const R = n.n(z); const j = n(20); const B = n.n(j); const F = n(93); const U = n(98); const V = n.n(U); var q = void 0; var H = {}; const W = {
    Fade: 150, Collapse: 350, Modal: 300, Carousel: 600,
  }; var $ = ['in', 'mountOnEnter', 'unmountOnExit', 'appear', 'enter', 'exit', 'timeout', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited']; const G = {
    ENTERING: 'entering', ENTERED: 'entered', EXITING: 'exiting', EXITED: 'exited',
  }; const Z = {
    esc: 27, space: 32, tab: 9, up: 38, down: 40,
  }; const K = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; var X = !(typeof window === 'undefined' || !window.document || !window.document.createElement); const Y = ['touchstart', 'click']; const J = (Object.freeze({
    getScrollbarWidth: r, setScrollbarWidth: i, isBodyOverflowing: o, getOriginalBodyPadding: a, conditionallyUpdateScrollbar: s, setGlobalCssModule: l, mapToCssModules: u, omit: c, pick: p, warnOnce: f, deprecated: h, DOMElement: d, TransitionTimeouts: W, TransitionPropTypeKeys: $, TransitionStatuses: G, keyCodes: Z, PopperPlacements: K, canUseDOM: X, findDOMElements: m, isArrayOrNodeList: g, getTarget: y, defaultToggleEvents: Y, addMultipleEventListeners: v,
  }), typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }); const Q = function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }; const ee = (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }()); const te = function (e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  }; var ne = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const re = function (e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  }; var ie = function (e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; }; const oe = function (e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; }; const ae = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), fluid: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const se = { tag: 'div' }; const le = function (e) { const t = e.className; const n = e.cssModule; const r = e.fluid; const i = e.tag; const o = ie(e, ['className', 'cssModule', 'fluid', 'tag']); const a = u(N()(t, r ? 'container-fluid' : 'container'), n); return O.a.createElement(i, ne({}, o, { className: a })); }; le.propTypes = ae, le.defaultProps = se; const ue = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), noGutters: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const ce = { tag: 'div' }; const pe = function (e) { const t = e.className; const n = e.cssModule; const r = e.noGutters; const i = e.tag; const o = ie(e, ['className', 'cssModule', 'noGutters', 'tag']); const a = u(N()(t, r ? 'no-gutters' : null, 'row'), n); return O.a.createElement(i, ne({}, o, { className: a })); }; pe.propTypes = ue, pe.defaultProps = ce; const fe = ['xs', 'sm', 'md', 'lg', 'xl']; const he = P.a.oneOfType([P.a.number, P.a.string]); const de = P.a.oneOfType([P.a.bool, P.a.number, P.a.string, P.a.shape({
    size: P.a.oneOfType([P.a.bool, P.a.number, P.a.string]), push: h(he, 'Please use the prop "order"'), pull: h(he, 'Please use the prop "order"'), order: he, offset: he,
  })]); const me = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), xs: de, sm: de, md: de, lg: de, xl: de, className: P.a.string, cssModule: P.a.object, widths: P.a.array,
  }; const ge = { tag: 'div', widths: fe }; const ye = function (e, t, n) { return !0 === n || n === '' ? e ? 'col' : `col-${t}` : n === 'auto' ? e ? 'col-auto' : `col-${t}-auto` : e ? `col-${n}` : `col-${t}-${n}`; }; const ve = function (e) { const t = e.className; const n = e.cssModule; const r = e.widths; const i = e.tag; const o = ie(e, ['className', 'cssModule', 'widths', 'tag']); const a = []; r.forEach((t, r) => { const i = e[t]; if (delete o[t], i || i === '') { const s = !r; if (R()(i)) { let l; const c = s ? '-' : `-${t}-`; const p = ye(s, t, i.size); a.push(u(N()((l = {}, te(l, p, i.size || i.size === ''), te(l, `order${c}${i.order}`, i.order || i.order === 0), te(l, `offset${c}${i.offset}`, i.offset || i.offset === 0), l)), n)); } else { const f = ye(s, t, i); a.push(f); } } }), a.length || a.push('col'); const s = u(N()(t, a), n); return O.a.createElement(i, ne({}, o, { className: s })); }; ve.propTypes = me, ve.defaultProps = ge; const _e = {
    light: P.a.bool, dark: P.a.bool, inverse: h(P.a.bool, 'Please use the prop "dark"'), full: P.a.bool, fixed: P.a.string, sticky: P.a.string, color: P.a.string, role: P.a.string, tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object, toggleable: h(P.a.oneOfType([P.a.bool, P.a.string]), 'Please use the prop "expand"'), expand: P.a.oneOfType([P.a.bool, P.a.string]),
  }; const be = { tag: 'nav', expand: !1 }; const xe = function (e) { return !1 !== e && (!0 === e || e === 'xs' ? 'navbar-expand' : `navbar-expand-${e}`); }; const we = {
    xs: 'sm', sm: 'md', md: 'lg', lg: 'xl',
  }; const Ee = function (e) { return void 0 !== e && e !== 'xl' && (!1 === e ? 'navbar-expand' : `navbar-expand-${!0 === e ? 'sm' : we[e] || e}`); }; const Te = function (e) { let t; const n = e.toggleable; const r = e.expand; const i = e.className; const o = e.cssModule; const a = e.light; const s = e.dark; const l = e.inverse; const c = e.fixed; const p = e.sticky; const f = e.color; const h = e.tag; const d = ie(e, ['toggleable', 'expand', 'className', 'cssModule', 'light', 'dark', 'inverse', 'fixed', 'sticky', 'color', 'tag']); const m = u(N()(i, 'navbar', xe(r) || Ee(n), (t = { 'navbar-light': a, 'navbar-dark': l || s }, te(t, `bg-${f}`, f), te(t, `fixed-${c}`, c), te(t, `sticky-${p}`, p), t)), o); return O.a.createElement(h, ne({}, d, { className: m })); }; Te.propTypes = _e, Te.defaultProps = be; const ke = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Ce = { tag: 'a' }; const Se = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'navbar-brand'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Se.propTypes = ke, Se.defaultProps = Ce; const Ae = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), type: P.a.string, className: P.a.string, cssModule: P.a.object, children: P.a.node,
  }; const Oe = { tag: 'button', type: 'button' }; const Ie = function (e) { const t = e.className; const n = e.cssModule; const r = e.children; const i = e.tag; const o = ie(e, ['className', 'cssModule', 'children', 'tag']); const a = u(N()(t, 'navbar-toggler'), n); return O.a.createElement(i, ne({}, o, { className: a }), r || O.a.createElement('span', { className: u('navbar-toggler-icon', n) })); }; Ie.propTypes = Ae, Ie.defaultProps = Oe; const Pe = {
    tabs: P.a.bool, pills: P.a.bool, vertical: P.a.oneOfType([P.a.bool, P.a.string]), horizontal: P.a.string, justified: P.a.bool, fill: P.a.bool, navbar: P.a.bool, card: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object,
  }; const Me = { tag: 'ul', vertical: !1 }; const Ne = function (e) { return !1 !== e && (!0 === e || e === 'xs' ? 'flex-column' : `flex-${e}-column`); }; const De = function (e) {
    const t = e.className; const n = e.cssModule; const r = e.tabs; const i = e.pills; const o = e.vertical; const a = e.horizontal; const s = e.justified; const l = e.fill; const c = e.navbar; const p = e.card; const f = e.tag; const h = ie(e, ['className', 'cssModule', 'tabs', 'pills', 'vertical', 'horizontal', 'justified', 'fill', 'navbar', 'card', 'tag']); const d = u(N()(t, c ? 'navbar-nav' : 'nav', !!a && `justify-content-${a}`, Ne(o), {
      'nav-tabs': r, 'card-header-tabs': p && r, 'nav-pills': i, 'card-header-pills': p && i, 'nav-justified': s, 'nav-fill': l,
    }), n); return O.a.createElement(f, ne({}, h, { className: d }));
  }; De.propTypes = Pe, De.defaultProps = Me; const Le = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), active: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const ze = { tag: 'li' }; const Re = function (e) { const t = e.className; const n = e.cssModule; const r = e.active; const i = e.tag; const o = ie(e, ['className', 'cssModule', 'active', 'tag']); const a = u(N()(t, 'nav-item', !!r && 'active'), n); return O.a.createElement(i, ne({}, o, { className: a })); }; Re.propTypes = Le, Re.defaultProps = ze; const je = {
    disabled: P.a.bool, dropup: h(P.a.bool, 'Please use the prop "direction" with the value "up".'), direction: P.a.oneOf(['up', 'down', 'left', 'right']), group: P.a.bool, isOpen: P.a.bool, nav: P.a.bool, active: P.a.bool, addonType: P.a.oneOfType([P.a.bool, P.a.oneOf(['prepend', 'append'])]), size: P.a.string, tag: P.a.string, toggle: P.a.func, children: P.a.node, className: P.a.string, cssModule: P.a.object, inNavbar: P.a.bool, setActiveFromChild: P.a.bool,
  }; const Be = {
    isOpen: !1, direction: 'down', nav: !1, active: !1, addonType: !1, inNavbar: !1, setActiveFromChild: !1,
  }; const Fe = {
    toggle: P.a.func.isRequired, isOpen: P.a.bool.isRequired, direction: P.a.oneOf(['up', 'down', 'left', 'right']).isRequired, inNavbar: P.a.bool.isRequired,
  }; const Ue = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.addEvents = n.addEvents.bind(n), n.handleDocumentClick = n.handleDocumentClick.bind(n), n.handleKeyDown = n.handleKeyDown.bind(n), n.removeEvents = n.removeEvents.bind(n), n.toggle = n.toggle.bind(n), n; } return re(t, e), ee(t, [{
      key: 'getChildContext',
      value() {
        return {
          toggle: this.props.toggle, isOpen: this.props.isOpen, direction: this.props.direction === 'down' && this.props.dropup ? 'up' : this.props.direction, inNavbar: this.props.inNavbar,
        };
      },
    }, { key: 'componentDidMount', value() { this.handleProps(); } }, { key: 'componentDidUpdate', value(e) { this.props.isOpen !== e.isOpen && this.handleProps(); } }, { key: 'componentWillUnmount', value() { this.removeEvents(); } }, { key: 'getContainer', value() { return B.a.findDOMNode(this); } }, { key: 'addEvents', value() { const e = this; ['click', 'touchstart', 'keyup'].forEach(t => document.addEventListener(t, e.handleDocumentClick, !0)); } }, { key: 'removeEvents', value() { const e = this; ['click', 'touchstart', 'keyup'].forEach(t => document.removeEventListener(t, e.handleDocumentClick, !0)); } }, { key: 'handleDocumentClick', value(e) { if (!e || e.which !== 3 && (e.type !== 'keyup' || e.which === Z.tab)) { const t = this.getContainer(); (!t.contains(e.target) || t === e.target || e.type === 'keyup' && e.which !== Z.tab) && this.toggle(e); } } }, { key: 'handleKeyDown', value(e) { if (!([Z.esc, Z.up, Z.down, Z.space].indexOf(e.which) === -1 || /button/i.test(e.target.tagName) && e.which === Z.space || /input|textarea/i.test(e.target.tagName)) && (e.preventDefault(), !this.props.disabled)) { const t = this.getContainer(); if (e.which === Z.space && this.props.isOpen && t !== e.target && e.target.click(), e.which === Z.esc || !this.props.isOpen) return this.toggle(e), void t.querySelector('[aria-expanded]').focus(); const n = u('dropdown-menu', this.props.cssModule); const r = u('dropdown-item', this.props.cssModule); const i = u('disabled', this.props.cssModule); const o = t.querySelectorAll(`.${n} .${r}:not(.${i})`); if (o.length) { for (var a = -1, s = 0; s < o.length; s += 1) if (o[s] === e.target) { a = s; break; }e.which === Z.up && a > 0 && (a -= 1), e.which === Z.down && a < o.length - 1 && (a += 1), a < 0 && (a = 0), o[a].focus(); } } } }, { key: 'handleProps', value() { this.props.isOpen ? this.addEvents() : this.removeEvents(); } }, { key: 'toggle', value(e) { return this.props.disabled ? e && e.preventDefault() : this.props.toggle(e); } }, { key: 'render', value() { let e; const t = c(this.props, ['toggle', 'disabled', 'inNavbar', 'direction']); const n = t.className; const r = t.cssModule; const i = t.dropup; const o = t.isOpen; const a = t.group; const s = t.size; const l = t.nav; const p = t.setActiveFromChild; const f = t.active; const h = t.addonType; const d = ie(t, ['className', 'cssModule', 'dropup', 'isOpen', 'group', 'size', 'nav', 'setActiveFromChild', 'active', 'addonType']); const m = this.props.direction === 'down' && i ? 'up' : this.props.direction; d.tag = d.tag || (l ? 'li' : 'div'); let g = !1; p && O.a.Children.map(this.props.children[1].props.children, (e) => { e.props.active && (g = !0); }); const y = u(N()(n, m !== 'down' && `drop${m}`, !(!l || !f) && 'active', !(!p || !g) && 'active', (e = {}, te(e, `input-group-${h}`, h), te(e, 'btn-group', a), te(e, `btn-group-${s}`, !!s), te(e, 'dropdown', !a && !h), te(e, 'show', o), te(e, 'nav-item', l), e)), r); return O.a.createElement(F.b, ne({}, d, { className: y, onKeyDown: this.handleKeyDown })); } }]), t;
  }(O.a.Component)); Ue.propTypes = je, Ue.defaultProps = Be, Ue.childContextTypes = Fe; const Ve = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), innerRef: P.a.oneOfType([P.a.object, P.a.func, P.a.string]), disabled: P.a.bool, active: P.a.bool, className: P.a.string, cssModule: P.a.object, onClick: P.a.func, href: P.a.any,
  }; const qe = { tag: 'a' }; const He = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.onClick = n.onClick.bind(n), n; } return re(t, e), ee(t, [{ key: 'onClick', value(e) { if (this.props.disabled) return void e.preventDefault(); this.props.href === '#' && e.preventDefault(), this.props.onClick && this.props.onClick(e); } }, { key: 'render', value() { const e = this.props; const t = e.className; const n = e.cssModule; const r = e.active; const i = e.tag; const o = e.innerRef; const a = ie(e, ['className', 'cssModule', 'active', 'tag', 'innerRef']); const s = u(N()(t, 'nav-link', { disabled: a.disabled, active: r }), n); return O.a.createElement(i, ne({}, a, { ref: o, onClick: this.onClick, className: s })); } }]), t; }(O.a.Component)); He.propTypes = Ve, He.defaultProps = qe; const We = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), listTag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, listClassName: P.a.string, cssModule: P.a.object, children: P.a.node, 'aria-label': P.a.string,
  }; const $e = { tag: 'nav', listTag: 'ol', 'aria-label': 'breadcrumb' }; const Ge = function (e) { const t = e.className; const n = e.listClassName; const r = e.cssModule; const i = e.children; const o = e.tag; const a = e.listTag; const s = e['aria-label']; const l = ie(e, ['className', 'listClassName', 'cssModule', 'children', 'tag', 'listTag', 'aria-label']); const c = u(N()(t), r); const p = u(N()('breadcrumb', n), r); return O.a.createElement(o, ne({}, l, { className: c, 'aria-label': s }), O.a.createElement(a, { className: p }, i)); }; Ge.propTypes = We, Ge.defaultProps = $e; const Ze = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), active: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const Ke = { tag: 'li' }; const Xe = function (e) { const t = e.className; const n = e.cssModule; const r = e.active; const i = e.tag; const o = ie(e, ['className', 'cssModule', 'active', 'tag']); const a = u(N()(t, !!r && 'active', 'breadcrumb-item'), n); return O.a.createElement(i, ne({}, o, { className: a, 'aria-current': r ? 'page' : void 0 })); }; Xe.propTypes = Ze, Xe.defaultProps = Ke; const Ye = {
    active: P.a.bool, block: P.a.bool, color: P.a.string, disabled: P.a.bool, outline: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), innerRef: P.a.oneOfType([P.a.object, P.a.func, P.a.string]), onClick: P.a.func, size: P.a.string, children: P.a.node, className: P.a.string, cssModule: P.a.object,
  }; const Je = { color: 'secondary', tag: 'button' }; const Qe = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.onClick = n.onClick.bind(n), n; } return re(t, e), ee(t, [{ key: 'onClick', value(e) { if (this.props.disabled) return void e.preventDefault(); this.props.onClick && this.props.onClick(e); } }, { key: 'render', value() { const e = this.props; const t = e.active; const n = e.block; const r = e.className; const i = e.cssModule; const o = e.color; const a = e.outline; const s = e.size; let l = e.tag; const c = e.innerRef; const p = ie(e, ['active', 'block', 'className', 'cssModule', 'color', 'outline', 'size', 'tag', 'innerRef']); const f = u(N()(r, 'btn', `btn${a ? '-outline' : ''}-${o}`, !!s && `btn-${s}`, !!n && 'btn-block', { active: t, disabled: this.props.disabled }), i); return p.href && l === 'button' && (l = 'a'), O.a.createElement(l, ne({ type: l === 'button' && p.onClick ? 'button' : void 0 }, p, { className: f, ref: c, onClick: this.onClick })); } }]), t; }(O.a.Component)); Qe.propTypes = Ye, Qe.defaultProps = Je; const et = { children: P.a.node }; const tt = function (e) { return O.a.createElement(Ue, ne({ group: !0 }, e)); }; tt.propTypes = et; const nt = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), 'aria-label': P.a.string, className: P.a.string, cssModule: P.a.object, role: P.a.string, size: P.a.string, vertical: P.a.bool,
  }; const rt = { tag: 'div', role: 'group' }; const it = function (e) { const t = e.className; const n = e.cssModule; const r = e.size; const i = e.vertical; const o = e.tag; const a = ie(e, ['className', 'cssModule', 'size', 'vertical', 'tag']); const s = u(N()(t, !!r && `btn-group-${r}`, i ? 'btn-group-vertical' : 'btn-group'), n); return O.a.createElement(o, ne({}, a, { className: s })); }; it.propTypes = nt, it.defaultProps = rt; const ot = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), 'aria-label': P.a.string, className: P.a.string, cssModule: P.a.object, role: P.a.string,
  }; const at = { tag: 'div', role: 'toolbar' }; const st = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'btn-toolbar'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; st.propTypes = ot, st.defaultProps = at; const lt = {
    children: P.a.node, active: P.a.bool, disabled: P.a.bool, divider: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), header: P.a.bool, onClick: P.a.func, className: P.a.string, cssModule: P.a.object, toggle: P.a.bool,
  }; const ut = { toggle: P.a.func }; const ct = { tag: 'button', toggle: !0 }; const pt = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.onClick = n.onClick.bind(n), n.getTabIndex = n.getTabIndex.bind(n), n; } return re(t, e), ee(t, [{ key: 'onClick', value(e) { if (this.props.disabled || this.props.header || this.props.divider) return void e.preventDefault(); this.props.onClick && this.props.onClick(e), this.props.toggle && this.context.toggle(e); } }, { key: 'getTabIndex', value() { return this.props.disabled || this.props.header || this.props.divider ? '-1' : '0'; } }, {
      key: 'render',
      value() {
        const e = this.getTabIndex(); const t = c(this.props, ['toggle']); const n = t.className; const r = t.cssModule; const i = t.divider; let o = t.tag; const a = t.header; const s = t.active; const l = ie(t, ['className', 'cssModule', 'divider', 'tag', 'header', 'active']); const p = u(N()(n, {
          disabled: l.disabled, 'dropdown-item': !i && !a, active: s, 'dropdown-header': a, 'dropdown-divider': i,
        }), r); return o === 'button' && (a ? o = 'h6' : i ? o = 'div' : l.href && (o = 'a')), O.a.createElement(o, ne({ type: o === 'button' && (l.onClick || this.props.toggle) ? 'button' : void 0 }, l, { tabIndex: e, className: p, onClick: this.onClick }));
      },
    }]), t;
  }(O.a.Component)); pt.propTypes = lt, pt.defaultProps = ct, pt.contextTypes = ut; const ft = {
    tag: P.a.string, children: P.a.node.isRequired, right: P.a.bool, flip: P.a.bool, modifiers: P.a.object, className: P.a.string, cssModule: P.a.object, persist: P.a.bool,
  }; const ht = { tag: 'div', flip: !0 }; const dt = { isOpen: P.a.bool.isRequired, direction: P.a.oneOf(['up', 'down', 'left', 'right']).isRequired, inNavbar: P.a.bool.isRequired }; const mt = { flip: { enabled: !1 } }; const gt = {
    up: 'top', left: 'left', right: 'right', down: 'bottom',
  }; const yt = function (e, t) { const n = e.className; const r = e.cssModule; const i = e.right; const o = e.tag; const a = e.flip; const s = e.modifiers; const l = e.persist; const c = ie(e, ['className', 'cssModule', 'right', 'tag', 'flip', 'modifiers', 'persist']); const p = u(N()(n, 'dropdown-menu', { 'dropdown-menu-right': i, show: t.isOpen }), r); let f = o; if (l || t.isOpen && !t.inNavbar) { f = F.c; const h = gt[t.direction] || 'bottom'; const d = i ? 'end' : 'start'; c.placement = `${h}-${d}`, c.component = o, c.modifiers = a ? s : ne({}, s, mt); } return O.a.createElement(f, ne({ tabIndex: '-1', role: 'menu' }, c, { 'aria-hidden': !t.isOpen, className: p, 'x-placement': c.placement })); }; yt.propTypes = ft, yt.defaultProps = ht, yt.contextTypes = dt; const vt = {
    caret: P.a.bool, color: P.a.string, children: P.a.node, className: P.a.string, cssModule: P.a.object, disabled: P.a.bool, onClick: P.a.func, 'aria-haspopup': P.a.bool, split: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), nav: P.a.bool,
  }; const _t = { 'aria-haspopup': !0, color: 'secondary' }; const bt = { isOpen: P.a.bool.isRequired, toggle: P.a.func.isRequired, inNavbar: P.a.bool.isRequired }; const xt = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.onClick = n.onClick.bind(n), n; } return re(t, e), ee(t, [{ key: 'onClick', value(e) { if (this.props.disabled) return void e.preventDefault(); this.props.nav && !this.props.tag && e.preventDefault(), this.props.onClick && this.props.onClick(e), this.context.toggle(e); } }, {
      key: 'render',
      value() {
        const e = this.props; const t = e.className; const n = e.color; const r = e.cssModule; const i = e.caret; const o = e.split; const a = e.nav; const s = e.tag; const l = ie(e, ['className', 'color', 'cssModule', 'caret', 'split', 'nav', 'tag']); const c = l['aria-label'] || 'Toggle Dropdown'; const p = u(N()(t, { 'dropdown-toggle': i || o, 'dropdown-toggle-split': o, 'nav-link': a }), r); const f = l.children || O.a.createElement('span', { className: 'sr-only' }, c); let h = void 0; return a && !s ? (h = 'a', l.href = '#') : s ? h = s : (h = Qe, l.color = n, l.cssModule = r), this.context.inNavbar ? O.a.createElement(h, ne({}, l, {
          className: p, onClick: this.onClick, 'aria-expanded': this.context.isOpen, children: f,
        })) : O.a.createElement(F.d, ne({}, l, {
          className: p, component: h, onClick: this.onClick, 'aria-expanded': this.context.isOpen, children: f,
        }));
      },
    }]), t;
  }(O.a.Component)); xt.propTypes = vt, xt.defaultProps = _t, xt.contextTypes = bt; const wt = b((e, t) => {
    function n(e) { const t = `transition${e}Timeout`; const n = `transition${e}`; return function (e) { if (e[n]) { if (e[t] == null) return new Error(`${t} wasn't supplied to CSSTransitionGroup: this can cause unreliable animations and won't be supported in a future version of React. See https://fb.me/react-animation-transition-group-timeout for more information.`); if (typeof e[t] !== 'number') return new Error(`${t} must be a number (in milliseconds)`); } return null; }; }t.__esModule = !0, t.classNamesShape = t.timeoutsShape = void 0, t.transitionTimeout = n; const r = (function (e) { return e && e.__esModule ? e : { default: e }; }(P.a)); t.timeoutsShape = r.default.oneOfType([r.default.number, r.default.shape({ enter: r.default.number, exit: r.default.number }).isRequired]), t.classNamesShape = r.default.oneOfType([r.default.string, r.default.shape({ enter: r.default.string, exit: r.default.string, active: r.default.string }), r.default.shape({
      enter: r.default.string, enterDone: r.default.string, enterActive: r.default.string, exit: r.default.string, exitDone: r.default.string, exitActive: r.default.string,
    })]);
  }); _(wt); const Et = b((e, t) => {
    function n(e) { return e && e.__esModule ? e : { default: e }; } function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } function i(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function o(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || (typeof t === 'undefined' ? 'undefined' : J(t)) !== 'object' && typeof t !== 'function' ? e : t; } function a(e, t) {
      if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t === 'undefined' ? 'undefined' : J(t)}`); e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
    } function s() {}t.__esModule = !0, t.EXITING = t.ENTERED = t.ENTERING = t.EXITED = t.UNMOUNTED = void 0; const l = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const n in e)Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]); return t.default = e, t; }(P.a)); const u = n(O.a); const c = n(B.a); const p = t.UNMOUNTED = 'unmounted'; const f = t.EXITED = 'exited'; const h = t.ENTERING = 'entering'; const d = t.ENTERED = 'entered'; const m = t.EXITING = 'exiting'; const g = (function (e) { function t(n, r) { i(this, t); const a = o(this, e.call(this, n, r)); const s = r.transitionGroup; const l = s && !s.isMounting ? n.enter : n.appear; let u = void 0; return a.nextStatus = null, n.in ? l ? (u = f, a.nextStatus = h) : u = d : u = n.unmountOnExit || n.mountOnEnter ? p : f, a.state = { status: u }, a.nextCallback = null, a; } return a(t, e), t.prototype.getChildContext = function () { return { transitionGroup: null }; }, t.prototype.componentDidMount = function () { this.updateStatus(!0); }, t.prototype.componentWillReceiveProps = function (e) { const t = this.pendingState || this.state; const n = t.status; e.in ? (n === p && this.setState({ status: f }), n !== h && n !== d && (this.nextStatus = h)) : n !== h && n !== d || (this.nextStatus = m); }, t.prototype.componentDidUpdate = function () { this.updateStatus(); }, t.prototype.componentWillUnmount = function () { this.cancelNextCallback(); }, t.prototype.getTimeouts = function () { const e = this.props.timeout; let t = void 0; let n = void 0; let r = void 0; return t = n = r = e, e != null && typeof e !== 'number' && (t = e.exit, n = e.enter, r = e.appear), { exit: t, enter: n, appear: r }; }, t.prototype.updateStatus = function () { const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; const t = this.nextStatus; if (t !== null) { this.nextStatus = null, this.cancelNextCallback(); const n = c.default.findDOMNode(this); t === h ? this.performEnter(n, e) : this.performExit(n); } else this.props.unmountOnExit && this.state.status === f && this.setState({ status: p }); }, t.prototype.performEnter = function (e, t) { const n = this; const r = this.props.enter; const i = this.context.transitionGroup ? this.context.transitionGroup.isMounting : t; const o = this.getTimeouts(); if (!t && !r) return void this.safeSetState({ status: d }, () => { n.props.onEntered(e); }); this.props.onEnter(e, i), this.safeSetState({ status: h }, () => { n.props.onEntering(e, i), n.onTransitionEnd(e, o.enter, () => { n.safeSetState({ status: d }, () => { n.props.onEntered(e, i); }); }); }); }, t.prototype.performExit = function (e) { const t = this; const n = this.props.exit; const r = this.getTimeouts(); if (!n) return void this.safeSetState({ status: f }, () => { t.props.onExited(e); }); this.props.onExit(e), this.safeSetState({ status: m }, () => { t.props.onExiting(e), t.onTransitionEnd(e, r.exit, () => { t.safeSetState({ status: f }, () => { t.props.onExited(e); }); }); }); }, t.prototype.cancelNextCallback = function () { this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null); }, t.prototype.safeSetState = function (e, t) { const n = this; this.pendingState = e, t = this.setNextCallback(t), this.setState(e, () => { n.pendingState = null, t(); }); }, t.prototype.setNextCallback = function (e) { const t = this; let n = !0; return this.nextCallback = function (r) { n && (n = !1, t.nextCallback = null, e(r)); }, this.nextCallback.cancel = function () { n = !1; }, this.nextCallback; }, t.prototype.onTransitionEnd = function (e, t, n) { this.setNextCallback(n), e ? (this.props.addEndListener && this.props.addEndListener(e, this.nextCallback), t != null && setTimeout(this.nextCallback, t)) : setTimeout(this.nextCallback, 0); }, t.prototype.render = function () { const e = this.state.status; if (e === p) return null; const t = this.props; const n = t.children; const i = r(t, ['children']); if (delete i.in, delete i.mountOnEnter, delete i.unmountOnExit, delete i.appear, delete i.enter, delete i.exit, delete i.timeout, delete i.addEndListener, delete i.onEnter, delete i.onEntering, delete i.onEntered, delete i.onExit, delete i.onExiting, delete i.onExited, typeof n === 'function') return n(e, i); const o = u.default.Children.only(n); return u.default.cloneElement(o, i); }, t; }(u.default.Component)); g.contextTypes = { transitionGroup: l.object }, g.childContextTypes = { transitionGroup() {} }, g.propTypes = {}, g.defaultProps = {
      in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: s, onEntering: s, onEntered: s, onExit: s, onExiting: s, onExited: s,
    }, g.UNMOUNTED = 0, g.EXITED = 1, g.ENTERING = 2, g.ENTERED = 3, g.EXITING = 4, t.default = g;
  }); var Tt = _(Et); const kt = ne({}, Tt.propTypes, {
    children: P.a.oneOfType([P.a.arrayOf(P.a.node), P.a.node]), tag: P.a.oneOfType([P.a.string, P.a.func]), baseClass: P.a.string, baseClassActive: P.a.string, className: P.a.string, cssModule: P.a.object,
  }); const Ct = ne({}, Tt.defaultProps, {
    tag: 'div', baseClass: 'fade', baseClassActive: 'show', timeout: W.Fade, appear: !0, enter: !0, exit: !0, in: !0,
  }); x.propTypes = kt, x.defaultProps = Ct; const St = {
    color: P.a.string, pill: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), children: P.a.node, className: P.a.string, cssModule: P.a.object,
  }; const At = { color: 'secondary', pill: !1, tag: 'span' }; const Ot = function (e) { const t = e.className; const n = e.cssModule; const r = e.color; const i = e.pill; let o = e.tag; const a = ie(e, ['className', 'cssModule', 'color', 'pill', 'tag']); const s = u(N()(t, 'badge', `badge-${r}`, !!i && 'badge-pill'), n); return a.href && o === 'span' && (o = 'a'), O.a.createElement(o, ne({}, a, { className: s })); }; Ot.propTypes = St, Ot.defaultProps = At; const It = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), inverse: P.a.bool, color: P.a.string, block: h(P.a.bool, 'Please use the props "body"'), body: P.a.bool, outline: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const Pt = { tag: 'div' }; const Mt = function (e) { const t = e.className; const n = e.cssModule; const r = e.color; const i = e.block; const o = e.body; const a = e.inverse; const s = e.outline; const l = e.tag; const c = ie(e, ['className', 'cssModule', 'color', 'block', 'body', 'inverse', 'outline', 'tag']); const p = u(N()(t, 'card', !!a && 'text-white', !(!i && !o) && 'card-body', !!r && `${s ? 'border' : 'bg'}-${r}`), n); return O.a.createElement(l, ne({}, c, { className: p })); }; Mt.propTypes = It, Mt.defaultProps = Pt; const Nt = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Dt = { tag: 'div' }; const Lt = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-group'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Lt.propTypes = Nt, Lt.defaultProps = Dt; const zt = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Rt = { tag: 'div' }; const jt = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-deck'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; jt.propTypes = zt, jt.defaultProps = Rt; const Bt = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Ft = { tag: 'div' }; const Ut = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-columns'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Ut.propTypes = Bt, Ut.defaultProps = Ft; const Vt = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const qt = { tag: 'div' }; const Ht = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-body'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Ht.propTypes = Vt, Ht.defaultProps = qt; const Wt = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), innerRef: P.a.oneOfType([P.a.object, P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object,
  }; const $t = { tag: 'a' }; const Gt = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = e.innerRef; const o = ie(e, ['className', 'cssModule', 'tag', 'innerRef']); const a = u(N()(t, 'card-link'), n); return O.a.createElement(r, ne({}, o, { ref: i, className: a })); }; Gt.propTypes = Wt, Gt.defaultProps = $t; const Zt = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Kt = { tag: 'div' }; const Xt = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-footer'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Xt.propTypes = Zt, Xt.defaultProps = Kt; const Yt = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Jt = { tag: 'div' }; const Qt = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-header'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Qt.propTypes = Yt, Qt.defaultProps = Jt; const en = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), top: P.a.bool, bottom: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const tn = { tag: 'img' }; const nn = function (e) { const t = e.className; const n = e.cssModule; const r = e.top; const i = e.bottom; const o = e.tag; const a = ie(e, ['className', 'cssModule', 'top', 'bottom', 'tag']); let s = 'card-img'; r && (s = 'card-img-top'), i && (s = 'card-img-bottom'); const l = u(N()(t, s), n); return O.a.createElement(o, ne({}, a, { className: l })); }; nn.propTypes = en, nn.defaultProps = tn; const rn = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const on = { tag: 'div' }; const an = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-img-overlay'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; an.propTypes = rn, an.defaultProps = on; var sn = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { startAnimation: !1 }, n.onEnter = n.onEnter.bind(n), n.onEntering = n.onEntering.bind(n), n.onExit = n.onExit.bind(n), n.onExiting = n.onExiting.bind(n), n.onExited = n.onExited.bind(n), n; } return re(t, e), ee(t, [{ key: 'onEnter', value(e, t) { this.setState({ startAnimation: !1 }), this.props.onEnter(e, t); } }, { key: 'onEntering', value(e, t) { const n = e.offsetHeight; return this.setState({ startAnimation: !0 }), this.props.onEntering(e, t), n; } }, { key: 'onExit', value(e) { this.setState({ startAnimation: !1 }), this.props.onExit(e); } }, { key: 'onExiting', value(e) { this.setState({ startAnimation: !0 }), e.dispatchEvent(new CustomEvent('slide.bs.carousel')), this.props.onExiting(e); } }, { key: 'onExited', value(e) { e.dispatchEvent(new CustomEvent('slid.bs.carousel')), this.props.onExited(e); } }, {
      key: 'render',
      value() {
        const e = this; const t = this.props; const n = t.in; const r = t.children; const i = t.cssModule; const o = t.slide; const a = t.tag; const s = t.className; const l = ie(t, ['in', 'children', 'cssModule', 'slide', 'tag', 'className']); return O.a.createElement(Tt, ne({}, l, {
          enter: o, exit: o, in: n, onEnter: this.onEnter, onEntering: this.onEntering, onExit: this.onExit, onExiting: this.onExiting, onExited: this.onExited,
        }), (t) => { const n = e.context.direction; const o = t === G.ENTERED || t === G.EXITING; const l = (t === G.ENTERING || t === G.EXITING) && e.state.startAnimation && (n === 'right' ? 'carousel-item-left' : 'carousel-item-right'); const c = t === G.ENTERING && (n === 'right' ? 'carousel-item-next' : 'carousel-item-prev'); const p = u(N()(s, 'carousel-item', o && 'active', l, c), i); return O.a.createElement(a, { className: p }, r); });
      },
    }]), t;
  }(O.a.Component)); sn.propTypes = ne({}, Tt.propTypes, {
    tag: P.a.oneOfType([P.a.func, P.a.string]), in: P.a.bool, cssModule: P.a.object, children: P.a.node, slide: P.a.bool, className: P.a.string,
  }), sn.defaultProps = ne({}, Tt.defaultProps, { tag: 'div', timeout: W.Carousel, slide: !0 }), sn.contextTypes = { direction: P.a.string }; var ln = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.handleKeyPress = n.handleKeyPress.bind(n), n.renderItems = n.renderItems.bind(n), n.hoverStart = n.hoverStart.bind(n), n.hoverEnd = n.hoverEnd.bind(n), n.state = { direction: 'right', indicatorClicked: !1 }, n; } return re(t, e), ee(t, [{ key: 'getChildContext', value() { return { direction: this.state.direction }; } }, { key: 'componentDidMount', value() { this.props.ride === 'carousel' && this.setInterval(), document.addEventListener('keyup', this.handleKeyPress); } }, { key: 'componentWillReceiveProps', value(e) { this.setInterval(e), this.props.activeIndex + 1 === e.activeIndex ? this.setState({ direction: 'right' }) : this.props.activeIndex - 1 === e.activeIndex ? this.setState({ direction: 'left' }) : this.props.activeIndex > e.activeIndex ? this.setState({ direction: this.state.indicatorClicked ? 'left' : 'right' }) : this.props.activeIndex !== e.activeIndex && this.setState({ direction: this.state.indicatorClicked ? 'right' : 'left' }), this.setState({ indicatorClicked: !1 }); } }, { key: 'componentWillUnmount', value() { this.clearInterval(), document.removeEventListener('keyup', this.handleKeyPress); } }, { key: 'setInterval', value: (function (e) { function t() { return e.apply(this, arguments); } return t.toString = function () { return e.toString(); }, t; }(function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props; this.clearInterval(), e.interval && (this.cycleInterval = setInterval(() => { e.next(); }, parseInt(e.interval, 10))); })) }, { key: 'clearInterval', value: (function (e) { function t() { return e.apply(this, arguments); } return t.toString = function () { return e.toString(); }, t; }(function () { clearInterval(this.cycleInterval); })) }, { key: 'hoverStart', value() { if (this.props.pause === 'hover' && this.clearInterval(), this.props.mouseEnter) { let e; (e = this.props).mouseEnter.apply(e, arguments); } } }, { key: 'hoverEnd', value() { if (this.props.pause === 'hover' && this.setInterval(), this.props.mouseLeave) { let e; (e = this.props).mouseLeave.apply(e, arguments); } } }, { key: 'handleKeyPress', value(e) { this.props.keyboard && (e.keyCode === 37 ? this.props.previous() : e.keyCode === 39 && this.props.next()); } }, { key: 'renderItems', value(e, t) { const n = this; const r = this.props.slide; return O.a.createElement('div', { role: 'listbox', className: t }, e.map((e, t) => { const i = t === n.props.activeIndex; return O.a.cloneElement(e, { in: i, slide: r }); })); } }, { key: 'render', value() { const e = this; const t = this.props; const n = t.children; const r = t.cssModule; const i = t.slide; const o = t.className; const a = u(N()(o, 'carousel', i && 'slide'), r); const s = u(N()('carousel-inner'), r); if (n.every(e => e.type === sn)) return O.a.createElement('div', { className: a, onMouseEnter: this.hoverStart, onMouseLeave: this.hoverEnd }, this.renderItems(n, s)); if (n[0] instanceof Array) { const l = n[0]; const c = n[1]; const p = n[2]; return O.a.createElement('div', { className: a, onMouseEnter: this.hoverStart, onMouseLeave: this.hoverEnd }, this.renderItems(l, s), c, p); } const f = n[0]; const h = function (t) { typeof f.props.onClickHandler === 'function' && e.setState({ indicatorClicked: !0 }, () => f.props.onClickHandler(t)); }; const d = O.a.cloneElement(f, { onClickHandler: h }); const m = n[1]; const g = n[2]; const y = n[3]; return O.a.createElement('div', { className: a, onMouseEnter: this.hoverStart, onMouseLeave: this.hoverEnd }, d, this.renderItems(m, s), g, y); } }]), t; }(O.a.Component)); ln.propTypes = {
    activeIndex: P.a.number, next: P.a.func.isRequired, previous: P.a.func.isRequired, keyboard: P.a.bool, pause: P.a.oneOf(['hover', !1]), ride: P.a.oneOf(['carousel']), interval: P.a.oneOfType([P.a.number, P.a.string, P.a.bool]), children: P.a.array, mouseEnter: P.a.func, mouseLeave: P.a.func, slide: P.a.bool, cssModule: P.a.object, className: P.a.string,
  }, ln.defaultProps = {
    interval: 5e3, pause: 'hover', keyboard: !0, slide: !0,
  }, ln.childContextTypes = { direction: P.a.string }; var un = function (e) {
    const t = e.direction; const n = e.onClickHandler; const r = e.cssModule; const i = e.directionText; const o = e.className; const a = u(N()(o, `carousel-control-${t}`), r); const s = u(N()(`carousel-control-${t}-icon`), r); const l = u(N()('sr-only'), r); return O.a.createElement('a', {
      className: a, role: 'button', tabIndex: '0', onClick(e) { e.preventDefault(), n(); },
    }, O.a.createElement('span', { className: s, 'aria-hidden': 'true' }), O.a.createElement('span', { className: l }, i || t));
  }; un.propTypes = {
    direction: P.a.oneOf(['prev', 'next']).isRequired, onClickHandler: P.a.func.isRequired, cssModule: P.a.object, directionText: P.a.string, className: P.a.string,
  }; var cn = function (e) { const t = e.items; const n = e.activeIndex; const r = e.cssModule; const i = e.onClickHandler; const o = e.className; const a = u(N()(o, 'carousel-indicators'), r); const s = t.map((e, t) => { const o = u(N()({ active: n === t }), r); return O.a.createElement('li', { key: `${e.key || e.src}${e.caption}${e.altText}`, onClick(e) { e.preventDefault(), i(t); }, className: o }); }); return O.a.createElement('ol', { className: a }, s); }; cn.propTypes = {
    items: P.a.array.isRequired, activeIndex: P.a.number.isRequired, cssModule: P.a.object, onClickHandler: P.a.func.isRequired, className: P.a.string,
  }; const pn = function (e) { const t = e.captionHeader; const n = e.captionText; const r = e.cssModule; const i = e.className; const o = u(N()(i, 'carousel-caption', 'd-none', 'd-md-block'), r); return O.a.createElement('div', { className: o }, O.a.createElement('h3', null, t), O.a.createElement('p', null, n)); }; pn.propTypes = {
    captionHeader: P.a.string, captionText: P.a.string.isRequired, cssModule: P.a.object, className: P.a.string,
  }; const fn = {
    items: P.a.array.isRequired, indicators: P.a.bool, controls: P.a.bool, autoPlay: P.a.bool, activeIndex: P.a.number, next: P.a.func, previous: P.a.func, goToIndex: P.a.func,
  }; const hn = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.animating = !1, n.state = { activeIndex: 0 }, n.next = n.next.bind(n), n.previous = n.previous.bind(n), n.goToIndex = n.goToIndex.bind(n), n.onExiting = n.onExiting.bind(n), n.onExited = n.onExited.bind(n), n; } return re(t, e), ee(t, [{ key: 'onExiting', value() { this.animating = !0; } }, { key: 'onExited', value() { this.animating = !1; } }, { key: 'next', value() { if (!this.animating) { const e = this.state.activeIndex === this.props.items.length - 1 ? 0 : this.state.activeIndex + 1; this.setState({ activeIndex: e }); } } }, { key: 'previous', value() { if (!this.animating) { const e = this.state.activeIndex === 0 ? this.props.items.length - 1 : this.state.activeIndex - 1; this.setState({ activeIndex: e }); } } }, { key: 'goToIndex', value(e) { this.animating || this.setState({ activeIndex: e }); } }, {
      key: 'render',
      value() {
        const e = this; const t = this.props; const n = t.autoPlay; const r = t.indicators; const i = t.controls; const o = t.items; const a = t.goToIndex; const s = ie(t, ['autoPlay', 'indicators', 'controls', 'items', 'goToIndex']); const l = this.state.activeIndex; const u = o.map(t => O.a.createElement(sn, { onExiting: e.onExiting, onExited: e.onExited, key: t.src }, O.a.createElement('img', { className: 'd-block w-100', src: t.src, alt: t.altText }), O.a.createElement(pn, { captionText: t.caption, captionHeader: t.header || t.caption }))); return O.a.createElement(ln, ne({
          activeIndex: l, next: this.next, previous: this.previous, ride: n ? 'carousel' : void 0,
        }, s), r && O.a.createElement(cn, { items: o, activeIndex: s.activeIndex || l, onClickHandler: a || this.goToIndex }), u, i && O.a.createElement(un, { direction: 'prev', directionText: 'Previous', onClickHandler: s.previous || this.previous }), i && O.a.createElement(un, { direction: 'next', directionText: 'Next', onClickHandler: s.next || this.next }));
      },
    }]), t;
  }(A.Component)); hn.propTypes = fn, hn.defaultProps = { controls: !0, indicators: !0, autoPlay: !0 }; const dn = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const mn = { tag: 'h6' }; const gn = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-subtitle'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; gn.propTypes = dn, gn.defaultProps = mn; const yn = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const vn = { tag: 'p' }; const _n = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-text'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; _n.propTypes = yn, _n.defaultProps = vn; const bn = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const xn = { tag: 'h5' }; const wn = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'card-title'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; wn.propTypes = bn, wn.defaultProps = xn; const En = {
    className: P.a.string, id: P.a.oneOfType([P.a.string, P.a.number]).isRequired, type: P.a.string.isRequired, label: P.a.string, inline: P.a.bool, valid: P.a.bool, invalid: P.a.bool, bsSize: P.a.string, cssModule: P.a.object, children: P.a.oneOfType([P.a.node, P.a.array, P.a.func]),
  }; w.propTypes = En; const Tn = {
    children: P.a.node.isRequired, className: P.a.string, placement: P.a.string, placementPrefix: P.a.string, hideArrow: P.a.bool, tag: P.a.string, isOpen: P.a.bool.isRequired, cssModule: P.a.object, offset: P.a.oneOfType([P.a.string, P.a.number]), fallbackPlacement: P.a.oneOfType([P.a.string, P.a.array]), flip: P.a.bool, container: P.a.oneOfType([P.a.string, P.a.func, d]), target: P.a.oneOfType([P.a.string, P.a.func, d]).isRequired, modifiers: P.a.object,
  }; const kn = {
    placement: 'auto', hideArrow: !1, isOpen: !1, offset: 0, fallbackPlacement: 'flip', flip: !0, container: 'body', modifiers: {},
  }; const Cn = { popperManager: P.a.object.isRequired }; const Sn = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.handlePlacementChange = n.handlePlacementChange.bind(n), n.setTargetNode = n.setTargetNode.bind(n), n.getTargetNode = n.getTargetNode.bind(n), n.state = {}, n; } return re(t, e), ee(t, [{ key: 'getChildContext', value() { return { popperManager: { setTargetNode: this.setTargetNode, getTargetNode: this.getTargetNode } }; } }, { key: 'componentDidMount', value() { this.handleProps(); } }, { key: 'componentDidUpdate', value(e) { this.props.isOpen !== e.isOpen ? this.handleProps() : this._element && this.renderIntoSubtree(); } }, { key: 'componentWillUnmount', value() { this.hide(); } }, { key: 'setTargetNode', value(e) { this.targetNode = e; } }, { key: 'getTargetNode', value() { return this.targetNode; } }, { key: 'getContainerNode', value() { return y(this.props.container); } }, { key: 'handlePlacementChange', value(e) { return this.state.placement !== e.placement && this.setState({ placement: e.placement }), e; } }, { key: 'handleProps', value() { this.props.container !== 'inline' && (this.props.isOpen ? this.show() : this.hide()); } }, { key: 'hide', value() { this._element && (this.getContainerNode().removeChild(this._element), B.a.unmountComponentAtNode(this._element), this._element = null); } }, { key: 'show', value() { this._element = document.createElement('div'), this.getContainerNode().appendChild(this._element), this.renderIntoSubtree(), this._element.childNodes && this._element.childNodes[0] && this._element.childNodes[0].focus && this._element.childNodes[0].focus(); } }, { key: 'renderIntoSubtree', value() { B.a.unstable_renderSubtreeIntoContainer(this, this.renderChildren(), this._element); } }, { key: 'renderChildren', value() { const e = this.props; const t = e.cssModule; const n = e.children; const r = (e.isOpen, e.flip); const i = (e.target, e.offset); const o = e.fallbackPlacement; const a = e.placementPrefix; const s = e.hideArrow; const l = e.className; const c = e.tag; const p = (e.container, e.modifiers); const f = ie(e, ['cssModule', 'children', 'isOpen', 'flip', 'target', 'offset', 'fallbackPlacement', 'placementPrefix', 'hideArrow', 'className', 'tag', 'container', 'modifiers']); const h = u('arrow', t); const d = (this.state.placement || f.placement).split('-')[0]; const m = u(N()(l, a ? `${a}-${d}` : d), this.props.cssModule); const g = ne({ offset: { offset: i }, flip: { enabled: r, behavior: o }, update: { enabled: !0, order: 950, fn: this.handlePlacementChange } }, p); return O.a.createElement(F.c, ne({ modifiers: g }, f, { component: c, className: m, 'x-placement': this.state.placement || f.placement }), n, !s && O.a.createElement(F.a, { className: h })); } }, { key: 'render', value() { return this.setTargetNode(y(this.props.target)), this.props.container === 'inline' && this.props.isOpen ? this.renderChildren() : null; } }]), t; }(O.a.Component)); Sn.propTypes = Tn, Sn.defaultProps = kn, Sn.childContextTypes = Cn; const An = function (e, t) { return t.popperManager.setTargetNode(y(e.target)), null; }; An.contextTypes = { popperManager: P.a.object.isRequired }, An.propTypes = { target: P.a.oneOfType([P.a.string, P.a.func, d]).isRequired }; const On = {
    placement: P.a.oneOf(K), target: P.a.oneOfType([P.a.string, P.a.func, d]).isRequired, container: P.a.oneOfType([P.a.string, P.a.func, d]), isOpen: P.a.bool, disabled: P.a.bool, hideArrow: P.a.bool, className: P.a.string, innerClassName: P.a.string, placementPrefix: P.a.string, cssModule: P.a.object, toggle: P.a.func, delay: P.a.oneOfType([P.a.shape({ show: P.a.number, hide: P.a.number }), P.a.number]), modifiers: P.a.object, offset: P.a.oneOfType([P.a.string, P.a.number]),
  }; const In = { show: 0, hide: 0 }; const Pn = {
    isOpen: !1, hideArrow: !1, placement: 'right', placementPrefix: 'bs-popover', delay: In, toggle() {},
  }; const Mn = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.addTargetEvents = n.addTargetEvents.bind(n), n.handleDocumentClick = n.handleDocumentClick.bind(n), n.removeTargetEvents = n.removeTargetEvents.bind(n), n.getRef = n.getRef.bind(n), n.toggle = n.toggle.bind(n), n.show = n.show.bind(n), n.hide = n.hide.bind(n), n; } return re(t, e), ee(t, [{ key: 'componentDidMount', value() { this._target = y(this.props.target), this.handleProps(); } }, { key: 'componentDidUpdate', value() { this.handleProps(); } }, { key: 'componentWillUnmount', value() { this.clearShowTimeout(), this.clearHideTimeout(), this.removeTargetEvents(); } }, { key: 'getRef', value(e) { this._popover = e; } }, { key: 'getDelay', value(e) { const t = this.props.delay; return (typeof t === 'undefined' ? 'undefined' : J(t)) === 'object' ? isNaN(t[e]) ? In[e] : t[e] : t; } }, { key: 'handleProps', value() { this.props.isOpen ? this.show() : this.hide(); } }, { key: 'show', value() { this.clearHideTimeout(), this.addTargetEvents(), this.props.isOpen || (this.clearShowTimeout(), this._showTimeout = setTimeout(this.toggle, this.getDelay('show'))); } }, { key: 'hide', value() { this.clearShowTimeout(), this.removeTargetEvents(), this.props.isOpen && (this.clearHideTimeout(), this._hideTimeout = setTimeout(this.toggle, this.getDelay('hide'))); } }, { key: 'clearShowTimeout', value() { clearTimeout(this._showTimeout), this._showTimeout = void 0; } }, { key: 'clearHideTimeout', value() { clearTimeout(this._hideTimeout), this._hideTimeout = void 0; } }, { key: 'handleDocumentClick', value(e) { e.target === this._target || this._target.contains(e.target) || e.target === this._popover || this._popover && this._popover.contains(e.target) || (this._hideTimeout && this.clearHideTimeout(), this.props.isOpen && this.toggle(e)); } }, { key: 'addTargetEvents', value() { const e = this; ['click', 'touchstart'].forEach(t => document.addEventListener(t, e.handleDocumentClick, !0)); } }, { key: 'removeTargetEvents', value() { const e = this; ['click', 'touchstart'].forEach(t => document.removeEventListener(t, e.handleDocumentClick, !0)); } }, { key: 'toggle', value(e) { return this.props.disabled ? e && e.preventDefault() : this.props.toggle(e); } }, {
      key: 'render',
      value() {
        if (!this.props.isOpen) return null; const e = c(this.props, Object.keys(On)); const t = u(N()('popover-inner', this.props.innerClassName), this.props.cssModule); const n = u(N()('popover', 'show', this.props.className), this.props.cssModule); return O.a.createElement(Sn, {
          className: n, target: this.props.target, isOpen: this.props.isOpen, hideArrow: this.props.hideArrow, placement: this.props.placement, placementPrefix: this.props.placementPrefix, container: this.props.container, modifiers: this.props.modifiers, offset: this.props.offset,
        }, O.a.createElement('div', ne({}, e, { className: t, ref: this.getRef })));
      },
    }]), t;
  }(O.a.Component)); Mn.propTypes = On, Mn.defaultProps = Pn; const Nn = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Dn = { tag: 'h3' }; const Ln = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'popover-header'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Ln.propTypes = Nn, Ln.defaultProps = Dn; const zn = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Rn = { tag: 'div' }; const jn = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'popover-body'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; jn.propTypes = zn, jn.defaultProps = Rn; const Bn = {
    children: P.a.node, bar: P.a.bool, multi: P.a.bool, tag: P.a.string, value: P.a.oneOfType([P.a.string, P.a.number]), max: P.a.oneOfType([P.a.string, P.a.number]), animated: P.a.bool, striped: P.a.bool, color: P.a.string, className: P.a.string, barClassName: P.a.string, cssModule: P.a.object,
  }; const Fn = { tag: 'div', value: 0, max: 100 }; const Un = function (e) {
    const t = e.children; const n = e.className; const r = e.barClassName; const i = e.cssModule; const o = e.value; const a = e.max; const s = e.animated; const l = e.striped; const c = e.color; const p = e.bar; const f = e.multi; const h = e.tag; const d = ie(e, ['children', 'className', 'barClassName', 'cssModule', 'value', 'max', 'animated', 'striped', 'color', 'bar', 'multi', 'tag']); const m = V()(o) / V()(a) * 100; const g = u(N()(n, 'progress'), i); const y = u(N()('progress-bar', p ? n || r : r, s ? 'progress-bar-animated' : null, c ? `bg-${c}` : null, l || s ? 'progress-bar-striped' : null), i); const v = f ? t : O.a.createElement('div', {
      className: y, style: { width: `${m}%` }, role: 'progressbar', 'aria-valuenow': o, 'aria-valuemin': '0', 'aria-valuemax': a, children: t,
    }); return p ? v : O.a.createElement(h, ne({}, d, { className: g, children: v }));
  }; Un.propTypes = Bn, Un.defaultProps = Fn; const Vn = { children: P.a.node.isRequired, node: P.a.any }; const qn = (function (e) { function t() { return Q(this, t), oe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments)); } return re(t, e), ee(t, [{ key: 'componentWillUnmount', value() { this.defaultNode && document.body.removeChild(this.defaultNode), this.defaultNode = null; } }, { key: 'render', value() { return X ? (this.props.node || this.defaultNode || (this.defaultNode = document.createElement('div'), document.body.appendChild(this.defaultNode)), B.a.createPortal(this.props.children, this.props.node || this.defaultNode)) : null; } }]), t; }(O.a.Component)); qn.propTypes = Vn; const Hn = P.a.shape(x.propTypes); const Wn = {
    isOpen: P.a.bool, autoFocus: P.a.bool, centered: P.a.bool, size: P.a.string, toggle: P.a.func, keyboard: P.a.bool, role: P.a.string, labelledBy: P.a.string, backdrop: P.a.oneOfType([P.a.bool, P.a.oneOf(['static'])]), onEnter: P.a.func, onExit: P.a.func, onOpened: P.a.func, onClosed: P.a.func, children: P.a.node, className: P.a.string, wrapClassName: P.a.string, modalClassName: P.a.string, backdropClassName: P.a.string, contentClassName: P.a.string, external: P.a.node, fade: P.a.bool, cssModule: P.a.object, zIndex: P.a.oneOfType([P.a.number, P.a.string]), backdropTransition: Hn, modalTransition: Hn,
  }; const $n = Object.keys(Wn); const Gn = {
    isOpen: !1, autoFocus: !0, centered: !1, role: 'dialog', backdrop: !0, keyboard: !0, zIndex: 1050, fade: !0, onOpened: E, onClosed: E, modalTransition: { timeout: W.Modal }, backdropTransition: { mountOnEnter: !0, timeout: W.Fade },
  }; const Zn = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n._element = null, n._originalBodyPadding = null, n.handleBackdropMouseDown = n.handleBackdropMouseDown.bind(n), n.handleBackdropMouseUp = n.handleBackdropMouseUp.bind(n), n.handleEscape = n.handleEscape.bind(n), n.onOpened = n.onOpened.bind(n), n.onClosed = n.onClosed.bind(n), n.state = { isOpen: e.isOpen }, e.isOpen && n.init(), n; } return re(t, e), ee(t, [{ key: 'componentDidMount', value() { this.props.onEnter && this.props.onEnter(), this.state.isOpen && this.props.autoFocus && this.setFocus(), this._isMounted = !0; } }, { key: 'componentWillReceiveProps', value(e) { e.isOpen && !this.props.isOpen && this.setState({ isOpen: e.isOpen }); } }, { key: 'componentWillUpdate', value(e, t) { t.isOpen && !this.state.isOpen && this.init(); } }, { key: 'componentDidUpdate', value(e, t) { this.props.autoFocus && this.state.isOpen && !t.isOpen && this.setFocus(), this._element && e.zIndex !== this.props.zIndex && (this._element.style.zIndex = this.props.zIndex); } }, { key: 'componentWillUnmount', value() { this.props.onExit && this.props.onExit(), this.state.isOpen && this.destroy(), this._isMounted = !1; } }, { key: 'onOpened', value(e, t) { this.props.onOpened(), (this.props.modalTransition.onEntered || E)(e, t); } }, { key: 'onClosed', value(e) { this.props.onClosed(), (this.props.modalTransition.onExited || E)(e), this.destroy(), this._isMounted && this.setState({ isOpen: !1 }); } }, { key: 'setFocus', value() { this._dialog && this._dialog.parentNode && typeof this._dialog.parentNode.focus === 'function' && this._dialog.parentNode.focus(); } }, { key: 'handleBackdropMouseDown', value(e) { this._mouseDownElement = e.target; } }, { key: 'handleBackdropMouseUp', value(e) { if (e.target === this._mouseDownElement) { if (e.stopPropagation(), !this.props.isOpen || !0 !== this.props.backdrop) return; const t = this._dialog; e.target && !t.contains(e.target) && this.props.toggle && this.props.toggle(e); } } }, { key: 'handleEscape', value(e) { this.props.isOpen && this.props.keyboard && e.keyCode === 27 && this.props.toggle && this.props.toggle(e); } }, { key: 'init', value() { this._element = document.createElement('div'), this._element.setAttribute('tabindex', '-1'), this._element.style.position = 'relative', this._element.style.zIndex = this.props.zIndex, this._originalBodyPadding = a(), s(), document.body.appendChild(this._element), this.bodyClassAdded || (document.body.className = N()(document.body.className, u('modal-open', this.props.cssModule)), this.bodyClassAdded = !0); } }, { key: 'destroy', value() { if (this._element && (document.body.removeChild(this._element), this._element = null), this.bodyClassAdded) { const e = u('modal-open', this.props.cssModule); const t = new RegExp(`(^| )${e}( |$)`); document.body.className = document.body.className.replace(t, ' ').trim(), this.bodyClassAdded = !1; }i(this._originalBodyPadding); } }, { key: 'renderModalDialog', value() { let e; const t = this; const n = c(this.props, $n); return O.a.createElement('div', ne({}, n, { className: u(N()('modal-dialog', this.props.className, (e = {}, te(e, `modal-${this.props.size}`, this.props.size), te(e, 'modal-dialog-centered', this.props.centered), e)), this.props.cssModule), role: 'document', ref(e) { t._dialog = e; } }), O.a.createElement('div', { className: u(N()('modal-content', this.props.contentClassName), this.props.cssModule) }, this.props.children)); } }, {
      key: 'render',
      value() {
        if (this.state.isOpen) {
          const e = this.props; const t = e.wrapClassName; const n = e.modalClassName; const r = e.backdropClassName; const i = e.cssModule; const o = e.isOpen; const a = e.backdrop; const s = e.role; const l = e.labelledBy; const c = e.external; const p = {
            onMouseDown: this.handleBackdropMouseDown, onMouseUp: this.handleBackdropMouseUp, onKeyUp: this.handleEscape, style: { display: 'block' }, 'aria-labelledby': l, role: s, tabIndex: '-1',
          }; const f = this.props.fade; const h = ne({}, x.defaultProps, this.props.modalTransition, { baseClass: f ? this.props.modalTransition.baseClass : '', timeout: f ? this.props.modalTransition.timeout : 0 }); const d = ne({}, x.defaultProps, this.props.backdropTransition, { baseClass: f ? this.props.backdropTransition.baseClass : '', timeout: f ? this.props.backdropTransition.timeout : 0 }); return O.a.createElement(qn, { node: this._element }, O.a.createElement('div', { className: u(t) }, O.a.createElement(x, ne({}, p, h, {
            in: o, onEntered: this.onOpened, onExited: this.onClosed, cssModule: i, className: u(N()('modal', n), i),
          }), c, this.renderModalDialog()), O.a.createElement(x, ne({}, d, { in: o && !!a, cssModule: i, className: u(N()('modal-backdrop', r), i) }))));
        } return null;
      },
    }]), t;
  }(O.a.Component)); Zn.propTypes = Wn, Zn.defaultProps = Gn; const Kn = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), wrapTag: P.a.oneOfType([P.a.func, P.a.string]), toggle: P.a.func, className: P.a.string, cssModule: P.a.object, children: P.a.node, closeAriaLabel: P.a.string,
  }; const Xn = { tag: 'h5', wrapTag: 'div', closeAriaLabel: 'Close' }; const Yn = function (e) {
    let t = void 0; const n = e.className; const r = e.cssModule; const i = e.children; const o = e.toggle; const a = e.tag; const s = e.wrapTag; const l = e.closeAriaLabel; const c = ie(e, ['className', 'cssModule', 'children', 'toggle', 'tag', 'wrapTag', 'closeAriaLabel']); const p = u(N()(n, 'modal-header'), r); return o && (t = O.a.createElement('button', {
      type: 'button', onClick: o, className: u('close', r), 'aria-label': l,
    }, O.a.createElement('span', { 'aria-hidden': 'true' }, String.fromCharCode(215)))), O.a.createElement(s, ne({}, c, { className: p }), O.a.createElement(a, { className: u('modal-title', r) }, i), t);
  }; Yn.propTypes = Kn, Yn.defaultProps = Xn; const Jn = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Qn = { tag: 'div' }; const er = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'modal-body'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; er.propTypes = Jn, er.defaultProps = Qn; const tr = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const nr = { tag: 'div' }; const rr = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'modal-footer'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; rr.propTypes = tr, rr.defaultProps = nr; const ir = {
    placement: P.a.oneOf(K), target: P.a.oneOfType([P.a.string, P.a.func, d]).isRequired, container: P.a.oneOfType([P.a.string, P.a.func, d]), isOpen: P.a.bool, disabled: P.a.bool, hideArrow: P.a.bool, className: P.a.string, innerClassName: P.a.string, cssModule: P.a.object, toggle: P.a.func, autohide: P.a.bool, placementPrefix: P.a.string, delay: P.a.oneOfType([P.a.shape({ show: P.a.number, hide: P.a.number }), P.a.number]), modifiers: P.a.object, offset: P.a.oneOfType([P.a.string, P.a.number]),
  }; const or = { show: 0, hide: 250 }; const ar = {
    isOpen: !1, hideArrow: !1, placement: 'top', placementPrefix: 'bs-tooltip', delay: or, autohide: !0, toggle() {},
  }; const sr = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.addTargetEvents = n.addTargetEvents.bind(n), n.handleDocumentClick = n.handleDocumentClick.bind(n), n.removeTargetEvents = n.removeTargetEvents.bind(n), n.toggle = n.toggle.bind(n), n.onMouseOverTooltip = n.onMouseOverTooltip.bind(n), n.onMouseLeaveTooltip = n.onMouseLeaveTooltip.bind(n), n.onMouseOverTooltipContent = n.onMouseOverTooltipContent.bind(n), n.onMouseLeaveTooltipContent = n.onMouseLeaveTooltipContent.bind(n), n.show = n.show.bind(n), n.hide = n.hide.bind(n), n.onEscKeyDown = n.onEscKeyDown.bind(n), n; } return re(t, e), ee(t, [{ key: 'componentDidMount', value() { this._target = y(this.props.target), this.addTargetEvents(); } }, { key: 'componentWillUnmount', value() { this.removeTargetEvents(); } }, { key: 'onMouseOverTooltip', value() { this._hideTimeout && this.clearHideTimeout(), this._showTimeout = setTimeout(this.show, this.getDelay('show')); } }, { key: 'onMouseLeaveTooltip', value() { this._showTimeout && this.clearShowTimeout(), this._hideTimeout = setTimeout(this.hide, this.getDelay('hide')); } }, { key: 'onMouseOverTooltipContent', value() { this.props.autohide || this._hideTimeout && this.clearHideTimeout(); } }, { key: 'onMouseLeaveTooltipContent', value() { this.props.autohide || (this._showTimeout && this.clearShowTimeout(), this._hideTimeout = setTimeout(this.hide, this.getDelay('hide'))); } }, { key: 'onEscKeyDown', value(e) { e.key === 'Escape' && this.hide(); } }, { key: 'getDelay', value(e) { const t = this.props.delay; return (typeof t === 'undefined' ? 'undefined' : J(t)) === 'object' ? isNaN(t[e]) ? or[e] : t[e] : t; } }, { key: 'show', value() { this.props.isOpen || (this.clearShowTimeout(), this.toggle()); } }, { key: 'hide', value() { this.props.isOpen && (this.clearHideTimeout(), this.toggle()); } }, { key: 'clearShowTimeout', value() { clearTimeout(this._showTimeout), this._showTimeout = void 0; } }, { key: 'clearHideTimeout', value() { clearTimeout(this._hideTimeout), this._hideTimeout = void 0; } }, { key: 'handleDocumentClick', value(e) { (e.target === this._target || this._target.contains(e.target)) && (this._hideTimeout && this.clearHideTimeout(), this.props.isOpen || this.toggle()); } }, { key: 'addTargetEvents', value() { const e = this; this._target.addEventListener('mouseover', this.onMouseOverTooltip, !0), this._target.addEventListener('mouseout', this.onMouseLeaveTooltip, !0), this._target.addEventListener('keydown', this.onEscKeyDown, !0), this._target.addEventListener('focusin', this.show, !0), this._target.addEventListener('focusout', this.hide, !0), ['click', 'touchstart'].forEach(t => document.addEventListener(t, e.handleDocumentClick, !0)); } }, { key: 'removeTargetEvents', value() { const e = this; this._target.removeEventListener('mouseover', this.onMouseOverTooltip, !0), this._target.removeEventListener('mouseout', this.onMouseLeaveTooltip, !0), this._target.addEventListener('keydown', this.onEscKeyDown, !0), this._target.addEventListener('focusin', this.show, !0), this._target.addEventListener('focusout', this.hide, !0), ['click', 'touchstart'].forEach(t => document.removeEventListener(t, e.handleDocumentClick, !0)); } }, { key: 'toggle', value(e) { return this.props.disabled ? e && e.preventDefault() : this.props.toggle(); } }, {
      key: 'render',
      value() {
        if (!this.props.isOpen) return null; const e = c(this.props, Object.keys(ir)); const t = u(N()('tooltip-inner', this.props.innerClassName), this.props.cssModule); const n = u(N()('tooltip', 'show', this.props.className), this.props.cssModule); return O.a.createElement(Sn, {
          className: n, target: this.props.target, isOpen: this.props.isOpen, hideArrow: this.props.hideArrow, placement: this.props.placement, placementPrefix: this.props.placementPrefix, container: this.props.container, modifiers: this.props.modifiers, offset: this.props.offset,
        }, O.a.createElement('div', ne({}, e, {
          className: t, role: 'tooltip', 'aria-hidden': this.props.isOpen, onMouseOver: this.onMouseOverTooltipContent, onMouseLeave: this.onMouseLeaveTooltipContent, onKeyDown: this.onEscKeyDown,
        })));
      },
    }]), t;
  }(O.a.Component)); sr.propTypes = ir, sr.defaultProps = ar; const lr = {
    className: P.a.string, cssModule: P.a.object, size: P.a.string, bordered: P.a.bool, borderless: P.a.bool, striped: P.a.bool, inverse: h(P.a.bool, 'Please use the prop "dark"'), dark: P.a.bool, hover: P.a.bool, responsive: P.a.oneOfType([P.a.bool, P.a.string]), tag: P.a.oneOfType([P.a.func, P.a.string]), responsiveTag: P.a.oneOfType([P.a.func, P.a.string]),
  }; const ur = { tag: 'table', responsiveTag: 'div' }; const cr = function (e) { const t = e.className; const n = e.cssModule; const r = e.size; const i = e.bordered; const o = e.borderless; const a = e.striped; const s = e.inverse; const l = e.dark; const c = e.hover; const p = e.responsive; const f = e.tag; const h = e.responsiveTag; const d = ie(e, ['className', 'cssModule', 'size', 'bordered', 'borderless', 'striped', 'inverse', 'dark', 'hover', 'responsive', 'tag', 'responsiveTag']); const m = u(N()(t, 'table', !!r && `table-${r}`, !!i && 'table-bordered', !!o && 'table-borderless', !!a && 'table-striped', !(!l && !s) && 'table-dark', !!c && 'table-hover'), n); const g = O.a.createElement(f, ne({}, d, { className: m })); if (p) { const y = !0 === p ? 'table-responsive' : `table-responsive-${p}`; return O.a.createElement(h, { className: y }, g); } return g; }; cr.propTypes = lr, cr.defaultProps = ur; const pr = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), flush: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const fr = { tag: 'ul' }; const hr = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = e.flush; const o = ie(e, ['className', 'cssModule', 'tag', 'flush']); const a = u(N()(t, 'list-group', !!i && 'list-group-flush'), n); return O.a.createElement(r, ne({}, o, { className: a })); }; hr.propTypes = pr, hr.defaultProps = fr; const dr = {
    children: P.a.node, inline: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), innerRef: P.a.oneOfType([P.a.object, P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object,
  }; const mr = { tag: 'form' }; const gr = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.getRef = n.getRef.bind(n), n.submit = n.submit.bind(n), n; } return re(t, e), ee(t, [{ key: 'getRef', value(e) { this.props.innerRef && this.props.innerRef(e), this.ref = e; } }, { key: 'submit', value() { this.ref && this.ref.submit(); } }, { key: 'render', value() { const e = this.props; const t = e.className; const n = e.cssModule; const r = e.inline; const i = e.tag; const o = e.innerRef; const a = ie(e, ['className', 'cssModule', 'inline', 'tag', 'innerRef']); const s = u(N()(t, !!r && 'form-inline'), n); return O.a.createElement(i, ne({}, a, { ref: o, className: s })); } }]), t; }(A.Component)); gr.propTypes = dr, gr.defaultProps = mr; const yr = {
    children: P.a.node, tag: P.a.string, className: P.a.string, cssModule: P.a.object, valid: P.a.bool,
  }; const vr = { tag: 'div', valid: void 0 }; const _r = function (e) { const t = e.className; const n = e.cssModule; const r = e.valid; const i = e.tag; const o = ie(e, ['className', 'cssModule', 'valid', 'tag']); const a = u(N()(t, r ? 'valid-feedback' : 'invalid-feedback'), n); return O.a.createElement(i, ne({}, o, { className: a })); }; _r.propTypes = yr, _r.defaultProps = vr; const br = {
    children: P.a.node, row: P.a.bool, check: P.a.bool, inline: P.a.bool, disabled: P.a.bool, tag: P.a.string, className: P.a.string, cssModule: P.a.object,
  }; const xr = { tag: 'div' }; const wr = function (e) { const t = e.className; const n = e.cssModule; const r = e.row; const i = e.disabled; const o = e.check; const a = e.inline; const s = e.tag; const l = ie(e, ['className', 'cssModule', 'row', 'disabled', 'check', 'inline', 'tag']); const c = u(N()(t, !!r && 'row', o ? 'form-check' : 'form-group', !(!o || !a) && 'form-check-inline', !(!o || !i) && 'disabled'), n); return O.a.createElement(s, ne({}, l, { className: c })); }; wr.propTypes = br, wr.defaultProps = xr; const Er = {
    children: P.a.node, inline: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), color: P.a.string, className: P.a.string, cssModule: P.a.object,
  }; const Tr = { tag: 'small', color: 'muted' }; const kr = function (e) { const t = e.className; const n = e.cssModule; const r = e.inline; const i = e.color; const o = e.tag; const a = ie(e, ['className', 'cssModule', 'inline', 'color', 'tag']); const s = u(N()(t, !r && 'form-text', !!i && `text-${i}`), n); return O.a.createElement(o, ne({}, a, { className: s })); }; kr.propTypes = Er, kr.defaultProps = Tr; const Cr = {
    children: P.a.node, type: P.a.string, size: P.a.string, bsSize: P.a.string, state: h(P.a.string, 'Please use the props "valid" and "invalid" to indicate the state.'), valid: P.a.bool, invalid: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), innerRef: P.a.oneOfType([P.a.object, P.a.func, P.a.string]), static: h(P.a.bool, 'Please use the prop "plaintext"'), plaintext: P.a.bool, addon: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const Sr = { type: 'text' }; const Ar = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.getRef = n.getRef.bind(n), n.focus = n.focus.bind(n), n; } return re(t, e), ee(t, [{ key: 'getRef', value(e) { this.props.innerRef && this.props.innerRef(e), this.ref = e; } }, { key: 'focus', value() { this.ref && this.ref.focus(); } }, { key: 'render', value() { const e = this.props; const t = e.className; const n = e.cssModule; const r = e.type; let i = e.bsSize; const o = e.state; let a = e.valid; let s = e.invalid; const l = e.tag; const c = e.addon; const p = e.static; const h = e.plaintext; const d = e.innerRef; const m = ie(e, ['className', 'cssModule', 'type', 'bsSize', 'state', 'valid', 'invalid', 'tag', 'addon', 'static', 'plaintext', 'innerRef']); const g = ['radio', 'checkbox'].indexOf(r) > -1; const y = new RegExp('\\D', 'g'); const v = r === 'file'; const _ = r === 'textarea'; const b = r === 'select'; let x = l || (b || _ ? r : 'input'); let w = 'form-control'; h || p ? (w += '-plaintext', x = l || 'p') : v ? w += '-file' : g && (w = c ? null : 'form-check-input'), o && typeof a === 'undefined' && typeof s === 'undefined' && (o === 'danger' ? s = !0 : o === 'success' && (a = !0)), m.size && y.test(m.size) && (f('Please use the prop "bsSize" instead of the "size" to bootstrap\'s input sizing.'), i = m.size, delete m.size); const E = u(N()(t, s && 'is-invalid', a && 'is-valid', !!i && `form-control-${i}`, w), n); return (x === 'input' || l && typeof l === 'function') && (m.type = r), !m.children || h || p || r === 'select' || typeof x !== 'string' || x === 'select' || (f(`Input with a type of "${r}" cannot have children. Please use "value"/"defaultValue" instead.`), delete m.children), O.a.createElement(x, ne({}, m, { ref: d, className: E })); } }]), t; }(O.a.Component)); Ar.propTypes = Cr, Ar.defaultProps = Sr; const Or = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), size: P.a.string, className: P.a.string, cssModule: P.a.object,
  }; const Ir = { tag: 'div' }; const Pr = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = e.size; const o = ie(e, ['className', 'cssModule', 'tag', 'size']); const a = u(N()(t, 'input-group', i ? `input-group-${i}` : null), n); return O.a.createElement(r, ne({}, o, { className: a })); }; Pr.propTypes = Or, Pr.defaultProps = Ir; const Mr = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object }; const Nr = { tag: 'span' }; const Dr = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'input-group-text'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Dr.propTypes = Mr, Dr.defaultProps = Nr; const Lr = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), addonType: P.a.oneOf(['prepend', 'append']).isRequired, children: P.a.node, className: P.a.string, cssModule: P.a.object,
  }; const zr = { tag: 'div' }; const Rr = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = e.addonType; const o = e.children; const a = ie(e, ['className', 'cssModule', 'tag', 'addonType', 'children']); const s = u(N()(t, `input-group-${i}`), n); return typeof o === 'string' ? O.a.createElement(r, ne({}, a, { className: s }), O.a.createElement(Dr, { children: o })) : O.a.createElement(r, ne({}, a, { className: s, children: o })); }; Rr.propTypes = Lr, Rr.defaultProps = zr; const jr = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), addonType: P.a.oneOf(['prepend', 'append']).isRequired, children: P.a.node, groupClassName: P.a.string, groupAttributes: P.a.object, className: P.a.string, cssModule: P.a.object,
  }; (function (e) { f('The "InputGroupButton" component has been deprecated.\nPlease use component "InputGroupAddon".'); const t = e.children; const n = e.groupClassName; const r = e.groupAttributes; const i = ie(e, ['children', 'groupClassName', 'groupAttributes']); if (typeof t === 'string') { const o = i.cssModule; const a = i.tag; const s = i.addonType; const l = ie(i, ['cssModule', 'tag', 'addonType']); const u = ne({}, r, { cssModule: o, tag: a, addonType: s }); return O.a.createElement(Rr, ne({}, u, { className: n }), O.a.createElement(Qe, ne({}, l, { children: t }))); } return O.a.createElement(Rr, ne({}, e, { children: t })); }).propTypes = jr; const Br = { addonType: P.a.oneOf(['prepend', 'append']).isRequired, children: P.a.node }; (function (e) { return O.a.createElement(Ue, e); }).propTypes = Br; const Fr = ['xs', 'sm', 'md', 'lg', 'xl']; const Ur = P.a.oneOfType([P.a.number, P.a.string]); const Vr = P.a.oneOfType([P.a.string, P.a.number, P.a.shape({
    size: Ur, push: h(Ur, 'Please use the prop "order"'), pull: h(Ur, 'Please use the prop "order"'), order: Ur, offset: Ur,
  })]); const qr = {
    children: P.a.node, hidden: P.a.bool, check: P.a.bool, size: P.a.string, for: P.a.string, tag: P.a.string, className: P.a.string, cssModule: P.a.object, xs: Vr, sm: Vr, md: Vr, lg: Vr, xl: Vr, widths: P.a.array,
  }; const Hr = { tag: 'label', widths: Fr }; const Wr = function (e, t, n) { return !0 === n || n === '' ? e ? 'col' : `col-${t}` : n === 'auto' ? e ? 'col-auto' : `col-${t}-auto` : e ? `col-${n}` : `col-${t}-${n}`; }; const $r = function (e) { const t = e.className; const n = e.cssModule; const r = e.hidden; const i = e.widths; const o = e.tag; const a = e.check; const s = e.size; const l = e.for; const c = ie(e, ['className', 'cssModule', 'hidden', 'widths', 'tag', 'check', 'size', 'for']); const p = []; i.forEach((t, r) => { const i = e[t]; if (delete c[t], i || i === '') { const o = !r; let a = void 0; if (R()(i)) { let s; const l = o ? '-' : `-${t}-`; a = Wr(o, t, i.size), p.push(u(N()((s = {}, te(s, a, i.size || i.size === ''), te(s, `order${l}${i.order}`, i.order || i.order === 0), te(s, `offset${l}${i.offset}`, i.offset || i.offset === 0), s))), n); } else a = Wr(o, t, i), p.push(a); } }); const f = u(N()(t, !!r && 'sr-only', !!a && 'form-check-label', !!s && `col-form-label-${s}`, p, !!p.length && 'col-form-label'), n); return O.a.createElement(o, ne({ htmlFor: l }, c, { className: f })); }; $r.propTypes = qr, $r.defaultProps = Hr; const Gr = {
    body: P.a.bool, bottom: P.a.bool, children: P.a.node, className: P.a.string, cssModule: P.a.object, heading: P.a.bool, left: P.a.bool, list: P.a.bool, middle: P.a.bool, object: P.a.bool, right: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]), top: P.a.bool,
  }; (function (e) {
    const t = e.body; const n = e.bottom; const r = e.className; const i = e.cssModule; const o = e.heading; const a = e.left; const s = e.list; const l = e.middle; const c = e.object; const p = e.right; const f = e.tag; const h = e.top; const d = ie(e, ['body', 'bottom', 'className', 'cssModule', 'heading', 'left', 'list', 'middle', 'object', 'right', 'tag', 'top']); let m = void 0; m = o ? 'h4' : d.href ? 'a' : d.src || c ? 'img' : s ? 'ul' : 'div'; const g = f || m; const y = u(N()(r, {
      'media-body': t, 'media-heading': o, 'media-left': a, 'media-right': p, 'media-top': h, 'media-bottom': n, 'media-middle': l, 'media-object': c, 'media-list': s, media: !t && !o && !a && !p && !h && !n && !l && !c && !s,
    }), i); return O.a.createElement(g, ne({}, d, { className: y }));
  }).propTypes = Gr; const Zr = {
    children: P.a.node, className: P.a.string, listClassName: P.a.string, cssModule: P.a.object, size: P.a.string, tag: P.a.oneOfType([P.a.func, P.a.string]), listTag: P.a.oneOfType([P.a.func, P.a.string]), 'aria-label': P.a.string,
  }; const Kr = { tag: 'nav', listTag: 'ul', 'aria-label': 'pagination' }; const Xr = function (e) { const t = e.className; const n = e.listClassName; const r = e.cssModule; const i = e.size; const o = e.tag; const a = e.listTag; const s = e['aria-label']; const l = ie(e, ['className', 'listClassName', 'cssModule', 'size', 'tag', 'listTag', 'aria-label']); const c = u(N()(t), r); const p = u(N()(n, 'pagination', te({}, `pagination-${i}`, !!i)), r); return O.a.createElement(o, { className: c, 'aria-label': s }, O.a.createElement(a, ne({}, l, { className: p }))); }; Xr.propTypes = Zr, Xr.defaultProps = Kr; const Yr = {
    active: P.a.bool, children: P.a.node, className: P.a.string, cssModule: P.a.object, disabled: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]),
  }; const Jr = { tag: 'li' }; const Qr = function (e) { const t = e.active; const n = e.className; const r = e.cssModule; const i = e.disabled; const o = e.tag; const a = ie(e, ['active', 'className', 'cssModule', 'disabled', 'tag']); const s = u(N()(n, 'page-item', { active: t, disabled: i }), r); return O.a.createElement(o, ne({}, a, { className: s })); }; Qr.propTypes = Yr, Qr.defaultProps = Jr; const ei = {
    'aria-label': P.a.string, children: P.a.node, className: P.a.string, cssModule: P.a.object, next: P.a.bool, previous: P.a.bool, tag: P.a.oneOfType([P.a.func, P.a.string]),
  }; const ti = { tag: 'a' }; const ni = function (e) { const t = e.className; const n = e.cssModule; const r = e.next; const i = e.previous; let o = e.tag; const a = ie(e, ['className', 'cssModule', 'next', 'previous', 'tag']); const s = u(N()(t, 'page-link'), n); let l = void 0; i ? l = 'Previous' : r && (l = 'Next'); const c = e['aria-label'] || l; let p = void 0; i ? p = '\xab' : r && (p = '\xbb'); let f = e.children; return f && Array.isArray(f) && f.length === 0 && (f = null), a.href || o !== 'a' || (o = 'button'), (i || r) && (f = [O.a.createElement('span', { 'aria-hidden': 'true', key: 'caret' }, f || p), O.a.createElement('span', { className: 'sr-only', key: 'sr' }, c)]), O.a.createElement(o, ne({}, a, { className: s, 'aria-label': c }), f); }; ni.propTypes = ei, ni.defaultProps = ti; const ri = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), activeTab: P.a.any, className: P.a.string, cssModule: P.a.object,
  }; const ii = { tag: 'div' }; const oi = { activeTabId: P.a.any }; const ai = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { activeTab: n.props.activeTab }, n; } return re(t, e), ee(t, [{ key: 'getChildContext', value() { return { activeTabId: this.state.activeTab }; } }, { key: 'componentWillReceiveProps', value(e) { this.state.activeTab !== e.activeTab && this.setState({ activeTab: e.activeTab }); } }, { key: 'render', value() { const e = this.props; const t = e.className; const n = e.cssModule; const r = e.tag; const i = c(this.props, Object.keys(ri)); const o = u(N()('tab-content', t), n); return O.a.createElement(r, ne({}, i, { className: o })); } }]), t; }(A.Component)); ai.propTypes = ri, ai.defaultProps = ii, ai.childContextTypes = oi; const si = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.string, cssModule: P.a.object, tabId: P.a.any,
  }; const li = { tag: 'div' }; const ui = { activeTabId: P.a.any }; T.propTypes = si, T.defaultProps = li, T.contextTypes = ui; const ci = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), fluid: P.a.bool, className: P.a.string, cssModule: P.a.object,
  }; const pi = { tag: 'div' }; const fi = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = e.fluid; const o = ie(e, ['className', 'cssModule', 'tag', 'fluid']); const a = u(N()(t, 'jumbotron', !!i && 'jumbotron-fluid'), n); return O.a.createElement(r, ne({}, o, { className: a })); }; fi.propTypes = ci, fi.defaultProps = pi; const hi = {
    children: P.a.node, className: P.a.string, closeClassName: P.a.string, closeAriaLabel: P.a.string, cssModule: P.a.object, color: P.a.string, isOpen: P.a.bool, toggle: P.a.func, tag: P.a.oneOfType([P.a.func, P.a.string]), transition: P.a.shape(x.propTypes),
  }; const di = {
    color: 'success', isOpen: !0, tag: 'div', closeAriaLabel: 'Close', transition: ne({}, x.defaultProps, { unmountOnExit: !0 }),
  }; k.propTypes = hi, k.defaultProps = di; let mi; const gi = ne({}, Tt.propTypes, {
    isOpen: P.a.bool, children: P.a.oneOfType([P.a.arrayOf(P.a.node), P.a.node]), tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.node, navbar: P.a.bool, cssModule: P.a.object,
  }); const yi = ne({}, Tt.defaultProps, {
    isOpen: !1, appear: !1, enter: !0, exit: !0, tag: 'div', timeout: W.Collapse,
  }); var vi = (mi = {}, te(mi, G.ENTERING, 'collapsing'), te(mi, G.ENTERED, 'collapse show'), te(mi, G.EXITING, 'collapsing'), te(mi, G.EXITED, 'collapse'), mi); const _i = (function (e) {
    function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { height: null }, ['onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited'].forEach((e) => { n[e] = n[e].bind(n); }), n; } return re(t, e), ee(t, [{ key: 'onEntering', value(e, t) { this.setState({ height: S(e) }), this.props.onEntering(e, t); } }, { key: 'onEntered', value(e, t) { this.setState({ height: null }), this.props.onEntered(e, t); } }, { key: 'onExit', value(e) { this.setState({ height: S(e) }), this.props.onExit(e); } }, { key: 'onExiting', value(e) { e.offsetHeight; this.setState({ height: 0 }), this.props.onExiting(e); } }, { key: 'onExited', value(e) { this.setState({ height: null }), this.props.onExited(e); } }, {
      key: 'render',
      value() {
        const e = this.props; const t = e.tag; const n = e.isOpen; const r = e.className; const i = e.navbar; const o = e.cssModule; const a = e.children; const s = ie(e, ['tag', 'isOpen', 'className', 'navbar', 'cssModule', 'children']); const l = this.state.height; const f = p(s, $); const h = c(s, $); return O.a.createElement(Tt, ne({}, f, {
          in: n, onEntering: this.onEntering, onEntered: this.onEntered, onExit: this.onExit, onExiting: this.onExiting, onExited: this.onExited,
        }), (e) => { const n = C(e); const s = u(N()(r, n, i && 'navbar-collapse'), o); const c = l === null ? null : { height: l }; return O.a.createElement(t, ne({}, h, { style: ne({}, h.style, c), className: s }), a); });
      },
    }]), t;
  }(A.Component)); _i.propTypes = gi, _i.defaultProps = yi; const bi = {
    tag: P.a.oneOfType([P.a.func, P.a.string]), active: P.a.bool, disabled: P.a.bool, color: P.a.string, action: P.a.bool, className: P.a.any, cssModule: P.a.object,
  }; const xi = { tag: 'li' }; const wi = function (e) { e.preventDefault(); }; const Ei = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = e.active; const o = e.disabled; const a = e.action; const s = e.color; const l = ie(e, ['className', 'cssModule', 'tag', 'active', 'disabled', 'action', 'color']); const c = u(N()(t, !!i && 'active', !!o && 'disabled', !!a && 'list-group-item-action', !!s && `list-group-item-${s}`, 'list-group-item'), n); return o && (l.onClick = wi), O.a.createElement(r, ne({}, l, { className: c })); }; Ei.propTypes = bi, Ei.defaultProps = xi; const Ti = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.any, cssModule: P.a.object }; const ki = { tag: 'h5' }; const Ci = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'list-group-item-heading'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Ci.propTypes = Ti, Ci.defaultProps = ki; const Si = { tag: P.a.oneOfType([P.a.func, P.a.string]), className: P.a.any, cssModule: P.a.object }; const Ai = { tag: 'p' }; const Oi = function (e) { const t = e.className; const n = e.cssModule; const r = e.tag; const i = ie(e, ['className', 'cssModule', 'tag']); const o = u(N()(t, 'list-group-item-text'), n); return O.a.createElement(r, ne({}, i, { className: o })); }; Oi.propTypes = Si, Oi.defaultProps = Ai; const Ii = ((function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { isOpen: !0 }, n.toggle = n.toggle.bind(n), n; }re(t, e), ee(t, [{ key: 'toggle', value() { this.setState({ isOpen: !this.state.isOpen }); } }, { key: 'render', value() { return O.a.createElement(k, ne({ isOpen: this.state.isOpen, toggle: this.toggle }, this.props)); } }]); }(A.Component)), (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { isOpen: !1 }, n.toggle = n.toggle.bind(n), n; }re(t, e), ee(t, [{ key: 'toggle', value() { this.setState({ isOpen: !this.state.isOpen }); } }, { key: 'render', value() { return O.a.createElement(tt, ne({ isOpen: this.state.isOpen, toggle: this.toggle }, this.props)); } }]); }(A.Component)), { toggler: P.a.string.isRequired, toggleEvents: P.a.arrayOf(P.a.string) }); const Pi = { toggleEvents: Y }; const Mi = (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.togglers = null, n.removeEventListeners = null, n.toggle = n.toggle.bind(n), n.state = { isOpen: !1 }, n; } return re(t, e), ee(t, [{ key: 'componentDidMount', value() { this.togglers = m(this.props.toggler), this.togglers.length && (this.removeEventListeners = v(this.togglers, this.toggle, this.props.toggleEvents)); } }, { key: 'componentWillUnmount', value() { this.togglers.length && this.removeEventListeners && this.removeEventListeners(); } }, { key: 'toggle', value(e) { this.setState(e => ({ isOpen: !e.isOpen })), e.preventDefault(); } }, { key: 'render', value() { const e = this.props; const t = (e.toggleEvents, ie(e, ['toggleEvents'])); return O.a.createElement(_i, ne({ isOpen: this.state.isOpen }, t)); } }]), t; }(A.Component)); Mi.propTypes = Ii, Mi.defaultProps = Pi; (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { isOpen: !1 }, n.toggle = n.toggle.bind(n), n; }re(t, e), ee(t, [{ key: 'toggle', value() { this.setState({ isOpen: !this.state.isOpen }); } }, { key: 'render', value() { return O.a.createElement(Ue, ne({ isOpen: this.state.isOpen, toggle: this.toggle }, this.props)); } }]); }(A.Component)), (function (e) { function t(e) { Q(this, t); const n = oe(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { isOpen: !1 }, n.toggle = n.toggle.bind(n), n; }re(t, e), ee(t, [{ key: 'toggle', value() { this.setState({ isOpen: !this.state.isOpen }); } }, { key: 'render', value() { return O.a.createElement(sr, ne({ isOpen: this.state.isOpen, toggle: this.toggle }, this.props)); } }]); }(A.Component));
}, function (e, t, n) { e.exports = n(88)(); }, function (e, t, n) {
  function r() {} const i = n(89); e.exports = function () {
    function e(e, t, n, r, o, a) { if (a !== i) { const s = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types'); throw s.name = 'Invariant Violation', s; } } function t() { return e; }e.isRequired = e; const n = {
      array: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t,
    }; return n.checkPropTypes = r, n.PropTypes = n, n;
  };
}, function (e, t, n) {
  e.exports = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
}, function (e, t, n) {
  let r; let i; !(function () {
    function n() { for (var e = [], t = 0; t < arguments.length; t++) { const r = arguments[t]; if (r) { const i = typeof r; if (i === 'string' || i === 'number')e.push(r); else if (Array.isArray(r) && r.length) { const a = n(...r); a && e.push(a); } else if (i === 'object') for (const s in r)o.call(r, s) && r[s] && e.push(s); } } return e.join(' '); } var o = {}.hasOwnProperty; typeof e !== 'undefined' && e.exports ? (n.default = n, e.exports = n) : (r = [], void 0 !== (i = function () { return n; }.apply(t, r)) && (e.exports = i));
  }());
}, function (e, t, n) { (function (t) { function n(e) { return e == null ? void 0 === e ? f : c : b && b in Object(e) ? r(e) : i(e); } function r(e) { const t = y.call(e, b); const n = e[b]; try { e[b] = void 0; var r = !0; } catch (e) {} const i = v.call(e); return r && (t ? e[b] = n : delete e[b]), i; } function i(e) { return v.call(e); } function o(e) { if (!a(e)) return !1; const t = n(e); return t == l || t == u || t == s || t == p; } function a(e) { const t = typeof e; return e != null && (t == 'object' || t == 'function'); } var s = '[object AsyncFunction]'; var l = '[object Function]'; var u = '[object GeneratorFunction]'; var c = '[object Null]'; var p = '[object Proxy]'; var f = '[object Undefined]'; const h = typeof t === 'object' && t && t.Object === Object && t; const d = typeof self === 'object' && self && self.Object === Object && self; const m = h || d || Function('return this')(); const g = Object.prototype; var y = g.hasOwnProperty; var v = g.toString; const _ = m.Symbol; var b = _ ? _.toStringTag : void 0; e.exports = o; }).call(t, n(4)); }, function (e, t) { function n(e) { const t = typeof e; return !!e && (t == 'object' || t == 'function'); }e.exports = n; }, function (e, t, n) {
  const r = n(94); n.d(t, 'b', () => r.a); const i = n(95); n.d(t, 'd', () => i.a); const o = n(96); n.d(t, 'c', () => o.a); const a = n(97); n.d(t, 'a', () => a.a);
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } function i(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function o(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function a(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const s = n(0); const l = (n.n(s), n(1)); const u = n.n(l); const c = (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }()); const p = (function (e) { function t() { let e; let n; let r; let a; i(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = r = o(this, (e = t.__proto__ || Object.getPrototypeOf(t)).call.apply(e, [this].concat(l))), r._setTargetNode = function (e) { r._targetNode = e; }, r._getTargetNode = function () { return r._targetNode; }, a = n, o(r, a); } return a(t, e), c(t, [{ key: 'getChildContext', value() { return { popperManager: { setTargetNode: this._setTargetNode, getTargetNode: this._getTargetNode } }; } }, { key: 'render', value() { const e = this.props; const t = e.tag; const n = e.children; const i = r(e, ['tag', 'children']); return !1 !== t ? Object(s.createElement)(t, i, n) : n; } }]), t; }(s.Component)); p.childContextTypes = { popperManager: u.a.object.isRequired }, p.propTypes = { tag: u.a.oneOfType([u.a.string, u.a.bool]), children: u.a.oneOfType([u.a.node, u.a.func]) }, p.defaultProps = { tag: 'div' }, t.a = p;
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } const i = n(0); const o = (n.n(i), n(1)); const a = n.n(o); const s = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const l = function (e, t) { const n = e.component; const o = void 0 === n ? 'div' : n; const a = e.innerRef; const l = e.children; const u = r(e, ['component', 'innerRef', 'children']); const c = t.popperManager; const p = function (e) { c.setTargetNode(e), typeof a === 'function' && a(e); }; if (typeof l === 'function') { return l({ targetProps: { ref: p }, restProps: u }); } const f = s({}, u); return typeof o === 'string' ? f.ref = p : f.innerRef = p, Object(i.createElement)(o, f, l); }; l.contextTypes = { popperManager: a.a.object.isRequired }, l.propTypes = { component: a.a.oneOfType([a.a.node, a.a.func]), innerRef: a.a.func, children: a.a.oneOfType([a.a.node, a.a.func]) }, t.a = l;
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } function i(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function o(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function a(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const s = n(0); const l = (n.n(s), n(1)); const u = n.n(l); const c = n(29); const p = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const f = (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }()); const h = c.default.placements; const d = (function (e) {
    function t() { let e; let n; let r; let a; i(this, t); for (var s = arguments.length, l = Array(s), u = 0; u < s; u++)l[u] = arguments[u]; return n = r = o(this, (e = t.__proto__ || Object.getPrototypeOf(t)).call.apply(e, [this].concat(l))), r.state = {}, r._setArrowNode = function (e) { r._arrowNode = e; }, r._getTargetNode = function () { if (r.props.target) return r.props.target; if (!r.context.popperManager || !r.context.popperManager.getTargetNode()) throw new Error('Target missing. Popper must be given a target from the Popper Manager, or as a prop.'); return r.context.popperManager.getTargetNode(); }, r._getOffsets = function (e) { return Object.keys(e.offsets).map(t => e.offsets[t]); }, r._isDataDirty = function (e) { return !r.state.data || JSON.stringify(r._getOffsets(r.state.data)) !== JSON.stringify(r._getOffsets(e)); }, r._updateStateModifier = { enabled: !0, order: 900, fn(e) { return r._isDataDirty(e) && r.setState({ data: e }), e; } }, r._getPopperStyle = function () { const e = r.state.data; return r._popper && e ? p({ position: e.offsets.popper.position }, e.styles) : { position: 'absolute', pointerEvents: 'none', opacity: 0 }; }, r._getPopperPlacement = function () { return r.state.data ? r.state.data.placement : void 0; }, r._getPopperHide = function () { return r.state.data && r.state.data.hide ? '' : void 0; }, r._getArrowStyle = function () { if (r.state.data && r.state.data.offsets.arrow) { const e = r.state.data.offsets.arrow; return { top: e.top, left: e.left }; } return {}; }, r._handlePopperRef = function (e) { r._popperNode = e, e ? r._createPopper() : r._destroyPopper(), r.props.innerRef && r.props.innerRef(e); }, r._scheduleUpdate = function () { r._popper && r._popper.scheduleUpdate(); }, a = n, o(r, a); } return a(t, e), f(t, [{ key: 'getChildContext', value() { return { popper: { setArrowNode: this._setArrowNode, getArrowStyle: this._getArrowStyle } }; } }, { key: 'componentDidUpdate', value(e) { e.placement === this.props.placement && e.eventsEnabled === this.props.eventsEnabled && e.target === this.props.target || (this._destroyPopper(), this._createPopper()), e.children !== this.props.children && this._scheduleUpdate(); } }, { key: 'componentWillUnmount', value() { this._destroyPopper(); } }, {
      key: '_createPopper',
      value() {
        const e = this; const t = this.props; const n = t.placement; const r = t.eventsEnabled; const i = t.positionFixed; const o = p({}, this.props.modifiers, { applyStyle: { enabled: !1 }, updateState: this._updateStateModifier }); this._arrowNode && (o.arrow = p({}, this.props.modifiers.arrow || {}, { element: this._arrowNode })), this._popper = new c.default(this._getTargetNode(), this._popperNode, {
          placement: n, positionFixed: i, eventsEnabled: r, modifiers: o,
        }), setTimeout(() => e._scheduleUpdate());
      },
    }, { key: '_destroyPopper', value() { this._popper && this._popper.destroy(); } }, {
      key: 'render',
      value() {
        const e = this.props; const t = e.component; const n = (e.innerRef, e.placement, e.eventsEnabled, e.positionFixed, e.modifiers, e.children); const i = r(e, ['component', 'innerRef', 'placement', 'eventsEnabled', 'positionFixed', 'modifiers', 'children']); const o = this._getPopperStyle(); const a = this._getPopperPlacement(); const l = this._getPopperHide(); if (typeof n === 'function') {
          return n({
            popperProps: {
              ref: this._handlePopperRef, style: o, 'data-placement': a, 'data-x-out-of-boundaries': l,
            },
            restProps: i,
            scheduleUpdate: this._scheduleUpdate,
          });
        } const u = p({}, i, { style: p({}, i.style, o), 'data-placement': a, 'data-x-out-of-boundaries': l }); return typeof t === 'string' ? u.ref = this._handlePopperRef : u.innerRef = this._handlePopperRef, Object(s.createElement)(t, u, n);
      },
    }]), t;
  }(s.Component)); d.contextTypes = { popperManager: u.a.object }, d.childContextTypes = { popper: u.a.object.isRequired }, d.propTypes = {
    component: u.a.oneOfType([u.a.node, u.a.func]), innerRef: u.a.func, placement: u.a.oneOf(h), eventsEnabled: u.a.bool, positionFixed: u.a.bool, modifiers: u.a.object, children: u.a.oneOfType([u.a.node, u.a.func]), target: u.a.oneOfType([u.a.instanceOf(typeof Element !== 'undefined' ? Element : Object), u.a.shape({ getBoundingClientRect: u.a.func.isRequired, clientWidth: u.a.number.isRequired, clientHeight: u.a.number.isRequired })]),
  }, d.defaultProps = {
    component: 'div', placement: 'bottom', eventsEnabled: !0, positionFixed: !1, modifiers: {},
  }, t.a = d;
}, function (e, t, n) {
  function r(e, t) { const n = {}; for (const r in e)t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n; } const i = n(0); const o = (n.n(i), n(1)); const a = n.n(o); const s = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }; const l = function (e, t) { const n = e.component; const o = void 0 === n ? 'span' : n; const a = e.innerRef; const l = e.children; const u = r(e, ['component', 'innerRef', 'children']); const c = t.popper; const p = function (e) { c.setArrowNode(e), typeof a === 'function' && a(e); }; const f = c.getArrowStyle(); if (typeof l === 'function') { return l({ arrowProps: { ref: p, style: f }, restProps: u }); } const h = s({}, u, { style: s({}, f, u.style) }); return typeof o === 'string' ? h.ref = p : h.innerRef = p, Object(i.createElement)(o, h, l); }; l.contextTypes = { popper: a.a.object.isRequired }, l.propTypes = { component: a.a.oneOfType([a.a.node, a.a.func]), innerRef: a.a.func, children: a.a.oneOfType([a.a.node, a.a.func]) }, t.a = l;
}, function (e, t) { function n(e) { const t = typeof e; return !!e && (t == 'object' || t == 'function'); } function r(e) { return !!e && typeof e === 'object'; } function i(e) { return typeof e === 'symbol' || r(e) && d.call(e) == s; } function o(e) { if (typeof e === 'number') return e; if (i(e)) return a; if (n(e)) { const t = typeof e.valueOf === 'function' ? e.valueOf() : e; e = n(t) ? `${t}` : t; } if (typeof e !== 'string') return e === 0 ? e : +e; e = e.replace(l, ''); const r = c.test(e); return r || p.test(e) ? f(e.slice(2), r ? 2 : 8) : u.test(e) ? a : +e; } var a = NaN; var s = '[object Symbol]'; var l = /^\s+|\s+$/g; var u = /^[-+]0x[0-9a-f]+$/i; var c = /^0b[01]+$/i; var p = /^0o[0-7]+$/i; var f = parseInt; const h = Object.prototype; var d = h.toString; e.exports = o; }, function (e, t) { function n() {} function r() { const e = new n(); return e.init(...arguments), e; }n.prototype.init = function () { if (!arguments.length) throw new Error('no arguments'); if (arguments[0].lat && arguments[0].lng) this.lat = arguments[0].lat, this.lon = arguments[0].lng; else if (typeof arguments[0] === 'string') { const e = arguments[0].split(','); this.lat = parseFloat(e[0].trim()), this.lon = parseFloat(e[1].trim()); } else if (Object.prototype.toString.call(arguments[0]) === '[object Array]') { const t = arguments[0]; !0 === arguments[1] ? (this.lat = t[1], this.lon = t[0]) : (this.lat = t[0], this.lon = t[1]); } else !0 === arguments[2] ? (this.lat = arguments[1], this.lon = arguments[0]) : (this.lat = arguments[0], this.lon = arguments[1]); this.compute(); }, n.prototype.compute = function () { function e(e) { const t = {}; return t.initValue = e, t.degrees = Math.abs(e), t.degreesInt = Math.floor(t.degrees), t.degreesFrac = t.degrees - t.degreesInt, t.secondsTotal = 3600 * t.degreesFrac, t.minutes = t.secondsTotal / 60, t.minutesInt = Math.floor(t.minutes), t.seconds = t.secondsTotal - 60 * t.minutesInt, t; } this.north = this.lat > 0, this.east = this.lon > 0, this.latValues = e(this.lat), this.lonValues = e(this.lon); }; const i = { FFf: 'DD MM ss X', Ff: 'DD mm X', f: 'dd X' }; const o = { degrees: '\xb0', minutes: '\u2032', seconds: '\u2033' }; n.prototype.format = function (e, t) { function n(n, r) { let i = e; return i = i.replace(/DD/g, n.degreesInt + o.degrees), i = i.replace(/dd/g, n.degrees.toFixed(t.decimalPlaces) + o.degrees), i = i.replace(/D/g, n.degreesInt), i = i.replace(/d/g, n.degrees.toFixed(t.decimalPlaces)), i = i.replace(/MM/g, n.minutesInt + o.minutes), i = i.replace(/mm/g, n.minutes.toFixed(t.decimalPlaces) + o.minutes), i = i.replace(/M/g, n.minutesInt), i = i.replace(/m/g, n.minutes.toFixed(t.decimalPlaces)), i = i.replace(/ss/g, n.seconds.toFixed(t.decimalPlaces) + o.seconds), i = i.replace(/s/g, n.seconds.toFixed(t.decimalPlaces)), i = i.replace(/-/g, n.initValue < 0 ? '-' : ''), i = i.replace(/X/g, r); } if (typeof e === 'object') { t = e, e = 'FFf'; } if (typeof e === 'undefined' && (e = 'FFf'), typeof t === 'undefined' && (t = {}), typeof t === 'string') { t = { latLonSeparator: t }; } typeof t.latLonSeparator === 'undefined' && (t.latLonSeparator = ' '), typeof t.decimalPlaces === 'undefined' ? t.decimalPlaces = 5 : t.decimalPlaces = parseInt(t.decimalPlaces), Object.keys(i).indexOf(e) > -1 && (e = i[e]); const r = n(this.latValues, this.north ? 'N' : 'S'); const a = n(this.lonValues, this.east ? 'E' : 'W'); return r + t.latLonSeparator + a; }, e.exports = r; }, function (e, t) {}, function (e, t) {}, function (e, t, n) {
  function r(e) { if (Array.isArray(e)) { for (var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t]; return n; } return Array.from(e); } function i(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function o(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function a(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const s = n(0); const l = n.n(s); const u = n(103); const c = n.n(u); const p = n(28); const f = n.n(p); const h = n(30); const d = n(104); const m = n(31); const g = n(108); const y = (n.n(g), (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }())); const v = function (e) { return l.a.createElement('tr', { className: 'stats-item' }, l.a.createElement('th', { nowrap: 'nowrap', scope: 'row' }, e.index), l.a.createElement('td', { nowrap: 'nowrap' }, h.a.names(e.item.name, e.item.localname)), l.a.createElement('td', { nowrap: 'nowrap' }, h.a.fracToPerc(e.item.recordFrac)), l.a.createElement('td', { nowrap: 'nowrap' }, h.a.temp(e.item.recordTemp))); }; const _ = (function (e) { function t(e) { i(this, t); const n = o(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { rankFn: n.rankByRecordTemp, expanded: !0 }, n; } return a(t, e), y(t, [{ key: 'changeRankFn', value(e) { const t = this; return function () { t.setState({ rankFn: e }); }; } }, { key: 'rankByRecordFrac', value(e) { return f.a.sortBy(e, e => -e.recordFrac); } }, { key: 'rankByRecordTemp', value(e) { return f.a.sortBy(e, e => -e.recordTemp); } }, { key: 'rank', value() { return this.state.expanded ? this.state.rankFn(this.props.data) : f.a.first(this.state.rankFn(this.props.data), 5); } }, { key: 'rows', value() { return this.rank().map((e, t) => l.a.createElement(v, { key: t, index: t + 1, item: e })); } }, { key: 'render', value() { return l.a.createElement('div', { className: 'ranking' }, l.a.createElement('table', { className: 'table-hover table-sm table-responsive d-table' }, l.a.createElement('thead', null, l.a.createElement('tr', null, l.a.createElement('th', { nowrap: 'nowrap', scope: 'col' }, '#'), l.a.createElement('th', { nowrap: 'nowrap', scope: 'col' }, 'city'), l.a.createElement('th', { nowrap: 'nowrap', scope: 'col', onClick: this.changeRankFn(this.rankByRecordFrac) }, 'record fraction', this.state.rankFn === this.rankByRecordFrac ? l.a.createElement('span', { className: 'fas fa-circle' }) : l.a.createElement('span', { className: 'far fa-circle' })), l.a.createElement('th', { nowrap: 'nowrap', scope: 'col', onClick: this.changeRankFn(this.rankByRecordTemp) }, 'record temperature', this.state.rankFn === this.rankByRecordTemp ? l.a.createElement('span', { className: 'fas fa-circle' }) : l.a.createElement('span', { className: 'far fa-circle' })))), l.a.createElement('tbody', null, this.rows()))); } }]), t; }(s.Component)); const b = (function (e) {
    function t() { i(this, t); const e = o(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return e.state = { isLoading: !0 }, e; } return a(t, e), y(t, [{ key: 'componentDidMount', value() { const e = this; Promise.all([fetch('/api/cities'), fetch('/api/stats/cities')]).then(e => Promise.all(e.map(e => e.json()))).then(t => e.setState({ data: { cities: t[0], recordCities: t[1] } })).then(() => { e.setState({ isLoading: !1 }); }); } }, { key: 'caption', value() { return this.state.isLoading ? 'Loading...' : 'Stats'; } }, {
      key: 'loadMapData',
      value(e) {
        const t = f.a.map(this.state.data.recordCities, (e) => { const t = e; return t.circleRadius = Math.sqrt(e.recordFrac), t.circleColor = e.recordTemp, t; }); const n = f.a.map(this.state.data.recordCities, e => e.recordTemp); const i = f.a.map(this.state.data.recordCities, e => e.recordFrac); return function () {
          e.addLayer({
            id: 'records', type: 'circle', source: { type: 'geojson', data: c.a.parse(t, { Point: ['lat', 'lng'] }) }, paint: { 'circle-color': { property: 'circleColor', stops: [[Math.min(...r(n)), 'rgba(244, 147, 29, 0)'], [Math.max(...r(n)), 'rgba(244, 147, 29, 1)']] }, 'circle-blur': 0.3, 'circle-radius': { property: 'circleRadius', stops: [[Math.min(...r(i)), 0], [Math.max(...r(i)), 10]] } },
          });
        };
      },
    }, {
      key: 'render',
      value() {
        return l.a.createElement('div', { className: 'stats' }, l.a.createElement('div', { className: 'stats-view' }, !this.state.isLoading && l.a.createElement(d.a, {
          mapstyle: 'mapbox://styles/bluephlavio/cjin553wo0vr92rrynvsksfuv', zoom: 1, center: [0, 0], load: this.loadMapData.bind(this),
        })), l.a.createElement(m.a, { title: this.caption(), isLoading: this.state.isLoading }, !this.state.isLoading && l.a.createElement(_, { data: this.state.data.recordCities })));
      },
    }]), t;
  }(s.Component)); t.a = b;
}, function (e, t, n) { !(function (e) { function t() { const e = arguments.length >= 1 ? [].slice.call(arguments, 0) : []; const t = e.shift(); const n = e.shift(); Error.apply(this, e), this.message = this.message || `Invalid Geometry: item: ${JSON.stringify(t)}, params: ${JSON.stringify(n)}`; } function n(e, t) { const n = e || {}; for (const r in t)t.hasOwnProperty(r) && !n[r] && (n[r] = t[r]); return n; } function r(e, t) { if (t.crs && i(t.crs) && (t.isPostgres ? e.geometry.crs = t.crs : e.crs = t.crs), t.bbox && (e.bbox = t.bbox), t.extraGlobal) { e.properties = {}; for (const n in t.extraGlobal)e.properties[n] = t.extraGlobal[n]; } } function i(e) { if (e.type === 'name') { if (e.properties && e.properties.name) return !0; throw new Error('Invalid CRS. Properties must contain "name" key'); } if (e.type === 'link') { if (e.properties && e.properties.href && e.properties.type) return !0; throw new Error('Invalid CRS. Properties must contain "href" and "type" key'); } throw new Error('Invald CRS. Type attribute must be "name" or "link"'); } function o(e) { e.geom = {}; for (const t in e)e.hasOwnProperty(t) && f.indexOf(t) !== -1 && (e.geom[t] = e[t], delete e[t]); a(e.geom); } function a(e) { for (const t in e)e.hasOwnProperty(t) && (typeof e[t] === 'string' ? h.push(e[t]) : typeof e[t] === 'object' && (h.push(e[t][0]), h.push(e[t][1]))); if (h.length === 0) throw new Error('No geometry attributes specified'); } function s(e) { const t = e.item; const n = e.params; const r = e.propFunc; const i = { type: 'Feature' }; return i.geometry = u(t, n), i.properties = r.call(t), i; } function l(e) { return /^.+\..+$/.test(e); } function u(n, r) { let i = {}; for (const o in r.geom) { var a = r.geom[o]; if (typeof a === 'string' && n.hasOwnProperty(a))o === 'GeoJSON' ? i = n[a] : (i.type = o, i.coordinates = n[a]); else if (typeof a !== 'object' || Array.isArray(a)) { if (Array.isArray(a) && n.hasOwnProperty(a[0]) && n.hasOwnProperty(a[1]))i.type = o, i.coordinates = [Number(n[a[1]]), Number(n[a[0]])]; else if (Array.isArray(a) && l(a[0]) && l(a[1])) { for (var s = [], c = 0; c < a.length; c++) { for (var p = a[c].split('.'), f = n, h = 0; h < p.length; h++) { if (!f.hasOwnProperty(p[h])) return !1; f = f[p[h]]; }s[c] = f; }i.type = o, i.coordinates = [Number(s[1]), Number(s[0])]; } } else { const d = Object.keys(a).map((e) => { const t = a[e]; return u(n[e], { geom: { Point: t } }); }); i.type = o, i.coordinates = [].concat(d.map(e => e.coordinates)); } } if (r.doThrows && r.doThrows.invalidGeometry && !e.isGeometryValid(i)) throw new t(n, r); return i; } function c(e) { let t; return e.exclude || e.include ? e.include ? t = function (t) { e.include.forEach(function (e) { t[e] = this[e]; }, this); } : e.exclude && (t = function (t) { for (const n in this) this.hasOwnProperty(n) && h.indexOf(n) === -1 && e.exclude.indexOf(n) === -1 && (t[n] = this[n]); }) : t = function (e) { for (const t in this) this.hasOwnProperty(t) && h.indexOf(t) === -1 && (e[t] = this[t]); }, function () { const n = {}; return t.call(this, n), e.extra && p(n, e.extra), n; }; } function p(e, t) { for (const n in t)t.hasOwnProperty(n) && (e[n] = t[n]); return e; }e.version = '0.5.0', e.defaults = { doThrows: { invalidGeometry: !1 } }, t.prototype = Error, e.errors = { InvalidGeometryError: t }, e.isGeometryValid = function (e) { return !(!e || !Object.keys(e).length) && (!!e.type && !!e.coordinates && Array.isArray(e.coordinates) && !!e.coordinates.length); }, e.parse = function (e, t, i) { let a; let l; const u = n(t, this.defaults); if (h.length = 0, o(u), l = c(u), Array.isArray(e) ? (a = { type: 'FeatureCollection', features: [] }, e.forEach((e) => { a.features.push(s({ item: e, params: u, propFunc: l })); }), r(a, u)) : (a = s({ item: e, params: u, propFunc: l }), r(a, u)), !i || typeof i !== 'function') return a; i(a); }; var f = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON']; var h = []; }(e.exports)); }, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(105); const u = n.n(l); const c = n(106); const p = (n.n(c), n(107)); const f = (n.n(p), (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }())); const h = (function (e) {
    function t(e) { r(this, t); const n = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return u.a.accessToken = 'pk.eyJ1IjoiYmx1ZXBobGF2aW8iLCJhIjoiY2ppMGFlNGhnMDAzcTNwcGpxbXA1dHAxdiJ9.wxN7uepuQStutK1vvxFzBg', n; } return o(t, e), f(t, [{
      key: 'componentDidMount',
      value() {
        const e = new u.a.Map({
          container: this.mapContainer, style: this.props.mapstyle, zoom: this.props.zoom, center: this.props.center,
        }); this.props.load && e.on('load', this.props.load(e));
      },
    }, { key: 'render', value() { const e = this; return s.a.createElement('div', { className: 'map', ref(t) { return e.mapContainer = t; } }); } }]), t;
  }(a.Component)); t.a = h;
}, function (e, t, n) {
  (function (t) {
    !(function (t, n) { e.exports = n(); }(0, () => {
      function e(e, t) { if (n) if (r) { const o = `var sharedChunk = {}; (${n})(sharedChunk); (${r})(sharedChunk);`; const a = {}; n(a), i = t(a), i.workerUrl = window.URL.createObjectURL(new Blob([o], { type: 'text/javascript' })); } else r = t; else n = t; } let n; let r; let i; return e(['exports'], (e) => {
        function n(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e; } function r(e, t) { return e(t = { exports: {} }, t.exports), t.exports; } function i(e, t, n, r) { this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (r - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = n, this.p2y = r; } function o(e, t) { this.x = e, this.y = t; } function a(e, t, n, r) { const i = new Rn(e, t, n, r); return function (e) { return i.solve(e); }; } function s(e, t, n) { return Math.min(n, Math.max(t, e)); } function l(e) { for (var t = [], n = arguments.length - 1; n-- > 0;)t[n] = arguments[n + 1]; for (let r = 0, i = t; r < i.length; r += 1) { const o = i[r]; for (const a in o)e[a] = o[a]; } return e; } function u(e, t) { e.forEach((e) => { t[e] && (t[e] = t[e].bind(t)); }); } function c(e, t) { return e.indexOf(t, e.length - t.length) !== -1; } function p(e, t, n) { const r = {}; for (const i in e)r[i] = t.call(n || this, e[i], i, e); return r; } function f(e, t, n) { const r = {}; for (const i in e)t.call(n || this, e[i], i, e) && (r[i] = e[i]); return r; } function h(e) { return Array.isArray(e) ? e.map(h) : typeof e === 'object' && e ? p(e, h) : e; } function d(e) { Vn[e] || (typeof console !== 'undefined' && console.warn(e), Vn[e] = !0); } function m(e, t, n) { return (n.y - e.y) * (t.x - e.x) > (t.y - e.y) * (n.x - e.x); } function g(e) { for (var t = 0, n = 0, r = e.length, i = r - 1, o = void 0, a = void 0; n < r; i = n++)o = e[n], t += ((a = e[i]).x - o.x) * (o.y + a.y); return t; } function y(e) { const t = new self.XMLHttpRequest(); for (const n in t.open('GET', e.url, !0), e.headers)t.setRequestHeader(n, e.headers[n]); return t.withCredentials = e.credentials === 'include', t; } function v(e, t, n) { n[e] = n[e] || [], n[e].push(t); } function _(e, t, n) { if (n && n[e]) { const r = n[e].indexOf(t); r !== -1 && n[e].splice(r, 1); } } function b(e) { const t = e.key; const n = e.value; return n ? [new Xn(t, n, 'constants have been deprecated as of v8')] : []; } function x(e) { for (var t = [], n = arguments.length - 1; n-- > 0;)t[n] = arguments[n + 1]; for (let r = 0, i = t; r < i.length; r += 1) { const o = i[r]; for (const a in o)e[a] = o[a]; } return e; } function w(e) { return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e; } function E(e) { return Array.isArray(e) ? e.map(E) : w(e); } function T(e, t) { return { kind: 'array', itemType: e, N: t }; } function k(e) { if (e.kind === 'array') { const t = k(e.itemType); return typeof e.N === 'number' ? `array<${t}, ${e.N}>` : e.itemType.kind === 'value' ? 'array' : `array<${t}>`; } return e.kind; } function C(e, t) { if (t.kind === 'error') return null; if (e.kind === 'array') { if (t.kind === 'array' && !C(e.itemType, t.itemType) && (typeof e.N !== 'number' || e.N === t.N)) return null; } else { if (e.kind === t.kind) return null; if (e.kind === 'value') for (let n = 0, r = sr; n < r.length; n += 1) if (!C(r[n], t)) return null; } return `Expected ${k(e)} but found ${k(t)} instead.`; } function S(e, t, n, r) { return typeof e === 'number' && e >= 0 && e <= 255 && typeof t === 'number' && t >= 0 && t <= 255 && typeof n === 'number' && n >= 0 && n <= 255 ? void 0 === r || typeof r === 'number' && r >= 0 && r <= 1 ? null : `Invalid rgba value [${[e, t, n, r].join(', ')}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof r === 'number' ? [e, t, n, r] : [e, t, n]).join(', ')}]: 'r', 'g', and 'b' must be between 0 and 255.`; } function A(e) { if (e === null) return Qn; if (typeof e === 'string') return tr; if (typeof e === 'boolean') return nr; if (typeof e === 'number') return er; if (e instanceof ur) return rr; if (e instanceof cr) return ar; if (Array.isArray(e)) { for (var t, n = e.length, r = 0, i = e; r < i.length; r += 1) { const o = A(i[r]); if (t) { if (t === o) continue; t = or; break; }t = o; } return T(t || or, n); } return ir; } function O(e) { if (e instanceof wr) { if (e.name === 'get' && e.args.length === 1) return !1; if (e.name === 'has' && e.args.length === 1) return !1; if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') return !1; if (/^filter-/.test(e.name)) return !1; } let t = !0; return e.eachChild((e) => { t && !O(e) && (t = !1); }), t; } function I(e, t) { if (e instanceof wr && t.indexOf(e.name) >= 0) return !1; let n = !0; return e.eachChild((e) => { n && !I(e, t) && (n = !1); }), n; } function P(e, t) { for (var n, r, i = 0, o = e.length - 1, a = 0; i <= o;) { if (n = e[a = Math.floor((i + o) / 2)], r = e[a + 1], t === n || t > n && t < r) return a; if (n < t)i = a + 1; else { if (!(n > t)) throw new hr('Input is not a number.'); o = a - 1; } } return Math.max(a - 1, 0); } function M(e, t, n) { return e * (1 - n) + t * n; } function N(e, t, n, r) { const i = r - n; const o = e - n; return i === 0 ? 0 : t === 1 ? o / i : (Math.pow(t, o) - 1) / (Math.pow(t, i) - 1); } function D(e) { return e.kind === 'string' || e.kind === 'number' || e.kind === 'boolean' || e.kind === 'null'; } function L(e, t) { return (function () { function n(e, t, n) { this.type = nr, this.lhs = e, this.rhs = t, this.collator = n; } return n.parse = function (e, t) { if (e.length !== 3 && e.length !== 4) return t.error('Expected two or three arguments.'); const r = t.parse(e[1], 1, or); if (!r) return null; const i = t.parse(e[2], 2, or); if (!i) return null; if (!D(r.type) && !D(i.type)) return t.error(`Expected at least one argument to be a string, number, boolean, or null, but found (${k(r.type)}, ${k(i.type)}) instead.`); if (r.type.kind !== i.type.kind && r.type.kind !== 'value' && i.type.kind !== 'value') return t.error(`Cannot compare ${k(r.type)} and ${k(i.type)}.`); let o = null; if (e.length === 4) { if (r.type.kind !== 'string' && i.type.kind !== 'string') return t.error('Cannot use collator to compare non-string types.'); if (!(o = t.parse(e[3], 3, ar))) return null; } return new n(r, i, o); }, n.prototype.evaluate = function (e) { const n = this.collator ? this.collator.evaluate(e).compare(this.lhs.evaluate(e), this.rhs.evaluate(e)) === 0 : this.lhs.evaluate(e) === this.rhs.evaluate(e); return t ? !n : n; }, n.prototype.eachChild = function (e) { e(this.lhs), e(this.rhs), this.collator && e(this.collator); }, n.prototype.possibleOutputs = function () { return [!0, !1]; }, n.prototype.serialize = function () { const t = [e]; return this.eachChild((e) => { t.push(e.serialize()); }), t; }, n; }()); } function z(e, t) { let n = t[0]; let r = t[1]; let i = t[2]; const o = t[3]; n = n.evaluate(e), r = r.evaluate(e), i = i.evaluate(e); const a = o ? o.evaluate(e) : 1; const s = S(n, r, i, a); if (s) throw new hr(s); return new ur(n / 255 * a, r / 255 * a, i / 255 * a, a); } function R(e, t) { return e in t; } function j(e, t) { const n = t[e]; return void 0 === n ? null : n; } function B(e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) < r.evaluate(e); } function F(e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) > r.evaluate(e); } function U(e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) <= r.evaluate(e); } function V(e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) >= r.evaluate(e); } function q(e) { return { type: e }; } function H(e) { return { result: 'success', value: e }; } function W(e) { return { result: 'error', value: e }; } function $(e) { return e > qr ? Math.pow(e, 1 / 3) : e / Vr + Fr; } function G(e) { return e > Ur ? e * e * e : Vr * (e - Fr); } function Z(e) { return 255 * (e <= 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055); } function K(e) { return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4); } function X(e) {
          const t = K(e.r); const n = K(e.g); const r = K(e.b); const i = $((0.4124564 * t + 0.3575761 * n + 0.1804375 * r) / Rr); const o = $((0.2126729 * t + 0.7151522 * n + 0.072175 * r) / jr); return {
            l: 116 * o - 16, a: 500 * (i - o), b: 200 * (o - $((0.0193339 * t + 0.119192 * n + 0.9503041 * r) / Br)), alpha: e.a,
          };
        } function Y(e) { let t = (e.l + 16) / 116; let n = isNaN(e.a) ? t : t + e.a / 500; let r = isNaN(e.b) ? t : t - e.b / 200; return t = jr * G(t), n = Rr * G(n), r = Br * G(r), new ur(Z(3.2404542 * n - 1.5371385 * t - 0.4985314 * r), Z(-0.969266 * n + 1.8760108 * t + 0.041556 * r), Z(0.0556434 * n - 0.2040259 * t + 1.0572252 * r), e.alpha); } function J(e) { return e instanceof Number ? 'number' : e instanceof String ? 'string' : e instanceof Boolean ? 'boolean' : Array.isArray(e) ? 'array' : e === null ? 'null' : typeof e; } function Q(e) { return typeof e === 'object' && e !== null && !Array.isArray(e); } function ee(e) { return e; } function te(e, t, n) { return void 0 !== e ? e : void 0 !== t ? t : void 0 !== n ? n : void 0; } function ne(e, t, n, r, i) { return te(typeof n === i ? r[n] : void 0, e.default, t.default); } function re(e, t, n) { if (J(n) !== 'number') return te(e.default, t.default); const r = e.stops.length; if (r === 1) return e.stops[0][1]; if (n <= e.stops[0][0]) return e.stops[0][1]; if (n >= e.stops[r - 1][0]) return e.stops[r - 1][1]; const i = ae(e.stops, n); return e.stops[i][1]; } function ie(e, t, n) { const r = void 0 !== e.base ? e.base : 1; if (J(n) !== 'number') return te(e.default, t.default); const i = e.stops.length; if (i === 1) return e.stops[0][1]; if (n <= e.stops[0][0]) return e.stops[0][1]; if (n >= e.stops[i - 1][0]) return e.stops[i - 1][1]; const o = ae(e.stops, n); const a = (function (e, t, n, r) { const i = r - n; const o = e - n; return i === 0 ? 0 : t === 1 ? o / i : (Math.pow(t, o) - 1) / (Math.pow(t, i) - 1); }(n, r, e.stops[o][0], e.stops[o + 1][0])); const s = e.stops[o][1]; const l = e.stops[o + 1][1]; let u = Cr[t.type] || ee; if (e.colorSpace && e.colorSpace !== 'rgb') { const c = Zr[e.colorSpace]; u = function (e, t) { return c.reverse(c.interpolate(c.forward(e), c.forward(t), a)); }; } return typeof s.evaluate === 'function' ? { evaluate() { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; const n = s.evaluate.apply(void 0, e); const r = l.evaluate.apply(void 0, e); if (void 0 !== n && void 0 !== r) return u(n, r, a); } } : u(s, l, a); } function oe(e, t, n) { return t.type === 'color' ? n = ur.parse(n) : J(n) === t.type || t.type === 'enum' && t.values[n] || (n = void 0), te(n, e.default, t.default); } function ae(e, t) { for (var n, r, i = 0, o = e.length - 1, a = 0; i <= o;) { if (n = e[a = Math.floor((i + o) / 2)][0], r = e[a + 1][0], t === n || t > n && t < r) return a; n < t ? i = a + 1 : n > t && (o = a - 1); } return Math.max(a - 1, 0); } function se(e) { return Array.isArray(e) && e.length > 0 && typeof e[0] === 'string' && e[0] in zr; } function le(e, t) {
          const n = new Tr(zr, [], (function (e) {
            const t = {
              color: rr, string: tr, number: er, enum: tr, boolean: nr,
            }; return e.type === 'array' ? T(t[e.value] || or, e.length) : t[e.type] || null;
          }(t))); const r = n.parse(e); return r ? H(new Kr(r, t)) : W(n.errors);
        } function ue(e, t) { if ((e = le(e, t)).result === 'error') return e; const n = e.value.expression; const r = O(n); if (!r && !t['property-function']) return W([new Yn('', 'property expressions not supported')]); const i = I(n, ['zoom']); if (!i && !1 === t['zoom-function']) return W([new Yn('', 'zoom expressions not supported')]); const o = (function e(t) { let n = null; if (t instanceof Or)n = e(t.result); else if (t instanceof Ar) for (let r = 0, i = t.args; r < i.length; r += 1) { const o = i[r]; if (n = e(o)) break; } else (t instanceof kr || t instanceof Sr) && t.input instanceof wr && t.input.name === 'zoom' && (n = t); return n instanceof Yn ? n : (t.eachChild((t) => { const r = e(t); r instanceof Yn ? n = r : !n && r ? n = new Yn('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && r && n !== r && (n = new Yn('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')); }), n); }(n)); return o || i ? o instanceof Yn ? W([o]) : o instanceof Sr && t.function === 'piecewise-constant' ? W([new Yn('', '"interpolate" expressions cannot be used with this property')]) : H(o ? new Yr(r ? 'camera' : 'composite', e.value, o) : new Xr(r ? 'constant' : 'source', e.value)) : W([new Yn('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]); } function ce(e, t) { if (Q(e)) return new Jr(e, t); if (se(e)) { const n = ue(e, t); if (n.result === 'error') throw new Error(n.value.map(e => `${e.key}: ${e.message}`).join(', ')); return n.value; } let r = e; return typeof e === 'string' && t.type === 'color' && (r = ur.parse(e)), { kind: 'constant', evaluate() { return r; } }; } function pe(e) {
          const t = e.key; const n = e.value; const r = e.valueSpec || {}; const i = e.objectElementValidators || {}; const o = e.style; const a = e.styleSpec; let s = []; const l = J(n); if (l !== 'object') return [new Xn(t, n, `object expected, ${l} found`)]; for (const u in n) {
            const c = u.split('.')[0]; const p = r[c] || r['*']; let f = void 0; if (i[c])f = i[c]; else if (r[c])f = Ne; else if (i['*'])f = i['*']; else { if (!r['*']) { s.push(new Xn(t, n[u], `unknown property "${u}"`)); continue; }f = Ne; }s = s.concat(f({
              key: (t ? `${t}.` : t) + u, value: n[u], valueSpec: p, style: o, styleSpec: a, object: n, objectKey: u,
            }, n));
          } for (const h in r)i[h] || r[h].required && void 0 === r[h].default && void 0 === n[h] && s.push(new Xn(t, n, `missing required property "${h}"`)); return s;
        } function fe(e) {
          const t = e.value; const n = e.valueSpec; const r = e.style; const i = e.styleSpec; const o = e.key; const a = e.arrayElementValidator || Ne; if (J(t) !== 'array') return [new Xn(o, t, `array expected, ${J(t)} found`)]; if (n.length && t.length !== n.length) return [new Xn(o, t, `array length ${n.length} expected, length ${t.length} found`)]; if (n['min-length'] && t.length < n['min-length']) return [new Xn(o, t, `array length at least ${n['min-length']} expected, length ${t.length} found`)]; let s = { type: n.value }; i.$version < 7 && (s.function = n.function), J(n.value) === 'object' && (s = n.value); for (var l = [], u = 0; u < t.length; u++) {
            l = l.concat(a({
              array: t, arrayIndex: u, value: t[u], valueSpec: s, style: r, styleSpec: i, key: `${o}[${u}]`,
            }));
          } return l;
        } function he(e) { const t = e.key; const n = e.value; const r = e.valueSpec; const i = J(n); return i !== 'number' ? [new Xn(t, n, `number expected, ${i} found`)] : 'minimum' in r && n < r.minimum ? [new Xn(t, n, `${n} is less than the minimum value ${r.minimum}`)] : 'maximum' in r && n > r.maximum ? [new Xn(t, n, `${n} is greater than the maximum value ${r.maximum}`)] : []; } function de(e) {
          function t(e) {
            let t = []; const r = e.value; const s = e.key; if (J(r) !== 'array') return [new Xn(s, r, `array expected, ${J(r)} found`)]; if (r.length !== 2) return [new Xn(s, r, `array length 2 expected, length ${r.length} found`)]; if (p) {
              if (J(r[0]) !== 'object') return [new Xn(s, r, `object expected, ${J(r[0])} found`)]; if (void 0 === r[0].zoom) return [new Xn(s, r, 'object stop key must have zoom')]; if (void 0 === r[0].value) return [new Xn(s, r, 'object stop key must have value')]; if (o && o > w(r[0].zoom)) return [new Xn(s, r[0].zoom, 'stop zoom values must appear in ascending order')]; w(r[0].zoom) !== o && (o = w(r[0].zoom), i = void 0, l = {}), t = t.concat(pe({
                key: `${s}[0]`, value: r[0], valueSpec: { zoom: {} }, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { zoom: he, value: n },
              }));
            } else {
              t = t.concat(n({
                key: `${s}[0]`, value: r[0], valueSpec: {}, style: e.style, styleSpec: e.styleSpec,
              }, r));
            } return t.concat(Ne({
              key: `${s}[1]`, value: r[1], valueSpec: a, style: e.style, styleSpec: e.styleSpec,
            }));
          } function n(e, t) { const n = J(e.value); const o = w(e.value); const u = e.value !== null ? e.value : t; if (r) { if (n !== r) return [new Xn(e.key, u, `${n} stop domain type must match previous stop domain type ${r}`)]; } else r = n; if (n !== 'number' && n !== 'string' && n !== 'boolean') return [new Xn(e.key, u, 'stop domain value must be a number, string, or boolean')]; if (n !== 'number' && s !== 'categorical') { let c = `number expected, ${n} found`; return a['property-function'] && void 0 === s && (c += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Xn(e.key, u, c)]; } return s !== 'categorical' || n !== 'number' || isFinite(o) && Math.floor(o) === o ? s !== 'categorical' && n === 'number' && void 0 !== i && o < i ? [new Xn(e.key, u, 'stop domain values must appear in ascending order')] : (i = o, s === 'categorical' && o in l ? [new Xn(e.key, u, 'stop domain values must be unique')] : (l[o] = !0, [])) : [new Xn(e.key, u, `integer expected, found ${o}`)]; } let r; let i; let o; var a = e.valueSpec; var s = w(e.value.type); var l = {}; const u = s !== 'categorical' && void 0 === e.value.property; const c = !u; var p = J(e.value.stops) === 'array' && J(e.value.stops[0]) === 'array' && J(e.value.stops[0][0]) === 'object'; const f = pe({
            key: e.key,
            value: e.value,
            valueSpec: e.styleSpec.function,
            style: e.style,
            styleSpec: e.styleSpec,
            objectElementValidators: {
              stops(e) {
                if (s === 'identity') return [new Xn(e.key, e.value, 'identity function may not have a "stops" property')]; let n = []; const r = e.value; return n = n.concat(fe({
                  key: e.key, value: r, valueSpec: e.valueSpec, style: e.style, styleSpec: e.styleSpec, arrayElementValidator: t,
                })), J(r) === 'array' && r.length === 0 && n.push(new Xn(e.key, r, 'array must have at least one stop')), n;
              },
              default(e) {
                return Ne({
                  key: e.key, value: e.value, valueSpec: a, style: e.style, styleSpec: e.styleSpec,
                });
              },
            },
          }); return s === 'identity' && u && f.push(new Xn(e.key, e.value, 'missing required property "property"')), s === 'identity' || e.value.stops || f.push(new Xn(e.key, e.value, 'missing required property "stops"')), s === 'exponential' && e.valueSpec.function === 'piecewise-constant' && f.push(new Xn(e.key, e.value, 'exponential functions not supported')), e.styleSpec.$version >= 8 && (c && !e.valueSpec['property-function'] ? f.push(new Xn(e.key, e.value, 'property functions not supported')) : u && !e.valueSpec['zoom-function'] && e.objectKey !== 'heatmap-color' && e.objectKey !== 'line-gradient' && f.push(new Xn(e.key, e.value, 'zoom functions not supported'))), s !== 'categorical' && !p || void 0 !== e.value.property || f.push(new Xn(e.key, e.value, '"property" property is required')), f;
        } function me(e) { const t = (e.expressionContext === 'property' ? ue : le)(E(e.value), e.valueSpec); return t.result === 'error' ? t.value.map(t => new Xn(`${e.key}${t.key}`, e.value, t.message)) : e.expressionContext === 'property' && e.propertyKey === 'text-font' && t.value._styleExpression.expression.possibleOutputs().indexOf(void 0) !== -1 ? [new Xn(e.key, e.value, 'Invalid data expression for "text-font". Output values must be contained as literals within the expression.')] : []; } function ge(e) { const t = e.key; const n = e.value; const r = e.valueSpec; const i = []; return Array.isArray(r.values) ? r.values.indexOf(w(n)) === -1 && i.push(new Xn(t, n, `expected one of [${r.values.join(', ')}], ${JSON.stringify(n)} found`)) : Object.keys(r.values).indexOf(w(n)) === -1 && i.push(new Xn(t, n, `expected one of [${Object.keys(r.values).join(', ')}], ${JSON.stringify(n)} found`)), i; } function ye(e) { if (!Array.isArray(e) || e.length === 0) return !1; switch (e[0]) { case 'has': return e.length >= 2 && e[1] !== '$id' && e[1] !== '$type'; case 'in': case '!in': case '!has': case 'none': return !1; case '==': case '!=': case '>': case '>=': case '<': case '<=': return e.length === 3 && (Array.isArray(e[1]) || Array.isArray(e[2])); case 'any': case 'all': for (let t = 0, n = e.slice(1); t < n.length; t += 1) { const r = n[t]; if (!ye(r) && typeof r !== 'boolean') return !1; } return !0; default: return !0; } } function ve(e) { if (!e) return function () { return !0; }; ye(e) || (e = be(e)); const t = le(e, Qr); if (t.result === 'error') throw new Error(t.value.map(e => `${e.key}: ${e.message}`).join(', ')); return function (e, n) { return t.value.evaluate(e, n); }; } function _e(e, t) { return e < t ? -1 : e > t ? 1 : 0; } function be(e) { if (!e) return !0; let t; const n = e[0]; return e.length <= 1 ? n !== 'any' : n === '==' ? xe(e[1], e[2], '==') : n === '!=' ? Te(xe(e[1], e[2], '==')) : n === '<' || n === '>' || n === '<=' || n === '>=' ? xe(e[1], e[2], n) : n === 'any' ? (t = e.slice(1), ['any'].concat(t.map(be))) : n === 'all' ? ['all'].concat(e.slice(1).map(be)) : n === 'none' ? ['all'].concat(e.slice(1).map(be).map(Te)) : n === 'in' ? we(e[1], e.slice(2)) : n === '!in' ? Te(we(e[1], e.slice(2))) : n === 'has' ? Ee(e[1]) : n !== '!has' || Te(Ee(e[1])); } function xe(e, t, n) { switch (e) { case '$type': return [`filter-type-${n}`, t]; case '$id': return [`filter-id-${n}`, t]; default: return [`filter-${n}`, e, t]; } } function we(e, t) { if (t.length === 0) return !1; switch (e) { case '$type': return ['filter-type-in', ['literal', t]]; case '$id': return ['filter-id-in', ['literal', t]]; default: return t.length > 200 && !t.some(e => typeof e !== typeof t[0]) ? ['filter-in-large', e, ['literal', t.sort(_e)]] : ['filter-in-small', e, ['literal', t]]; } } function Ee(e) { switch (e) { case '$type': return !0; case '$id': return ['filter-has-id']; default: return ['filter-has', e]; } } function Te(e) { return ['!', e]; } function ke(e) {
          return ye(E(e.value)) ? me(x({}, e, { expressionContext: 'filter', valueSpec: { value: 'boolean' } })) : (function e(t) {
            const n = t.value; const r = t.key; if (J(n) !== 'array') return [new Xn(r, n, `array expected, ${J(n)} found`)]; let i; const o = t.styleSpec; let a = []; if (n.length < 1) return [new Xn(r, n, 'filter array must have at least 1 element')]; switch (a = a.concat(ge({
              key: `${r}[0]`, value: n[0], valueSpec: o.filter_operator, style: t.style, styleSpec: t.styleSpec,
            })), w(n[0])) {
              case '<': case '<=': case '>': case '>=': n.length >= 2 && w(n[1]) === '$type' && a.push(new Xn(r, n, `"$type" cannot be use with operator "${n[0]}"`)); case '==': case '!=': n.length !== 3 && a.push(new Xn(r, n, `filter array for operator "${n[0]}" must have 3 elements`)); case 'in': case '!in': n.length >= 2 && (i = J(n[1])) !== 'string' && a.push(new Xn(`${r}[1]`, n[1], `string expected, ${i} found`)); for (let s = 2; s < n.length; s++) {
 i = J(n[s]), w(n[1]) === '$type' ? a = a.concat(ge({
                key: `${r}[${s}]`, value: n[s], valueSpec: o.geometry_type, style: t.style, styleSpec: t.styleSpec,
              })) : i !== 'string' && i !== 'number' && i !== 'boolean' && a.push(new Xn(`${r}[${s}]`, n[s], `string, number, or boolean expected, ${i } found`)); 
} break; case 'any': case 'all': case 'none': for (let l = 1; l < n.length; l++) {
                a = a.concat(e({
                  key: `${r}[${l}]`, value: n[l], style: t.style, styleSpec: t.styleSpec,
                })); 
} break; case 'has': case '!has': i = J(n[1]), n.length !== 2 ? a.push(new Xn(r, n, `filter array for "${n[0]}" operator must have 2 elements`)) : i !== 'string' && a.push(new Xn(`${r}[1]`, n[1], `string expected, ${i} found`));
            } return a;
          }(e));
        } function Ce(e, t) {
          const n = e.key; const r = e.style; const i = e.styleSpec; const o = e.value; const a = e.objectKey; const s = i[`${t}_${e.layerType}`]; if (!s) return []; const l = a.match(/^(.*)-transition$/); if (t === 'paint' && l && s[l[1]] && s[l[1]].transition) {
            return Ne({
              key: n, value: o, valueSpec: i.transition, style: r, styleSpec: i,
            });
          } let u; const c = e.valueSpec || s[a]; if (!c) return [new Xn(n, o, `unknown property "${a}"`)]; if (J(o) === 'string' && c['property-function'] && !c.tokens && (u = /^{([^}]+)}$/.exec(o))) return [new Xn(n, o, `"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(u[1])} }\`.`)]; const p = []; return e.layerType === 'symbol' && (a === 'text-field' && r && !r.glyphs && p.push(new Xn(n, o, 'use of "text-field" requires a style "glyphs" property')), a === 'text-font' && Q(E(o)) && w(o.type) === 'identity' && p.push(new Xn(n, o, '"text-font" does not support identity functions'))), p.concat(Ne({
            key: e.key, value: o, valueSpec: c, style: r, styleSpec: i, expressionContext: 'property', propertyKey: a,
          }));
        } function Se(e) { return Ce(e, 'paint'); } function Ae(e) { return Ce(e, 'layout'); } function Oe(e) {
          let t = []; const n = e.value; const r = e.key; const i = e.style; const o = e.styleSpec; n.type || n.ref || t.push(new Xn(r, n, 'either "type" or "ref" is required')); let a; let s = w(n.type); const l = w(n.ref); if (n.id) for (let u = w(n.id), c = 0; c < e.arrayIndex; c++) { const p = i.layers[c]; w(p.id) === u && t.push(new Xn(r, n.id, `duplicate layer id "${n.id}", previously used at line ${p.id.__line__}`)); } if ('ref' in n)['type', 'source', 'source-layer', 'filter', 'layout'].forEach((e) => { e in n && t.push(new Xn(r, n[e], `"${e}" is prohibited for ref layers`)); }), i.layers.forEach((e) => { w(e.id) === l && (a = e); }), a ? a.ref ? t.push(new Xn(r, n.ref, 'ref cannot reference another ref layer')) : s = w(a.type) : t.push(new Xn(r, n.ref, `ref layer "${l}" not found`)); else if (s !== 'background') if (n.source) { const f = i.sources && i.sources[n.source]; const h = f && w(f.type); f ? h === 'vector' && s === 'raster' ? t.push(new Xn(r, n.source, `layer "${n.id}" requires a raster source`)) : h === 'raster' && s !== 'raster' ? t.push(new Xn(r, n.source, `layer "${n.id}" requires a vector source`)) : h !== 'vector' || n['source-layer'] ? h === 'raster-dem' && s !== 'hillshade' ? t.push(new Xn(r, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : s !== 'line' || !n.paint || !n.paint['line-gradient'] || h === 'geojson' && f.lineMetrics || t.push(new Xn(r, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new Xn(r, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new Xn(r, n.source, `source "${n.source}" not found`)); } else t.push(new Xn(r, n, 'missing required property "source"')); return t = t.concat(pe({
            key: r,
            value: n,
            valueSpec: o.layer,
            style: e.style,
            styleSpec: e.styleSpec,
            objectElementValidators: {
              '*': function () { return []; },
              type() {
                return Ne({
                  key: `${r}.type`, value: n.type, valueSpec: o.layer.type, style: e.style, styleSpec: e.styleSpec, object: n, objectKey: 'type',
                });
              },
              filter: ke,
              layout(e) {
                return pe({
                  layer: n, key: e.key, value: e.value, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { '*': function (e) { return Ae(x({ layerType: s }, e)); } },
                });
              },
              paint(e) {
                return pe({
                  layer: n, key: e.key, value: e.value, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { '*': function (e) { return Se(x({ layerType: s }, e)); } },
                });
              },
            },
          }));
        } function Ie(e) {
          const t = e.value; const n = e.key; const r = e.styleSpec; const i = e.style; if (!t.type) return [new Xn(n, t, '"type" is required')]; const o = w(t.type); let a = []; switch (o) {
            case 'vector': case 'raster': case 'raster-dem': if (a = a.concat(pe({
              key: n, value: t, valueSpec: r[`source_${o.replace('-', '_')}`], style: e.style, styleSpec: r,
            })), 'url' in t) for (const s in t)['type', 'url', 'tileSize'].indexOf(s) < 0 && a.push(new Xn(`${n}.${s}`, t[s], `a source with a "url" property may not include a "${s}" property`)); return a; case 'geojson': return pe({
              key: n, value: t, valueSpec: r.source_geojson, style: i, styleSpec: r,
            }); case 'video': return pe({
              key: n, value: t, valueSpec: r.source_video, style: i, styleSpec: r,
            }); case 'image': return pe({
              key: n, value: t, valueSpec: r.source_image, style: i, styleSpec: r,
            }); case 'canvas': return a.push(new Xn(n, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')), a; default: return ge({
              key: `${n}.type`, value: t.type, valueSpec: { values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image'] }, style: i, styleSpec: r,
            });
          }
        } function Pe(e) {
          const t = e.value; const n = e.styleSpec; const r = n.light; const i = e.style; let o = []; const a = J(t); if (void 0 === t) return o; if (a !== 'object') return o = o.concat([new Xn('light', t, `object expected, ${a} found`)]); for (const s in t) {
            const l = s.match(/^(.*)-transition$/); o = l && r[l[1]] && r[l[1]].transition ? o.concat(Ne({
              key: s, value: t[s], valueSpec: n.transition, style: i, styleSpec: n,
            })) : r[s] ? o.concat(Ne({
              key: s, value: t[s], valueSpec: r[s], style: i, styleSpec: n,
            })) : o.concat([new Xn(s, t[s], `unknown property "${s}"`)]);
          } return o;
        } function Me(e) { const t = e.value; const n = e.key; const r = J(t); return r !== 'string' ? [new Xn(n, t, `string expected, ${r} found`)] : []; } function Ne(e) { const t = e.value; const n = e.valueSpec; const r = e.styleSpec; return n.function && Q(w(t)) ? de(e) : n.function && se(E(t)) ? me(e) : n.type && ei[n.type] ? ei[n.type](e) : pe(x({}, e, { valueSpec: n.type ? r[n.type] : n })); } function De(e) { const t = e.value; const n = e.key; const r = Me(e); return r.length ? r : (t.indexOf('{fontstack}') === -1 && r.push(new Xn(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf('{range}') === -1 && r.push(new Xn(n, t, '"glyphs" url must include a "{range}" token')), r); } function Le(e, t) {
          t = t || Kn; let n = []; return n = n.concat(Ne({
            key: '', value: e, valueSpec: t.$root, styleSpec: t, style: e, objectElementValidators: { glyphs: De, '*': function () { return []; } },
          })), e.constants && (n = n.concat(b({
            key: 'constants', value: e.constants, style: e, styleSpec: t,
          }))), ze(n);
        } function ze(e) { return [].concat(e).sort((e, t) => e.line - t.line); } function Re(e) { return function () { return ze(e.apply(this, arguments)); }; } function je(e, t) { let n = !1; if (t && t.length) for (let r = 0, i = t; r < i.length; r += 1) { const o = i[r]; e.fire(new Gn(new Error(o.message))), n = !0; } return n; } function Be(e, t, n) { const r = this.cells = []; if (e instanceof ArrayBuffer) { this.arrayBuffer = e; const i = new Int32Array(this.arrayBuffer); e = i[0], t = i[1], n = i[2], this.d = t + 2 * n; for (let o = 0; o < this.d * this.d; o++) { const a = i[ai + o]; const s = i[ai + o + 1]; r.push(a === s ? null : i.subarray(a, s)); } const l = i[ai + r.length]; const u = i[ai + r.length + 1]; this.keys = i.subarray(l, u), this.bboxes = i.subarray(u), this.insert = this._insertReadonly; } else { this.d = t + 2 * n; for (let c = 0; c < this.d * this.d; c++)r.push([]); this.keys = [], this.bboxes = []; } this.n = t, this.extent = e, this.padding = n, this.scale = t / e, this.uid = 0; const p = n / t * e; this.min = -p, this.max = e + p; } function Fe(e, t, n) { void 0 === n && (n = {}), Object.defineProperty(t, '_classRegistryKey', { value: e, writeable: !1 }), li[e] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] }; } function Ue(e, t) { if (e == null || typeof e === 'boolean' || typeof e === 'number' || typeof e === 'string' || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp) return e; if (e instanceof ArrayBuffer) return t && t.push(e), e; if (ArrayBuffer.isView(e)) { const n = e; return t && t.push(n.buffer), n; } if (e instanceof si) return t && t.push(e.data.buffer), e; if (Array.isArray(e)) { for (var r = [], i = 0, o = e; i < o.length; i += 1) { const a = o[i]; r.push(Ue(a, t)); } return r; } if (typeof e === 'object') { const s = e.constructor; const l = s._classRegistryKey; if (!l) throw new Error("can't serialize object of unregistered class"); const u = {}; if (s.serialize)u._serialized = s.serialize(e, t); else { for (const c in e) if (e.hasOwnProperty(c) && !(li[l].omit.indexOf(c) >= 0)) { const p = e[c]; u[c] = li[l].shallow.indexOf(c) >= 0 ? p : Ue(p, t); }e instanceof Error && (u.message = e.message); } return { name: l, properties: u }; } throw new Error(`can't serialize object of type ${typeof e}`); } function Ve(e) { if (e == null || typeof e === 'boolean' || typeof e === 'number' || typeof e === 'string' || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp || e instanceof ArrayBuffer || ArrayBuffer.isView(e) || e instanceof si) return e; if (Array.isArray(e)) return e.map(e => Ve(e)); if (typeof e === 'object') { const t = e; const n = t.name; const r = t.properties; if (!n) throw new Error("can't deserialize object of anonymous class"); const i = li[n].klass; if (!i) throw new Error(`can't deserialize unregistered class ${n}`); if (i.deserialize) return i.deserialize(r._serialized); for (var o = Object.create(i.prototype), a = 0, s = Object.keys(r); a < s.length; a += 1) { const l = s[a]; o[l] = li[n].shallow.indexOf(l) >= 0 ? r[l] : Ve(r[l]); } return o; } throw new Error(`can't deserialize object of type ${typeof e}`); } function qe(e) { for (let t = 0, n = e; t < n.length; t += 1) if (We(n[t].charCodeAt(0))) return !0; return !1; } function He(e) { return !fi.Arabic(e) && !fi['Arabic Supplement'](e) && !fi['Arabic Extended-A'](e) && !fi['Arabic Presentation Forms-A'](e) && !fi['Arabic Presentation Forms-B'](e); } function We(e) { return e === 746 || e === 747 || !(e < 4352) && (!!fi['Bopomofo Extended'](e) || !!fi.Bopomofo(e) || !(!fi['CJK Compatibility Forms'](e) || e >= 65097 && e <= 65103) || !!fi['CJK Compatibility Ideographs'](e) || !!fi['CJK Compatibility'](e) || !!fi['CJK Radicals Supplement'](e) || !!fi['CJK Strokes'](e) || !(!fi['CJK Symbols and Punctuation'](e) || e >= 12296 && e <= 12305 || e >= 12308 && e <= 12319 || e === 12336) || !!fi['CJK Unified Ideographs Extension A'](e) || !!fi['CJK Unified Ideographs'](e) || !!fi['Enclosed CJK Letters and Months'](e) || !!fi['Hangul Compatibility Jamo'](e) || !!fi['Hangul Jamo Extended-A'](e) || !!fi['Hangul Jamo Extended-B'](e) || !!fi['Hangul Jamo'](e) || !!fi['Hangul Syllables'](e) || !!fi.Hiragana(e) || !!fi['Ideographic Description Characters'](e) || !!fi.Kanbun(e) || !!fi['Kangxi Radicals'](e) || !!fi['Katakana Phonetic Extensions'](e) || !(!fi.Katakana(e) || e === 12540) || !(!fi['Halfwidth and Fullwidth Forms'](e) || e === 65288 || e === 65289 || e === 65293 || e >= 65306 && e <= 65310 || e === 65339 || e === 65341 || e === 65343 || e >= 65371 && e <= 65503 || e === 65507 || e >= 65512 && e <= 65519) || !(!fi['Small Form Variants'](e) || e >= 65112 && e <= 65118 || e >= 65123 && e <= 65126) || !!fi['Unified Canadian Aboriginal Syllabics'](e) || !!fi['Unified Canadian Aboriginal Syllabics Extended'](e) || !!fi['Vertical Forms'](e) || !!fi['Yijing Hexagram Symbols'](e) || !!fi['Yi Syllables'](e) || !!fi['Yi Radicals'](e)); } function $e(e) { return !(We(e) || (function (e) { return !!(fi['Latin-1 Supplement'](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || fi['General Punctuation'](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || fi['Letterlike Symbols'](e) || fi['Number Forms'](e) || fi['Miscellaneous Technical'](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || fi['Control Pictures'](e) && e !== 9251 || fi['Optical Character Recognition'](e) || fi['Enclosed Alphanumerics'](e) || fi['Geometric Shapes'](e) || fi['Miscellaneous Symbols'](e) && !(e >= 9754 && e <= 9759) || fi['Miscellaneous Symbols and Arrows'](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || fi['CJK Symbols and Punctuation'](e) || fi.Katakana(e) || fi['Private Use Area'](e) || fi['CJK Compatibility Forms'](e) || fi['Small Form Variants'](e) || fi['Halfwidth and Fullwidth Forms'](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533); }(e))); } function Ge(e, t) { return !(!t && (e >= 1424 && e <= 2303 || fi['Arabic Presentation Forms-A'](e) || fi['Arabic Presentation Forms-B'](e))) && !(e >= 2304 && e <= 3583 || e >= 3840 && e <= 4255 || fi.Khmer(e)); } function Ze(e, t) {
          void 0 === t && (t = 1); let n = 0; let r = 0; return {
            members: e.map((e) => {
              let i; const o = (i = e.type, Ni[i].BYTES_PER_ELEMENT); const a = n = Ke(n, Math.max(t, o)); const s = e.components || 1; return r = Math.max(r, o), n += o * s, {
                name: e.name, type: e.type, components: s, offset: a,
              };
            }),
            size: Ke(n, Math.max(r, t)),
            alignment: t,
          };
        } function Ke(e, t) { return Math.ceil(e / t) * t; } function Xe(e) { return [fo(255 * e.r, 255 * e.g), fo(255 * e.b, 255 * e.a)]; } function Ye(e, t) {
          return {
            'text-opacity': 'opacity', 'icon-opacity': 'opacity', 'text-color': 'fill_color', 'icon-color': 'fill_color', 'text-halo-color': 'halo_color', 'icon-halo-color': 'halo_color', 'text-halo-blur': 'halo_blur', 'icon-halo-blur': 'halo_blur', 'text-halo-width': 'halo_width', 'icon-halo-width': 'halo_width', 'line-gap-width': 'gapwidth',
          }[e] || e.replace(`${t}-`, '').replace(/-/g, '_');
        } function Je(e) { for (var t = bo / e.extent, n = e.loadGeometry(), r = 0; r < n.length; r++) for (let i = n[r], o = 0; o < i.length; o++) { const a = i[o]; a.x = Math.round(a.x * t), a.y = Math.round(a.y * t), (a.x < xo.min || a.x > xo.max || a.y < xo.min || a.y > xo.max) && d('Geometry exceeds allowed extent, reduce your vector tile buffer size'); } return n; } function Qe(e, t, n, r, i) { e.emplaceBack(2 * t + (r + 1) / 2, 2 * n + (i + 1) / 2); } function et(e, t, n) { for (let r = 0; r < e.length; r++) { const i = e[r]; if (ut(i, t)) return !0; if (at(t, i, n)) return !0; } return !1; } function tt(e, t) { if (e.length === 1 && e[0].length === 1) return lt(t, e[0][0]); for (let n = 0; n < t.length; n++) for (let r = t[n], i = 0; i < r.length; i++) if (lt(e, r[i])) return !0; for (let o = 0; o < e.length; o++) { for (var a = e[o], s = 0; s < a.length; s++) if (lt(t, a[s])) return !0; for (let l = 0; l < t.length; l++) if (it(a, t[l])) return !0; } return !1; } function nt(e, t, n) { for (let r = 0; r < t.length; r++) for (let i = t[r], o = 0; o < e.length; o++) { const a = e[o]; if (a.length >= 3) for (let s = 0; s < i.length; s++) if (ut(a, i[s])) return !0; if (rt(a, i, n)) return !0; } return !1; } function rt(e, t, n) { if (e.length > 1) { if (it(e, t)) return !0; for (let r = 0; r < t.length; r++) if (at(t[r], e, n)) return !0; } for (let i = 0; i < e.length; i++) if (at(e[i], t, n)) return !0; return !1; } function it(e, t) { if (e.length === 0 || t.length === 0) return !1; for (let n = 0; n < e.length - 1; n++) for (let r = e[n], i = e[n + 1], o = 0; o < t.length - 1; o++) if (ot(r, i, t[o], t[o + 1])) return !0; return !1; } function ot(e, t, n, r) { return m(e, n, r) !== m(t, n, r) && m(e, t, n) !== m(e, t, r); } function at(e, t, n) { const r = n * n; if (t.length === 1) return e.distSqr(t[0]) < r; for (let i = 1; i < t.length; i++) if (st(e, t[i - 1], t[i]) < r) return !0; return !1; } function st(e, t, n) { const r = t.distSqr(n); if (r === 0) return e.distSqr(t); const i = ((e.x - t.x) * (n.x - t.x) + (e.y - t.y) * (n.y - t.y)) / r; return i < 0 ? e.distSqr(t) : i > 1 ? e.distSqr(n) : e.distSqr(n.sub(t)._mult(i)._add(t)); } function lt(e, t) { for (var n, r, i, o = !1, a = 0; a < e.length; a++) for (let s = 0, l = (n = e[a]).length - 1; s < n.length; l = s++)r = n[s], i = n[l], r.y > t.y != i.y > t.y && t.x < (i.x - r.x) * (t.y - r.y) / (i.y - r.y) + r.x && (o = !o); return o; } function ut(e, t) { for (var n = !1, r = 0, i = e.length - 1; r < e.length; i = r++) { const o = e[r]; const a = e[i]; o.y > t.y != a.y > t.y && t.x < (a.x - o.x) * (t.y - o.y) / (a.y - o.y) + o.x && (n = !n); } return n; } function ct(e, t, n) { const r = t.paint.get(e).value; return r.kind === 'constant' ? r.value : n.programConfigurations.get(t.id).binders[e].statistics.max; } function pt(e) { return Math.sqrt(e[0] * e[0] + e[1] * e[1]); } function ft(e, t, n, r, i) { if (!t[0] && !t[1]) return e; const o = Bn.convert(t); n === 'viewport' && o._rotate(-r); for (var a = [], s = 0; s < e.length; s++) { for (var l = e[s], u = [], c = 0; c < l.length; c++)u.push(l[c].sub(o._mult(i))); a.push(u); } return a; } function ht(e, t, n) { const r = ko.transformMat4([], [e.x, e.y, 0, 1], t); return new Bn((r[0] / r[3] + 1) * n.width * 0.5, (r[1] / r[3] + 1) * n.height * 0.5); } function dt(e, t, n, r) { const i = t.width; const o = t.height; if (r) { if (r.length !== i * o * n) throw new RangeError('mismatched image size'); } else r = new Uint8Array(i * o * n); return e.width = i, e.height = o, e.data = r, e; } function mt(e, t, n) { const r = t.width; const i = t.height; if (r !== e.width || i !== e.height) { const o = dt({}, { width: r, height: i }, n); gt(e, o, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e.width, r), height: Math.min(e.height, i) }, n), e.width = r, e.height = i, e.data = o.data; } } function gt(e, t, n, r, i, o) { if (i.width === 0 || i.height === 0) return t; if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError('out of range source coordinates for image copy'); if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError('out of range destination coordinates for image copy'); for (let a = e.data, s = t.data, l = 0; l < i.height; l++) for (let u = ((n.y + l) * e.width + n.x) * o, c = ((r.y + l) * t.width + r.x) * o, p = 0; p < i.width * o; p++)s[c + p] = a[u + p]; return t; } function yt(e, t) { for (var n = new Uint8Array(1024), r = {}, i = 0, o = 0; i < 256; i++, o += 4) { r[t] = i / 255; const a = e.evaluate(r); n[o + 0] = Math.floor(255 * a.r / a.a), n[o + 1] = Math.floor(255 * a.g / a.a), n[o + 2] = Math.floor(255 * a.b / a.a), n[o + 3] = Math.floor(255 * a.a); } return new Io({ width: 256, height: 1 }, n); } function vt(e, t, n) { n = n || 2; let r; let i; let o; let a; let s; let l; let u; const c = t && t.length; const p = c ? t[0] * n : e.length; let f = _t(e, 0, p, n, !0); const h = []; if (!f) return h; if (c && (f = (function (e, t, n, r) { let i; let o; let a; let s; let l; const u = []; for (i = 0, o = t.length; i < o; i++)a = t[i] * r, s = i < o - 1 ? t[i + 1] * r : e.length, (l = _t(e, a, s, r, !1)) === l.next && (l.steiner = !0), u.push(Ot(l)); for (u.sort(Ct), i = 0; i < u.length; i++)St(u[i], n), n = bt(n, n.next); return n; }(e, t, f, n))), e.length > 80 * n) { r = o = e[0], i = a = e[1]; for (let d = n; d < p; d += n)(s = e[d]) < r && (r = s), (l = e[d + 1]) < i && (i = l), s > o && (o = s), l > a && (a = l); u = (u = Math.max(o - r, a - i)) !== 0 ? 1 / u : 0; } return xt(f, h, n, r, i, u), h; } function _t(e, t, n, r, i) { let o; let a; if (i === Ft(e, t, n, r) > 0) for (o = t; o < n; o += r)a = Rt(o, e[o], e[o + 1], a); else for (o = n - r; o >= t; o -= r)a = Rt(o, e[o], e[o + 1], a); return a && Nt(a, a.next) && (jt(a), a = a.next), a; } function bt(e, t) { if (!e) return e; t || (t = e); let n; let r = e; do { if (n = !1, r.steiner || !Nt(r, r.next) && Mt(r.prev, r, r.next) !== 0)r = r.next; else { if (jt(r), (r = t = r.prev) === r.next) break; n = !0; } } while (n || r !== t);return t; } function xt(e, t, n, r, i, o, a) { if (e) { !a && o && (function (e, t, n, r) { let i = e; do { i.z === null && (i.z = At(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; } while (i !== e);i.prevZ.nextZ = null, i.prevZ = null, (function (e) { let t; let n; let r; let i; let o; let a; let s; let l; let u = 1; do { for (n = e, e = null, o = null, a = 0; n;) { for (a++, r = n, s = 0, t = 0; t < u && (s++, r = r.nextZ); t++);for (l = u; s > 0 || l > 0 && r;)s !== 0 && (l === 0 || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i; n = r; }o.nextZ = null, u *= 2; } while (a > 1); }(i)); }(e, r, i, o)); for (var s, l, u = e; e.prev !== e.next;) if (s = e.prev, l = e.next, o ? Et(e, r, i, o) : wt(e))t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), jt(e), e = l.next, u = l.next; else if ((e = l) === u) { a ? a === 1 ? xt(e = Tt(e, t, n), t, n, r, i, o, 2) : a === 2 && kt(e, t, n, r, i, o) : xt(bt(e), t, n, r, i, o, 1); break; } } } function wt(e) { const t = e.prev; const n = e; const r = e.next; if (Mt(t, n, r) >= 0) return !1; for (let i = e.next.next; i !== e.prev;) { if (It(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && Mt(i.prev, i, i.next) >= 0) return !1; i = i.next; } return !0; } function Et(e, t, n, r) { const i = e.prev; const o = e; const a = e.next; if (Mt(i, o, a) >= 0) return !1; for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, l = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, u = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, c = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, p = At(s, l, t, n, r), f = At(u, c, t, n, r), h = e.prevZ, d = e.nextZ; h && h.z >= p && d && d.z <= f;) { if (h !== e.prev && h !== e.next && It(i.x, i.y, o.x, o.y, a.x, a.y, h.x, h.y) && Mt(h.prev, h, h.next) >= 0) return !1; if (h = h.prevZ, d !== e.prev && d !== e.next && It(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && Mt(d.prev, d, d.next) >= 0) return !1; d = d.nextZ; } for (;h && h.z >= p;) { if (h !== e.prev && h !== e.next && It(i.x, i.y, o.x, o.y, a.x, a.y, h.x, h.y) && Mt(h.prev, h, h.next) >= 0) return !1; h = h.prevZ; } for (;d && d.z <= f;) { if (d !== e.prev && d !== e.next && It(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && Mt(d.prev, d, d.next) >= 0) return !1; d = d.nextZ; } return !0; } function Tt(e, t, n) { let r = e; do { const i = r.prev; const o = r.next.next; !Nt(i, o) && Dt(i, r, r.next, o) && Lt(i, o) && Lt(o, i) && (t.push(i.i / n), t.push(r.i / n), t.push(o.i / n), jt(r), jt(r.next), r = e = o), r = r.next; } while (r !== e);return r; } function kt(e, t, n, r, i, o) { let a = e; do { for (let s = a.next.next; s !== a.prev;) { if (a.i !== s.i && Pt(a, s)) { let l = zt(a, s); return a = bt(a, a.next), l = bt(l, l.next), xt(a, t, n, r, i, o), void xt(l, t, n, r, i, o); }s = s.next; }a = a.next; } while (a !== e); } function Ct(e, t) { return e.x - t.x; } function St(e, t) { if (t = (function (e, t) { let n; let r = t; const i = e.x; const o = e.y; let a = -1 / 0; do { if (o <= r.y && o >= r.next.y && r.next.y !== r.y) { const s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (s <= i && s > a) { if (a = s, s === i) { if (o === r.y) return r; if (o === r.next.y) return r.next; }n = r.x < r.next.x ? r : r.next; } }r = r.next; } while (r !== t);if (!n) return null; if (i === a) return n.prev; let l; const u = n; const c = n.x; const p = n.y; let f = 1 / 0; for (r = n.next; r !== u;)i >= r.x && r.x >= c && i !== r.x && It(o < p ? i : a, o, c, p, o < p ? a : i, o, r.x, r.y) && ((l = Math.abs(o - r.y) / (i - r.x)) < f || l === f && r.x > n.x) && Lt(r, e) && (n = r, f = l), r = r.next; return n; }(e, t))) { const n = zt(t, e); bt(n, n.next); } } function At(e, t, n, r, i) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1; } function Ot(e) { let t = e; let n = e; do { t.x < n.x && (n = t), t = t.next; } while (t !== e);return n; } function It(e, t, n, r, i, o, a, s) { return (i - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (r - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0; } function Pt(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !(function (e, t) { let n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Dt(n, n.next, e, t)) return !0; n = n.next; } while (n !== e);return !1; }(e, t)) && Lt(e, t) && Lt(t, e) && (function (e, t) { let n = e; let r = !1; const i = (e.x + t.x) / 2; const o = (e.y + t.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; } while (n !== e);return r; }(e, t)); } function Mt(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y); } function Nt(e, t) { return e.x === t.x && e.y === t.y; } function Dt(e, t, n, r) { return !!(Nt(e, t) && Nt(n, r) || Nt(e, r) && Nt(n, t)) || Mt(e, t, n) > 0 != Mt(e, t, r) > 0 && Mt(n, r, e) > 0 != Mt(n, r, t) > 0; } function Lt(e, t) { return Mt(e.prev, e, e.next) < 0 ? Mt(e, t, e.next) >= 0 && Mt(e, e.prev, t) >= 0 : Mt(e, t, e.prev) < 0 || Mt(e, e.next, t) < 0; } function zt(e, t) { const n = new Bt(e.i, e.x, e.y); const r = new Bt(t.i, t.x, t.y); const i = e.next; const o = t.prev; return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r; } function Rt(e, t, n, r) { const i = new Bt(e, t, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i; } function jt(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ); } function Bt(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1; } function Ft(e, t, n, r) { for (var i = 0, o = t, a = n - r; o < n; o += r)i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o; return i; } function Ut(e, t, n, r, i) { !(function e(t, n, r, i, o) { for (;i > r;) { if (i - r > 600) { const a = i - r + 1; const s = n - r + 1; const l = Math.log(a); const u = 0.5 * Math.exp(2 * l / 3); const c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1); e(t, n, Math.max(r, Math.floor(n - s * u / a + c)), Math.min(i, Math.floor(n + (a - s) * u / a + c)), o); } const p = t[n]; let f = r; let h = i; for (Vt(t, r, n), o(t[i], p) > 0 && Vt(t, r, i); f < h;) { for (Vt(t, f, h), f++, h--; o(t[f], p) < 0;)f++; for (;o(t[h], p) > 0;)h--; }o(t[r], p) === 0 ? Vt(t, r, h) : Vt(t, ++h, i), h <= n && (r = h + 1), n <= h && (i = h - 1); } }(e, t, n || 0, r || e.length - 1, i || qt)); } function Vt(e, t, n) { const r = e[t]; e[t] = e[n], e[n] = r; } function qt(e, t) { return e < t ? -1 : e > t ? 1 : 0; } function Ht(e, t) { const n = e.length; if (n <= 1) return [e]; for (var r, i, o = [], a = 0; a < n; a++) { const s = g(e[a]); s !== 0 && (e[a].area = Math.abs(s), void 0 === i && (i = s < 0), i === s < 0 ? (r && o.push(r), r = [e[a]]) : r.push(e[a])); } if (r && o.push(r), t > 1) for (let l = 0; l < o.length; l++)o[l].length <= t || (jo(o[l], t, 1, o[l].length - 1, Wt), o[l] = o[l].slice(0, t)); return o; } function Wt(e, t) { return t.area - e.area; } function $t(e, t, n, r, i, o, a, s) { e.emplaceBack(t, n, 2 * Math.floor(r * Ho) + a, i * Ho * 2, o * Ho * 2, Math.round(s)); } function Gt(e, t) { return e.x === t.x && (e.x < 0 || e.x > bo) || e.y === t.y && (e.y < 0 || e.y > bo); } function Zt(e) { return e.every(e => e.x < 0) || e.every(e => e.x > bo) || e.every(e => e.y < 0) || e.every(e => e.y > bo); } function Kt(e, t, n, r, i) { this.properties = {}, this.extent = n, this.type = 0, this._pbf = e, this._geometry = -1, this._keys = r, this._values = i, e.readFields(Xt, this, t); } function Xt(e, t, n) { e == 1 ? t.id = n.readVarint() : e == 2 ? (function (e, t) { for (let n = e.readVarint() + e.pos; e.pos < n;) { const r = t._keys[e.readVarint()]; const i = t._values[e.readVarint()]; t.properties[r] = i; } }(n, t)) : e == 3 ? t.type = n.readVarint() : e == 4 && (t._geometry = n.pos); } function Yt(e) { for (var t, n, r = 0, i = 0, o = e.length, a = o - 1; i < o; a = i++)t = e[i], r += ((n = e[a]).x - t.x) * (t.y + n.y); return r; } function Jt(e, t) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(Qt, this, t), this.length = this._features.length; } function Qt(e, t, n) { e === 15 ? t.version = n.readVarint() : e === 1 ? t.name = n.readString() : e === 5 ? t.extent = n.readVarint() : e === 2 ? t._features.push(n.pos) : e === 3 ? t._keys.push(n.readString()) : e === 4 && t._values.push(function (e) { for (var t = null, n = e.readVarint() + e.pos; e.pos < n;) { const r = e.readVarint() >> 3; t = r === 1 ? e.readString() : r === 2 ? e.readFloat() : r === 3 ? e.readDouble() : r === 4 ? e.readVarint64() : r === 5 ? e.readVarint() : r === 6 ? e.readSVarint() : r === 7 ? e.readBoolean() : null; } return t; }(n)); } function en(e, t, n) { if (e === 3) { const r = new Xo(n, n.readVarint() + n.pos); r.length && (t[r.name] = r); } } function tn(e, t, n, r, i, o, a) { e.emplaceBack(t.x, t.y, r ? 1 : 0, i ? 1 : -1, Math.round(Qo * n.x) + 128, Math.round(Qo * n.y) + 128, 1 + (o === 0 ? 0 : o < 0 ? -1 : 1) | (a * ta & 63) << 2, a * ta >> 6); } function nn(e, t) { return (e / t.tileTotal * (t.end - t.start) + t.start) * (na - 1); } function rn(e, t) { return t > 0 ? t + 2 * e : e; } function on(e, t, n) { const r = t.layout.get('text-transform').evaluate(n); return r === 'uppercase' ? e = e.toLocaleUpperCase() : r === 'lowercase' && (e = e.toLocaleLowerCase()), yi.applyArabicShaping && (e = yi.applyArabicShaping(e)), e; } function an(e, t) {
          const n = t.expression; if (n.kind === 'constant') return { functionType: 'constant', layoutSize: n.evaluate(new vi(e + 1)) }; if (n.kind === 'source') return { functionType: 'source' }; for (var r = n.zoomStops, i = 0; i < r.length && r[i] <= e;)i++; for (var o = i = Math.max(0, i - 1); o < r.length && r[o] < e + 1;)o++; o = Math.min(r.length - 1, o); const a = { min: r[i], max: r[o] }; return n.kind === 'composite' ? { functionType: 'composite', zoomRange: a, propertyValue: t.value } : {
            functionType: 'camera', layoutSize: n.evaluate(new vi(e + 1)), zoomRange: a, sizeRange: { min: n.evaluate(new vi(a.min)), max: n.evaluate(new vi(a.max)) }, propertyValue: t.value,
          };
        } function sn(e, t, n, r, i, o, a, s) { e.emplaceBack(t, n, Math.round(32 * r), Math.round(32 * i), o, a, s ? s[0] : 0, s ? s[1] : 0); } function ln(e, t, n) { e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n); } function un(e) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.length = this.buf.length; } function cn(e) { return e.type === un.Bytes ? e.readVarint() + e.pos : e.pos + 1; } function pn(e, t, n) { return n ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0); } function fn(e, t, n) { const r = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.ceil(Math.log(t) / (7 * Math.LN2)); n.realloc(r); for (let i = n.pos - 1; i >= e; i--)n.buf[i + r] = n.buf[i]; } function hn(e, t) { for (let n = 0; n < e.length; n++)t.writeVarint(e[n]); } function dn(e, t) { for (let n = 0; n < e.length; n++)t.writeSVarint(e[n]); } function mn(e, t) { for (let n = 0; n < e.length; n++)t.writeFloat(e[n]); } function gn(e, t) { for (let n = 0; n < e.length; n++)t.writeDouble(e[n]); } function yn(e, t) { for (let n = 0; n < e.length; n++)t.writeBoolean(e[n]); } function vn(e, t) { for (let n = 0; n < e.length; n++)t.writeFixed32(e[n]); } function _n(e, t) { for (let n = 0; n < e.length; n++)t.writeSFixed32(e[n]); } function bn(e, t) { for (let n = 0; n < e.length; n++)t.writeFixed64(e[n]); } function xn(e, t) { for (let n = 0; n < e.length; n++)t.writeSFixed64(e[n]); } function wn(e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 16777216 * e[t + 3]; } function En(e, t, n) { e[n] = t, e[n + 1] = t >>> 8, e[n + 2] = t >>> 16, e[n + 3] = t >>> 24; } function Tn(e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24); } function kn(e, t, n) { e === 1 && n.readMessage(Cn, t); } function Cn(e, t, n) {
          if (e === 3) {
            const r = n.readMessage(Sn, {}); const i = r.id; const o = r.bitmap; const a = r.width; const s = r.height; const l = r.left; const u = r.top; const c = r.advance; t.push({
              id: i,
              bitmap: new Oo({ width: a + 2 * Da, height: s + 2 * Da }, o),
              metrics: {
                width: a, height: s, left: l, top: u, advance: c,
              },
            });
          }
        } function Sn(e, t, n) { e === 1 ? t.id = n.readVarint() : e === 2 ? t.bitmap = n.readBytes() : e === 3 ? t.width = n.readVarint() : e === 4 ? t.height = n.readVarint() : e === 5 ? t.left = n.readSVarint() : e === 6 ? t.top = n.readSVarint() : e === 7 && (t.advance = n.readVarint()); } function An(e, t, n, r) { (e *= 2) < 0 && (e = -1 * e - 1); const i = 1 << t; return 32 * (i * i * e + i * r + n) + t; } function On(e, t) { return t - e; } function In(e, t, n, r) { const i = Math.pow(e - t, 2); return r ? e < t ? i / 2 : 2 * i : i + Math.abs(n) * n; } function Pn(e, t) { let n = 0; return e === 10 && (n -= 1e4), e !== 40 && e !== 65288 || (n += 50), t !== 41 && t !== 65289 || (n += 50), n; } function Mn(e, t, n, r, i, o) {
          for (var a = null, s = In(t, n, i, o), l = 0, u = r; l < u.length; l += 1) { const c = u[l]; const p = In(t - c.x, n, i, o) + c.badness; p <= s && (a = c, s = p); } return {
            index: e, x: t, priorBreak: a, badness: s,
          };
        } function Nn(e, t, n, r) { if (!n) return []; if (!e) return []; for (var i, o = [], a = (function (e, t, n, r) { for (var i = 0, o = 0; o < e.length; o++) { const a = r[e.charCodeAt(o)]; a && (i += a.metrics.advance + t); } return i / Math.max(1, Math.ceil(i / n)); }(e, t, n, r)), s = 0, l = 0; l < e.length; l++) { const u = e.charCodeAt(l); const c = r[u]; c && !Za[u] && (s += c.metrics.advance + t), l < e.length - 1 && (Ka[u] || !((i = u) < 11904) && (fi['Bopomofo Extended'](i) || fi.Bopomofo(i) || fi['CJK Compatibility Forms'](i) || fi['CJK Compatibility Ideographs'](i) || fi['CJK Compatibility'](i) || fi['CJK Radicals Supplement'](i) || fi['CJK Strokes'](i) || fi['CJK Symbols and Punctuation'](i) || fi['CJK Unified Ideographs Extension A'](i) || fi['CJK Unified Ideographs'](i) || fi['Enclosed CJK Letters and Months'](i) || fi['Halfwidth and Fullwidth Forms'](i) || fi.Hiragana(i) || fi['Ideographic Description Characters'](i) || fi['Kangxi Radicals'](i) || fi['Katakana Phonetic Extensions'](i) || fi.Katakana(i) || fi['Vertical Forms'](i) || fi['Yi Radicals'](i) || fi['Yi Syllables'](i))) && o.push(Mn(l + 1, s, a, o, Pn(u, e.charCodeAt(l + 1)), !1)); } return (function e(t) { return t ? e(t.priorBreak).concat(t.index) : []; }(Mn(e.length, s, a, o, 0, !0))); } function Dn(e) { let t = 0.5; let n = 0.5; switch (e) { case 'right': case 'top-right': case 'bottom-right': t = 1; break; case 'left': case 'top-left': case 'bottom-left': t = 0; } switch (e) { case 'bottom': case 'bottom-right': case 'bottom-left': n = 1; break; case 'top': case 'top-right': case 'top-left': n = 0; } return { horizontalAlign: t, verticalAlign: n }; } function Ln(e, t, n, r, i) { if (i) { const o = t[e[r].glyph]; if (o) for (let a = o.metrics.advance, s = (e[r].x + a) * i, l = n; l <= r; l++)e[l].x -= s; } } const zn = typeof window !== 'undefined' ? window : typeof t !== 'undefined' ? t : typeof self !== 'undefined' ? self : {}; var Rn = i; i.prototype.sampleCurveX = function (e) { return ((this.ax * e + this.bx) * e + this.cx) * e; }, i.prototype.sampleCurveY = function (e) { return ((this.ay * e + this.by) * e + this.cy) * e; }, i.prototype.sampleCurveDerivativeX = function (e) { return (3 * this.ax * e + 2 * this.bx) * e + this.cx; }, i.prototype.solveCurveX = function (e, t) { let n; let r; let i; let o; let a; for (void 0 === t && (t = 1e-6), i = e, a = 0; a < 8; a++) { if (o = this.sampleCurveX(i) - e, Math.abs(o) < t) return i; const s = this.sampleCurveDerivativeX(i); if (Math.abs(s) < 1e-6) break; i -= o / s; } if ((i = e) < (n = 0)) return n; if (i > (r = 1)) return r; for (;n < r;) { if (o = this.sampleCurveX(i), Math.abs(o - e) < t) return i; e > o ? n = i : r = i, i = 0.5 * (r - n) + n; } return i; }, i.prototype.solve = function (e, t) { return this.sampleCurveY(this.solveCurveX(e, t)); }; const jn = function (e, t, n) { this.column = e, this.row = t, this.zoom = n; }; jn.prototype.clone = function () { return new jn(this.column, this.row, this.zoom); }, jn.prototype.zoomTo = function (e) { return this.clone()._zoomTo(e); }, jn.prototype.sub = function (e) { return this.clone()._sub(e); }, jn.prototype._zoomTo = function (e) { const t = Math.pow(2, e - this.zoom); return this.column *= t, this.row *= t, this.zoom = e, this; }, jn.prototype._sub = function (e) { return e = e.zoomTo(this.zoom), this.column -= e.column, this.row -= e.row, this; }; var Bn = o; o.prototype = {
          clone() { return new o(this.x, this.y); }, add(e) { return this.clone()._add(e); }, sub(e) { return this.clone()._sub(e); }, multByPoint(e) { return this.clone()._multByPoint(e); }, divByPoint(e) { return this.clone()._divByPoint(e); }, mult(e) { return this.clone()._mult(e); }, div(e) { return this.clone()._div(e); }, rotate(e) { return this.clone()._rotate(e); }, rotateAround(e, t) { return this.clone()._rotateAround(e, t); }, matMult(e) { return this.clone()._matMult(e); }, unit() { return this.clone()._unit(); }, perp() { return this.clone()._perp(); }, round() { return this.clone()._round(); }, mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }, equals(e) { return this.x === e.x && this.y === e.y; }, dist(e) { return Math.sqrt(this.distSqr(e)); }, distSqr(e) { const t = e.x - this.x; const n = e.y - this.y; return t * t + n * n; }, angle() { return Math.atan2(this.y, this.x); }, angleTo(e) { return Math.atan2(this.y - e.y, this.x - e.x); }, angleWith(e) { return this.angleWithSep(e.x, e.y); }, angleWithSep(e, t) { return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t); }, _matMult(e) { const t = e[0] * this.x + e[1] * this.y; const n = e[2] * this.x + e[3] * this.y; return this.x = t, this.y = n, this; }, _add(e) { return this.x += e.x, this.y += e.y, this; }, _sub(e) { return this.x -= e.x, this.y -= e.y, this; }, _mult(e) { return this.x *= e, this.y *= e, this; }, _div(e) { return this.x /= e, this.y /= e, this; }, _multByPoint(e) { return this.x *= e.x, this.y *= e.y, this; }, _divByPoint(e) { return this.x /= e.x, this.y /= e.y, this; }, _unit() { return this._div(this.mag()), this; }, _perp() { const e = this.y; return this.y = this.x, this.x = -e, this; }, _rotate(e) { const t = Math.cos(e); const n = Math.sin(e); const r = t * this.x - n * this.y; const i = n * this.x + t * this.y; return this.x = r, this.y = i, this; }, _rotateAround(e, t) { const n = Math.cos(e); const r = Math.sin(e); const i = t.x + n * (this.x - t.x) - r * (this.y - t.y); const o = t.y + r * (this.x - t.x) + n * (this.y - t.y); return this.x = i, this.y = o, this; }, _round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this; },
        }, o.convert = function (e) { return e instanceof o ? e : Array.isArray(e) ? new o(e[0], e[1]) : e; }; const Fn = a(0.25, 0.1, 0.25, 1); let Un = 1; var Vn = {}; const qn = {
          Unknown: 'Unknown', Style: 'Style', Source: 'Source', Tile: 'Tile', Glyphs: 'Glyphs', SpriteImage: 'SpriteImage', SpriteJSON: 'SpriteJSON', Image: 'Image',
        }; typeof Object.freeze === 'function' && Object.freeze(qn); const Hn = (function (e) { function t(t, n, r) { e.call(this, t), this.status = n, this.url = r, this.name = this.constructor.name, this.message = t; } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.toString = function () { return `${this.name}: ${this.message} (${this.status}): ${this.url}`; }, t; }(Error)); const Wn = function (e, t) { const n = y(e); return n.responseType = 'arraybuffer', n.onerror = function () { t(new Error(n.statusText)); }, n.onload = function () { const r = n.response; if (r.byteLength === 0 && n.status === 200) return t(new Error('http status 200 returned without content.')); n.status >= 200 && n.status < 300 && n.response ? t(null, { data: r, cacheControl: n.getResponseHeader('Cache-Control'), expires: n.getResponseHeader('Expires') }) : t(new Hn(n.statusText, n.status, e.url)); }, n.send(), n; }; const $n = function (e, t) { void 0 === t && (t = {}), l(this, t), this.type = e; }; var Gn = (function (e) { function t(t, n) { void 0 === n && (n = {}), e.call(this, 'error', l({ error: t }, n)); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t; }($n)); const Zn = function () {}; Zn.prototype.on = function (e, t) { return this._listeners = this._listeners || {}, v(e, t, this._listeners), this; }, Zn.prototype.off = function (e, t) { return _(e, t, this._listeners), _(e, t, this._oneTimeListeners), this; }, Zn.prototype.once = function (e, t) { return this._oneTimeListeners = this._oneTimeListeners || {}, v(e, t, this._oneTimeListeners), this; }, Zn.prototype.fire = function (e) { typeof e === 'string' && (e = new $n(e, arguments[1] || {})); const t = e.type; if (this.listens(t)) { e.target = this; for (let n = 0, r = this._listeners && this._listeners[t] ? this._listeners[t].slice() : []; n < r.length; n += 1)r[n].call(this, e); for (let i = 0, o = this._oneTimeListeners && this._oneTimeListeners[t] ? this._oneTimeListeners[t].slice() : []; i < o.length; i += 1) { const a = o[i]; _(t, a, this._oneTimeListeners), a.call(this, e); } const s = this._eventedParent; s && (l(e, typeof this._eventedParentData === 'function' ? this._eventedParentData() : this._eventedParentData), s.fire(e)); } else c(t, 'error') ? console.error(e && e.error || e || 'Empty error event') : c(t, 'warning') && console.warn(e && e.warning || e || 'Empty warning event'); return this; }, Zn.prototype.listens = function (e) { return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e); }, Zn.prototype.setEventedParent = function (e, t) { return this._eventedParent = e, this._eventedParentData = t, this; }; var Kn = {
          $version: 8,
          $root: {
            version: { required: !0, type: 'enum', values: [8] },
            name: { type: 'string' },
            metadata: { type: '*' },
            center: { type: 'array', value: 'number' },
            zoom: { type: 'number' },
            bearing: {
              type: 'number', default: 0, period: 360, units: 'degrees',
            },
            pitch: { type: 'number', default: 0, units: 'degrees' },
            light: { type: 'light' },
            sources: { required: !0, type: 'sources' },
            sprite: { type: 'string' },
            glyphs: { type: 'string' },
            transition: { type: 'transition' },
            layers: { required: !0, type: 'array', value: 'layer' },
          },
          sources: { '*': { type: 'source' } },
          source: ['source_vector', 'source_raster', 'source_raster_dem', 'source_geojson', 'source_video', 'source_image'],
          source_vector: {
            type: { required: !0, type: 'enum', values: { vector: {} } },
            url: { type: 'string' },
            tiles: { type: 'array', value: 'string' },
            bounds: {
              type: 'array', value: 'number', length: 4, default: [-180, -85.0511, 180, 85.0511],
            },
            minzoom: { type: 'number', default: 0 },
            maxzoom: { type: 'number', default: 22 },
            attribution: { type: 'string' },
            '*': { type: '*' },
          },
          source_raster: {
            type: { required: !0, type: 'enum', values: { raster: {} } },
            url: { type: 'string' },
            tiles: { type: 'array', value: 'string' },
            bounds: {
              type: 'array', value: 'number', length: 4, default: [-180, -85.0511, 180, 85.0511],
            },
            minzoom: { type: 'number', default: 0 },
            maxzoom: { type: 'number', default: 22 },
            tileSize: { type: 'number', default: 512, units: 'pixels' },
            scheme: { type: 'enum', values: { xyz: {}, tms: {} }, default: 'xyz' },
            attribution: { type: 'string' },
            '*': { type: '*' },
          },
          source_raster_dem: {
            type: { required: !0, type: 'enum', values: { 'raster-dem': {} } },
            url: { type: 'string' },
            tiles: { type: 'array', value: 'string' },
            bounds: {
              type: 'array', value: 'number', length: 4, default: [-180, -85.0511, 180, 85.0511],
            },
            minzoom: { type: 'number', default: 0 },
            maxzoom: { type: 'number', default: 22 },
            tileSize: { type: 'number', default: 512, units: 'pixels' },
            attribution: { type: 'string' },
            encoding: { type: 'enum', values: { terrarium: {}, mapbox: {} }, default: 'mapbox' },
            '*': { type: '*' },
          },
          source_geojson: {
            type: { required: !0, type: 'enum', values: { geojson: {} } },
            data: { type: '*' },
            maxzoom: { type: 'number', default: 18 },
            buffer: {
              type: 'number', default: 128, maximum: 512, minimum: 0,
            },
            tolerance: { type: 'number', default: 0.375 },
            cluster: { type: 'boolean', default: !1 },
            clusterRadius: { type: 'number', default: 50, minimum: 0 },
            clusterMaxZoom: { type: 'number' },
            lineMetrics: { type: 'boolean', default: !1 },
          },
          source_video: {
            type: { required: !0, type: 'enum', values: { video: {} } },
            urls: { required: !0, type: 'array', value: 'string' },
            coordinates: {
              required: !0, type: 'array', length: 4, value: { type: 'array', length: 2, value: 'number' },
            },
          },
          source_image: {
            type: { required: !0, type: 'enum', values: { image: {} } },
            url: { required: !0, type: 'string' },
            coordinates: {
              required: !0, type: 'array', length: 4, value: { type: 'array', length: 2, value: 'number' },
            },
          },
          layer: {
            id: { type: 'string', required: !0 },
            type: {
              type: 'enum',
              values: {
                fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, 'fill-extrusion': {}, raster: {}, hillshade: {}, background: {},
              },
              required: !0,
            },
            metadata: { type: '*' },
            source: { type: 'string' },
            'source-layer': { type: 'string' },
            minzoom: { type: 'number', minimum: 0, maximum: 24 },
            maxzoom: { type: 'number', minimum: 0, maximum: 24 },
            filter: { type: 'filter' },
            layout: { type: 'layout' },
            paint: { type: 'paint' },
          },
          layout: ['layout_fill', 'layout_line', 'layout_circle', 'layout_heatmap', 'layout_fill-extrusion', 'layout_symbol', 'layout_raster', 'layout_hillshade', 'layout_background'],
          layout_background: { visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' } },
          layout_fill: { visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' } },
          layout_circle: { visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' } },
          layout_heatmap: { visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' } },
          layout_line: {
            'line-cap': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { butt: {}, round: {}, square: {} }, default: 'butt',
            },
            'line-join': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, 'property-function': !0, values: { bevel: {}, round: {}, miter: {} }, default: 'miter',
            },
            'line-miter-limit': {
              type: 'number', default: 2, function: 'interpolated', 'zoom-function': !0, requires: [{ 'line-join': 'miter' }],
            },
            'line-round-limit': {
              type: 'number', default: 1.05, function: 'interpolated', 'zoom-function': !0, requires: [{ 'line-join': 'round' }],
            },
            visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' },
          },
          layout_symbol: {
            'symbol-placement': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { point: {}, line: {} }, default: 'point',
            },
            'symbol-spacing': {
              type: 'number', default: 250, minimum: 1, function: 'interpolated', 'zoom-function': !0, units: 'pixels', requires: [{ 'symbol-placement': 'line' }],
            },
            'symbol-avoid-edges': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1,
            },
            'icon-allow-overlap': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1, requires: ['icon-image'],
            },
            'icon-ignore-placement': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1, requires: ['icon-image'],
            },
            'icon-optional': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1, requires: ['icon-image', 'text-field'],
            },
            'icon-rotation-alignment': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {}, auto: {} }, default: 'auto', requires: ['icon-image'],
            },
            'icon-size': {
              type: 'number', default: 1, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, units: 'factor of the original icon size', requires: ['icon-image'],
            },
            'icon-text-fit': {
              type: 'enum',
              function: 'piecewise-constant',
              'zoom-function': !0,
              values: {
                none: {}, width: {}, height: {}, both: {},
              },
              default: 'none',
              requires: ['icon-image', 'text-field'],
            },
            'icon-text-fit-padding': {
              type: 'array', value: 'number', length: 4, default: [0, 0, 0, 0], units: 'pixels', function: 'interpolated', 'zoom-function': !0, requires: ['icon-image', 'text-field', { 'icon-text-fit': ['both', 'width', 'height'] }],
            },
            'icon-image': {
              type: 'string', function: 'piecewise-constant', 'zoom-function': !0, 'property-function': !0, tokens: !0,
            },
            'icon-rotate': {
              type: 'number', default: 0, period: 360, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, units: 'degrees', requires: ['icon-image'],
            },
            'icon-padding': {
              type: 'number', default: 2, minimum: 0, function: 'interpolated', 'zoom-function': !0, units: 'pixels', requires: ['icon-image'],
            },
            'icon-keep-upright': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1, requires: ['icon-image', { 'icon-rotation-alignment': 'map' }, { 'symbol-placement': 'line' }],
            },
            'icon-offset': {
              type: 'array', value: 'number', length: 2, default: [0, 0], function: 'interpolated', 'zoom-function': !0, 'property-function': !0, requires: ['icon-image'],
            },
            'icon-anchor': {
              type: 'enum',
              function: 'piecewise-constant',
              'zoom-function': !0,
              'property-function': !0,
              values: {
                center: {}, left: {}, right: {}, top: {}, bottom: {}, 'top-left': {}, 'top-right': {}, 'bottom-left': {}, 'bottom-right': {},
              },
              default: 'center',
              requires: ['icon-image'],
            },
            'icon-pitch-alignment': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {}, auto: {} }, default: 'auto', requires: ['icon-image'],
            },
            'text-pitch-alignment': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {}, auto: {} }, default: 'auto', requires: ['text-field'],
            },
            'text-rotation-alignment': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {}, auto: {} }, default: 'auto', requires: ['text-field'],
            },
            'text-field': {
              type: 'string', function: 'piecewise-constant', 'zoom-function': !0, 'property-function': !0, default: '', tokens: !0,
            },
            'text-font': {
              type: 'array', value: 'string', function: 'piecewise-constant', 'zoom-function': !0, 'property-function': !0, default: ['Open Sans Regular', 'Arial Unicode MS Regular'], requires: ['text-field'],
            },
            'text-size': {
              type: 'number', default: 16, minimum: 0, units: 'pixels', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, requires: ['text-field'],
            },
            'text-max-width': {
              type: 'number', default: 10, minimum: 0, units: 'ems', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, requires: ['text-field'],
            },
            'text-line-height': {
              type: 'number', default: 1.2, units: 'ems', function: 'interpolated', 'zoom-function': !0, requires: ['text-field'],
            },
            'text-letter-spacing': {
              type: 'number', default: 0, units: 'ems', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, requires: ['text-field'],
            },
            'text-justify': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, 'property-function': !0, values: { left: {}, center: {}, right: {} }, default: 'center', requires: ['text-field'],
            },
            'text-anchor': {
              type: 'enum',
              function: 'piecewise-constant',
              'zoom-function': !0,
              'property-function': !0,
              values: {
                center: {}, left: {}, right: {}, top: {}, bottom: {}, 'top-left': {}, 'top-right': {}, 'bottom-left': {}, 'bottom-right': {},
              },
              default: 'center',
              requires: ['text-field'],
            },
            'text-max-angle': {
              type: 'number', default: 45, units: 'degrees', function: 'interpolated', 'zoom-function': !0, requires: ['text-field', { 'symbol-placement': 'line' }],
            },
            'text-rotate': {
              type: 'number', default: 0, period: 360, units: 'degrees', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, requires: ['text-field'],
            },
            'text-padding': {
              type: 'number', default: 2, minimum: 0, units: 'pixels', function: 'interpolated', 'zoom-function': !0, requires: ['text-field'],
            },
            'text-keep-upright': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !0, requires: ['text-field', { 'text-rotation-alignment': 'map' }, { 'symbol-placement': 'line' }],
            },
            'text-transform': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, 'property-function': !0, values: { none: {}, uppercase: {}, lowercase: {} }, default: 'none', requires: ['text-field'],
            },
            'text-offset': {
              type: 'array', value: 'number', units: 'ems', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, length: 2, default: [0, 0], requires: ['text-field'],
            },
            'text-allow-overlap': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1, requires: ['text-field'],
            },
            'text-ignore-placement': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1, requires: ['text-field'],
            },
            'text-optional': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !1, requires: ['text-field', 'icon-image'],
            },
            visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' },
          },
          layout_raster: { visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' } },
          layout_hillshade: { visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' } },
          filter: { type: 'array', value: '*' },
          filter_operator: {
            type: 'enum',
            values: {
              '==': {}, '!=': {}, '>': {}, '>=': {}, '<': {}, '<=': {}, in: {}, '!in': {}, all: {}, any: {}, none: {}, has: {}, '!has': {},
            },
          },
          geometry_type: { type: 'enum', values: { Point: {}, LineString: {}, Polygon: {} } },
          function_stop: {
            type: 'array', minimum: 0, maximum: 22, value: ['number', 'color'], length: 2,
          },
          expression: { type: 'array', value: '*', minimum: 1 },
          expression_name: {
            type: 'enum',
            values: {
              let: { group: 'Variable binding' }, var: { group: 'Variable binding' }, literal: { group: 'Types' }, array: { group: 'Types' }, at: { group: 'Lookup' }, case: { group: 'Decision' }, match: { group: 'Decision' }, coalesce: { group: 'Decision' }, step: { group: 'Ramps, scales, curves' }, interpolate: { group: 'Ramps, scales, curves' }, ln2: { group: 'Math' }, pi: { group: 'Math' }, e: { group: 'Math' }, typeof: { group: 'Types' }, string: { group: 'Types' }, number: { group: 'Types' }, boolean: { group: 'Types' }, object: { group: 'Types' }, collator: { group: 'Types' }, 'to-string': { group: 'Types' }, 'to-number': { group: 'Types' }, 'to-boolean': { group: 'Types' }, 'to-rgba': { group: 'Color' }, 'to-color': { group: 'Types' }, rgb: { group: 'Color' }, rgba: { group: 'Color' }, get: { group: 'Lookup' }, has: { group: 'Lookup' }, length: { group: 'Lookup' }, properties: { group: 'Feature data' }, 'geometry-type': { group: 'Feature data' }, id: { group: 'Feature data' }, zoom: { group: 'Zoom' }, 'heatmap-density': { group: 'Heatmap' }, 'line-progress': { group: 'Heatmap' }, '+': { group: 'Math' }, '*': { group: 'Math' }, '-': { group: 'Math' }, '/': { group: 'Math' }, '%': { group: 'Math' }, '^': { group: 'Math' }, sqrt: { group: 'Math' }, log10: { group: 'Math' }, ln: { group: 'Math' }, log2: { group: 'Math' }, sin: { group: 'Math' }, cos: { group: 'Math' }, tan: { group: 'Math' }, asin: { group: 'Math' }, acos: { group: 'Math' }, atan: { group: 'Math' }, min: { group: 'Math' }, max: { group: 'Math' }, round: { group: 'Math' }, abs: { group: 'Math' }, ceil: { group: 'Math' }, floor: { group: 'Math' }, '==': { group: 'Decision' }, '!=': { group: 'Decision' }, '>': { group: 'Decision' }, '<': { group: 'Decision' }, '>=': { group: 'Decision' }, '<=': { group: 'Decision' }, all: { group: 'Decision' }, any: { group: 'Decision' }, '!': { group: 'Decision' }, 'is-supported-script': { group: 'String' }, upcase: { group: 'String' }, downcase: { group: 'String' }, concat: { group: 'String' }, 'resolved-locale': { group: 'String' },
            },
          },
          light: {
            anchor: {
              type: 'enum', default: 'viewport', values: { map: {}, viewport: {} }, transition: !1, 'zoom-function': !0, 'property-function': !1, function: 'piecewise-constant',
            },
            position: {
              type: 'array', default: [1.15, 210, 30], length: 3, value: 'number', transition: !0, function: 'interpolated', 'zoom-function': !0, 'property-function': !1,
            },
            color: {
              type: 'color', default: '#ffffff', function: 'interpolated', 'zoom-function': !0, 'property-function': !1, transition: !0,
            },
            intensity: {
              type: 'number', default: 0.5, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, 'property-function': !1, transition: !0,
            },
          },
          paint: ['paint_fill', 'paint_line', 'paint_circle', 'paint_heatmap', 'paint_fill-extrusion', 'paint_symbol', 'paint_raster', 'paint_hillshade', 'paint_background'],
          paint_fill: {
            'fill-antialias': {
              type: 'boolean', function: 'piecewise-constant', 'zoom-function': !0, default: !0,
            },
            'fill-opacity': {
              type: 'number', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, default: 1, minimum: 0, maximum: 1, transition: !0,
            },
            'fill-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: [{ '!': 'fill-pattern' }],
            },
            'fill-outline-color': {
              type: 'color', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: [{ '!': 'fill-pattern' }, { 'fill-antialias': !0 }],
            },
            'fill-translate': {
              type: 'array', value: 'number', length: 2, default: [0, 0], function: 'interpolated', 'zoom-function': !0, transition: !0, units: 'pixels',
            },
            'fill-translate-anchor': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'map', requires: ['fill-translate'],
            },
            'fill-pattern': {
              type: 'string', function: 'piecewise-constant', 'zoom-function': !0, transition: !0,
            },
          },
          paint_line: {
            'line-opacity': {
              type: 'number', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, default: 1, minimum: 0, maximum: 1, transition: !0,
            },
            'line-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: [{ '!': 'line-pattern' }],
            },
            'line-translate': {
              type: 'array', value: 'number', length: 2, default: [0, 0], function: 'interpolated', 'zoom-function': !0, transition: !0, units: 'pixels',
            },
            'line-translate-anchor': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'map', requires: ['line-translate'],
            },
            'line-width': {
              type: 'number', default: 1, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels',
            },
            'line-gap-width': {
              type: 'number', default: 0, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels',
            },
            'line-offset': {
              type: 'number', default: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels',
            },
            'line-blur': {
              type: 'number', default: 0, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels',
            },
            'line-dasharray': {
              type: 'array', value: 'number', function: 'piecewise-constant', 'zoom-function': !0, minimum: 0, transition: !0, units: 'line widths', requires: [{ '!': 'line-pattern' }],
            },
            'line-pattern': {
              type: 'string', function: 'piecewise-constant', 'zoom-function': !0, transition: !0,
            },
            'line-gradient': {
              type: 'color', function: 'interpolated', 'zoom-function': !1, 'property-function': !1, transition: !1, requires: [{ '!': 'line-dasharray' }, { '!': 'line-pattern' }, { source: 'geojson', has: { lineMetrics: !0 } }],
            },
          },
          paint_circle: {
            'circle-radius': {
              type: 'number', default: 5, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels',
            },
            'circle-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0,
            },
            'circle-blur': {
              type: 'number', default: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0,
            },
            'circle-opacity': {
              type: 'number', default: 1, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0,
            },
            'circle-translate': {
              type: 'array', value: 'number', length: 2, default: [0, 0], function: 'interpolated', 'zoom-function': !0, transition: !0, units: 'pixels',
            },
            'circle-translate-anchor': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'map', requires: ['circle-translate'],
            },
            'circle-pitch-scale': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'map',
            },
            'circle-pitch-alignment': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'viewport',
            },
            'circle-stroke-width': {
              type: 'number', default: 0, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels',
            },
            'circle-stroke-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0,
            },
            'circle-stroke-opacity': {
              type: 'number', default: 1, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0,
            },
          },
          paint_heatmap: {
            'heatmap-radius': {
              type: 'number', default: 30, minimum: 1, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels',
            },
            'heatmap-weight': {
              type: 'number', default: 1, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !1,
            },
            'heatmap-intensity': {
              type: 'number', default: 1, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !1, transition: !0,
            },
            'heatmap-color': {
              type: 'color', default: ['interpolate', ['linear'], ['heatmap-density'], 0, 'rgba(0, 0, 255, 0)', 0.1, 'royalblue', 0.3, 'cyan', 0.5, 'lime', 0.7, 'yellow', 1, 'red'], function: 'interpolated', 'zoom-function': !1, 'property-function': !1, transition: !1,
            },
            'heatmap-opacity': {
              type: 'number', default: 1, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, 'property-function': !1, transition: !0,
            },
          },
          paint_symbol: {
            'icon-opacity': {
              type: 'number', default: 1, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: ['icon-image'],
            },
            'icon-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: ['icon-image'],
            },
            'icon-halo-color': {
              type: 'color', default: 'rgba(0, 0, 0, 0)', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: ['icon-image'],
            },
            'icon-halo-width': {
              type: 'number', default: 0, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels', requires: ['icon-image'],
            },
            'icon-halo-blur': {
              type: 'number', default: 0, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels', requires: ['icon-image'],
            },
            'icon-translate': {
              type: 'array', value: 'number', length: 2, default: [0, 0], function: 'interpolated', 'zoom-function': !0, transition: !0, units: 'pixels', requires: ['icon-image'],
            },
            'icon-translate-anchor': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'map', requires: ['icon-image', 'icon-translate'],
            },
            'text-opacity': {
              type: 'number', default: 1, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: ['text-field'],
            },
            'text-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: ['text-field'],
            },
            'text-halo-color': {
              type: 'color', default: 'rgba(0, 0, 0, 0)', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: ['text-field'],
            },
            'text-halo-width': {
              type: 'number', default: 0, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels', requires: ['text-field'],
            },
            'text-halo-blur': {
              type: 'number', default: 0, minimum: 0, function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, units: 'pixels', requires: ['text-field'],
            },
            'text-translate': {
              type: 'array', value: 'number', length: 2, default: [0, 0], function: 'interpolated', 'zoom-function': !0, transition: !0, units: 'pixels', requires: ['text-field'],
            },
            'text-translate-anchor': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'map', requires: ['text-field', 'text-translate'],
            },
          },
          paint_raster: {
            'raster-opacity': {
              type: 'number', default: 1, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
            'raster-hue-rotate': {
              type: 'number', default: 0, period: 360, function: 'interpolated', 'zoom-function': !0, transition: !0, units: 'degrees',
            },
            'raster-brightness-min': {
              type: 'number', function: 'interpolated', 'zoom-function': !0, default: 0, minimum: 0, maximum: 1, transition: !0,
            },
            'raster-brightness-max': {
              type: 'number', function: 'interpolated', 'zoom-function': !0, default: 1, minimum: 0, maximum: 1, transition: !0,
            },
            'raster-saturation': {
              type: 'number', default: 0, minimum: -1, maximum: 1, function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
            'raster-contrast': {
              type: 'number', default: 0, minimum: -1, maximum: 1, function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
            'raster-fade-duration': {
              type: 'number', default: 300, minimum: 0, function: 'interpolated', 'zoom-function': !0, transition: !1, units: 'milliseconds',
            },
          },
          paint_hillshade: {
            'hillshade-illumination-direction': {
              type: 'number', default: 335, minimum: 0, maximum: 359, function: 'interpolated', 'zoom-function': !0, transition: !1,
            },
            'hillshade-illumination-anchor': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'viewport',
            },
            'hillshade-exaggeration': {
              type: 'number', default: 0.5, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
            'hillshade-shadow-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
            'hillshade-highlight-color': {
              type: 'color', default: '#FFFFFF', function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
            'hillshade-accent-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
          },
          paint_background: {
            'background-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, transition: !0, requires: [{ '!': 'background-pattern' }],
            },
            'background-pattern': {
              type: 'string', function: 'piecewise-constant', 'zoom-function': !0, transition: !0,
            },
            'background-opacity': {
              type: 'number', default: 1, minimum: 0, maximum: 1, function: 'interpolated', 'zoom-function': !0, transition: !0,
            },
          },
          transition: {
            duration: {
              type: 'number', default: 300, minimum: 0, units: 'milliseconds',
            },
            delay: {
              type: 'number', default: 0, minimum: 0, units: 'milliseconds',
            },
          },
          'layout_fill-extrusion': { visibility: { type: 'enum', values: { visible: {}, none: {} }, default: 'visible' } },
          function: {
            expression: { type: 'expression' },
            stops: { type: 'array', value: 'function_stop' },
            base: { type: 'number', default: 1, minimum: 0 },
            property: { type: 'string', default: '$zoom' },
            type: {
              type: 'enum',
              values: {
                identity: {}, exponential: {}, interval: {}, categorical: {},
              },
              default: 'exponential',
            },
            colorSpace: { type: 'enum', values: { rgb: {}, lab: {}, hcl: {} }, default: 'rgb' },
            default: { type: '*', required: !1 },
          },
          'paint_fill-extrusion': {
            'fill-extrusion-opacity': {
              type: 'number', function: 'interpolated', 'zoom-function': !0, 'property-function': !1, default: 1, minimum: 0, maximum: 1, transition: !0,
            },
            'fill-extrusion-color': {
              type: 'color', default: '#000000', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, transition: !0, requires: [{ '!': 'fill-extrusion-pattern' }],
            },
            'fill-extrusion-translate': {
              type: 'array', value: 'number', length: 2, default: [0, 0], function: 'interpolated', 'zoom-function': !0, transition: !0, units: 'pixels',
            },
            'fill-extrusion-translate-anchor': {
              type: 'enum', function: 'piecewise-constant', 'zoom-function': !0, values: { map: {}, viewport: {} }, default: 'map', requires: ['fill-extrusion-translate'],
            },
            'fill-extrusion-pattern': {
              type: 'string', function: 'piecewise-constant', 'zoom-function': !0, transition: !0,
            },
            'fill-extrusion-height': {
              type: 'number', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, default: 0, minimum: 0, units: 'meters', transition: !0,
            },
            'fill-extrusion-base': {
              type: 'number', function: 'interpolated', 'zoom-function': !0, 'property-function': !0, default: 0, minimum: 0, units: 'meters', transition: !0, requires: ['fill-extrusion-height'],
            },
          },
        }; var Xn = function (e, t, n, r) { this.message = (e ? `${e}: ` : '') + n, r && (this.identifier = r), t != null && t.__line__ && (this.line = t.__line__); }; var Yn = (function (e) { function t(t, n) { e.call(this, n), this.message = n, this.key = t; } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t; }(Error)); const Jn = function (e, t) { void 0 === t && (t = []), this.parent = e, this.bindings = {}; for (let n = 0, r = t; n < r.length; n += 1) { const i = r[n]; const o = i[0]; const a = i[1]; this.bindings[o] = a; } }; Jn.prototype.concat = function (e) { return new Jn(this, e); }, Jn.prototype.get = function (e) { if (this.bindings[e]) return this.bindings[e]; if (this.parent) return this.parent.get(e); throw new Error(`${e} not found in scope.`); }, Jn.prototype.has = function (e) { return !!this.bindings[e] || !!this.parent && this.parent.has(e); }; var Qn = { kind: 'null' }; var er = { kind: 'number' }; var tr = { kind: 'string' }; var nr = { kind: 'boolean' }; var rr = { kind: 'color' }; var ir = { kind: 'object' }; var or = { kind: 'value' }; var ar = { kind: 'collator' }; var sr = [Qn, er, tr, nr, rr, ir, T(or)]; const lr = r((e, t) => {
          function n(e) { return (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : e; } function r(e) { return e < 0 ? 0 : e > 1 ? 1 : e; } function i(e) { return n(e[e.length - 1] === '%' ? parseFloat(e) / 100 * 255 : parseInt(e)); } function o(e) { return r(e[e.length - 1] === '%' ? parseFloat(e) / 100 : parseFloat(e)); } function a(e, t, n) { return n < 0 ? n += 1 : n > 1 && (n -= 1), 6 * n < 1 ? e + (t - e) * n * 6 : 2 * n < 1 ? t : 3 * n < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e; } const s = {
            transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1],
          }; try { t.parseCSSColor = function (e) { let t; const r = e.replace(/ /g, '').toLowerCase(); if (r in s) return s[r].slice(); if (r[0] === '#') return r.length === 4 ? (t = parseInt(r.substr(1), 16)) >= 0 && t <= 4095 ? [(3840 & t) >> 4 | (3840 & t) >> 8, 240 & t | (240 & t) >> 4, 15 & t | (15 & t) << 4, 1] : null : r.length === 7 && (t = parseInt(r.substr(1), 16)) >= 0 && t <= 16777215 ? [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t, 1] : null; const l = r.indexOf('('); const u = r.indexOf(')'); if (l !== -1 && u + 1 === r.length) { const c = r.substr(0, l); const p = r.substr(l + 1, u - (l + 1)).split(','); let f = 1; switch (c) { case 'rgba': if (p.length !== 4) return null; f = o(p.pop()); case 'rgb': return p.length !== 3 ? null : [i(p[0]), i(p[1]), i(p[2]), f]; case 'hsla': if (p.length !== 4) return null; f = o(p.pop()); case 'hsl': if (p.length !== 3) return null; var h = (parseFloat(p[0]) % 360 + 360) % 360 / 360; var d = o(p[1]); var m = o(p[2]); var g = m <= 0.5 ? m * (d + 1) : m + d - m * d; var y = 2 * m - g; return [n(255 * a(y, g, h + 1 / 3)), n(255 * a(y, g, h)), n(255 * a(y, g, h - 1 / 3)), f]; default: return null; } } return null; }; } catch (e) {}
        }).parseCSSColor; var ur = function (e, t, n, r) { void 0 === r && (r = 1), this.r = e, this.g = t, this.b = n, this.a = r; }; ur.parse = function (e) { if (e) { if (e instanceof ur) return e; if (typeof e === 'string') { const t = lr(e); if (t) return new ur(t[0] / 255 * t[3], t[1] / 255 * t[3], t[2] / 255 * t[3], t[3]); } } }, ur.prototype.toString = function () { const e = this.toArray(); const t = e[0]; const n = e[1]; const r = e[2]; const i = e[3]; return `rgba(${Math.round(t)},${Math.round(n)},${Math.round(r)},${i})`; }, ur.prototype.toArray = function () { const e = this.r; const t = this.g; const n = this.b; const r = this.a; return r === 0 ? [0, 0, 0, 0] : [255 * e / r, 255 * t / r, 255 * n / r, r]; }, ur.black = new ur(0, 0, 0, 1), ur.white = new ur(1, 1, 1, 1), ur.transparent = new ur(0, 0, 0, 0); var cr = function (e, t, n) { this.sensitivity = e ? t ? 'variant' : 'case' : t ? 'accent' : 'base', this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: 'search' }); }; cr.prototype.compare = function (e, t) { return this.collator.compare(e, t); }, cr.prototype.resolvedLocale = function () { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale; }; const pr = function (e, t, n) { this.type = ar, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t; }; pr.parse = function (e, t) { if (e.length !== 2) return t.error('Expected one argument.'); const n = e[1]; if (typeof n !== 'object' || Array.isArray(n)) return t.error('Collator options argument must be an object.'); const r = t.parse(void 0 !== n['case-sensitive'] && n['case-sensitive'], 1, nr); if (!r) return null; const i = t.parse(void 0 !== n['diacritic-sensitive'] && n['diacritic-sensitive'], 1, nr); if (!i) return null; let o = null; return n.locale && !(o = t.parse(n.locale, 1, tr)) ? null : new pr(r, i, o); }, pr.prototype.evaluate = function (e) { return new cr(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null); }, pr.prototype.eachChild = function (e) { e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale); }, pr.prototype.possibleOutputs = function () { return [void 0]; }, pr.prototype.serialize = function () { const e = {}; return e['case-sensitive'] = this.caseSensitive.serialize(), e['diacritic-sensitive'] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ['collator', e]; }; const fr = function (e, t) { this.type = e, this.value = t; }; fr.parse = function (e, t) { if (e.length !== 2) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (!(function e(t) { if (t === null) return !0; if (typeof t === 'string') return !0; if (typeof t === 'boolean') return !0; if (typeof t === 'number') return !0; if (t instanceof ur) return !0; if (t instanceof cr) return !0; if (Array.isArray(t)) { for (let n = 0, r = t; n < r.length; n += 1) if (!e(r[n])) return !1; return !0; } if (typeof t === 'object') { for (const i in t) if (!e(t[i])) return !1; return !0; } return !1; }(e[1]))) return t.error('invalid value'); const n = e[1]; let r = A(n); const i = t.expectedType; return r.kind !== 'array' || r.N !== 0 || !i || i.kind !== 'array' || typeof i.N === 'number' && i.N !== 0 || (r = i), new fr(r, n); }, fr.prototype.evaluate = function () { return this.value; }, fr.prototype.eachChild = function () {}, fr.prototype.possibleOutputs = function () { return [this.value]; }, fr.prototype.serialize = function () { return this.type.kind === 'array' || this.type.kind === 'object' ? ['literal', this.value] : this.value instanceof ur ? ['rgba'].concat(this.value.toArray()) : this.value; }; var hr = function (e) { this.name = 'ExpressionEvaluationError', this.message = e; }; hr.prototype.toJSON = function () { return this.message; }; const dr = {
          string: tr, number: er, boolean: nr, object: ir,
        }; const mr = function (e, t) { this.type = e, this.args = t; }; mr.parse = function (e, t) { if (e.length < 2) return t.error('Expected at least one argument.'); for (var n = e[0], r = dr[n], i = [], o = 1; o < e.length; o++) { const a = t.parse(e[o], o, or); if (!a) return null; i.push(a); } return new mr(r, i); }, mr.prototype.evaluate = function (e) { for (let t = 0; t < this.args.length; t++) { const n = this.args[t].evaluate(e); if (!C(this.type, A(n))) return n; if (t === this.args.length - 1) throw new hr(`Expected value to be of type ${k(this.type)}, but found ${k(A(n))} instead.`); } return null; }, mr.prototype.eachChild = function (e) { this.args.forEach(e); }, mr.prototype.possibleOutputs = function () { return (e = []).concat.apply(e, this.args.map(e => e.possibleOutputs())); let e; }, mr.prototype.serialize = function () { return [this.type.kind].concat(this.args.map(e => e.serialize())); }; const gr = { string: tr, number: er, boolean: nr }; const yr = function (e, t) { this.type = e, this.input = t; }; yr.parse = function (e, t) { if (e.length < 2 || e.length > 4) return t.error(`Expected 1, 2, or 3 arguments, but found ${e.length - 1} instead.`); let n; let r; if (e.length > 2) { const i = e[1]; if (typeof i !== 'string' || !(i in gr)) return t.error('The item type argument of "array" must be one of string, number, boolean', 1); n = gr[i]; } else n = or; if (e.length > 3) { if (typeof e[2] !== 'number' || e[2] < 0 || e[2] !== Math.floor(e[2])) return t.error('The length argument to "array" must be a positive integer literal', 2); r = e[2]; } const o = T(n, r); const a = t.parse(e[e.length - 1], e.length - 1, or); return a ? new yr(o, a) : null; }, yr.prototype.evaluate = function (e) { const t = this.input.evaluate(e); if (C(this.type, A(t))) throw new hr(`Expected value to be of type ${k(this.type)}, but found ${k(A(t))} instead.`); return t; }, yr.prototype.eachChild = function (e) { e(this.input); }, yr.prototype.possibleOutputs = function () { return this.input.possibleOutputs(); }, yr.prototype.serialize = function () { const e = ['array']; const t = this.type.itemType; if (t.kind === 'string' || t.kind === 'number' || t.kind === 'boolean') { e.push(t.kind); const n = this.type.N; typeof n === 'number' && e.push(n); } return e.push(this.input.serialize()), e; }; const vr = { 'to-number': er, 'to-color': rr }; const _r = function (e, t) { this.type = e, this.args = t; }; _r.parse = function (e, t) { if (e.length < 2) return t.error('Expected at least one argument.'); for (var n = e[0], r = vr[n], i = [], o = 1; o < e.length; o++) { const a = t.parse(e[o], o, or); if (!a) return null; i.push(a); } return new _r(r, i); }, _r.prototype.evaluate = function (e) { if (this.type.kind === 'color') { for (var t, n, r = 0, i = this.args; r < i.length; r += 1) if (n = null, typeof (t = i[r].evaluate(e)) === 'string') { const o = e.parseColor(t); if (o) return o; } else if (Array.isArray(t) && !(n = t.length < 3 || t.length > 4 ? `Invalid rbga value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : S(t[0], t[1], t[2], t[3]))) return new ur(t[0] / 255, t[1] / 255, t[2] / 255, t[3]); throw new hr(n || `Could not parse color from value '${typeof t === 'string' ? t : JSON.stringify(t)}'`); } for (var a = null, s = 0, l = this.args; s < l.length; s += 1) if ((a = l[s].evaluate(e)) !== null) { const u = Number(a); if (!isNaN(u)) return u; } throw new hr(`Could not convert ${JSON.stringify(a)} to number.`); }, _r.prototype.eachChild = function (e) { this.args.forEach(e); }, _r.prototype.possibleOutputs = function () { return (e = []).concat.apply(e, this.args.map(e => e.possibleOutputs())); let e; }, _r.prototype.serialize = function () { const e = [`to-${this.type.kind}`]; return this.eachChild((t) => { e.push(t.serialize()); }), e; }; const br = ['Unknown', 'Point', 'LineString', 'Polygon']; const xr = function () { this._parseColorCache = {}; }; xr.prototype.id = function () { return this.feature && 'id' in this.feature ? this.feature.id : null; }, xr.prototype.geometryType = function () { return this.feature ? typeof this.feature.type === 'number' ? br[this.feature.type] : this.feature.type : null; }, xr.prototype.properties = function () { return this.feature && this.feature.properties || {}; }, xr.prototype.parseColor = function (e) { let t = this._parseColorCache[e]; return t || (t = this._parseColorCache[e] = ur.parse(e)), t; }; var wr = function (e, t, n, r) { this.name = e, this.type = t, this._evaluate = n, this.args = r; }; wr.prototype.evaluate = function (e) { return this._evaluate(e, this.args); }, wr.prototype.eachChild = function (e) { this.args.forEach(e); }, wr.prototype.possibleOutputs = function () { return [void 0]; }, wr.prototype.serialize = function () { return [this.name].concat(this.args.map(e => e.serialize())); }, wr.parse = function (e, t) { const n = e[0]; const r = wr.definitions[n]; if (!r) return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0); for (var i = Array.isArray(r) ? r[0] : r.type, o = Array.isArray(r) ? [[r[1], r[2]]] : r.overloads, a = o.filter((t) => { const n = t[0]; return !Array.isArray(n) || n.length === e.length - 1; }), s = [], l = 1; l < e.length; l++) { const u = e[l]; let c = void 0; if (a.length === 1) { const p = a[0][0]; c = Array.isArray(p) ? p[l - 1] : p.type; } const f = t.parse(u, 1 + s.length, c); if (!f) return null; s.push(f); } for (var h = null, d = 0, m = a; d < m.length; d += 1) { const g = m[d]; const y = g[0]; const v = g[1]; if (h = new Tr(t.registry, t.path, null, t.scope), Array.isArray(y) && y.length !== s.length)h.error(`Expected ${y.length} arguments, but found ${s.length} instead.`); else { for (let _ = 0; _ < s.length; _++) { const b = Array.isArray(y) ? y[_] : y.type; const x = s[_]; h.concat(_ + 1).checkSubtype(b, x.type); } if (h.errors.length === 0) return new wr(n, i, v, s); } } if (a.length === 1)t.errors.push.apply(t.errors, h.errors); else { const w = (a.length ? a : o).map((e) => { let t; return t = e[0], Array.isArray(t) ? `(${t.map(k).join(', ')})` : `(${k(t.type)}...)`; }).join(' | '); const E = s.map(e => k(e.type)).join(', '); t.error(`Expected arguments of type ${w}, but found (${E}) instead.`); } return null; }, wr.register = function (e, t) { for (const n in wr.definitions = t, t)e[n] = wr; }; const Er = function (e, t) { this.type = t.type, this.name = e, this.boundExpression = t; }; Er.parse = function (e, t) { if (e.length !== 2 || typeof e[1] !== 'string') return t.error("'var' expression requires exactly one string literal argument."); const n = e[1]; return t.scope.has(n) ? new Er(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1); }, Er.prototype.evaluate = function (e) { return this.boundExpression.evaluate(e); }, Er.prototype.eachChild = function () {}, Er.prototype.possibleOutputs = function () { return [void 0]; }, Er.prototype.serialize = function () { return ['var', this.name]; }; var Tr = function (e, t, n, r, i) { void 0 === t && (t = []), void 0 === r && (r = new Jn()), void 0 === i && (i = []), this.registry = e, this.path = t, this.key = t.map(e => `[${e}]`).join(''), this.scope = r, this.errors = i, this.expectedType = n; }; Tr.prototype.parse = function (e, t, n, r, i) { return void 0 === i && (i = {}), t ? this.concat(t, n, r)._parse(e, i) : this._parse(e, i); }, Tr.prototype._parse = function (e, t) { if (e !== null && typeof e !== 'string' && typeof e !== 'boolean' && typeof e !== 'number' || (e = ['literal', e]), Array.isArray(e)) { if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); const n = e[0]; if (typeof n !== 'string') return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null; const r = this.registry[n]; if (r) { let i = r.parse(e, this); if (!i) return null; if (this.expectedType) { const o = this.expectedType; const a = i.type; if (o.kind !== 'string' && o.kind !== 'number' && o.kind !== 'boolean' && o.kind !== 'object' || a.kind !== 'value') if (o.kind === 'array' && a.kind === 'value')t.omitTypeAnnotations || (i = new yr(o, i)); else if (o.kind !== 'color' || a.kind !== 'value' && a.kind !== 'string') { if (this.checkSubtype(this.expectedType, i.type)) return null; } else t.omitTypeAnnotations || (i = new _r(o, [i])); else t.omitTypeAnnotations || (i = new mr(o, [i])); } if (!(i instanceof fr) && (function e(t) { if (t instanceof Er) return e(t.boundExpression); if (t instanceof wr && t.name === 'error') return !1; if (t instanceof pr) return !1; const n = t instanceof _r || t instanceof mr || t instanceof yr; let r = !0; return t.eachChild((t) => { r = n ? r && e(t) : r && t instanceof fr; }), !!r && (O(t) && I(t, ['zoom', 'heatmap-density', 'line-progress', 'is-supported-script'])); }(i))) { const s = new xr(); try { i = new fr(i.type, i.evaluate(s)); } catch (e) { return this.error(e.message), null; } } return i; } return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0); } return void 0 === e ? this.error("'undefined' value invalid. Use null instead.") : typeof e === 'object' ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`); }, Tr.prototype.concat = function (e, t, n) { const r = typeof e === 'number' ? this.path.concat(e) : this.path; const i = n ? this.scope.concat(n) : this.scope; return new Tr(this.registry, r, t || null, i, this.errors); }, Tr.prototype.error = function (e) { for (var t = [], n = arguments.length - 1; n-- > 0;)t[n] = arguments[n + 1]; const r = `${this.key}${t.map(e => `[${e}]`).join('')}`; this.errors.push(new Yn(r, e)); }, Tr.prototype.checkSubtype = function (e, t) { const n = C(e, t); return n && this.error(n), n; }; var kr = function (e, t, n) { this.type = e, this.input = t, this.labels = [], this.outputs = []; for (let r = 0, i = n; r < i.length; r += 1) { const o = i[r]; const a = o[0]; const s = o[1]; this.labels.push(a), this.outputs.push(s); } }; kr.parse = function (e, t) { let n = e[1]; const r = e.slice(2); if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if ((e.length - 1) % 2 != 0) return t.error('Expected an even number of arguments.'); if (!(n = t.parse(n, 1, er))) return null; const i = []; let o = null; t.expectedType && t.expectedType.kind !== 'value' && (o = t.expectedType), r.unshift(-1 / 0); for (let a = 0; a < r.length; a += 2) { const s = r[a]; const l = r[a + 1]; const u = a + 1; const c = a + 2; if (typeof s !== 'number') return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u); if (i.length && i[i.length - 1][0] >= s) return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u); const p = t.parse(l, c, o); if (!p) return null; o = o || p.type, i.push([s, p]); } return new kr(o, n, i); }, kr.prototype.evaluate = function (e) { const t = this.labels; const n = this.outputs; if (t.length === 1) return n[0].evaluate(e); const r = this.input.evaluate(e); if (r <= t[0]) return n[0].evaluate(e); const i = t.length; return r >= t[i - 1] ? n[i - 1].evaluate(e) : n[P(t, r)].evaluate(e); }, kr.prototype.eachChild = function (e) { e(this.input); for (let t = 0, n = this.outputs; t < n.length; t += 1)e(n[t]); }, kr.prototype.possibleOutputs = function () { return (e = []).concat.apply(e, this.outputs.map(e => e.possibleOutputs())); let e; }, kr.prototype.serialize = function () { for (var e = ['step', this.input.serialize()], t = 0; t < this.labels.length; t++)t > 0 && e.push(this.labels[t]), e.push(this.outputs[t].serialize()); return e; }; var Cr = Object.freeze({ number: M, color(e, t, n) { return new ur(M(e.r, t.r, n), M(e.g, t.g, n), M(e.b, t.b, n), M(e.a, t.a, n)); }, array(e, t, n) { return e.map((e, r) => M(e, t[r], n)); } }); var Sr = function (e, t, n, r) { this.type = e, this.interpolation = t, this.input = n, this.labels = [], this.outputs = []; for (let i = 0, o = r; i < o.length; i += 1) { const a = o[i]; const s = a[0]; const l = a[1]; this.labels.push(s), this.outputs.push(l); } }; Sr.interpolationFactor = function (e, t, n, r) { let i = 0; if (e.name === 'exponential')i = N(t, e.base, n, r); else if (e.name === 'linear')i = N(t, 1, n, r); else if (e.name === 'cubic-bezier') { const o = e.controlPoints; i = new Rn(o[0], o[1], o[2], o[3]).solve(N(t, 1, n, r)); } return i; }, Sr.parse = function (e, t) { let n = e[1]; let r = e[2]; const i = e.slice(3); if (!Array.isArray(n) || n.length === 0) return t.error('Expected an interpolation type expression.', 1); if (n[0] === 'linear')n = { name: 'linear' }; else if (n[0] === 'exponential') { const o = n[1]; if (typeof o !== 'number') return t.error('Exponential interpolation requires a numeric base.', 1, 1); n = { name: 'exponential', base: o }; } else { if (n[0] !== 'cubic-bezier') return t.error(`Unknown interpolation type ${String(n[0])}`, 1, 0); const a = n.slice(1); if (a.length !== 4 || a.some(e => typeof e !== 'number' || e < 0 || e > 1)) return t.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1); n = { name: 'cubic-bezier', controlPoints: a }; } if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if ((e.length - 1) % 2 != 0) return t.error('Expected an even number of arguments.'); if (!(r = t.parse(r, 2, er))) return null; const s = []; let l = null; t.expectedType && t.expectedType.kind !== 'value' && (l = t.expectedType); for (let u = 0; u < i.length; u += 2) { const c = i[u]; const p = i[u + 1]; const f = u + 3; const h = u + 4; if (typeof c !== 'number') return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f); if (s.length && s[s.length - 1][0] >= c) return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f); const d = t.parse(p, h, l); if (!d) return null; l = l || d.type, s.push([c, d]); } return l.kind === 'number' || l.kind === 'color' || l.kind === 'array' && l.itemType.kind === 'number' && typeof l.N === 'number' ? new Sr(l, n, r, s) : t.error(`Type ${k(l)} is not interpolatable.`); }, Sr.prototype.evaluate = function (e) { const t = this.labels; const n = this.outputs; if (t.length === 1) return n[0].evaluate(e); const r = this.input.evaluate(e); if (r <= t[0]) return n[0].evaluate(e); const i = t.length; if (r >= t[i - 1]) return n[i - 1].evaluate(e); const o = P(t, r); const a = t[o]; const s = t[o + 1]; const l = Sr.interpolationFactor(this.interpolation, r, a, s); const u = n[o].evaluate(e); const c = n[o + 1].evaluate(e); return Cr[this.type.kind.toLowerCase()](u, c, l); }, Sr.prototype.eachChild = function (e) { e(this.input); for (let t = 0, n = this.outputs; t < n.length; t += 1)e(n[t]); }, Sr.prototype.possibleOutputs = function () { return (e = []).concat.apply(e, this.outputs.map(e => e.possibleOutputs())); let e; }, Sr.prototype.serialize = function () { for (var e = ['interpolate', this.interpolation.name === 'linear' ? ['linear'] : this.interpolation.name === 'exponential' ? this.interpolation.base === 1 ? ['linear'] : ['exponential', this.interpolation.base] : ['cubic-bezier'].concat(this.interpolation.controlPoints), this.input.serialize()], t = 0; t < this.labels.length; t++)e.push(this.labels[t], this.outputs[t].serialize()); return e; }; var Ar = function (e, t) { this.type = e, this.args = t; }; Ar.parse = function (e, t) { if (e.length < 2) return t.error('Expectected at least one argument.'); let n = null; const r = t.expectedType; r && r.kind !== 'value' && (n = r); for (var i = [], o = 0, a = e.slice(1); o < a.length; o += 1) { const s = a[o]; const l = t.parse(s, 1 + i.length, n, void 0, { omitTypeAnnotations: !0 }); if (!l) return null; n = n || l.type, i.push(l); } const u = r && i.some(e => C(r, e.type)); return new Ar(u ? or : n, i); }, Ar.prototype.evaluate = function (e) { for (var t = null, n = 0, r = this.args; n < r.length && (t = r[n].evaluate(e)) === null; n += 1);return t; }, Ar.prototype.eachChild = function (e) { this.args.forEach(e); }, Ar.prototype.possibleOutputs = function () { return (e = []).concat.apply(e, this.args.map(e => e.possibleOutputs())); let e; }, Ar.prototype.serialize = function () { const e = ['coalesce']; return this.eachChild((t) => { e.push(t.serialize()); }), e; }; var Or = function (e, t) { this.type = t.type, this.bindings = [].concat(e), this.result = t; }; Or.prototype.evaluate = function (e) { return this.result.evaluate(e); }, Or.prototype.eachChild = function (e) { for (let t = 0, n = this.bindings; t < n.length; t += 1)e(n[t][1]); e(this.result); }, Or.parse = function (e, t) { if (e.length < 4) return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`); for (var n = [], r = 1; r < e.length - 1; r += 2) { const i = e[r]; if (typeof i !== 'string') return t.error(`Expected string, but found ${typeof i} instead.`, r); if (/[^a-zA-Z0-9_]/.test(i)) return t.error("Variable names must contain only alphanumeric characters or '_'.", r); const o = t.parse(e[r + 1], r + 1); if (!o) return null; n.push([i, o]); } const a = t.parse(e[e.length - 1], e.length - 1, void 0, n); return a ? new Or(n, a) : null; }, Or.prototype.possibleOutputs = function () { return this.result.possibleOutputs(); }, Or.prototype.serialize = function () { for (var e = ['let'], t = 0, n = this.bindings; t < n.length; t += 1) { const r = n[t]; const i = r[0]; const o = r[1]; e.push(i, o.serialize()); } return e.push(this.result.serialize()), e; }; const Ir = function (e, t, n) { this.type = e, this.index = t, this.input = n; }; Ir.parse = function (e, t) { if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const n = t.parse(e[1], 1, er); const r = t.parse(e[2], 2, T(t.expectedType || or)); if (!n || !r) return null; const i = r.type; return new Ir(i.itemType, n, r); }, Ir.prototype.evaluate = function (e) { const t = this.index.evaluate(e); const n = this.input.evaluate(e); if (t < 0) throw new hr(`Array index out of bounds: ${t} < 0.`); if (t >= n.length) throw new hr(`Array index out of bounds: ${t} > ${n.length - 1}.`); if (t !== Math.floor(t)) throw new hr(`Array index must be an integer, but found ${t} instead.`); return n[t]; }, Ir.prototype.eachChild = function (e) { e(this.index), e(this.input); }, Ir.prototype.possibleOutputs = function () { return [void 0]; }, Ir.prototype.serialize = function () { return ['at', this.index.serialize(), this.input.serialize()]; }; const Pr = function (e, t, n, r, i, o) { this.inputType = e, this.type = t, this.input = n, this.cases = r, this.outputs = i, this.otherwise = o; }; Pr.parse = function (e, t) { if (e.length < 5) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 1) return t.error('Expected an even number of arguments.'); let n; let r; t.expectedType && t.expectedType.kind !== 'value' && (r = t.expectedType); for (var i = {}, o = [], a = 2; a < e.length - 1; a += 2) { let s = e[a]; const l = e[a + 1]; Array.isArray(s) || (s = [s]); const u = t.concat(a); if (s.length === 0) return u.error('Expected at least one branch label.'); for (let c = 0, p = s; c < p.length; c += 1) { const f = p[c]; if (typeof f !== 'number' && typeof f !== 'string') return u.error('Branch labels must be numbers or strings.'); if (typeof f === 'number' && Math.abs(f) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`); if (typeof f === 'number' && Math.floor(f) !== f) return u.error('Numeric branch labels must be integer values.'); if (n) { if (u.checkSubtype(n, A(f))) return null; } else n = A(f); if (void 0 !== i[String(f)]) return u.error('Branch labels must be unique.'); i[String(f)] = o.length; } const h = t.parse(l, a, r); if (!h) return null; r = r || h.type, o.push(h); } const d = t.parse(e[1], 1, n); if (!d) return null; const m = t.parse(e[e.length - 1], e.length - 1, r); return m ? new Pr(n, r, d, i, o, m) : null; }, Pr.prototype.evaluate = function (e) { const t = this.input.evaluate(e); return (this.outputs[this.cases[t]] || this.otherwise).evaluate(e); }, Pr.prototype.eachChild = function (e) { e(this.input), this.outputs.forEach(e), e(this.otherwise); }, Pr.prototype.possibleOutputs = function () { return (e = []).concat.apply(e, this.outputs.map(e => e.possibleOutputs())).concat(this.otherwise.possibleOutputs()); let e; }, Pr.prototype.serialize = function () { for (var e = this, t = ['match', this.input.serialize()], n = [], r = {}, i = 0, o = Object.keys(this.cases).sort(); i < o.length; i += 1) { const a = o[i]; const s = r[e.cases[a]]; void 0 === s ? (r[e.cases[a]] = n.length, n.push([e.cases[a], [a]])) : n[s][1].push(a); } for (let l = function (t) { return e.input.type.kind === 'number' ? Number(t) : t; }, u = 0, c = n; u < c.length; u += 1) { const p = c[u]; const f = p[0]; const h = p[1]; h.length === 1 ? t.push(l(h[0])) : t.push(h.map(l)), t.push(e.outputs[f].serialize()); } return t.push(this.otherwise.serialize()), t; }; const Mr = function (e, t, n) { this.type = e, this.branches = t, this.otherwise = n; }; Mr.parse = function (e, t) { if (e.length < 4) return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 0) return t.error('Expected an odd number of arguments.'); let n; t.expectedType && t.expectedType.kind !== 'value' && (n = t.expectedType); for (var r = [], i = 1; i < e.length - 1; i += 2) { const o = t.parse(e[i], i, nr); if (!o) return null; const a = t.parse(e[i + 1], i + 1, n); if (!a) return null; r.push([o, a]), n = n || a.type; } const s = t.parse(e[e.length - 1], e.length - 1, n); return s ? new Mr(n, r, s) : null; }, Mr.prototype.evaluate = function (e) { for (let t = 0, n = this.branches; t < n.length; t += 1) { const r = n[t]; const i = r[0]; const o = r[1]; if (i.evaluate(e)) return o.evaluate(e); } return this.otherwise.evaluate(e); }, Mr.prototype.eachChild = function (e) { for (let t = 0, n = this.branches; t < n.length; t += 1) { const r = n[t]; const i = r[0]; const o = r[1]; e(i), e(o); }e(this.otherwise); }, Mr.prototype.possibleOutputs = function () { return (e = []).concat.apply(e, this.branches.map(e => e[0], e[1].possibleOutputs())).concat(this.otherwise.possibleOutputs()); let e; }, Mr.prototype.serialize = function () { const e = ['case']; return this.eachChild((t) => { e.push(t.serialize()); }), e; }; const Nr = L('==', !1); const Dr = L('!=', !0); const Lr = function (e) { this.type = er, this.input = e; }; Lr.parse = function (e, t) { if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`); const n = t.parse(e[1], 1); return n ? n.type.kind !== 'array' && n.type.kind !== 'string' && n.type.kind !== 'value' ? t.error(`Expected argument of type string or array, but found ${k(n.type)} instead.`) : new Lr(n) : null; }, Lr.prototype.evaluate = function (e) { const t = this.input.evaluate(e); if (typeof t === 'string') return t.length; if (Array.isArray(t)) return t.length; throw new hr(`Expected value to be of type string or array, but found ${k(A(t))} instead.`); }, Lr.prototype.eachChild = function (e) { e(this.input); }, Lr.prototype.possibleOutputs = function () { return [void 0]; }, Lr.prototype.serialize = function () { const e = ['length']; return this.eachChild((t) => { e.push(t.serialize()); }), e; }; var zr = {
          '==': Nr, '!=': Dr, array: yr, at: Ir, boolean: mr, case: Mr, coalesce: Ar, collator: pr, interpolate: Sr, length: Lr, let: Or, literal: fr, match: Pr, number: mr, object: mr, step: kr, string: mr, 'to-color': _r, 'to-number': _r, var: Er,
        }; wr.register(zr, {
          error: [{ kind: 'error' }, [tr], function (e, t) { const n = t[0]; throw new hr(n.evaluate(e)); }], typeof: [tr, [or], function (e, t) { return k(A(t[0].evaluate(e))); }], 'to-string': [tr, [or], function (e, t) { let n = t[0]; const r = typeof (n = n.evaluate(e)); return n === null ? '' : r === 'string' || r === 'number' || r === 'boolean' ? String(n) : n instanceof ur ? n.toString() : JSON.stringify(n); }], 'to-boolean': [nr, [or], function (e, t) { const n = t[0]; return Boolean(n.evaluate(e)); }], 'to-rgba': [T(er, 4), [rr], function (e, t) { return t[0].evaluate(e).toArray(); }], rgb: [rr, [er, er, er], z], rgba: [rr, [er, er, er, er], z], has: { type: nr, overloads: [[[tr], function (e, t) { return R(t[0].evaluate(e), e.properties()); }], [[tr, ir], function (e, t) { const n = t[0]; const r = t[1]; return R(n.evaluate(e), r.evaluate(e)); }]] }, get: { type: or, overloads: [[[tr], function (e, t) { return j(t[0].evaluate(e), e.properties()); }], [[tr, ir], function (e, t) { const n = t[0]; const r = t[1]; return j(n.evaluate(e), r.evaluate(e)); }]] }, properties: [ir, [], function (e) { return e.properties(); }], 'geometry-type': [tr, [], function (e) { return e.geometryType(); }], id: [or, [], function (e) { return e.id(); }], zoom: [er, [], function (e) { return e.globals.zoom; }], 'heatmap-density': [er, [], function (e) { return e.globals.heatmapDensity || 0; }], 'line-progress': [er, [], function (e) { return e.globals.lineProgress || 0; }], '+': [er, q(er), function (e, t) { for (var n = 0, r = 0, i = t; r < i.length; r += 1)n += i[r].evaluate(e); return n; }], '*': [er, q(er), function (e, t) { for (var n = 1, r = 0, i = t; r < i.length; r += 1)n *= i[r].evaluate(e); return n; }], '-': { type: er, overloads: [[[er, er], function (e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) - r.evaluate(e); }], [[er], function (e, t) { return -t[0].evaluate(e); }]] }, '/': [er, [er, er], function (e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) / r.evaluate(e); }], '%': [er, [er, er], function (e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) % r.evaluate(e); }], ln2: [er, [], function () { return Math.LN2; }], pi: [er, [], function () { return Math.PI; }], e: [er, [], function () { return Math.E; }], '^': [er, [er, er], function (e, t) { const n = t[0]; const r = t[1]; return Math.pow(n.evaluate(e), r.evaluate(e)); }], sqrt: [er, [er], function (e, t) { const n = t[0]; return Math.sqrt(n.evaluate(e)); }], log10: [er, [er], function (e, t) { const n = t[0]; return Math.log10(n.evaluate(e)); }], ln: [er, [er], function (e, t) { const n = t[0]; return Math.log(n.evaluate(e)); }], log2: [er, [er], function (e, t) { const n = t[0]; return Math.log2(n.evaluate(e)); }], sin: [er, [er], function (e, t) { const n = t[0]; return Math.sin(n.evaluate(e)); }], cos: [er, [er], function (e, t) { const n = t[0]; return Math.cos(n.evaluate(e)); }], tan: [er, [er], function (e, t) { const n = t[0]; return Math.tan(n.evaluate(e)); }], asin: [er, [er], function (e, t) { const n = t[0]; return Math.asin(n.evaluate(e)); }], acos: [er, [er], function (e, t) { const n = t[0]; return Math.acos(n.evaluate(e)); }], atan: [er, [er], function (e, t) { const n = t[0]; return Math.atan(n.evaluate(e)); }], min: [er, q(er), function (e, t) { return Math.min(...t.map(t => t.evaluate(e))); }], max: [er, q(er), function (e, t) { return Math.max(...t.map(t => t.evaluate(e))); }], abs: [er, [er], function (e, t) { const n = t[0]; return Math.abs(n.evaluate(e)); }], round: [er, [er], function (e, t) { const n = t[0].evaluate(e); return n < 0 ? -Math.round(-n) : Math.round(n); }], floor: [er, [er], function (e, t) { const n = t[0]; return Math.floor(n.evaluate(e)); }], ceil: [er, [er], function (e, t) { const n = t[0]; return Math.ceil(n.evaluate(e)); }], 'filter-==': [nr, [tr, or], function (e, t) { const n = t[0]; const r = t[1]; return e.properties()[n.value] === r.value; }], 'filter-id-==': [nr, [or], function (e, t) { const n = t[0]; return e.id() === n.value; }], 'filter-type-==': [nr, [tr], function (e, t) { const n = t[0]; return e.geometryType() === n.value; }], 'filter-<': [nr, [tr, or], function (e, t) { const n = t[0]; const r = t[1]; const i = e.properties()[n.value]; const o = r.value; return typeof i === typeof o && i < o; }], 'filter-id-<': [nr, [or], function (e, t) { const n = t[0]; const r = e.id(); const i = n.value; return typeof r === typeof i && r < i; }], 'filter->': [nr, [tr, or], function (e, t) { const n = t[0]; const r = t[1]; const i = e.properties()[n.value]; const o = r.value; return typeof i === typeof o && i > o; }], 'filter-id->': [nr, [or], function (e, t) { const n = t[0]; const r = e.id(); const i = n.value; return typeof r === typeof i && r > i; }], 'filter-<=': [nr, [tr, or], function (e, t) { const n = t[0]; const r = t[1]; const i = e.properties()[n.value]; const o = r.value; return typeof i === typeof o && i <= o; }], 'filter-id-<=': [nr, [or], function (e, t) { const n = t[0]; const r = e.id(); const i = n.value; return typeof r === typeof i && r <= i; }], 'filter->=': [nr, [tr, or], function (e, t) { const n = t[0]; const r = t[1]; const i = e.properties()[n.value]; const o = r.value; return typeof i === typeof o && i >= o; }], 'filter-id->=': [nr, [or], function (e, t) { const n = t[0]; const r = e.id(); const i = n.value; return typeof r === typeof i && r >= i; }], 'filter-has': [nr, [or], function (e, t) { return t[0].value in e.properties(); }], 'filter-has-id': [nr, [], function (e) { return e.id() !== null; }], 'filter-type-in': [nr, [T(tr)], function (e, t) { return t[0].value.indexOf(e.geometryType()) >= 0; }], 'filter-id-in': [nr, [T(or)], function (e, t) { return t[0].value.indexOf(e.id()) >= 0; }], 'filter-in-small': [nr, [tr, T(or)], function (e, t) { const n = t[0]; return t[1].value.indexOf(e.properties()[n.value]) >= 0; }], 'filter-in-large': [nr, [tr, T(or)], function (e, t) { const n = t[0]; const r = t[1]; return (function (e, t, n, r) { for (;n <= r;) { const i = n + r >> 1; if (t[i] === e) return !0; t[i] > e ? r = i - 1 : n = i + 1; } return !1; }(e.properties()[n.value], r.value, 0, r.value.length - 1)); }], '>': { type: nr, overloads: [[[er, er], F], [[tr, tr], F], [[tr, tr, ar], function (e, t) { const n = t[0]; const r = t[1]; return t[2].evaluate(e).compare(n.evaluate(e), r.evaluate(e)) > 0; }]] }, '<': { type: nr, overloads: [[[er, er], B], [[tr, tr], B], [[tr, tr, ar], function (e, t) { const n = t[0]; const r = t[1]; return t[2].evaluate(e).compare(n.evaluate(e), r.evaluate(e)) < 0; }]] }, '>=': { type: nr, overloads: [[[er, er], V], [[tr, tr], V], [[tr, tr, ar], function (e, t) { const n = t[0]; const r = t[1]; return t[2].evaluate(e).compare(n.evaluate(e), r.evaluate(e)) >= 0; }]] }, '<=': { type: nr, overloads: [[[er, er], U], [[tr, tr], U], [[tr, tr, ar], function (e, t) { const n = t[0]; const r = t[1]; return t[2].evaluate(e).compare(n.evaluate(e), r.evaluate(e)) <= 0; }]] }, all: { type: nr, overloads: [[[nr, nr], function (e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) && r.evaluate(e); }], [q(nr), function (e, t) { for (let n = 0, r = t; n < r.length; n += 1) if (!r[n].evaluate(e)) return !1; return !0; }]] }, any: { type: nr, overloads: [[[nr, nr], function (e, t) { const n = t[0]; const r = t[1]; return n.evaluate(e) || r.evaluate(e); }], [q(nr), function (e, t) { for (let n = 0, r = t; n < r.length; n += 1) if (r[n].evaluate(e)) return !0; return !1; }]] }, '!': [nr, [nr], function (e, t) { return !t[0].evaluate(e); }], 'is-supported-script': [nr, [tr], function (e, t) { const n = t[0]; const r = e.globals && e.globals.isSupportedScript; return !r || r(n.evaluate(e)); }], upcase: [tr, [tr], function (e, t) { return t[0].evaluate(e).toUpperCase(); }], downcase: [tr, [tr], function (e, t) { return t[0].evaluate(e).toLowerCase(); }], concat: [tr, q(tr), function (e, t) { return t.map(t => t.evaluate(e)).join(''); }], 'resolved-locale': [tr, [ar], function (e, t) { return t[0].evaluate(e).resolvedLocale(); }],
        }); var Rr = 0.95047; var jr = 1; var Br = 1.08883; var Fr = 4 / 29; var Ur = 6 / 29; var Vr = 3 * Ur * Ur; var qr = Ur * Ur * Ur; const Hr = Math.PI / 180; const Wr = 180 / Math.PI; const $r = {
          forward: X,
          reverse: Y,
          interpolate(e, t, n) {
            return {
              l: M(e.l, t.l, n), a: M(e.a, t.a, n), b: M(e.b, t.b, n), alpha: M(e.alpha, t.alpha, n),
            };
          }, 
        }; const Gr = {
          forward(e) {
            const t = X(e); const n = t.l; const r = t.a; const i = t.b; const o = Math.atan2(i, r) * Wr; return {
              h: o < 0 ? o + 360 : o, c: Math.sqrt(r * r + i * i), l: n, alpha: e.a,
            };
          },
          reverse(e) {
            const t = e.h * Hr; const n = e.c; return Y({
              l: e.l, a: Math.cos(t) * n, b: Math.sin(t) * n, alpha: e.alpha,
            });
          },
          interpolate(e, t, n) {
            return {
              h: (function (e, t, n) { const r = t - e; return e + n * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r); }(e.h, t.h, n)), c: M(e.c, t.c, n), l: M(e.l, t.l, n), alpha: M(e.alpha, t.alpha, n),
            };
          },
        }; var Zr = Object.freeze({ lab: $r, hcl: Gr }); var Kr = function (e, t) { let n; this.expression = e, this._warningHistory = {}, this._defaultValue = (n = t).type === 'color' && Q(n.default) ? new ur(0, 0, 0, 0) : n.type === 'color' ? ur.parse(n.default) || null : void 0 === n.default ? null : n.default, t.type === 'enum' && (this._enumValues = t.values); }; Kr.prototype.evaluateWithoutErrorHandling = function (e, t) { return this._evaluator || (this._evaluator = new xr()), this._evaluator.globals = e, this._evaluator.feature = t, this.expression.evaluate(this._evaluator); }, Kr.prototype.evaluate = function (e, t) { this._evaluator || (this._evaluator = new xr()), this._evaluator.globals = e, this._evaluator.feature = t; try { const n = this.expression.evaluate(this._evaluator); if (n == null) return this._defaultValue; if (this._enumValues && !(n in this._enumValues)) throw new hr(`Expected value to be one of ${Object.keys(this._enumValues).map(e => JSON.stringify(e)).join(', ')}, but found ${JSON.stringify(n)} instead.`); return n; } catch (e) { return this._warningHistory[e.message] || (this._warningHistory[e.message] = !0, typeof console !== 'undefined' && console.warn(e.message)), this._defaultValue; } }; var Xr = function (e, t) { this.kind = e, this._styleExpression = t; }; Xr.prototype.evaluateWithoutErrorHandling = function (e, t) { return this._styleExpression.evaluateWithoutErrorHandling(e, t); }, Xr.prototype.evaluate = function (e, t) { return this._styleExpression.evaluate(e, t); }; var Yr = function (e, t, n) { this.kind = e, this.zoomStops = n.labels, this._styleExpression = t, n instanceof Sr && (this._interpolationType = n.interpolation); }; Yr.prototype.evaluateWithoutErrorHandling = function (e, t) { return this._styleExpression.evaluateWithoutErrorHandling(e, t); }, Yr.prototype.evaluate = function (e, t) { return this._styleExpression.evaluate(e, t); }, Yr.prototype.interpolationFactor = function (e, t, n) { return this._interpolationType ? Sr.interpolationFactor(this._interpolationType, e, t, n) : 0; }; var Jr = function (e, t) {
          this._parameters = e, this._specification = t, x(this, (function e(t, n) {
            let r; let i; let o; const a = n.type === 'color'; const s = t.stops && typeof t.stops[0][0] === 'object'; const l = s || void 0 !== t.property; const u = s || !l; const c = t.type || (n.function === 'interpolated' ? 'exponential' : 'interval'); if (a && ((t = x({}, t)).stops && (t.stops = t.stops.map(e => [e[0], ur.parse(e[1])])), t.default ? t.default = ur.parse(t.default) : t.default = ur.parse(n.default)), t.colorSpace && t.colorSpace !== 'rgb' && !Zr[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`); if (c === 'exponential')r = ie; else if (c === 'interval')r = re; else if (c === 'categorical') { r = ne, i = Object.create(null); for (let p = 0, f = t.stops; p < f.length; p += 1) { const h = f[p]; i[h[0]] = h[1]; }o = typeof t.stops[0][0]; } else { if (c !== 'identity') throw new Error(`Unknown function type "${c}"`); r = oe; } if (s) {
              for (var d = {}, m = [], g = 0; g < t.stops.length; g++) {
                const y = t.stops[g]; const v = y[0].zoom; void 0 === d[v] && (d[v] = {
                  zoom: v, type: t.type, property: t.property, default: t.default, stops: [],
                }, m.push(v)), d[v].stops.push([y[0].value, y[1]]);
              } for (var _ = [], b = 0, w = m; b < w.length; b += 1) { const E = w[b]; _.push([d[E].zoom, e(d[E], n)]); } return {
                kind: 'composite', interpolationFactor: Sr.interpolationFactor.bind(void 0, { name: 'linear' }), zoomStops: _.map(e => e[0]), evaluate(e, r) { const i = e.zoom; return ie({ stops: _, base: t.base }, n, i).evaluate(i, r); },
              };
            } return u ? {
              kind: 'camera', interpolationFactor: c === 'exponential' ? Sr.interpolationFactor.bind(void 0, { name: 'exponential', base: void 0 !== t.base ? t.base : 1 }) : function () { return 0; }, zoomStops: t.stops.map(e => e[0]), evaluate(e) { const a = e.zoom; return r(t, n, a, i, o); },
            } : { kind: 'source', evaluate(e, a) { const s = a && a.properties ? a.properties[t.property] : void 0; return void 0 === s ? te(t.default, n.default) : r(t, n, s, i, o); } };
          }(this._parameters, this._specification)));
        }; Jr.deserialize = function (e) { return new Jr(e._parameters, e._specification); }, Jr.serialize = function (e) { return { _parameters: e._parameters, _specification: e._specification }; }; var Qr = {
          type: 'boolean', default: !1, function: !0, 'property-function': !0, 'zoom-function': !0,
        }; var ei = {
          '*': function () { return []; }, array: fe, boolean(e) { const t = e.value; const n = e.key; const r = J(t); return r !== 'boolean' ? [new Xn(n, t, `boolean expected, ${r} found`)] : []; }, number: he, color(e) { const t = e.key; const n = e.value; const r = J(n); return r !== 'string' ? [new Xn(t, n, `color expected, ${r} found`)] : lr(n) === null ? [new Xn(t, n, `color expected, "${n}" found`)] : []; }, constants: b, enum: ge, filter: ke, function: de, layer: Oe, object: pe, source: Ie, light: Pe, string: Me,
        }; Le.source = Re(Ie), Le.light = Re(Pe), Le.layer = Re(Oe), Le.filter = Re(ke), Le.paintProperty = Re(Se), Le.layoutProperty = Re(Ae); const ti = Le; const ni = Le.light; const ri = Le.paintProperty; const ii = Le.layoutProperty; const oi = Be; var ai = 3; Be.prototype.insert = function (e, t, n, r, i) { this._forEachCell(t, n, r, i, this._insertCell, this.uid++), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(n), this.bboxes.push(r), this.bboxes.push(i); }, Be.prototype._insertReadonly = function () { throw 'Cannot insert into a GridIndex created from an ArrayBuffer.'; }, Be.prototype._insertCell = function (e, t, n, r, i, o) { this.cells[i].push(o); }, Be.prototype.query = function (e, t, n, r) { const i = this.min; const o = this.max; if (e <= i && t <= i && o <= n && o <= r) return Array.prototype.slice.call(this.keys); const a = []; return this._forEachCell(e, t, n, r, this._queryCell, a, {}), a; }, Be.prototype._queryCell = function (e, t, n, r, i, o, a) { const s = this.cells[i]; if (s !== null) for (let l = this.keys, u = this.bboxes, c = 0; c < s.length; c++) { const p = s[c]; if (void 0 === a[p]) { const f = 4 * p; e <= u[f + 2] && t <= u[f + 3] && n >= u[f + 0] && r >= u[f + 1] ? (a[p] = !0, o.push(l[p])) : a[p] = !1; } } }, Be.prototype._forEachCell = function (e, t, n, r, i, o, a) { for (let s = this._convertToCellCoord(e), l = this._convertToCellCoord(t), u = this._convertToCellCoord(n), c = this._convertToCellCoord(r), p = s; p <= u; p++) for (let f = l; f <= c; f++) { const h = this.d * f + p; if (i.call(this, e, t, n, r, h, o, a)) return; } }, Be.prototype._convertToCellCoord = function (e) { return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding)); }, Be.prototype.toArrayBuffer = function () { if (this.arrayBuffer) return this.arrayBuffer; for (var e = this.cells, t = ai + this.cells.length + 1 + 1, n = 0, r = 0; r < this.cells.length; r++)n += this.cells[r].length; const i = new Int32Array(t + n + this.keys.length + this.bboxes.length); i[0] = this.extent, i[1] = this.n, i[2] = this.padding; for (var o = t, a = 0; a < e.length; a++) { const s = e[a]; i[ai + a] = o, i.set(s, o), o += s.length; } return i[ai + e.length] = o, i.set(this.keys, o), o += this.keys.length, i[ai + e.length + 1] = o, i.set(this.bboxes, o), o += this.bboxes.length, i.buffer; }; var si = self.ImageData; var li = {}; for (const ui in Fe('Object', Object), oi.serialize = function (e, t) { const n = e.toArrayBuffer(); return t && t.push(n), n; }, oi.deserialize = function (e) { return new oi(e); }, Fe('Grid', oi), Fe('Color', ur), Fe('Error', Error), Fe('StylePropertyFunction', Jr), Fe('StyleExpression', Kr, { omit: ['_evaluator'] }), Fe('ZoomDependentExpression', Yr), Fe('ZoomConstantExpression', Xr), Fe('CompoundExpression', wr, { omit: ['_evaluate'] }), zr)zr[ui]._classRegistryKey || Fe(`Expression_${ui}`, zr[ui]); const ci = function () { this.first = !0; }; ci.prototype.update = function (e, t) { const n = Math.floor(e); return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = t) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = t), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = n, !0)); }; let pi; var fi = {
          'Latin-1 Supplement': function (e) { return e >= 128 && e <= 255; }, Arabic(e) { return e >= 1536 && e <= 1791; }, 'Arabic Supplement': function (e) { return e >= 1872 && e <= 1919; }, 'Arabic Extended-A': function (e) { return e >= 2208 && e <= 2303; }, 'Hangul Jamo': function (e) { return e >= 4352 && e <= 4607; }, 'Unified Canadian Aboriginal Syllabics': function (e) { return e >= 5120 && e <= 5759; }, Khmer(e) { return e >= 6016 && e <= 6143; }, 'Unified Canadian Aboriginal Syllabics Extended': function (e) { return e >= 6320 && e <= 6399; }, 'General Punctuation': function (e) { return e >= 8192 && e <= 8303; }, 'Letterlike Symbols': function (e) { return e >= 8448 && e <= 8527; }, 'Number Forms': function (e) { return e >= 8528 && e <= 8591; }, 'Miscellaneous Technical': function (e) { return e >= 8960 && e <= 9215; }, 'Control Pictures': function (e) { return e >= 9216 && e <= 9279; }, 'Optical Character Recognition': function (e) { return e >= 9280 && e <= 9311; }, 'Enclosed Alphanumerics': function (e) { return e >= 9312 && e <= 9471; }, 'Geometric Shapes': function (e) { return e >= 9632 && e <= 9727; }, 'Miscellaneous Symbols': function (e) { return e >= 9728 && e <= 9983; }, 'Miscellaneous Symbols and Arrows': function (e) { return e >= 11008 && e <= 11263; }, 'CJK Radicals Supplement': function (e) { return e >= 11904 && e <= 12031; }, 'Kangxi Radicals': function (e) { return e >= 12032 && e <= 12255; }, 'Ideographic Description Characters': function (e) { return e >= 12272 && e <= 12287; }, 'CJK Symbols and Punctuation': function (e) { return e >= 12288 && e <= 12351; }, Hiragana(e) { return e >= 12352 && e <= 12447; }, Katakana(e) { return e >= 12448 && e <= 12543; }, Bopomofo(e) { return e >= 12544 && e <= 12591; }, 'Hangul Compatibility Jamo': function (e) { return e >= 12592 && e <= 12687; }, Kanbun(e) { return e >= 12688 && e <= 12703; }, 'Bopomofo Extended': function (e) { return e >= 12704 && e <= 12735; }, 'CJK Strokes': function (e) { return e >= 12736 && e <= 12783; }, 'Katakana Phonetic Extensions': function (e) { return e >= 12784 && e <= 12799; }, 'Enclosed CJK Letters and Months': function (e) { return e >= 12800 && e <= 13055; }, 'CJK Compatibility': function (e) { return e >= 13056 && e <= 13311; }, 'CJK Unified Ideographs Extension A': function (e) { return e >= 13312 && e <= 19903; }, 'Yijing Hexagram Symbols': function (e) { return e >= 19904 && e <= 19967; }, 'CJK Unified Ideographs': function (e) { return e >= 19968 && e <= 40959; }, 'Yi Syllables': function (e) { return e >= 40960 && e <= 42127; }, 'Yi Radicals': function (e) { return e >= 42128 && e <= 42191; }, 'Hangul Jamo Extended-A': function (e) { return e >= 43360 && e <= 43391; }, 'Hangul Syllables': function (e) { return e >= 44032 && e <= 55215; }, 'Hangul Jamo Extended-B': function (e) { return e >= 55216 && e <= 55295; }, 'Private Use Area': function (e) { return e >= 57344 && e <= 63743; }, 'CJK Compatibility Ideographs': function (e) { return e >= 63744 && e <= 64255; }, 'Arabic Presentation Forms-A': function (e) { return e >= 64336 && e <= 65023; }, 'Vertical Forms': function (e) { return e >= 65040 && e <= 65055; }, 'CJK Compatibility Forms': function (e) { return e >= 65072 && e <= 65103; }, 'Small Form Variants': function (e) { return e >= 65104 && e <= 65135; }, 'Arabic Presentation Forms-B': function (e) { return e >= 65136 && e <= 65279; }, 'Halfwidth and Fullwidth Forms': function (e) { return e >= 65280 && e <= 65519; },
        }; let hi = !1; let di = null; let mi = !1; const gi = new Zn(); var yi = { applyArabicShaping: null, processBidirectionalText: null, isLoaded() { return mi || yi.applyArabicShaping != null; } }; var vi = function (e, t) { this.zoom = e, t ? (this.now = t.now, this.fadeDuration = t.fadeDuration, this.zoomHistory = t.zoomHistory, this.transition = t.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ci(), this.transition = {}); }; vi.prototype.isSupportedScript = function (e) { return (function (e, t) { for (let n = 0, r = e; n < r.length; n += 1) if (!Ge(r[n].charCodeAt(0), t)) return !1; return !0; }(e, yi.isLoaded())); }, vi.prototype.crossFadingFactor = function () { return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1); }; const _i = function (e, t) { this.property = e, this.value = t, this.expression = ce(void 0 === t ? e.specification.default : t, e.specification); }; _i.prototype.isDataDriven = function () { return this.expression.kind === 'source' || this.expression.kind === 'composite'; }, _i.prototype.possiblyEvaluate = function (e) { return this.property.possiblyEvaluate(this, e); }; const bi = function (e) { this.property = e, this.value = new _i(e, void 0); }; bi.prototype.transitioned = function (e, t) { return new wi(this.property, this.value, t, l({}, e.transition, this.transition), e.now); }, bi.prototype.untransitioned = function () { return new wi(this.property, this.value, null, {}, 0); }; const xi = function (e) { this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues); }; xi.prototype.getValue = function (e) { return h(this._values[e].value.value); }, xi.prototype.setValue = function (e, t) { this._values.hasOwnProperty(e) || (this._values[e] = new bi(this._values[e].property)), this._values[e].value = new _i(this._values[e].property, t === null ? void 0 : h(t)); }, xi.prototype.getTransition = function (e) { return h(this._values[e].transition); }, xi.prototype.setTransition = function (e, t) { this._values.hasOwnProperty(e) || (this._values[e] = new bi(this._values[e].property)), this._values[e].transition = h(t) || void 0; }, xi.prototype.serialize = function () { for (var e = {}, t = 0, n = Object.keys(this._values); t < n.length; t += 1) { const r = n[t]; const i = this.getValue(r); void 0 !== i && (e[r] = i); const o = this.getTransition(r); void 0 !== o && (e[`${r}-transition`] = o); } return e; }, xi.prototype.transitioned = function (e, t) { for (var n = new Ei(this._properties), r = 0, i = Object.keys(this._values); r < i.length; r += 1) { const o = i[r]; n._values[o] = this._values[o].transitioned(e, t._values[o]); } return n; }, xi.prototype.untransitioned = function () { for (var e = new Ei(this._properties), t = 0, n = Object.keys(this._values); t < n.length; t += 1) { const r = n[t]; e._values[r] = this._values[r].untransitioned(); } return e; }; var wi = function (e, t, n, r, i) { this.property = e, this.value = t, this.begin = i + r.delay || 0, this.end = this.begin + r.duration || 0, e.specification.transition && (r.delay || r.duration) && (this.prior = n); }; wi.prototype.possiblyEvaluate = function (e) { const t = e.now || 0; const n = this.value.possiblyEvaluate(e); const r = this.prior; if (r) { if (t > this.end) return this.prior = null, n; if (this.value.isDataDriven()) return this.prior = null, n; if (t < this.begin) return r.possiblyEvaluate(e); const i = (t - this.begin) / (this.end - this.begin); return this.property.interpolate(r.possiblyEvaluate(e), n, (function (e) { if (e <= 0) return 0; if (e >= 1) return 1; const t = e * e; const n = t * e; return 4 * (e < 0.5 ? n : 3 * (e - t) + n - 0.75); }(i))); } return n; }; var Ei = function (e) { this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues); }; Ei.prototype.possiblyEvaluate = function (e) { for (var t = new Ci(this._properties), n = 0, r = Object.keys(this._values); n < r.length; n += 1) { const i = r[n]; t._values[i] = this._values[i].possiblyEvaluate(e); } return t; }, Ei.prototype.hasTransition = function () { for (let e = 0, t = Object.keys(this._values); e < t.length; e += 1) { const n = t[e]; if (this._values[n].prior) return !0; } return !1; }; const Ti = function (e) { this._properties = e, this._values = Object.create(e.defaultPropertyValues); }; Ti.prototype.getValue = function (e) { return h(this._values[e].value); }, Ti.prototype.setValue = function (e, t) { this._values[e] = new _i(this._values[e].property, t === null ? void 0 : h(t)); }, Ti.prototype.serialize = function () { for (var e = {}, t = 0, n = Object.keys(this._values); t < n.length; t += 1) { const r = n[t]; const i = this.getValue(r); void 0 !== i && (e[r] = i); } return e; }, Ti.prototype.possiblyEvaluate = function (e) { for (var t = new Ci(this._properties), n = 0, r = Object.keys(this._values); n < r.length; n += 1) { const i = r[n]; t._values[i] = this._values[i].possiblyEvaluate(e); } return t; }; const ki = function (e, t, n) { this.property = e, this.value = t, this.globals = n; }; ki.prototype.isConstant = function () { return this.value.kind === 'constant'; }, ki.prototype.constantOr = function (e) { return this.value.kind === 'constant' ? this.value.value : e; }, ki.prototype.evaluate = function (e) { return this.property.evaluate(this.value, this.globals, e); }; var Ci = function (e) { this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues); }; Ci.prototype.get = function (e) { return this._values[e]; }; const Si = function (e) { this.specification = e; }; Si.prototype.possiblyEvaluate = function (e, t) { return e.expression.evaluate(t); }, Si.prototype.interpolate = function (e, t, n) { const r = Cr[this.specification.type]; return r ? r(e, t, n) : e; }; const Ai = function (e) { this.specification = e; }; Ai.prototype.possiblyEvaluate = function (e, t) { return e.expression.kind === 'constant' || e.expression.kind === 'camera' ? new ki(this, { kind: 'constant', value: e.expression.evaluate(t) }, t) : new ki(this, e.expression, t); }, Ai.prototype.interpolate = function (e, t, n) { if (e.value.kind !== 'constant' || t.value.kind !== 'constant') return e; if (void 0 === e.value.value || void 0 === t.value.value) return new ki(this, { kind: 'constant', value: void 0 }, e.globals); const r = Cr[this.specification.type]; return r ? new ki(this, { kind: 'constant', value: r(e.value.value, t.value.value, n) }, e.globals) : e; }, Ai.prototype.evaluate = function (e, t, n) { return e.kind === 'constant' ? e.value : e.evaluate(t, n); }; const Oi = function (e) { this.specification = e; }; Oi.prototype.possiblyEvaluate = function (e, t) { if (void 0 !== e.value) { if (e.expression.kind === 'constant') { const n = e.expression.evaluate(t); return this._calculate(n, n, n, t); } return this._calculate(e.expression.evaluate(new vi(Math.floor(t.zoom - 1), t)), e.expression.evaluate(new vi(Math.floor(t.zoom), t)), e.expression.evaluate(new vi(Math.floor(t.zoom + 1), t)), t); } }, Oi.prototype._calculate = function (e, t, n, r) {
          const i = r.zoom; const o = i - Math.floor(i); const a = r.crossFadingFactor(); return i > r.zoomHistory.lastIntegerZoom ? {
            from: e, to: t, fromScale: 2, toScale: 1, t: o + (1 - o) * a,
          } : {
            from: n, to: t, fromScale: 0.5, toScale: 1, t: 1 - (1 - a) * o,
          };
        }, Oi.prototype.interpolate = function (e) { return e; }; const Ii = function (e) { this.specification = e; }; Ii.prototype.possiblyEvaluate = function (e, t) { return !!e.expression.evaluate(t); }, Ii.prototype.interpolate = function () { return !1; }; const Pi = function (e) { for (const t in this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, e) { const n = e[t]; const r = this.defaultPropertyValues[t] = new _i(n, void 0); const i = this.defaultTransitionablePropertyValues[t] = new bi(n); this.defaultTransitioningPropertyValues[t] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[t] = r.possiblyEvaluate({}); } }; Fe('DataDrivenProperty', Ai), Fe('DataConstantProperty', Si), Fe('CrossFadedProperty', Oi), Fe('ColorRampProperty', Ii); const Mi = (function (e) {
          function t(t, n) { for (const r in e.call(this), this.id = t.id, this.metadata = t.metadata, this.type = t.type, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, this.visibility = 'visible', t.type !== 'background' && (this.source = t.source, this.sourceLayer = t['source-layer'], this.filter = t.filter), this._featureFilter = function () { return !0; }, n.layout && (this._unevaluatedLayout = new Ti(n.layout)), this._transitionablePaint = new xi(n.paint), t.paint) this.setPaintProperty(r, t.paint[r], { validate: !1 }); for (const i in t.layout) this.setLayoutProperty(i, t.layout[i], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned(); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.getLayoutProperty = function (e) { return e === 'visibility' ? this.visibility : this._unevaluatedLayout.getValue(e); }, t.prototype.setLayoutProperty = function (e, t, n) { if (t != null) { const r = `layers.${this.id}.layout.${e}`; if (this._validate(ii, r, e, t, n)) return; }e !== 'visibility' ? this._unevaluatedLayout.setValue(e, t) : this.visibility = t === 'none' ? t : 'visible'; }, t.prototype.getPaintProperty = function (e) { return c(e, '-transition') ? this._transitionablePaint.getTransition(e.slice(0, -'-transition'.length)) : this._transitionablePaint.getValue(e); }, t.prototype.setPaintProperty = function (e, t, n) { if (t != null) { const r = `layers.${this.id}.paint.${e}`; if (this._validate(ri, r, e, t, n)) return; }c(e, '-transition') ? this._transitionablePaint.setTransition(e.slice(0, -'-transition'.length), t || void 0) : this._transitionablePaint.setValue(e, t); }, t.prototype.isHidden = function (e) { return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === 'none'; }, t.prototype.updateTransitions = function (e) { this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint); }, t.prototype.hasTransition = function () { return this._transitioningPaint.hasTransition(); }, t.prototype.recalculate = function (e) { this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e)), this.paint = this._transitioningPaint.possiblyEvaluate(e); }, t.prototype.serialize = function () {
            const e = {
              id: this.id, type: this.type, source: this.source, 'source-layer': this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize(),
            }; return this.visibility === 'none' && (e.layout = e.layout || {}, e.layout.visibility = 'none'), f(e, (e, t) => !(void 0 === e || t === 'layout' && !Object.keys(e).length || t === 'paint' && !Object.keys(e).length));
          }, t.prototype._validate = function (e, t, n, r, i) {
            return (!i || !1 !== i.validate) && je(this, e.call(ti, {
              key: t, layerType: this.type, objectKey: n, value: r, styleSpec: Kn, style: { glyphs: !0, sprite: !0 },
            }));
          }, t.prototype.hasOffscreenPass = function () { return !1; }, t.prototype.resize = function () {}, t;
        }(Zn)); var Ni = {
          Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array,
        }; const Di = function (e, t) { this._structArray = e, this._pos1 = t * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8; }; const Li = function () { this.isTransferred = !1, this.capacity = -1, this.resize(0); }; Li.serialize = function (e, t) { return e._trim(), t && (e.isTransferred = !0, t.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer }; }, Li.deserialize = function (e) { const t = Object.create(this.prototype); return t.arrayBuffer = e.arrayBuffer, t.length = e.length, t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement, t._refreshViews(), t; }, Li.prototype._trim = function () { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()); }, Li.prototype.clear = function () { this.length = 0; }, Li.prototype.resize = function (e) { this.reserve(e), this.length = e; }, Li.prototype.reserve = function (e) { if (e > this.capacity) { this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement); const t = this.uint8; this._refreshViews(), t && this.uint8.set(t); } }, Li.prototype._refreshViews = function () { throw new Error('_refreshViews() must be implemented by each concrete StructArray layout'); }; const zi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t) { const n = this.length; this.resize(n + 1); const r = 2 * n; return this.int16[r + 0] = e, this.int16[r + 1] = t, n; }, t; }(Li)); zi.prototype.bytesPerElement = 4, Fe('StructArrayLayout2i4', zi); const Ri = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r) { const i = this.length; this.resize(i + 1); const o = 4 * i; return this.int16[o + 0] = e, this.int16[o + 1] = t, this.int16[o + 2] = n, this.int16[o + 3] = r, i; }, t; }(Li)); Ri.prototype.bytesPerElement = 8, Fe('StructArrayLayout4i8', Ri); const ji = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r, i, o) { const a = this.length; this.resize(a + 1); const s = 6 * a; return this.int16[s + 0] = e, this.int16[s + 1] = t, this.int16[s + 2] = n, this.int16[s + 3] = r, this.int16[s + 4] = i, this.int16[s + 5] = o, a; }, t; }(Li)); ji.prototype.bytesPerElement = 12, Fe('StructArrayLayout2i4i12', ji); const Bi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r, i, o, a, s) { const l = this.length; this.resize(l + 1); const u = 6 * l; const c = 12 * l; return this.int16[u + 0] = e, this.int16[u + 1] = t, this.int16[u + 2] = n, this.int16[u + 3] = r, this.uint8[c + 8] = i, this.uint8[c + 9] = o, this.uint8[c + 10] = a, this.uint8[c + 11] = s, l; }, t; }(Li)); Bi.prototype.bytesPerElement = 12, Fe('StructArrayLayout4i4ub12', Bi); const Fi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r, i, o, a, s) { const l = this.length; this.resize(l + 1); const u = 8 * l; return this.int16[u + 0] = e, this.int16[u + 1] = t, this.int16[u + 2] = n, this.int16[u + 3] = r, this.uint16[u + 4] = i, this.uint16[u + 5] = o, this.uint16[u + 6] = a, this.uint16[u + 7] = s, l; }, t; }(Li)); Fi.prototype.bytesPerElement = 16, Fe('StructArrayLayout4i4ui16', Fi); const Ui = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n) { const r = this.length; this.resize(r + 1); const i = 3 * r; return this.float32[i + 0] = e, this.float32[i + 1] = t, this.float32[i + 2] = n, r; }, t; }(Li)); Ui.prototype.bytesPerElement = 12, Fe('StructArrayLayout3f12', Ui); const Vi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e) { const t = this.length; this.resize(t + 1); const n = 1 * t; return this.uint32[n + 0] = e, t; }, t; }(Li)); Vi.prototype.bytesPerElement = 4, Fe('StructArrayLayout1ul4', Vi); const qi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r, i, o, a, s, l, u, c) { const p = this.length; this.resize(p + 1); const f = 12 * p; const h = 6 * p; return this.int16[f + 0] = e, this.int16[f + 1] = t, this.int16[f + 2] = n, this.int16[f + 3] = r, this.int16[f + 4] = i, this.int16[f + 5] = o, this.uint32[h + 3] = a, this.uint16[f + 8] = s, this.uint16[f + 9] = l, this.int16[f + 10] = u, this.int16[f + 11] = c, p; }, t; }(Li)); qi.prototype.bytesPerElement = 24, Fe('StructArrayLayout6i1ul2ui2i24', qi); const Hi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r, i, o) { const a = this.length; this.resize(a + 1); const s = 6 * a; return this.int16[s + 0] = e, this.int16[s + 1] = t, this.int16[s + 2] = n, this.int16[s + 3] = r, this.int16[s + 4] = i, this.int16[s + 5] = o, a; }, t; }(Li)); Hi.prototype.bytesPerElement = 12, Fe('StructArrayLayout2i2i2i12', Hi); const Wi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t) { const n = this.length; this.resize(n + 1); const r = 4 * n; return this.uint8[r + 0] = e, this.uint8[r + 1] = t, n; }, t; }(Li)); Wi.prototype.bytesPerElement = 4, Fe('StructArrayLayout2ub4', Wi); const $i = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r, i, o, a, s, l, u, c, p, f, h) { const d = this.length; this.resize(d + 1); const m = 20 * d; const g = 10 * d; const y = 40 * d; return this.int16[m + 0] = e, this.int16[m + 1] = t, this.uint16[m + 2] = n, this.uint16[m + 3] = r, this.uint32[g + 2] = i, this.uint32[g + 3] = o, this.uint32[g + 4] = a, this.uint16[m + 10] = s, this.uint16[m + 11] = l, this.uint16[m + 12] = u, this.float32[g + 7] = c, this.float32[g + 8] = p, this.uint8[y + 36] = f, this.uint8[y + 37] = h, d; }, t; }(Li)); $i.prototype.bytesPerElement = 40, Fe('StructArrayLayout2i2ui3ul3ui2f2ub40', $i); const Gi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e) { const t = this.length; this.resize(t + 1); const n = 1 * t; return this.float32[n + 0] = e, t; }, t; }(Li)); Gi.prototype.bytesPerElement = 4, Fe('StructArrayLayout1f4', Gi); const Zi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n) { const r = this.length; this.resize(r + 1); const i = 3 * r; return this.int16[i + 0] = e, this.int16[i + 1] = t, this.int16[i + 2] = n, r; }, t; }(Li)); Zi.prototype.bytesPerElement = 6, Fe('StructArrayLayout3i6', Zi); const Ki = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n) { const r = this.length; this.resize(r + 1); const i = 2 * r; const o = 4 * r; return this.uint32[i + 0] = e, this.uint16[o + 2] = t, this.uint16[o + 3] = n, r; }, t; }(Li)); Ki.prototype.bytesPerElement = 8, Fe('StructArrayLayout1ul2ui8', Ki); const Xi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n) { const r = this.length; this.resize(r + 1); const i = 3 * r; return this.uint16[i + 0] = e, this.uint16[i + 1] = t, this.uint16[i + 2] = n, r; }, t; }(Li)); Xi.prototype.bytesPerElement = 6, Fe('StructArrayLayout3ui6', Xi); const Yi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t) { const n = this.length; this.resize(n + 1); const r = 2 * n; return this.uint16[r + 0] = e, this.uint16[r + 1] = t, n; }, t; }(Li)); Yi.prototype.bytesPerElement = 4, Fe('StructArrayLayout2ui4', Yi); const Ji = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t) { const n = this.length; this.resize(n + 1); const r = 2 * n; return this.float32[r + 0] = e, this.float32[r + 1] = t, n; }, t; }(Li)); Ji.prototype.bytesPerElement = 8, Fe('StructArrayLayout2f8', Ji); const Qi = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }, t.prototype.emplaceBack = function (e, t, n, r) { const i = this.length; this.resize(i + 1); const o = 4 * i; return this.float32[o + 0] = e, this.float32[o + 1] = t, this.float32[o + 2] = n, this.float32[o + 3] = r, i; }, t; }(Li)); Qi.prototype.bytesPerElement = 16, Fe('StructArrayLayout4f16', Qi); const eo = (function (e) {
          function t() { e.apply(this, arguments); }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const n = {
            anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, radius: { configurable: !0 }, signedDistanceFromAnchor: { configurable: !0 }, anchorPoint: { configurable: !0 },
          }; return n.anchorPointX.get = function () { return this._structArray.int16[this._pos2 + 0]; }, n.anchorPointX.set = function (e) { this._structArray.int16[this._pos2 + 0] = e; }, n.anchorPointY.get = function () { return this._structArray.int16[this._pos2 + 1]; }, n.anchorPointY.set = function (e) { this._structArray.int16[this._pos2 + 1] = e; }, n.x1.get = function () { return this._structArray.int16[this._pos2 + 2]; }, n.x1.set = function (e) { this._structArray.int16[this._pos2 + 2] = e; }, n.y1.get = function () { return this._structArray.int16[this._pos2 + 3]; }, n.y1.set = function (e) { this._structArray.int16[this._pos2 + 3] = e; }, n.x2.get = function () { return this._structArray.int16[this._pos2 + 4]; }, n.x2.set = function (e) { this._structArray.int16[this._pos2 + 4] = e; }, n.y2.get = function () { return this._structArray.int16[this._pos2 + 5]; }, n.y2.set = function (e) { this._structArray.int16[this._pos2 + 5] = e; }, n.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 3]; }, n.featureIndex.set = function (e) { this._structArray.uint32[this._pos4 + 3] = e; }, n.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 8]; }, n.sourceLayerIndex.set = function (e) { this._structArray.uint16[this._pos2 + 8] = e; }, n.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 9]; }, n.bucketIndex.set = function (e) { this._structArray.uint16[this._pos2 + 9] = e; }, n.radius.get = function () { return this._structArray.int16[this._pos2 + 10]; }, n.radius.set = function (e) { this._structArray.int16[this._pos2 + 10] = e; }, n.signedDistanceFromAnchor.get = function () { return this._structArray.int16[this._pos2 + 11]; }, n.signedDistanceFromAnchor.set = function (e) { this._structArray.int16[this._pos2 + 11] = e; }, n.anchorPoint.get = function () { return new Bn(this.anchorPointX, this.anchorPointY); }, Object.defineProperties(t.prototype, n), t;
        }(Di)); eo.prototype.size = 24; const to = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.get = function (e) { return new eo(this, e); }, t; }(qi)); Fe('CollisionBoxArray', to); const no = (function (e) {
          function t() { e.apply(this, arguments); }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const n = {
            anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, hidden: { configurable: !0 },
          }; return n.anchorX.get = function () { return this._structArray.int16[this._pos2 + 0]; }, n.anchorX.set = function (e) { this._structArray.int16[this._pos2 + 0] = e; }, n.anchorY.get = function () { return this._structArray.int16[this._pos2 + 1]; }, n.anchorY.set = function (e) { this._structArray.int16[this._pos2 + 1] = e; }, n.glyphStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 2]; }, n.glyphStartIndex.set = function (e) { this._structArray.uint16[this._pos2 + 2] = e; }, n.numGlyphs.get = function () { return this._structArray.uint16[this._pos2 + 3]; }, n.numGlyphs.set = function (e) { this._structArray.uint16[this._pos2 + 3] = e; }, n.vertexStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 2]; }, n.vertexStartIndex.set = function (e) { this._structArray.uint32[this._pos4 + 2] = e; }, n.lineStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 3]; }, n.lineStartIndex.set = function (e) { this._structArray.uint32[this._pos4 + 3] = e; }, n.lineLength.get = function () { return this._structArray.uint32[this._pos4 + 4]; }, n.lineLength.set = function (e) { this._structArray.uint32[this._pos4 + 4] = e; }, n.segment.get = function () { return this._structArray.uint16[this._pos2 + 10]; }, n.segment.set = function (e) { this._structArray.uint16[this._pos2 + 10] = e; }, n.lowerSize.get = function () { return this._structArray.uint16[this._pos2 + 11]; }, n.lowerSize.set = function (e) { this._structArray.uint16[this._pos2 + 11] = e; }, n.upperSize.get = function () { return this._structArray.uint16[this._pos2 + 12]; }, n.upperSize.set = function (e) { this._structArray.uint16[this._pos2 + 12] = e; }, n.lineOffsetX.get = function () { return this._structArray.float32[this._pos4 + 7]; }, n.lineOffsetX.set = function (e) { this._structArray.float32[this._pos4 + 7] = e; }, n.lineOffsetY.get = function () { return this._structArray.float32[this._pos4 + 8]; }, n.lineOffsetY.set = function (e) { this._structArray.float32[this._pos4 + 8] = e; }, n.writingMode.get = function () { return this._structArray.uint8[this._pos1 + 36]; }, n.writingMode.set = function (e) { this._structArray.uint8[this._pos1 + 36] = e; }, n.hidden.get = function () { return this._structArray.uint8[this._pos1 + 37]; }, n.hidden.set = function (e) { this._structArray.uint8[this._pos1 + 37] = e; }, Object.defineProperties(t.prototype, n), t;
        }(Di)); no.prototype.size = 40; const ro = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.get = function (e) { return new no(this, e); }, t; }($i)); Fe('PlacedSymbolArray', ro); const io = (function (e) { function t() { e.apply(this, arguments); }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const n = { offsetX: { configurable: !0 } }; return n.offsetX.get = function () { return this._structArray.float32[this._pos4 + 0]; }, n.offsetX.set = function (e) { this._structArray.float32[this._pos4 + 0] = e; }, Object.defineProperties(t.prototype, n), t; }(Di)); io.prototype.size = 4; const oo = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.getoffsetX = function (e) { return this.float32[1 * e + 0]; }, t.prototype.get = function (e) { return new io(this, e); }, t; }(Gi)); Fe('GlyphOffsetArray', oo); const ao = (function (e) { function t() { e.apply(this, arguments); }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const n = { x: { configurable: !0 }, y: { configurable: !0 }, tileUnitDistanceFromAnchor: { configurable: !0 } }; return n.x.get = function () { return this._structArray.int16[this._pos2 + 0]; }, n.x.set = function (e) { this._structArray.int16[this._pos2 + 0] = e; }, n.y.get = function () { return this._structArray.int16[this._pos2 + 1]; }, n.y.set = function (e) { this._structArray.int16[this._pos2 + 1] = e; }, n.tileUnitDistanceFromAnchor.get = function () { return this._structArray.int16[this._pos2 + 2]; }, n.tileUnitDistanceFromAnchor.set = function (e) { this._structArray.int16[this._pos2 + 2] = e; }, Object.defineProperties(t.prototype, n), t; }(Di)); ao.prototype.size = 6; const so = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.getx = function (e) { return this.int16[3 * e + 0]; }, t.prototype.gety = function (e) { return this.int16[3 * e + 1]; }, t.prototype.gettileUnitDistanceFromAnchor = function (e) { return this.int16[3 * e + 2]; }, t.prototype.get = function (e) { return new ao(this, e); }, t; }(Zi)); Fe('SymbolLineVertexArray', so); const lo = (function (e) { function t() { e.apply(this, arguments); }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const n = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } }; return n.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 0]; }, n.featureIndex.set = function (e) { this._structArray.uint32[this._pos4 + 0] = e; }, n.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 2]; }, n.sourceLayerIndex.set = function (e) { this._structArray.uint16[this._pos2 + 2] = e; }, n.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 3]; }, n.bucketIndex.set = function (e) { this._structArray.uint16[this._pos2 + 3] = e; }, Object.defineProperties(t.prototype, n), t; }(Di)); lo.prototype.size = 8; const uo = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.get = function (e) { return new lo(this, e); }, t; }(Ki)); Fe('FeatureIndexArray', uo); const co = Ze([{ name: 'a_pos', components: 2, type: 'Int16' }], 4).members; const po = function (e) { void 0 === e && (e = []), this.segments = e; }; po.prototype.prepareSegment = function (e, t, n) {
          let r = this.segments[this.segments.length - 1]; return e > po.MAX_VERTEX_ARRAY_LENGTH && d(`Max vertices per segment is ${po.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!r || r.vertexLength + e > po.MAX_VERTEX_ARRAY_LENGTH) && (r = {
            vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0,
          }, this.segments.push(r)), r;
        }, po.prototype.get = function () { return this.segments; }, po.prototype.destroy = function () { for (let e = 0, t = this.segments; e < t.length; e += 1) { const n = t[e]; for (const r in n.vaos)n.vaos[r].destroy(); } }, po.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Fe('SegmentVector', po); var fo = function (e, t) { return 256 * (e = s(Math.floor(e), 0, 255)) + (t = s(Math.floor(t), 0, 255)); }; const ho = function (e, t, n) { this.value = e, this.name = t, this.type = n, this.statistics = { max: -1 / 0 }; }; ho.prototype.defines = function () { return [`#define HAS_UNIFORM_u_${this.name}`]; }, ho.prototype.populatePaintArray = function () {}, ho.prototype.upload = function () {}, ho.prototype.destroy = function () {}, ho.prototype.setUniforms = function (e, t, n, r) { const i = r.constantOr(this.value); const o = e.gl; this.type === 'color' ? o.uniform4f(t.uniforms[`u_${this.name}`], i.r, i.g, i.b, i.a) : o.uniform1f(t.uniforms[`u_${this.name}`], i); }; const mo = function (e, t, n) {
          this.expression = e, this.name = t, this.type = n, this.statistics = { max: -1 / 0 }; const r = n === 'color' ? Ji : Gi; this.paintVertexAttributes = [{
            name: `a_${t}`, type: 'Float32', components: n === 'color' ? 2 : 1, offset: 0,
          }], this.paintVertexArray = new r();
        }; mo.prototype.defines = function () { return []; }, mo.prototype.populatePaintArray = function (e, t) { const n = this.paintVertexArray; const r = n.length; n.reserve(e); const i = this.expression.evaluate(new vi(0), t); if (this.type === 'color') for (let o = Xe(i), a = r; a < e; a++)n.emplaceBack(o[0], o[1]); else { for (let s = r; s < e; s++)n.emplaceBack(i); this.statistics.max = Math.max(this.statistics.max, i); } }, mo.prototype.upload = function (e) { this.paintVertexArray && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes)); }, mo.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy(); }, mo.prototype.setUniforms = function (e, t) { e.gl.uniform1f(t.uniforms[`a_${this.name}_t`], 0); }; const go = function (e, t, n, r, i) {
          this.expression = e, this.name = t, this.type = n, this.useIntegerZoom = r, this.zoom = i, this.statistics = { max: -1 / 0 }; const o = n === 'color' ? Qi : Ji; this.paintVertexAttributes = [{
            name: `a_${t}`, type: 'Float32', components: n === 'color' ? 4 : 2, offset: 0,
          }], this.paintVertexArray = new o();
        }; go.prototype.defines = function () { return []; }, go.prototype.populatePaintArray = function (e, t) { const n = this.paintVertexArray; const r = n.length; n.reserve(e); const i = this.expression.evaluate(new vi(this.zoom), t); const o = this.expression.evaluate(new vi(this.zoom + 1), t); if (this.type === 'color') for (let a = Xe(i), s = Xe(o), l = r; l < e; l++)n.emplaceBack(a[0], a[1], s[0], s[1]); else { for (let u = r; u < e; u++)n.emplaceBack(i, o); this.statistics.max = Math.max(this.statistics.max, i, o); } }, go.prototype.upload = function (e) { this.paintVertexArray && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes)); }, go.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy(); }, go.prototype.interpolationFactor = function (e) { return this.useIntegerZoom ? this.expression.interpolationFactor(Math.floor(e), this.zoom, this.zoom + 1) : this.expression.interpolationFactor(e, this.zoom, this.zoom + 1); }, go.prototype.setUniforms = function (e, t, n) { e.gl.uniform1f(t.uniforms[`a_${this.name}_t`], this.interpolationFactor(n.zoom)); }; const yo = function () { this.binders = {}, this.cacheKey = '', this._buffers = []; }; yo.createDynamic = function (e, t, n) {
          const r = new yo();


          const i = []; for (const o in e.paint._values) if (n(o)) { const a = e.paint.get(o); if (a instanceof ki && a.property.specification['property-function']) { const s = Ye(o, e.type); const l = a.property.specification.type; const u = a.property.useIntegerZoom; a.value.kind === 'constant' ? (r.binders[o] = new ho(a.value, s, l), i.push(`/u_${s}`)) : a.value.kind === 'source' ? (r.binders[o] = new mo(a.value, s, l), i.push(`/a_${s}`)) : (r.binders[o] = new go(a.value, s, l, u, t), i.push(`/z_${s}`)); } } return r.cacheKey = i.sort().join(''), r;
        }, yo.prototype.populatePaintArrays = function (e, t) { for (const n in this.binders) this.binders[n].populatePaintArray(e, t); }, yo.prototype.defines = function () { const e = []; for (const t in this.binders)e.push(...this.binders[t].defines()); return e; }, yo.prototype.setUniforms = function (e, t, n, r) { for (const i in this.binders) this.binders[i].setUniforms(e, t, r, n.get(i)); }, yo.prototype.getPaintVertexBuffers = function () { return this._buffers; }, yo.prototype.upload = function (e) { for (const t in this.binders) this.binders[t].upload(e); const n = []; for (const r in this.binders) { const i = this.binders[r]; (i instanceof mo || i instanceof go) && i.paintVertexBuffer && n.push(i.paintVertexBuffer); } this._buffers = n; }, yo.prototype.destroy = function () { for (const e in this.binders) this.binders[e].destroy(); }; const vo = function (e, t, n, r) { void 0 === r && (r = function () { return !0; }), this.programConfigurations = {}; for (let i = 0, o = t; i < o.length; i += 1) { const a = o[i]; this.programConfigurations[a.id] = yo.createDynamic(a, n, r), this.programConfigurations[a.id].layoutAttributes = e; } }; vo.prototype.populatePaintArrays = function (e, t) { for (const n in this.programConfigurations) this.programConfigurations[n].populatePaintArrays(e, t); }, vo.prototype.get = function (e) { return this.programConfigurations[e]; }, vo.prototype.upload = function (e) { for (const t in this.programConfigurations) this.programConfigurations[t].upload(e); }, vo.prototype.destroy = function () { for (const e in this.programConfigurations) this.programConfigurations[e].destroy(); }, Fe('ConstantBinder', ho), Fe('SourceExpressionBinder', mo), Fe('CompositeExpressionBinder', go), Fe('ProgramConfiguration', yo, { omit: ['_buffers'] }), Fe('ProgramConfigurationSet', vo); let _o; var bo = 8192; var xo = (_o = 16, { min: -1 * Math.pow(2, _o - 1), max: Math.pow(2, _o - 1) - 1 }); const wo = function (e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.layoutVertexArray = new zi(), this.indexArray = new Xi(), this.segments = new po(), this.programConfigurations = new vo(co, e.layers, e.zoom); }; wo.prototype.populate = function (e, t) { for (let n = 0, r = e; n < r.length; n += 1) { const i = r[n]; const o = i.feature; const a = i.index; const s = i.sourceLayerIndex; if (this.layers[0]._featureFilter(new vi(this.zoom), o)) { const l = Je(o); this.addFeature(o, l), t.featureIndex.insert(o, l, a, s, this.index); } } }, wo.prototype.isEmpty = function () { return this.layoutVertexArray.length === 0; }, wo.prototype.upload = function (e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, co), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.programConfigurations.upload(e); }, wo.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()); }, wo.prototype.addFeature = function (e, t) { for (let n = 0, r = t; n < r.length; n += 1) for (let i = 0, o = r[n]; i < o.length; i += 1) { const a = o[i]; const s = a.x; const l = a.y; if (!(s < 0 || s >= bo || l < 0 || l >= bo)) { const u = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray); const c = u.vertexLength; Qe(this.layoutVertexArray, s, l, -1, -1), Qe(this.layoutVertexArray, s, l, 1, -1), Qe(this.layoutVertexArray, s, l, 1, 1), Qe(this.layoutVertexArray, s, l, -1, 1), this.indexArray.emplaceBack(c, c + 1, c + 2), this.indexArray.emplaceBack(c, c + 3, c + 2), u.vertexLength += 4, u.primitiveLength += 2; } } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e); }, Fe('CircleBucket', wo, { omit: ['layers'] }); const Eo = {
          paint: new Pi({
            'circle-radius': new Ai(Kn.paint_circle['circle-radius']), 'circle-color': new Ai(Kn.paint_circle['circle-color']), 'circle-blur': new Ai(Kn.paint_circle['circle-blur']), 'circle-opacity': new Ai(Kn.paint_circle['circle-opacity']), 'circle-translate': new Si(Kn.paint_circle['circle-translate']), 'circle-translate-anchor': new Si(Kn.paint_circle['circle-translate-anchor']), 'circle-pitch-scale': new Si(Kn.paint_circle['circle-pitch-scale']), 'circle-pitch-alignment': new Si(Kn.paint_circle['circle-pitch-alignment']), 'circle-stroke-width': new Ai(Kn.paint_circle['circle-stroke-width']), 'circle-stroke-color': new Ai(Kn.paint_circle['circle-stroke-color']), 'circle-stroke-opacity': new Ai(Kn.paint_circle['circle-stroke-opacity']),
          }),
        }; const To = r((e, t) => {
          let n; e.exports = ((n = new Float32Array(3))[0] = 0, n[1] = 0, n[2] = 0, (function () { const e = new Float32Array(4); e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0; }()), {
            vec3: { transformMat3(e, t, n) { const r = t[0]; const i = t[1]; const o = t[2]; return e[0] = r * n[0] + i * n[3] + o * n[6], e[1] = r * n[1] + i * n[4] + o * n[7], e[2] = r * n[2] + i * n[5] + o * n[8], e; } },
            vec4: { transformMat4(e, t, n) { const r = t[0]; const i = t[1]; const o = t[2]; const a = t[3]; return e[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * a, e[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * a, e[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * a, e[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * a, e; } },
            mat2: { create() { const e = new Float32Array(4); return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e; }, rotate(e, t, n) { const r = t[0]; const i = t[1]; const o = t[2]; const a = t[3]; const s = Math.sin(n); const l = Math.cos(n); return e[0] = r * l + o * s, e[1] = i * l + a * s, e[2] = r * -s + o * l, e[3] = i * -s + a * l, e; }, scale(e, t, n) { const r = t[0]; const i = t[1]; const o = t[2]; const a = t[3]; const s = n[0]; const l = n[1]; return e[0] = r * s, e[1] = i * s, e[2] = o * l, e[3] = a * l, e; } },
            mat3: { create() { const e = new Float32Array(9); return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e; }, fromRotation(e, t) { const n = Math.sin(t); const r = Math.cos(t); return e[0] = r, e[1] = n, e[2] = 0, e[3] = -n, e[4] = r, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e; } },
            mat4: {
              create () { const e = new Float32Array(16); return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e; }, identity(e) { return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e; }, translate(e, t, n) { let r; let i; let o; let a; let s; let l; let u; let c; let p; let f; let h; let d; const m = n[0]; const g = n[1]; const y = n[2]; return t === e ? (e[12] = t[0] * m + t[4] * g + t[8] * y + t[12], e[13] = t[1] * m + t[5] * g + t[9] * y + t[13], e[14] = t[2] * m + t[6] * g + t[10] * y + t[14], e[15] = t[3] * m + t[7] * g + t[11] * y + t[15]) : (r = t[0], i = t[1], o = t[2], a = t[3], s = t[4], l = t[5], u = t[6], c = t[7], p = t[8], f = t[9], h = t[10], d = t[11], e[0] = r, e[1] = i, e[2] = o, e[3] = a, e[4] = s, e[5] = l, e[6] = u, e[7] = c, e[8] = p, e[9] = f, e[10] = h, e[11] = d, e[12] = r * m + s * g + p * y + t[12], e[13] = i * m + l * g + f * y + t[13], e[14] = o * m + u * g + h * y + t[14], e[15] = a * m + c * g + d * y + t[15]), e; }, scale(e, t, n) { const r = n[0]; const i = n[1]; const o = n[2]; return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = t[11] * o, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e; }, multiply(e, t, n) { const r = t[0]; const i = t[1]; const o = t[2]; const a = t[3]; const s = t[4]; const l = t[5]; const u = t[6]; const c = t[7]; const p = t[8]; const f = t[9]; const h = t[10]; const d = t[11]; const m = t[12]; const g = t[13]; const y = t[14]; const v = t[15]; let _ = n[0]; let b = n[1]; let x = n[2]; let w = n[3]; return e[0] = _ * r + b * s + x * p + w * m, e[1] = _ * i + b * l + x * f + w * g, e[2] = _ * o + b * u + x * h + w * y, e[3] = _ * a + b * c + x * d + w * v, _ = n[4], b = n[5], x = n[6], w = n[7], e[4] = _ * r + b * s + x * p + w * m, e[5] = _ * i + b * l + x * f + w * g, e[6] = _ * o + b * u + x * h + w * y, e[7] = _ * a + b * c + x * d + w * v, _ = n[8], b = n[9], x = n[10], w = n[11], e[8] = _ * r + b * s + x * p + w * m, e[9] = _ * i + b * l + x * f + w * g, e[10] = _ * o + b * u + x * h + w * y, e[11] = _ * a + b * c + x * d + w * v, _ = n[12], b = n[13], x = n[14], w = n[15], e[12] = _ * r + b * s + x * p + w * m, e[13] = _ * i + b * l + x * f + w * g, e[14] = _ * o + b * u + x * h + w * y, e[15] = _ * a + b * c + x * d + w * v, e; }, perspective(e, t, n, r, i) { const o = 1 / Math.tan(t / 2); const a = 1 / (r - i); return e[0] = o / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = o, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (i + r) * a, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * i * r * a, e[15] = 0, e; }, rotateX(e, t, n) { const r = Math.sin(n); const i = Math.cos(n); const o = t[4]; const a = t[5]; const s = t[6]; const l = t[7]; const u = t[8]; const c = t[9]; const p = t[10]; const f = t[11]; return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = o * i + u * r, e[5] = a * i + c * r, e[6] = s * i + p * r, e[7] = l * i + f * r, e[8] = u * i - o * r, e[9] = c * i - a * r, e[10] = p * i - s * r, e[11] = f * i - l * r, e; }, rotateZ(e, t, n) { const r = Math.sin(n); const i = Math.cos(n); const o = t[0]; const a = t[1]; const s = t[2]; const l = t[3]; const u = t[4]; const c = t[5]; const p = t[6]; const f = t[7]; return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * i + u * r, e[1] = a * i + c * r, e[2] = s * i + p * r, e[3] = l * i + f * r, e[4] = u * i - o * r, e[5] = c * i - a * r, e[6] = p * i - s * r, e[7] = f * i - l * r, e; }, invert(e, t) { const n = t[0]; const r = t[1]; const i = t[2]; const o = t[3]; const a = t[4]; const s = t[5]; const l = t[6]; const u = t[7]; const c = t[8]; const p = t[9]; const f = t[10]; const h = t[11]; const d = t[12]; const m = t[13]; const g = t[14]; const y = t[15]; const v = n * s - r * a; const _ = n * l - i * a; const b = n * u - o * a; const x = r * l - i * s; const w = r * u - o * s; const E = i * u - o * l; const T = c * m - p * d; const k = c * g - f * d; const C = c * y - h * d; const S = p * g - f * m; const A = p * y - h * m; const O = f * y - h * g; let I = v * O - _ * A + b * S + x * C - w * k + E * T; return I ? (I = 1 / I, e[0] = (s * O - l * A + u * S) * I, e[1] = (i * A - r * O - o * S) * I, e[2] = (m * E - g * w + y * x) * I, e[3] = (f * w - p * E - h * x) * I, e[4] = (l * C - a * O - u * k) * I, e[5] = (n * O - i * C + o * k) * I, e[6] = (g * b - d * E - y * _) * I, e[7] = (c * E - f * b + h * _) * I, e[8] = (a * A - s * C + u * T) * I, e[9] = (r * C - n * A - o * T) * I, e[10] = (d * w - m * b + y * v) * I, e[11] = (p * b - c * w - h * v) * I, e[12] = (s * k - a * S - l * T) * I, e[13] = (n * S - r * k + i * T) * I, e[14] = (m * _ - d * x - g * v) * I, e[15] = (c * x - p * _ + f * v) * I, e) : null; }, ortho(e, t, n, r, i, o, a) { const s = 1 / (t - n); const l = 1 / (r - i); const u = 1 / (o - a); return e[0] = -2 * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * s, e[13] = (i + r) * l, e[14] = (a + o) * u, e[15] = 1, e; },
            },
          });
        }); var ko = (To.vec3, To.vec4); const Co = (To.mat2, To.mat3, To.mat4); const So = (function (e) { function t(t) { e.call(this, t, Eo); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.createBucket = function (e) { return new wo(e); }, t.prototype.queryRadius = function (e) { const t = e; return ct('circle-radius', this, t) + ct('circle-stroke-width', this, t) + pt(this.paint.get('circle-translate')); }, t.prototype.queryIntersectsFeature = function (e, t, n, r, i, o, a) { for (let s = ft(e, this.paint.get('circle-translate'), this.paint.get('circle-translate-anchor'), i.angle, o), l = this.paint.get('circle-radius').evaluate(t) + this.paint.get('circle-stroke-width').evaluate(t), u = this.paint.get('circle-pitch-alignment') === 'map', c = u ? s : (function (e, t, n) { return e.map(e => e.map((e) => {return ht(e,t,n)})); }(s, a, i)), p = u ? l * o : l, f = 0, h = n; f < h.length; f += 1) for (let d = 0, m = h[f]; d < m.length; d += 1) { const g = m[d]; const y = u ? g : ht(g, a, i); let v = p; const _ = ko.transformMat4([], [g.x, g.y, 0, 1], a); if (this.paint.get('circle-pitch-scale') === 'viewport' && this.paint.get('circle-pitch-alignment') === 'map' ? v *= _[3] / i.cameraToCenterDistance : this.paint.get('circle-pitch-scale') === 'map' && this.paint.get('circle-pitch-alignment') === 'viewport' && (v *= i.cameraToCenterDistance / _[3]), et(c, y, v)) return !0; } return !1; }, t; }(Mi)); const Ao = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t; }(wo)); Fe('HeatmapBucket', Ao, { omit: ['layers'] }); var Oo = function (e, t) { dt(this, e, 1, t); }; Oo.prototype.resize = function (e) { mt(this, e, 1); }, Oo.prototype.clone = function () { return new Oo({ width: this.width, height: this.height }, new Uint8Array(this.data)); }, Oo.copy = function (e, t, n, r, i) { gt(e, t, n, r, i, 1); }; var Io = function (e, t) { dt(this, e, 4, t); }; Io.prototype.resize = function (e) { mt(this, e, 4); }, Io.prototype.clone = function () { return new Io({ width: this.width, height: this.height }, new Uint8Array(this.data)); }, Io.copy = function (e, t, n, r, i) { gt(e, t, n, r, i, 4); }, Fe('AlphaImage', Oo), Fe('RGBAImage', Io); const Po = {
          paint: new Pi({
            'heatmap-radius': new Ai(Kn.paint_heatmap['heatmap-radius']), 'heatmap-weight': new Ai(Kn.paint_heatmap['heatmap-weight']), 'heatmap-intensity': new Si(Kn.paint_heatmap['heatmap-intensity']), 'heatmap-color': new Ii(Kn.paint_heatmap['heatmap-color']), 'heatmap-opacity': new Si(Kn.paint_heatmap['heatmap-opacity']),
          }),
        }; const Mo = (function (e) { function t(t) { e.call(this, t, Po), this._updateColorRamp(); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.createBucket = function (e) { return new Ao(e); }, t.prototype.setPaintProperty = function (t, n, r) { e.prototype.setPaintProperty.call(this, t, n, r), t === 'heatmap-color' && this._updateColorRamp(); }, t.prototype._updateColorRamp = function () { const e = this._transitionablePaint._values['heatmap-color'].value.expression; this.colorRamp = yt(e, 'heatmapDensity'), this.colorRampTexture = null; }, t.prototype.resize = function () { this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null); }, t.prototype.queryRadius = function () { return 0; }, t.prototype.queryIntersectsFeature = function () { return !1; }, t.prototype.hasOffscreenPass = function () { return this.paint.get('heatmap-opacity') !== 0 && this.visibility !== 'none'; }, t; }(Mi)); const No = {
          paint: new Pi({
            'hillshade-illumination-direction': new Si(Kn.paint_hillshade['hillshade-illumination-direction']), 'hillshade-illumination-anchor': new Si(Kn.paint_hillshade['hillshade-illumination-anchor']), 'hillshade-exaggeration': new Si(Kn.paint_hillshade['hillshade-exaggeration']), 'hillshade-shadow-color': new Si(Kn.paint_hillshade['hillshade-shadow-color']), 'hillshade-highlight-color': new Si(Kn.paint_hillshade['hillshade-highlight-color']), 'hillshade-accent-color': new Si(Kn.paint_hillshade['hillshade-accent-color']),
          }),
        }; const Do = (function (e) { function t(t) { e.call(this, t, No); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.hasOffscreenPass = function () { return this.paint.get('hillshade-exaggeration') !== 0 && this.visibility !== 'none'; }, t; }(Mi)); const Lo = Ze([{ name: 'a_pos', components: 2, type: 'Int16' }], 4).members; const zo = vt; const Ro = vt; vt.deviation = function (e, t, n, r) { const i = t && t.length; const o = i ? t[0] * n : e.length; let a = Math.abs(Ft(e, 0, o, n)); if (i) for (var s = 0, l = t.length; s < l; s++) { const u = t[s] * n; const c = s < l - 1 ? t[s + 1] * n : e.length; a -= Math.abs(Ft(e, u, c, n)); } let p = 0; for (s = 0; s < r.length; s += 3) { const f = r[s] * n; const h = r[s + 1] * n; const d = r[s + 2] * n; p += Math.abs((e[f] - e[d]) * (e[h + 1] - e[f + 1]) - (e[f] - e[h]) * (e[d + 1] - e[f + 1])); } return a === 0 && p === 0 ? 0 : Math.abs((p - a) / a); }, vt.flatten = function (e) { for (var t = e[0][0].length, n = { vertices: [], holes: [], dimensions: t }, r = 0, i = 0; i < e.length; i++) { for (let o = 0; o < e[i].length; o++) for (let a = 0; a < t; a++)n.vertices.push(e[i][o][a]); i > 0 && (r += e[i - 1].length, n.holes.push(r)); } return n; }, zo.default = Ro; var jo = Ut; const Bo = Ut; jo.default = Bo; const Fo = function (e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.layoutVertexArray = new zi(), this.indexArray = new Xi(), this.indexArray2 = new Yi(), this.programConfigurations = new vo(Lo, e.layers, e.zoom), this.segments = new po(), this.segments2 = new po(); }; Fo.prototype.populate = function (e, t) { for (let n = 0, r = e; n < r.length; n += 1) { const i = r[n]; const o = i.feature; const a = i.index; const s = i.sourceLayerIndex; if (this.layers[0]._featureFilter(new vi(this.zoom), o)) { const l = Je(o); this.addFeature(o, l), t.featureIndex.insert(o, l, a, s, this.index); } } }, Fo.prototype.isEmpty = function () { return this.layoutVertexArray.length === 0; }, Fo.prototype.upload = function (e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Lo), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2), this.programConfigurations.upload(e); }, Fo.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()); }, Fo.prototype.addFeature = function (e, t) { for (let n = 0, r = Ht(t, 500); n < r.length; n += 1) { for (var i = r[n], o = 0, a = 0, s = i; a < s.length; a += 1)o += s[a].length; for (var l = this.segments.prepareSegment(o, this.layoutVertexArray, this.indexArray), u = l.vertexLength, c = [], p = [], f = 0, h = i; f < h.length; f += 1) { const d = h[f]; if (d.length !== 0) { d !== i[0] && p.push(c.length / 2); const m = this.segments2.prepareSegment(d.length, this.layoutVertexArray, this.indexArray2); const g = m.vertexLength; this.layoutVertexArray.emplaceBack(d[0].x, d[0].y), this.indexArray2.emplaceBack(g + d.length - 1, g), c.push(d[0].x), c.push(d[0].y); for (let y = 1; y < d.length; y++) this.layoutVertexArray.emplaceBack(d[y].x, d[y].y), this.indexArray2.emplaceBack(g + y - 1, g + y), c.push(d[y].x), c.push(d[y].y); m.vertexLength += d.length, m.primitiveLength += d.length; } } for (var v = zo(c, p), _ = 0; _ < v.length; _ += 3) this.indexArray.emplaceBack(u + v[_], u + v[_ + 1], u + v[_ + 2]); l.vertexLength += o, l.primitiveLength += v.length / 3; } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e); }, Fe('FillBucket', Fo, { omit: ['layers'] }); const Uo = {
          paint: new Pi({
            'fill-antialias': new Si(Kn.paint_fill['fill-antialias']), 'fill-opacity': new Ai(Kn.paint_fill['fill-opacity']), 'fill-color': new Ai(Kn.paint_fill['fill-color']), 'fill-outline-color': new Ai(Kn.paint_fill['fill-outline-color']), 'fill-translate': new Si(Kn.paint_fill['fill-translate']), 'fill-translate-anchor': new Si(Kn.paint_fill['fill-translate-anchor']), 'fill-pattern': new Oi(Kn.paint_fill['fill-pattern']),
          }),
        }; const Vo = (function (e) { function t(t) { e.call(this, t, Uo); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.recalculate = function (e) { this.paint = this._transitioningPaint.possiblyEvaluate(e); const t = this.paint._values['fill-outline-color']; t.value.kind === 'constant' && void 0 === t.value.value && (this.paint._values['fill-outline-color'] = this.paint._values['fill-color']); }, t.prototype.createBucket = function (e) { return new Fo(e); }, t.prototype.queryRadius = function () { return pt(this.paint.get('fill-translate')); }, t.prototype.queryIntersectsFeature = function (e, t, n, r, i, o) { return tt(ft(e, this.paint.get('fill-translate'), this.paint.get('fill-translate-anchor'), i.angle, o), n); }, t; }(Mi)); const qo = Ze([{ name: 'a_pos', components: 2, type: 'Int16' }, { name: 'a_normal_ed', components: 4, type: 'Int16' }], 4).members; var Ho = Math.pow(2, 13); const Wo = function (e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.layoutVertexArray = new ji(), this.indexArray = new Xi(), this.programConfigurations = new vo(qo, e.layers, e.zoom), this.segments = new po(); }; Wo.prototype.populate = function (e, t) { for (let n = 0, r = e; n < r.length; n += 1) { const i = r[n]; const o = i.feature; const a = i.index; const s = i.sourceLayerIndex; if (this.layers[0]._featureFilter(new vi(this.zoom), o)) { const l = Je(o); this.addFeature(o, l), t.featureIndex.insert(o, l, a, s, this.index); } } }, Wo.prototype.isEmpty = function () { return this.layoutVertexArray.length === 0; }, Wo.prototype.upload = function (e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, qo), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.programConfigurations.upload(e); }, Wo.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()); }, Wo.prototype.addFeature = function (e, t) { for (let n = 0, r = Ht(t, 500); n < r.length; n += 1) { for (var i = r[n], o = 0, a = 0, s = i; a < s.length; a += 1)o += s[a].length; for (var l = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), u = 0, c = i; u < c.length; u += 1) { const p = c[u]; if (p.length !== 0 && !Zt(p)) for (let f = 0, h = 0; h < p.length; h++) { const d = p[h]; if (h >= 1) { const m = p[h - 1]; if (!Gt(d, m)) { l.vertexLength + 4 > po.MAX_VERTEX_ARRAY_LENGTH && (l = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)); const g = d.sub(m)._perp()._unit(); const y = m.dist(d); f + y > 32768 && (f = 0), $t(this.layoutVertexArray, d.x, d.y, g.x, g.y, 0, 0, f), $t(this.layoutVertexArray, d.x, d.y, g.x, g.y, 0, 1, f), f += y, $t(this.layoutVertexArray, m.x, m.y, g.x, g.y, 0, 0, f), $t(this.layoutVertexArray, m.x, m.y, g.x, g.y, 0, 1, f); const v = l.vertexLength; this.indexArray.emplaceBack(v, v + 1, v + 2), this.indexArray.emplaceBack(v + 1, v + 2, v + 3), l.vertexLength += 4, l.primitiveLength += 2; } } } }l.vertexLength + o > po.MAX_VERTEX_ARRAY_LENGTH && (l = this.segments.prepareSegment(o, this.layoutVertexArray, this.indexArray)); for (var _ = [], b = [], x = l.vertexLength, w = 0, E = i; w < E.length; w += 1) { const T = E[w]; if (T.length !== 0) { T !== i[0] && b.push(_.length / 2); for (let k = 0; k < T.length; k++) { const C = T[k]; $t(this.layoutVertexArray, C.x, C.y, 0, 0, 1, 1, 0), _.push(C.x), _.push(C.y); } } } for (var S = zo(_, b), A = 0; A < S.length; A += 3) this.indexArray.emplaceBack(x + S[A], x + S[A + 1], x + S[A + 2]); l.primitiveLength += S.length / 3, l.vertexLength += o; } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e); }, Fe('FillExtrusionBucket', Wo, { omit: ['layers'] }); const $o = {
          paint: new Pi({
            'fill-extrusion-opacity': new Si(Kn['paint_fill-extrusion']['fill-extrusion-opacity']), 'fill-extrusion-color': new Ai(Kn['paint_fill-extrusion']['fill-extrusion-color']), 'fill-extrusion-translate': new Si(Kn['paint_fill-extrusion']['fill-extrusion-translate']), 'fill-extrusion-translate-anchor': new Si(Kn['paint_fill-extrusion']['fill-extrusion-translate-anchor']), 'fill-extrusion-pattern': new Oi(Kn['paint_fill-extrusion']['fill-extrusion-pattern']), 'fill-extrusion-height': new Ai(Kn['paint_fill-extrusion']['fill-extrusion-height']), 'fill-extrusion-base': new Ai(Kn['paint_fill-extrusion']['fill-extrusion-base']),
          }),
        }; const Go = (function (e) { function t(t) { e.call(this, t, $o); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.createBucket = function (e) { return new Wo(e); }, t.prototype.queryRadius = function () { return pt(this.paint.get('fill-extrusion-translate')); }, t.prototype.queryIntersectsFeature = function (e, t, n, r, i, o) { return tt(ft(e, this.paint.get('fill-extrusion-translate'), this.paint.get('fill-extrusion-translate-anchor'), i.angle, o), n); }, t.prototype.hasOffscreenPass = function () { return this.paint.get('fill-extrusion-opacity') !== 0 && this.visibility !== 'none'; }, t.prototype.resize = function () { this.viewportFrame && (this.viewportFrame.destroy(), this.viewportFrame = null); }, t; }(Mi)); const Zo = Ze([{ name: 'a_pos_normal', components: 4, type: 'Int16' }, { name: 'a_data', components: 4, type: 'Uint8' }], 4).members; const Ko = Kt; Kt.types = ['Unknown', 'Point', 'LineString', 'Polygon'], Kt.prototype.loadGeometry = function () { const e = this._pbf; e.pos = this._geometry; for (var t, n = e.readVarint() + e.pos, r = 1, i = 0, o = 0, a = 0, s = []; e.pos < n;) { if (i <= 0) { const l = e.readVarint(); r = 7 & l, i = l >> 3; } if (i--, r === 1 || r === 2)o += e.readSVarint(), a += e.readSVarint(), r === 1 && (t && s.push(t), t = []), t.push(new Bn(o, a)); else { if (r !== 7) throw new Error(`unknown command ${r}`); t && t.push(t[0].clone()); } } return t && s.push(t), s; }, Kt.prototype.bbox = function () { const e = this._pbf; e.pos = this._geometry; for (var t = e.readVarint() + e.pos, n = 1, r = 0, i = 0, o = 0, a = 1 / 0, s = -1 / 0, l = 1 / 0, u = -1 / 0; e.pos < t;) { if (r <= 0) { const c = e.readVarint(); n = 7 & c, r = c >> 3; } if (r--, n === 1 || n === 2)(i += e.readSVarint()) < a && (a = i), i > s && (s = i), (o += e.readSVarint()) < l && (l = o), o > u && (u = o); else if (n !== 7) throw new Error(`unknown command ${n}`); } return [a, l, s, u]; }, Kt.prototype.toGeoJSON = function (e, t, n) { function r(e) { for (let t = 0; t < e.length; t++) { const n = e[t]; const r = 180 - 360 * (n.y + l) / a; e[t] = [360 * (n.x + s) / a - 180, 360 / Math.PI * Math.atan(Math.exp(r * Math.PI / 180)) - 90]; } } let i; let o; var a = this.extent * Math.pow(2, n); var s = this.extent * e; var l = this.extent * t; let u = this.loadGeometry(); let c = Kt.types[this.type]; switch (this.type) { case 1: var p = []; for (i = 0; i < u.length; i++)p[i] = u[i][0]; r(u = p); break; case 2: for (i = 0; i < u.length; i++)r(u[i]); break; case 3: for (u = (function (e) { const t = e.length; if (t <= 1) return [e]; for (var n, r, i = [], o = 0; o < t; o++) { const a = Yt(e[o]); a !== 0 && (void 0 === r && (r = a < 0), r === a < 0 ? (n && i.push(n), n = [e[o]]) : n.push(e[o])); } return n && i.push(n), i; }(u)), i = 0; i < u.length; i++) for (o = 0; o < u[i].length; o++)r(u[i][o]); }u.length === 1 ? u = u[0] : c = `Multi${c}`; const f = { type: 'Feature', geometry: { type: c, coordinates: u }, properties: this.properties }; return 'id' in this && (f.id = this.id), f; }; var Xo = Jt; Jt.prototype.feature = function (e) { if (e < 0 || e >= this._features.length) throw new Error('feature index out of bounds'); this._pbf.pos = this._features[e]; const t = this._pbf.readVarint() + this._pbf.pos; return new Ko(this._pbf, t, this.extent, this._keys, this._values); }; const Yo = { VectorTile(e, t) { this.layers = e.readFields(en, {}, t); }, VectorTileFeature: Ko, VectorTileLayer: Xo }; const Jo = Yo.VectorTileFeature.types; var Qo = 63; const ea = Math.cos(Math.PI / 180 * 37.5); var ta = 0.5; var na = Math.pow(2, 14) / ta; const ra = function (e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.layoutVertexArray = new Bi(), this.indexArray = new Xi(), this.programConfigurations = new vo(Zo, e.layers, e.zoom), this.segments = new po(); }; ra.prototype.populate = function (e, t) { for (let n = 0, r = e; n < r.length; n += 1) { const i = r[n]; const o = i.feature; const a = i.index; const s = i.sourceLayerIndex; if (this.layers[0]._featureFilter(new vi(this.zoom), o)) { const l = Je(o); this.addFeature(o, l), t.featureIndex.insert(o, l, a, s, this.index); } } }, ra.prototype.isEmpty = function () { return this.layoutVertexArray.length === 0; }, ra.prototype.upload = function (e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Zo), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.programConfigurations.upload(e); }, ra.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()); }, ra.prototype.addFeature = function (e, t) { for (let n = this.layers[0].layout, r = n.get('line-join').evaluate(e), i = n.get('line-cap'), o = n.get('line-miter-limit'), a = n.get('line-round-limit'), s = 0, l = t; s < l.length; s += 1) { const u = l[s]; this.addLine(u, e, r, i, o, a); } }, ra.prototype.addLine = function (e, t, n, r, i, o) { let a = null; t.properties && t.properties.hasOwnProperty('mapbox_clip_start') && t.properties.hasOwnProperty('mapbox_clip_end') && (a = { start: t.properties.mapbox_clip_start, end: t.properties.mapbox_clip_end, tileTotal: void 0 }); for (var s = Jo[t.type] === 'Polygon', l = e.length; l >= 2 && e[l - 1].equals(e[l - 2]);)l--; for (var u = 0; u < l - 1 && e[u].equals(e[u + 1]);)u++; if (!(l < (s ? 3 : 2))) { a && (a.tileTotal = (function (e, t, n) { for (var r, i, o = 0, a = t; a < n - 1; a++)r = e[a], i = e[a + 1], o += r.dist(i); return o; }(e, u, l))), n === 'bevel' && (i = 1.05); const c = bo / (512 * this.overscaling) * 15; const p = e[u]; const f = this.segments.prepareSegment(10 * l, this.layoutVertexArray, this.indexArray); this.distance = 0; let h; let d; let m; const g = r; const y = s ? 'butt' : r; let v = !0; let _ = void 0; let b = void 0; let x = void 0; let w = void 0; this.e1 = this.e2 = this.e3 = -1, s && (h = e[l - 2], w = p.sub(h)._unit()._perp()); for (let E = u; E < l; E++) if (!(b = s && E === l - 1 ? e[u + 1] : e[E + 1]) || !e[E].equals(b)) { w && (x = w), h && (_ = h), h = e[E], w = b ? b.sub(h)._unit()._perp() : x; let T = (x = x || w).add(w); T.x === 0 && T.y === 0 || T._unit(); const k = T.x * w.x + T.y * w.y; const C = k !== 0 ? 1 / k : 1 / 0; const S = k < ea && _ && b; if (S && E > u) { const A = h.dist(_); if (A > 2 * c) { const O = h.sub(h.sub(_)._mult(c / A)._round()); this.distance += O.dist(_), this.addCurrentVertex(O, this.distance, x.mult(1), 0, 0, !1, f, a), _ = O; } } const I = _ && b; let P = I ? n : b ? g : y; if (I && P === 'round' && (C < o ? P = 'miter' : C <= 2 && (P = 'fakeround')), P === 'miter' && C > i && (P = 'bevel'), P === 'bevel' && (C > 2 && (P = 'flipbevel'), C < i && (P = 'miter')), _ && (this.distance += h.dist(_)), P === 'miter')T._mult(C), this.addCurrentVertex(h, this.distance, T, 0, 0, !1, f, a); else if (P === 'flipbevel') { if (C > 100)T = w.clone().mult(-1); else { const M = x.x * w.y - x.y * w.x > 0 ? -1 : 1; const N = C * x.add(w).mag() / x.sub(w).mag(); T._perp()._mult(N * M); } this.addCurrentVertex(h, this.distance, T, 0, 0, !1, f, a), this.addCurrentVertex(h, this.distance, T.mult(-1), 0, 0, !1, f, a); } else if (P === 'bevel' || P === 'fakeround') { const D = x.x * w.y - x.y * w.x > 0; const L = -Math.sqrt(C * C - 1); if (D ? (m = 0, d = L) : (d = 0, m = L), v || this.addCurrentVertex(h, this.distance, x, d, m, !1, f, a), P === 'fakeround') { for (var z = Math.floor(8 * (0.5 - (k - 0.5))), R = void 0, j = 0; j < z; j++)R = w.mult((j + 1) / (z + 1))._add(x)._unit(), this.addPieSliceVertex(h, this.distance, R, D, f, a); this.addPieSliceVertex(h, this.distance, T, D, f, a); for (let B = z - 1; B >= 0; B--)R = x.mult((B + 1) / (z + 1))._add(w)._unit(), this.addPieSliceVertex(h, this.distance, R, D, f, a); }b && this.addCurrentVertex(h, this.distance, w, -d, -m, !1, f, a); } else P === 'butt' ? (v || this.addCurrentVertex(h, this.distance, x, 0, 0, !1, f, a), b && this.addCurrentVertex(h, this.distance, w, 0, 0, !1, f, a)) : P === 'square' ? (v || (this.addCurrentVertex(h, this.distance, x, 1, 1, !1, f, a), this.e1 = this.e2 = -1), b && this.addCurrentVertex(h, this.distance, w, -1, -1, !1, f, a)) : P === 'round' && (v || (this.addCurrentVertex(h, this.distance, x, 0, 0, !1, f, a), this.addCurrentVertex(h, this.distance, x, 1, 1, !0, f, a), this.e1 = this.e2 = -1), b && (this.addCurrentVertex(h, this.distance, w, -1, -1, !0, f, a), this.addCurrentVertex(h, this.distance, w, 0, 0, !1, f, a))); if (S && E < l - 1) { const F = h.dist(b); if (F > 2 * c) { const U = h.add(b.sub(h)._mult(c / F)._round()); this.distance += U.dist(h), this.addCurrentVertex(U, this.distance, w.mult(1), 0, 0, !1, f, a), h = U; } }v = !1; } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t); } }, ra.prototype.addCurrentVertex = function (e, t, n, r, i, o, a, s) { let l; const u = this.layoutVertexArray; const c = this.indexArray; s && (t = nn(t, s)), l = n.clone(), r && l._sub(n.perp()._mult(r)), tn(u, e, l, o, !1, r, t), this.e3 = a.vertexLength++, this.e1 >= 0 && this.e2 >= 0 && (c.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++), this.e1 = this.e2, this.e2 = this.e3, l = n.mult(-1), i && l._sub(n.perp()._mult(i)), tn(u, e, l, o, !0, -i, t), this.e3 = a.vertexLength++, this.e1 >= 0 && this.e2 >= 0 && (c.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++), this.e1 = this.e2, this.e2 = this.e3, t > na / 2 && !s && (this.distance = 0, this.addCurrentVertex(e, this.distance, n, r, i, o, a)); }, ra.prototype.addPieSliceVertex = function (e, t, n, r, i, o) { n = n.mult(r ? -1 : 1); const a = this.layoutVertexArray; const s = this.indexArray; o && (t = nn(t, o)), tn(a, e, n, !1, r, 0, t), this.e3 = i.vertexLength++, this.e1 >= 0 && this.e2 >= 0 && (s.emplaceBack(this.e1, this.e2, this.e3), i.primitiveLength++), r ? this.e2 = this.e3 : this.e1 = this.e3; }, Fe('LineBucket', ra, { omit: ['layers'] }); const ia = new Pi({
          'line-cap': new Si(Kn.layout_line['line-cap']), 'line-join': new Ai(Kn.layout_line['line-join']), 'line-miter-limit': new Si(Kn.layout_line['line-miter-limit']), 'line-round-limit': new Si(Kn.layout_line['line-round-limit']),
        }); const oa = {
          paint: new Pi({
            'line-opacity': new Ai(Kn.paint_line['line-opacity']), 'line-color': new Ai(Kn.paint_line['line-color']), 'line-translate': new Si(Kn.paint_line['line-translate']), 'line-translate-anchor': new Si(Kn.paint_line['line-translate-anchor']), 'line-width': new Ai(Kn.paint_line['line-width']), 'line-gap-width': new Ai(Kn.paint_line['line-gap-width']), 'line-offset': new Ai(Kn.paint_line['line-offset']), 'line-blur': new Ai(Kn.paint_line['line-blur']), 'line-dasharray': new Oi(Kn.paint_line['line-dasharray']), 'line-pattern': new Oi(Kn.paint_line['line-pattern']), 'line-gradient': new Ii(Kn.paint_line['line-gradient']),
          }),
          layout: ia,
        }; const aa = new (function (e) {
          function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.possiblyEvaluate = function (t, n) {
            return n = new vi(Math.floor(n.zoom), {
              now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition,
            }), e.prototype.possiblyEvaluate.call(this, t, n);
          }, t.prototype.evaluate = function (t, n, r) { return n = l({}, n, { zoom: Math.floor(n.zoom) }), e.prototype.evaluate.call(this, t, n, r); }, t;
        }(Ai))(oa.paint.properties['line-width'].specification); aa.useIntegerZoom = !0; const sa = (function (e) { function t(t) { e.call(this, t, oa); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.setPaintProperty = function (t, n, r) { e.prototype.setPaintProperty.call(this, t, n, r), t === 'line-gradient' && this._updateGradient(); }, t.prototype._updateGradient = function () { const e = this._transitionablePaint._values['line-gradient'].value.expression; this.gradient = yt(e, 'lineProgress'), this.gradientTexture = null; }, t.prototype.recalculate = function (t) { e.prototype.recalculate.call(this, t), this.paint._values['line-floorwidth'] = aa.possiblyEvaluate(this._transitioningPaint._values['line-width'].value, t); }, t.prototype.createBucket = function (e) { return new ra(e); }, t.prototype.queryRadius = function (e) { const t = e; const n = rn(ct('line-width', this, t), ct('line-gap-width', this, t)); const r = ct('line-offset', this, t); return n / 2 + Math.abs(r) + pt(this.paint.get('line-translate')); }, t.prototype.queryIntersectsFeature = function (e, t, n, r, i, o) { const a = ft(e, this.paint.get('line-translate'), this.paint.get('line-translate-anchor'), i.angle, o); const s = o / 2 * rn(this.paint.get('line-width').evaluate(t), this.paint.get('line-gap-width').evaluate(t)); const l = this.paint.get('line-offset').evaluate(t); return l && (n = (function (e, t) { for (var n = [], r = new Bn(0, 0), i = 0; i < e.length; i++) { for (var o = e[i], a = [], s = 0; s < o.length; s++) { const l = o[s - 1]; const u = o[s]; const c = o[s + 1]; const p = s === 0 ? r : u.sub(l)._unit()._perp(); const f = s === o.length - 1 ? r : c.sub(u)._unit()._perp(); const h = p._add(f)._unit(); const d = h.x * f.x + h.y * f.y; h._mult(1 / d), a.push(h._mult(t)._add(u)); }n.push(a); } return n; }(n, l * o))), nt(a, n, s); }, t; }(Mi)); const la = Ze([{ name: 'a_pos_offset', components: 4, type: 'Int16' }, { name: 'a_data', components: 4, type: 'Uint16' }]); const ua = Ze([{ name: 'a_projected_pos', components: 3, type: 'Float32' }], 4); const ca = (Ze([{ name: 'a_fade_opacity', components: 1, type: 'Uint32' }], 4), Ze([{ name: 'a_placed', components: 2, type: 'Uint8' }], 4)); const pa = (Ze([{ type: 'Int16', name: 'anchorPointX' }, { type: 'Int16', name: 'anchorPointY' }, { type: 'Int16', name: 'x1' }, { type: 'Int16', name: 'y1' }, { type: 'Int16', name: 'x2' }, { type: 'Int16', name: 'y2' }, { type: 'Uint32', name: 'featureIndex' }, { type: 'Uint16', name: 'sourceLayerIndex' }, { type: 'Uint16', name: 'bucketIndex' }, { type: 'Int16', name: 'radius' }, { type: 'Int16', name: 'signedDistanceFromAnchor' }]), Ze([{ name: 'a_pos', components: 2, type: 'Int16' }, { name: 'a_anchor_pos', components: 2, type: 'Int16' }, { name: 'a_extrude', components: 2, type: 'Int16' }], 4)); const fa = Ze([{ name: 'a_pos', components: 2, type: 'Int16' }, { name: 'a_anchor_pos', components: 2, type: 'Int16' }, { name: 'a_extrude', components: 2, type: 'Int16' }], 4); Ze([{ type: 'Int16', name: 'anchorX' }, { type: 'Int16', name: 'anchorY' }, { type: 'Uint16', name: 'glyphStartIndex' }, { type: 'Uint16', name: 'numGlyphs' }, { type: 'Uint32', name: 'vertexStartIndex' }, { type: 'Uint32', name: 'lineStartIndex' }, { type: 'Uint32', name: 'lineLength' }, { type: 'Uint16', name: 'segment' }, { type: 'Uint16', name: 'lowerSize' }, { type: 'Uint16', name: 'upperSize' }, { type: 'Float32', name: 'lineOffsetX' }, { type: 'Float32', name: 'lineOffsetY' }, { type: 'Uint8', name: 'writingMode' }, { type: 'Uint8', name: 'hidden' }]), Ze([{ type: 'Float32', name: 'offsetX' }]), Ze([{ type: 'Int16', name: 'x' }, { type: 'Int16', name: 'y' }, { type: 'Int16', name: 'tileUnitDistanceFromAnchor' }]); const ha = {
          '!': '\ufe15', '#': '\uff03', $: '\uff04', '%': '\uff05', '&': '\uff06', '(': '\ufe35', ')': '\ufe36', '*': '\uff0a', '+': '\uff0b', ',': '\ufe10', '-': '\ufe32', '.': '\u30fb', '/': '\uff0f', ':': '\ufe13', ';': '\ufe14', '<': '\ufe3f', '=': '\uff1d', '>': '\ufe40', '?': '\ufe16', '@': '\uff20', '[': '\ufe47', '\\': '\uff3c', ']': '\ufe48', '^': '\uff3e', _: '\ufe33', '`': '\uff40', '{': '\ufe37', '|': '\u2015', '}': '\ufe38', '~': '\uff5e', '\xa2': '\uffe0', '\xa3': '\uffe1', '\xa5': '\uffe5', '\xa6': '\uffe4', '\xac': '\uffe2', '\xaf': '\uffe3', '\u2013': '\ufe32', '\u2014': '\ufe31', '\u2018': '\ufe43', '\u2019': '\ufe44', '\u201c': '\ufe41', '\u201d': '\ufe42', '\u2026': '\ufe19', '\u2027': '\u30fb', '\u20a9': '\uffe6', '\u3001': '\ufe11', '\u3002': '\ufe12', '\u3008': '\ufe3f', '\u3009': '\ufe40', '\u300a': '\ufe3d', '\u300b': '\ufe3e', '\u300c': '\ufe41', '\u300d': '\ufe42', '\u300e': '\ufe43', '\u300f': '\ufe44', '\u3010': '\ufe3b', '\u3011': '\ufe3c', '\u3014': '\ufe39', '\u3015': '\ufe3a', '\u3016': '\ufe17', '\u3017': '\ufe18', '\uff01': '\ufe15', '\uff08': '\ufe35', '\uff09': '\ufe36', '\uff0c': '\ufe10', '\uff0d': '\ufe32', '\uff0e': '\u30fb', '\uff1a': '\ufe13', '\uff1b': '\ufe14', '\uff1c': '\ufe3f', '\uff1e': '\ufe40', '\uff1f': '\ufe16', '\uff3b': '\ufe47', '\uff3d': '\ufe48', '\uff3f': '\ufe33', '\uff5b': '\ufe37', '\uff5c': '\u2015', '\uff5d': '\ufe38', '\uff5f': '\ufe35', '\uff60': '\ufe36', '\uff61': '\ufe12', '\uff62': '\ufe41', '\uff63': '\ufe42',
        }; const da = (function (e) { function t(t, n, r, i) { e.call(this, t, n), this.angle = r, void 0 !== i && (this.segment = i); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.clone = function () { return new t(this.x, this.y, this.angle, this.segment); }, t; }(Bn)); Fe('Anchor', da); const ma = Yo.VectorTileFeature.types; const ga = [{
          name: 'a_fade_opacity', components: 1, type: 'Uint8', offset: 0,
        }]; const ya = function (e) { this.layoutVertexArray = new Fi(), this.indexArray = new Xi(), this.programConfigurations = e, this.segments = new po(), this.dynamicLayoutVertexArray = new Ui(), this.opacityVertexArray = new Vi(), this.placedSymbolArray = new ro(); }; ya.prototype.upload = function (e, t) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, la.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t), this.programConfigurations.upload(e), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, ua.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, ga, !0), this.opacityVertexBuffer.itemSize = 1; }, ya.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy()); }, Fe('SymbolBuffers', ya); const va = function (e, t, n) { this.layoutVertexArray = new e(), this.layoutAttributes = t, this.indexArray = new n(), this.segments = new po(), this.collisionVertexArray = new Wi(); }; va.prototype.upload = function (e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, ca.members, !0); }, va.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy()); }, Fe('CollisionBuffers', va); const _a = function (e) { this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(e => e.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex; const t = this.layers[0]._unevaluatedLayout._values; this.textSizeData = an(this.zoom, t['text-size']), this.iconSizeData = an(this.zoom, t['icon-size']); const n = this.layers[0].layout; this.sortFeaturesByY = n.get('text-allow-overlap') || n.get('icon-allow-overlap') || n.get('text-ignore-placement') || n.get('icon-ignore-placement'); }; _a.prototype.createArrays = function () { this.text = new ya(new vo(la.members, this.layers, this.zoom, (e => /^text/.test(e)))), this.icon = new ya(new vo(la.members, this.layers, this.zoom, (e => /^icon/.test(e)))), this.collisionBox = new va(Hi, pa.members, Yi), this.collisionCircle = new va(Hi, fa.members, Xi), this.glyphOffsetArray = new oo(), this.lineVertexArray = new so(); }, _a.prototype.populate = function (e, t) {
          const n = this.layers[0]; const r = n.layout; const i = r.get('text-font'); const o = r.get('text-field'); const a = r.get('icon-image'); const s = (o.value.kind !== 'constant' || o.value.value.length > 0) && (i.value.kind !== 'constant' || i.value.value.length > 0); const l = a.value.kind !== 'constant' || a.value.value && a.value.value.length > 0; if (this.features = [], s || l) {
            for (let u = t.iconDependencies, c = t.glyphDependencies, p = new vi(this.zoom), f = 0, h = e; f < h.length; f += 1) {
              const d = h[f]; const m = d.feature; const g = d.index; const y = d.sourceLayerIndex; if (n._featureFilter(p, m)) {
                let v = void 0; s && (v = on(v = n.getValueAndResolveTokens('text-field', m), n, m)); let _ = void 0; if (l && (_ = n.getValueAndResolveTokens('icon-image', m)), v || _) {
                  const b = {
                    text: v, icon: _, index: g, sourceLayerIndex: y, geometry: Je(m), properties: m.properties, type: ma[m.type],
                  }; if (void 0 !== m.id && (b.id = m.id), this.features.push(b), _ && (u[_] = !0), v) for (let x = i.evaluate(m).join(','), w = c[x] = c[x] || {}, E = r.get('text-rotation-alignment') === 'map' && r.get('symbol-placement') === 'line', T = qe(v), k = 0; k < v.length; k++) if (w[v.charCodeAt(k)] = !0, E && T) { const C = ha[v.charAt(k)]; C && (w[C.charCodeAt(0)] = !0); }
                }
              }
            }r.get('symbol-placement') === 'line' && (this.features = (function (e) { function t(t) { s.push(e[t]), l++; } function n(e, t, n) { const r = a[e]; return delete a[e], a[t] = r, s[r].geometry[0].pop(), s[r].geometry[0] = s[r].geometry[0].concat(n[0]), r; } function r(e, t, n) { const r = o[t]; return delete o[t], o[e] = r, s[r].geometry[0].shift(), s[r].geometry[0] = n[0].concat(s[r].geometry[0]), r; } function i(e, t, n) { const r = n ? t[0][t[0].length - 1] : t[0][0]; return `${e}:${r.x}:${r.y}`; } for (var o = {}, a = {}, s = [], l = 0, u = 0; u < e.length; u++) { const c = e[u]; const p = c.geometry; const f = c.text; if (f) { const h = i(f, p); const d = i(f, p, !0); if (h in a && d in o && a[h] !== o[d]) { const m = r(h, d, p); const g = n(h, d, s[m].geometry); delete o[h], delete a[d], a[i(f, s[g].geometry, !0)] = g, s[m].geometry = null; } else h in a ? n(h, d, p) : d in o ? r(h, d, p) : (t(u), o[h] = l - 1, a[d] = l - 1); } else t(u); } return s.filter(e => e.geometry); }(this.features)));
          }
        }, _a.prototype.isEmpty = function () { return this.symbolInstances.length === 0; }, _a.prototype.upload = function (e) { this.text.upload(e, this.sortFeaturesByY), this.icon.upload(e, this.sortFeaturesByY), this.collisionBox.upload(e), this.collisionCircle.upload(e); }, _a.prototype.destroy = function () { this.text.destroy(), this.icon.destroy(), this.collisionBox.destroy(), this.collisionCircle.destroy(); }, _a.prototype.addToLineVertexArray = function (e, t) { const n = this.lineVertexArray.length; if (void 0 !== e.segment) { for (var r = e.dist(t[e.segment + 1]), i = e.dist(t[e.segment]), o = {}, a = e.segment + 1; a < t.length; a++)o[a] = { x: t[a].x, y: t[a].y, tileUnitDistanceFromAnchor: r }, a < t.length - 1 && (r += t[a + 1].dist(t[a])); for (let s = e.segment || 0; s >= 0; s--)o[s] = { x: t[s].x, y: t[s].y, tileUnitDistanceFromAnchor: i }, s > 0 && (i += t[s - 1].dist(t[s])); for (let l = 0; l < t.length; l++) { const u = o[l]; this.lineVertexArray.emplaceBack(u.x, u.y, u.tileUnitDistanceFromAnchor); } } return { lineStartIndex: n, lineLength: this.lineVertexArray.length - n }; }, _a.prototype.addSymbols = function (e, t, n, r, i, o, a, s, l, u) { for (var c = e.indexArray, p = e.layoutVertexArray, f = e.dynamicLayoutVertexArray, h = e.segments.prepareSegment(4 * t.length, e.layoutVertexArray, e.indexArray), d = this.glyphOffsetArray.length, m = h.vertexLength, g = 0, y = t; g < y.length; g += 1) { const v = y[g]; const _ = v.tl; const b = v.tr; const x = v.bl; const w = v.br; const E = v.tex; const T = h.vertexLength; const k = v.glyphOffset[1]; sn(p, s.x, s.y, _.x, k + _.y, E.x, E.y, n), sn(p, s.x, s.y, b.x, k + b.y, E.x + E.w, E.y, n), sn(p, s.x, s.y, x.x, k + x.y, E.x, E.y + E.h, n), sn(p, s.x, s.y, w.x, k + w.y, E.x + E.w, E.y + E.h, n), ln(f, s, 0), c.emplaceBack(T, T + 1, T + 2), c.emplaceBack(T + 1, T + 2, T + 3), h.vertexLength += 4, h.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(v.glyphOffset[0]); }e.placedSymbolArray.emplaceBack(s.x, s.y, d, this.glyphOffsetArray.length - d, m, l, u, s.segment, n ? n[0] : 0, n ? n[1] : 0, r[0], r[1], a, !1), e.programConfigurations.populatePaintArrays(e.layoutVertexArray.length, o); }, _a.prototype._addCollisionDebugVertex = function (e, t, n, r, i) { return t.emplaceBack(0, 0), e.emplaceBack(n.x, n.y, r.x, r.y, Math.round(i.x), Math.round(i.y)); }, _a.prototype.addCollisionDebugVertices = function (e, t, n, r, i, o, a, s) { const l = i.segments.prepareSegment(4, i.layoutVertexArray, i.indexArray); const u = l.vertexLength; const c = i.layoutVertexArray; const p = i.collisionVertexArray; if (this._addCollisionDebugVertex(c, p, o, a.anchor, new Bn(e, t)), this._addCollisionDebugVertex(c, p, o, a.anchor, new Bn(n, t)), this._addCollisionDebugVertex(c, p, o, a.anchor, new Bn(n, r)), this._addCollisionDebugVertex(c, p, o, a.anchor, new Bn(e, r)), l.vertexLength += 4, s) { const f = i.indexArray; f.emplaceBack(u, u + 1, u + 2), f.emplaceBack(u, u + 2, u + 3), l.primitiveLength += 2; } else { const h = i.indexArray; h.emplaceBack(u, u + 1), h.emplaceBack(u + 1, u + 2), h.emplaceBack(u + 2, u + 3), h.emplaceBack(u + 3, u), l.primitiveLength += 4; } }, _a.prototype.generateCollisionDebugBuffers = function () { for (let e = 0, t = this.symbolInstances; e < t.length; e += 1) { const n = t[e]; n.textCollisionFeature = { boxStartIndex: n.textBoxStartIndex, boxEndIndex: n.textBoxEndIndex }, n.iconCollisionFeature = { boxStartIndex: n.iconBoxStartIndex, boxEndIndex: n.iconBoxEndIndex }; for (let r = 0; r < 2; r++) { const i = n[r === 0 ? 'textCollisionFeature' : 'iconCollisionFeature']; if (i) for (let o = i.boxStartIndex; o < i.boxEndIndex; o++) { const a = this.collisionBoxArray.get(o); const s = a.x1; const l = a.y1; const u = a.x2; const c = a.y2; const p = a.radius > 0; this.addCollisionDebugVertices(s, l, u, c, p ? this.collisionCircle : this.collisionBox, a.anchorPoint, n, p); } } } }, _a.prototype.deserializeCollisionBoxes = function (e, t, n, r, i) {
          for (var o = {}, a = t; a < n; a++) {
            const s = e.get(a); if (s.radius === 0) {
              o.textBox = {
                x1: s.x1, y1: s.y1, x2: s.x2, y2: s.y2, anchorPointX: s.anchorPointX, anchorPointY: s.anchorPointY,
              }, o.textFeatureIndex = s.featureIndex; break;
            }o.textCircles || (o.textCircles = [], o.textFeatureIndex = s.featureIndex), o.textCircles.push(s.anchorPointX, s.anchorPointY, s.radius, s.signedDistanceFromAnchor, 1);
          } for (let l = r; l < i; l++) {
            const u = e.get(l); if (u.radius === 0) {
              o.iconBox = {
                x1: u.x1, y1: u.y1, x2: u.x2, y2: u.y2, anchorPointX: u.anchorPointX, anchorPointY: u.anchorPointY,
              }, o.iconFeatureIndex = u.featureIndex; break;
            }
          } return o;
        }, _a.prototype.hasTextData = function () { return this.text.segments.get().length > 0; }, _a.prototype.hasIconData = function () { return this.icon.segments.get().length > 0; }, _a.prototype.hasCollisionBoxData = function () { return this.collisionBox.segments.get().length > 0; }, _a.prototype.hasCollisionCircleData = function () { return this.collisionCircle.segments.get().length > 0; }, _a.prototype.sortFeatures = function (e) { const t = this; if (this.sortFeaturesByY && this.sortedAngle !== e && (this.sortedAngle = e, !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1))) { for (var n = [], r = 0; r < this.symbolInstances.length; r++)n.push(r); const i = Math.sin(e); const o = Math.cos(e); n.sort((e, n) => { const r = t.symbolInstances[e]; const a = t.symbolInstances[n]; return (i * r.anchor.x + o * r.anchor.y | 0) - (i * a.anchor.x + o * a.anchor.y | 0) || a.featureIndex - r.featureIndex; }), this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (let a = 0, s = n; a < s.length; a += 1) { const l = s[a]; const u = t.symbolInstances[l]; t.featureSortOrder.push(u.featureIndex); for (let c = 0, p = u.placedTextSymbolIndices; c < p.length; c += 1) for (let f = p[c], h = t.text.placedSymbolArray.get(f), d = h.vertexStartIndex + 4 * h.numGlyphs, m = h.vertexStartIndex; m < d; m += 4)t.text.indexArray.emplaceBack(m, m + 1, m + 2), t.text.indexArray.emplaceBack(m + 1, m + 2, m + 3); const g = t.icon.placedSymbolArray.get(l); if (g.numGlyphs) { const y = g.vertexStartIndex; t.icon.indexArray.emplaceBack(y, y + 1, y + 2), t.icon.indexArray.emplaceBack(y + 1, y + 2, y + 3); } } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray); } }, Fe('SymbolBucket', _a, { omit: ['layers', 'collisionBoxArray', 'features', 'compareText'], shallow: ['symbolInstances'] }), _a.MAX_GLYPHS = 65535, _a.addDynamicAttributes = ln; const ba = new Pi({
          'symbol-placement': new Si(Kn.layout_symbol['symbol-placement']), 'symbol-spacing': new Si(Kn.layout_symbol['symbol-spacing']), 'symbol-avoid-edges': new Si(Kn.layout_symbol['symbol-avoid-edges']), 'icon-allow-overlap': new Si(Kn.layout_symbol['icon-allow-overlap']), 'icon-ignore-placement': new Si(Kn.layout_symbol['icon-ignore-placement']), 'icon-optional': new Si(Kn.layout_symbol['icon-optional']), 'icon-rotation-alignment': new Si(Kn.layout_symbol['icon-rotation-alignment']), 'icon-size': new Ai(Kn.layout_symbol['icon-size']), 'icon-text-fit': new Si(Kn.layout_symbol['icon-text-fit']), 'icon-text-fit-padding': new Si(Kn.layout_symbol['icon-text-fit-padding']), 'icon-image': new Ai(Kn.layout_symbol['icon-image']), 'icon-rotate': new Ai(Kn.layout_symbol['icon-rotate']), 'icon-padding': new Si(Kn.layout_symbol['icon-padding']), 'icon-keep-upright': new Si(Kn.layout_symbol['icon-keep-upright']), 'icon-offset': new Ai(Kn.layout_symbol['icon-offset']), 'icon-anchor': new Ai(Kn.layout_symbol['icon-anchor']), 'icon-pitch-alignment': new Si(Kn.layout_symbol['icon-pitch-alignment']), 'text-pitch-alignment': new Si(Kn.layout_symbol['text-pitch-alignment']), 'text-rotation-alignment': new Si(Kn.layout_symbol['text-rotation-alignment']), 'text-field': new Ai(Kn.layout_symbol['text-field']), 'text-font': new Ai(Kn.layout_symbol['text-font']), 'text-size': new Ai(Kn.layout_symbol['text-size']), 'text-max-width': new Ai(Kn.layout_symbol['text-max-width']), 'text-line-height': new Si(Kn.layout_symbol['text-line-height']), 'text-letter-spacing': new Ai(Kn.layout_symbol['text-letter-spacing']), 'text-justify': new Ai(Kn.layout_symbol['text-justify']), 'text-anchor': new Ai(Kn.layout_symbol['text-anchor']), 'text-max-angle': new Si(Kn.layout_symbol['text-max-angle']), 'text-rotate': new Ai(Kn.layout_symbol['text-rotate']), 'text-padding': new Si(Kn.layout_symbol['text-padding']), 'text-keep-upright': new Si(Kn.layout_symbol['text-keep-upright']), 'text-transform': new Ai(Kn.layout_symbol['text-transform']), 'text-offset': new Ai(Kn.layout_symbol['text-offset']), 'text-allow-overlap': new Si(Kn.layout_symbol['text-allow-overlap']), 'text-ignore-placement': new Si(Kn.layout_symbol['text-ignore-placement']), 'text-optional': new Si(Kn.layout_symbol['text-optional']),
        }); const xa = {
          paint: new Pi({
            'icon-opacity': new Ai(Kn.paint_symbol['icon-opacity']), 'icon-color': new Ai(Kn.paint_symbol['icon-color']), 'icon-halo-color': new Ai(Kn.paint_symbol['icon-halo-color']), 'icon-halo-width': new Ai(Kn.paint_symbol['icon-halo-width']), 'icon-halo-blur': new Ai(Kn.paint_symbol['icon-halo-blur']), 'icon-translate': new Si(Kn.paint_symbol['icon-translate']), 'icon-translate-anchor': new Si(Kn.paint_symbol['icon-translate-anchor']), 'text-opacity': new Ai(Kn.paint_symbol['text-opacity']), 'text-color': new Ai(Kn.paint_symbol['text-color']), 'text-halo-color': new Ai(Kn.paint_symbol['text-halo-color']), 'text-halo-width': new Ai(Kn.paint_symbol['text-halo-width']), 'text-halo-blur': new Ai(Kn.paint_symbol['text-halo-blur']), 'text-translate': new Si(Kn.paint_symbol['text-translate']), 'text-translate-anchor': new Si(Kn.paint_symbol['text-translate-anchor']),
          }),
          layout: ba,
        }; const wa = (function (e) { function t(t) { e.call(this, t, xa); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.recalculate = function (t) { e.prototype.recalculate.call(this, t), this.layout.get('icon-rotation-alignment') === 'auto' && (this.layout.get('symbol-placement') === 'line' ? this.layout._values['icon-rotation-alignment'] = 'map' : this.layout._values['icon-rotation-alignment'] = 'viewport'), this.layout.get('text-rotation-alignment') === 'auto' && (this.layout.get('symbol-placement') === 'line' ? this.layout._values['text-rotation-alignment'] = 'map' : this.layout._values['text-rotation-alignment'] = 'viewport'), this.layout.get('text-pitch-alignment') === 'auto' && (this.layout._values['text-pitch-alignment'] = this.layout.get('text-rotation-alignment')), this.layout.get('icon-pitch-alignment') === 'auto' && (this.layout._values['icon-pitch-alignment'] = this.layout.get('icon-rotation-alignment')); }, t.prototype.getValueAndResolveTokens = function (e, t) { let n; const r = this.layout.get(e).evaluate(t); const i = this._unevaluatedLayout._values[e]; return i.isDataDriven() || se(i.value) ? r : (n = t.properties, r.replace(/{([^{}]+)}/g, (e, t) => (t in n ? String(n[t]):''))); }, t.prototype.createBucket = function (e) { return new _a(e); }, t.prototype.queryRadius = function () { return 0; }, t.prototype.queryIntersectsFeature = function () { return !1; }, t; }(Mi)); const Ea = { paint: new Pi({ 'background-color': new Si(Kn.paint_background['background-color']), 'background-pattern': new Oi(Kn.paint_background['background-pattern']), 'background-opacity': new Si(Kn.paint_background['background-opacity']) }) }; const Ta = (function (e) { function t(t) { e.call(this, t, Ea); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t; }(Mi)); const ka = {
          paint: new Pi({
            'raster-opacity': new Si(Kn.paint_raster['raster-opacity']), 'raster-hue-rotate': new Si(Kn.paint_raster['raster-hue-rotate']), 'raster-brightness-min': new Si(Kn.paint_raster['raster-brightness-min']), 'raster-brightness-max': new Si(Kn.paint_raster['raster-brightness-max']), 'raster-saturation': new Si(Kn.paint_raster['raster-saturation']), 'raster-contrast': new Si(Kn.paint_raster['raster-contrast']), 'raster-fade-duration': new Si(Kn.paint_raster['raster-fade-duration']),
          }),
        }; const Ca = {
          circle: So, heatmap: Mo, hillshade: Do, fill: Vo, 'fill-extrusion': Go, line: sa, symbol: wa, background: Ta, raster: (function (e) { function t(t) { e.call(this, t, ka); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t; }(Mi)),
        }; const Sa = r((e, t) => { e.exports = (function () { function e(e, t, n) { n = n || {}, this.w = e || 64, this.h = t || 64, this.autoResize = !!n.autoResize, this.shelves = [], this.freebins = [], this.stats = {}, this.bins = {}, this.maxId = 0; } function t(e, t, n) { this.x = 0, this.y = e, this.w = this.free = t, this.h = n; } return e.prototype.pack = function (e, t) { e = [].concat(e), t = t || {}; for (var n, r, i, o, a = [], s = 0; s < e.length; s++) if (n = e[s].w || e[s].width, r = e[s].h || e[s].height, i = e[s].id, n && r) { if (!(o = this.packOne(n, r, i))) continue; t.inPlace && (e[s].x = o.x, e[s].y = o.y, e[s].id = o.id), a.push(o); } return this.shrink(), a; }, e.prototype.packOne = function (e, n, r) { let i; let o; let a; let s; let l; let u; let c; let p; const f = { freebin: -1, shelf: -1, waste: 1 / 0 }; let h = 0; if (typeof r == 'string' || typeof r==='number') { if (i = this.getBin(r)) return this.ref(i), i; typeof r==='number' && (this.maxId = Math.max(r, this.maxId)); } else r = ++this.maxId; for (s = 0; s < this.freebins.length; s++) { if (n === (i = this.freebins[s]).maxh && e === i.maxw) return this.allocFreebin(s, e, n, r); n > i.maxh || e > i.maxw || n <= i.maxh && e <= i.maxw && (a = i.maxw * i.maxh - e * n) < f.waste && (f.waste = a, f.freebin = s); } for (s = 0; s < this.shelves.length; s++) if (h += (o = this.shelves[s]).h, !(e > o.free)) { if (n === o.h) return this.allocShelf(s, e, n, r); n > o.h || n < o.h && (a = (o.h - n) * e) < f.waste && (f.freebin = -1, f.waste = a, f.shelf = s); } return f.freebin !== -1 ? this.allocFreebin(f.freebin, e, n, r) : f.shelf !== -1 ? this.allocShelf(f.shelf, e, n, r) : n <= this.h - h && e <= this.w ? (o = new t(h, this.w, n), this.allocShelf(this.shelves.push(o) - 1, e, n, r)) : this.autoResize ? (l = u = this.h, ((c = p = this.w) <= l || e > c) && (p = 2 * Math.max(e, c)), (l < c || n > l) && (u = 2 * Math.max(n, l)), this.resize(p, u), this.packOne(e, n, r)) : null; }, e.prototype.allocFreebin = function (e, t, n, r) { const i = this.freebins.splice(e, 1)[0]; return i.id = r, i.w = t, i.h = n, i.refcount = 0, this.bins[r] = i, this.ref(i), i; }, e.prototype.allocShelf = function (e, t, n, r) { const i = this.shelves[e].alloc(t, n, r); return this.bins[r] = i, this.ref(i), i; }, e.prototype.shrink = function () { if (this.shelves.length > 0) { for (var e = 0, t = 0, n = 0; n < this.shelves.length; n++) { const r = this.shelves[n]; t += r.h, e = Math.max(r.w - r.free, e); } this.resize(e, t); } }, e.prototype.getBin = function (e) { return this.bins[e]; }, e.prototype.ref = function (e) { if (++e.refcount == 1) { const t = e.h; this.stats[t] = 1 + (0 | this.stats[t]); } return e.refcount; }, e.prototype.unref = function (e) { return e.refcount === 0 ? 0 : (--e.refcount == 0 && (this.stats[e.h]--, delete this.bins[e.id], this.freebins.push(e)), e.refcount); }, e.prototype.clear = function () { this.shelves = [], this.freebins = [], this.stats = {}, this.bins = {}, this.maxId = 0; }, e.prototype.resize = function (e, t) { this.w = e, this.h = t; for (let n = 0; n < this.shelves.length; n++) this.shelves[n].resize(e); return !0; }, t.prototype.alloc = function (e, t, n) { if (e > this.free || t > this.h) return null; const r = this.x; return this.x += e, this.free -= e, new function (e, t, n, r, i, o, a) { this.id = e, this.x = t, this.y = n, this.w = r, this.h = i, this.maxw = o || r, this.maxh = a || i, this.refcount = 0; }(n, r, this.y, e, t, e, this.h); }, t.prototype.resize = function (e) { return this.free += e - this.w, this.w = e, !0; }, e; }()); }); const Aa = function (e, t) { const n = t.pixelRatio; this.paddedRect = e, this.pixelRatio = n; }; const Oa = { tl: { configurable: !0 }, br: { configurable: !0 }, displaySize: { configurable: !0 } }; Oa.tl.get = function () { return [this.paddedRect.x + 1, this.paddedRect.y + 1]; }, Oa.br.get = function () { return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]; }, Oa.displaySize.get = function () { return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]; }, Object.defineProperties(Aa.prototype, Oa); const Ia = function (e) { const t = new Io({ width: 0, height: 0 }); const n = {}; const r = new Sa(0, 0, { autoResize: !0 }); for (const i in e) { const o = e[i]; const a = r.packOne(o.data.width + 2, o.data.height + 2); t.resize({ width: r.w, height: r.h }), Io.copy(o.data, t, { x: 0, y: 0 }, { x: a.x + 1, y: a.y + 1 }, o.data), n[i] = new Aa(a, o); }r.shrink(), t.resize({ width: r.w, height: r.h }), this.image = t, this.positions = n; }; Fe('ImagePosition', Aa), Fe('ImageAtlas', Ia); const Pa = function (e, t, n, r, i) { let o; let a; const s = 8 * i - r - 1; const l = (1 << s) - 1; const u = l >> 1; let c = -7; let p = n ? i - 1 : 0; const f = n ? -1 : 1; let h = e[t + p]; for (p += f, o = h & (1 << -c) - 1, h >>= -c, c += s; c > 0; o = 256 * o + e[t + p], p += f, c -= 8);for (a = o & (1 << -c) - 1, o >>= -c, c += r; c > 0; a = 256 * a + e[t + p], p += f, c -= 8);if (o === 0)o = 1 - u; else { if (o === l) return a ? NaN : 1 / 0 * (h ? -1 : 1); a += Math.pow(2, r), o -= u; } return (h ? -1 : 1) * a * Math.pow(2, o - r); }; const Ma = function (e, t, n, r, i, o) { let a; let s; let l; let u = 8 * o - i - 1; const c = (1 << u) - 1; const p = c >> 1; const f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; let h = r ? 0 : o - 1; const d = r ? 1 : -1; const m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (t += a + p >= 1 ? f / l : f * Math.pow(2, 1 - p)) * l >= 2 && (a++, l /= 2), a + p >= c ? (s = 0, a = c) : a + p >= 1 ? (s = (t * l - 1) * Math.pow(2, i), a += p) : (s = t * Math.pow(2, p - 1) * Math.pow(2, i), a = 0)); i >= 8; e[n + h] = 255 & s, h += d, s /= 256, i -= 8);for (a = a << i | s, u += i; u > 0; e[n + h] = 255 & a, h += d, a /= 256, u -= 8);e[n + h - d] |= 128 * m; }; const Na = un; un.Varint = 0, un.Fixed64 = 1, un.Bytes = 2, un.Fixed32 = 5, un.prototype = {
          destroy() { this.buf = null; }, readFields(e, t, n) { for (n = n || this.length; this.pos < n;) { const r = this.readVarint(); const i = r >> 3; const o = this.pos; this.type = 7 & r, e(i, t, this), this.pos === o && this.skip(r); } return t; }, readMessage(e, t) { return this.readFields(e, t, this.readVarint() + this.pos); }, readFixed32() { const e = wn(this.buf, this.pos); return this.pos += 4, e; }, readSFixed32() { const e = Tn(this.buf, this.pos); return this.pos += 4, e; }, readFixed64() { const e = wn(this.buf, this.pos) + 4294967296 * wn(this.buf, this.pos + 4); return this.pos += 8, e; }, readSFixed64() { const e = wn(this.buf, this.pos) + 4294967296 * Tn(this.buf, this.pos + 4); return this.pos += 8, e; }, readFloat() { const e = Pa(this.buf, this.pos, !0, 23, 4); return this.pos += 4, e; }, readDouble() { const e = Pa(this.buf, this.pos, !0, 52, 8); return this.pos += 8, e; }, readVarint(e) { let t; let n; const r = this.buf; return t = 127 & (n = r[this.pos++]), n < 128 ? t : (t |= (127 & (n = r[this.pos++])) << 7, n < 128 ? t : (t |= (127 & (n = r[this.pos++])) << 14, n < 128 ? t : (t |= (127 & (n = r[this.pos++])) << 21, n < 128 ? t : (function (e, t, n) { let r; let i; const o = n.buf; if (i = o[n.pos++], r = (112 & i) >> 4, i < 128) return pn(e, r, t); if (i = o[n.pos++], r |= (127 & i) << 3, i < 128) return pn(e, r, t); if (i = o[n.pos++], r |= (127 & i) << 10, i < 128) return pn(e, r, t); if (i = o[n.pos++], r |= (127 & i) << 17, i < 128) return pn(e, r, t); if (i = o[n.pos++], r |= (127 & i) << 24, i < 128) return pn(e, r, t); if (i = o[n.pos++], r |= (1 & i) << 31, i < 128) return pn(e, r, t); throw new Error('Expected varint not more than 10 bytes'); }(t |= (15 & (n = r[this.pos])) << 28, e, this))))); }, readVarint64() { return this.readVarint(!0); }, readSVarint() { const e = this.readVarint(); return e % 2 == 1 ? (e + 1) / -2 : e / 2; }, readBoolean() { return Boolean(this.readVarint()); }, readString() { const e = this.readVarint() + this.pos; const t = (function (e, t, n) { for (var r = '', i = t; i < n;) { var o; var a; var s; const l = e[i]; let u = null; let c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1; if (i + c > n) break; c === 1 ? l < 128 && (u = l) : c === 2 ? (192 & (o = e[i + 1])) == 128 && (u = (31 & l) << 6 | 63 & o) <= 127 && (u = null) : c === 3 ? (o = e[i + 1], a = e[i + 2], (192 & o) == 128 && (192 & a) == 128 && ((u = (15 & l) << 12 | (63 & o) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : c === 4 && (o = e[i + 1], a = e[i + 2], s = e[i + 3], (192 & o) == 128 && (192 & a) == 128 && (192 & s) == 128 && ((u = (15 & l) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s) <= 65535 || u >= 1114112) && (u = null)), u === null ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, r += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), r += String.fromCharCode(u), i += c; } return r; }(this.buf, this.pos, e)); return this.pos = e, t; }, readBytes() { const e = this.readVarint() + this.pos; const t = this.buf.subarray(this.pos, e); return this.pos = e, t; }, readPackedVarint(e, t) { const n = cn(this); for (e = e || []; this.pos < n;)e.push(this.readVarint(t)); return e; }, readPackedSVarint(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readSVarint()); return e; }, readPackedBoolean(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readBoolean()); return e; }, readPackedFloat(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readFloat()); return e; }, readPackedDouble(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readDouble()); return e; }, readPackedFixed32(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readFixed32()); return e; }, readPackedSFixed32(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readSFixed32()); return e; }, readPackedFixed64(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readFixed64()); return e; }, readPackedSFixed64(e) { const t = cn(this); for (e = e || []; this.pos < t;)e.push(this.readSFixed64()); return e; }, skip(e) { const t = 7 & e; if (t === un.Varint) for (;this.buf[this.pos++] > 127;);else if (t === un.Bytes) this.pos = this.readVarint() + this.pos; else if (t === un.Fixed32) this.pos += 4; else { if (t !== un.Fixed64) throw new Error(`Unimplemented type: ${t}`); this.pos += 8; } }, writeTag(e, t) { this.writeVarint(e << 3 | t); }, realloc(e) { for (var t = this.length || 16; t < this.pos + e;)t *= 2; if (t !== this.length) { const n = new Uint8Array(t); n.set(this.buf), this.buf = n, this.length = t; } }, finish() { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length); }, writeFixed32(e) { this.realloc(4), En(this.buf, e, this.pos), this.pos += 4; }, writeSFixed32(e) { this.realloc(4), En(this.buf, e, this.pos), this.pos += 4; }, writeFixed64(e) { this.realloc(8), En(this.buf, -1 & e, this.pos), En(this.buf, Math.floor(e * (1 / 4294967296)), this.pos + 4), this.pos += 8; }, writeSFixed64(e) { this.realloc(8), En(this.buf, -1 & e, this.pos), En(this.buf, Math.floor(e * (1 / 4294967296)), this.pos + 4), this.pos += 8; }, writeVarint(e) { (e = +e || 0) > 268435455 || e < 0 ? (function (e, t) { let n; let r; if (e >= 0 ? (n = e % 4294967296 | 0, r = e / 4294967296 | 0) : (r = ~(-e / 4294967296), 4294967295 ^ (n = ~(-e % 4294967296)) ? n = n + 1 | 0 : (n = 0, r = r + 1 | 0)), e >= 0x10000000000000000 || e < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); t.realloc(10), (function (e, t, n) { n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos] = 127 & e; }(n, 0, t)), (function (e, t) { const n = (7 & e) << 4; t.buf[t.pos++] |= n | ((e >>>= 3) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e))))); }(r, t)); }(e, this)) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127)))); }, writeSVarint(e) { this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e); }, writeBoolean(e) { this.writeVarint(Boolean(e)); }, writeString(e) { e = String(e), this.realloc(4 * e.length), this.pos++; const t = this.pos; this.pos = (function (e, t, n) { for (var r, i, o = 0; o < t.length; o++) { if ((r = t.charCodeAt(o)) > 55295 && r < 57344) { if (!i) { r > 56319 || o + 1 === t.length ? (e[n++] = 239, e[n++] = 191, e[n++] = 189) : i = r; continue; } if (r < 56320) { e[n++] = 239, e[n++] = 191, e[n++] = 189, i = r; continue; }r = i - 55296 << 10 | r - 56320 | 65536, i = null; } else i && (e[n++] = 239, e[n++] = 191, e[n++] = 189, i = null); r < 128 ? e[n++] = r : (r < 2048 ? e[n++] = r >> 6 | 192 : (r < 65536 ? e[n++] = r >> 12 | 224 : (e[n++] = r >> 18 | 240, e[n++] = r >> 12 & 63 | 128), e[n++] = r >> 6 & 63 | 128), e[n++] = 63 & r | 128); } return n; }(this.buf, e, this.pos)); const n = this.pos - t; n >= 128 && fn(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n; }, writeFloat(e) { this.realloc(4), Ma(this.buf, e, this.pos, !0, 23, 4), this.pos += 4; }, writeDouble(e) { this.realloc(8), Ma(this.buf, e, this.pos, !0, 52, 8), this.pos += 8; }, writeBytes(e) { const t = e.length; this.writeVarint(t), this.realloc(t); for (let n = 0; n < t; n++) this.buf[this.pos++] = e[n]; }, writeRawMessage(e, t) { this.pos++; const n = this.pos; e(t, this); const r = this.pos - n; r >= 128 && fn(n, r, this), this.pos = n - 1, this.writeVarint(r), this.pos += r; }, writeMessage(e, t, n) { this.writeTag(e, un.Bytes), this.writeRawMessage(t, n); }, writePackedVarint(e, t) { this.writeMessage(e, hn, t); }, writePackedSVarint(e, t) { this.writeMessage(e, dn, t); }, writePackedBoolean(e, t) { this.writeMessage(e, yn, t); }, writePackedFloat(e, t) { this.writeMessage(e, mn, t); }, writePackedDouble(e, t) { this.writeMessage(e, gn, t); }, writePackedFixed32(e, t) { this.writeMessage(e, vn, t); }, writePackedSFixed32(e, t) { this.writeMessage(e, _n, t); }, writePackedFixed64(e, t) { this.writeMessage(e, bn, t); }, writePackedSFixed64(e, t) { this.writeMessage(e, xn, t); }, writeBytesField(e, t) { this.writeTag(e, un.Bytes), this.writeBytes(t); }, writeFixed32Field(e, t) { this.writeTag(e, un.Fixed32), this.writeFixed32(t); }, writeSFixed32Field(e, t) { this.writeTag(e, un.Fixed32), this.writeSFixed32(t); }, writeFixed64Field(e, t) { this.writeTag(e, un.Fixed64), this.writeFixed64(t); }, writeSFixed64Field(e, t) { this.writeTag(e, un.Fixed64), this.writeSFixed64(t); }, writeVarintField(e, t) { this.writeTag(e, un.Varint), this.writeVarint(t); }, writeSVarintField(e, t) { this.writeTag(e, un.Varint), this.writeSVarint(t); }, writeStringField(e, t) { this.writeTag(e, un.Bytes), this.writeString(t); }, writeFloatField(e, t) { this.writeTag(e, un.Fixed32), this.writeFloat(t); }, writeDoubleField(e, t) { this.writeTag(e, un.Fixed64), this.writeDouble(t); }, writeBooleanField(e, t) { this.writeVarintField(e, Boolean(t)); },
        }; var Da = 3; const La = Da; const za = function (e, t, n) { this.target = e, this.parent = t, this.mapId = n, this.callbacks = {}, this.callbackID = 0, u(['receive'], this), this.target.addEventListener('message', this.receive, !1); }; za.prototype.send = function (e, t, n, r) {
          const i = n ? `${this.mapId}:${this.callbackID++}` : null; n && (this.callbacks[i] = n); const o = []; this.target.postMessage({
            targetMapId: r, sourceMapId: this.mapId, type: e, id: String(i), data: Ue(t, o),
          }, o);
        }, za.prototype.receive = function (e) {
          let t; const n = this; const r = e.data; const i = r.id; if (!r.targetMapId || this.mapId === r.targetMapId) {
            const o = function (e, t) {
              const r = []; n.target.postMessage({
                sourceMapId: n.mapId, type: '<response>', id: String(i), error: e ? Ue(e) : null, data: Ue(t, r),
              }, r);
            }; if (r.type === '<response>')t = this.callbacks[r.id], delete this.callbacks[r.id], t && r.error ? t(Ve(r.error)) : t && t(null, Ve(r.data)); else if (void 0 !== r.id && this.parent[r.type]) this.parent[r.type](r.sourceMapId, Ve(r.data), o); else if (void 0 !== r.id && this.parent.getWorkerSource) { const a = r.type.split('.'); this.parent.getWorkerSource(r.sourceMapId, a[0], a[1])[a[2]](Ve(r.data), o); } else this.parent[r.type](Ve(r.data));
          }
        }, za.prototype.remove = function () { this.target.removeEventListener('message', this.receive, !1); }; const Ra = n(r((e, t) => { !(function (e) { function t(e, t, r) { t = Math.pow(2, r) - t - 1; const i = n(256 * e, 256 * t, r); const o = n(256 * (e + 1), 256 * (t + 1), r); return `${i[0]},${i[1]},${o[0]},${o[1]}`; } function n(e, t, n) { const r = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n); return [e * r - 2 * Math.PI * 6378137 / 2, t * r - 2 * Math.PI * 6378137 / 2]; }e.getURL = function (e, n, r, i, o, a) { return a = a || {}, `${e}?${[`bbox=${t(r, i, o)}`, `format=${  a.format || 'image/png'}`, `service=${  a.service || 'WMS'}`, `version=${  a.version || '1.1.1'}`, `request=${  a.request || 'GetMap'}`, `srs=${  a.srs || 'EPSG:3857'}`, `width=${  a.width || 256}`, `height=${  a.height || 256}`, `layers=${  n}`].join('&')}`; }, e.getTileBBox = t, e.getMercCoords = n, Object.defineProperty(e, '__esModule', { value: !0 }); }(t)); })); const ja = function (e, t, n) { this.z = e, this.x = t, this.y = n, this.key = An(0, e, t, n); }; ja.prototype.equals = function (e) { return this.z === e.z && this.x === e.x && this.y === e.y; }, ja.prototype.url = function (e, t) {
          const n = Ra.getTileBBox(this.x, this.y, this.z); const r = (function (e, t, n) { for (var r, i = '', o = e; o > 0; o--)i += (t & (r = 1 << o - 1) ? 1 : 0) + (n & r ? 2 : 0); return i; }(this.z, this.x, this.y)); return e[(this.x + this.y) % e.length].replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace('{z}', String(this.z)).replace('{x}', String(this.x)).replace('{y}', String(t === 'tms' ? Math.pow(2, this.z) - this.y - 1 : this.y))
            .replace('{quadkey}', r)
            .replace('{bbox-epsg-3857}', n);
        }; const Ba = function (e, t) { this.wrap = e, this.canonical = t, this.key = An(e, t.z, t.x, t.y); }; const Fa = function (e, t, n, r, i) { this.overscaledZ = e, this.wrap = t, this.canonical = new ja(n, +r, +i), this.key = An(t, e, r, i); }; Fa.prototype.equals = function (e) { return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical); }, Fa.prototype.scaledTo = function (e) { const t = this.canonical.z - e; return e > this.canonical.z ? new Fa(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Fa(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t); }, Fa.prototype.isChildOf = function (e) { const t = this.canonical.z - e.canonical.z; return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> t && e.canonical.y === this.canonical.y >> t; }, Fa.prototype.children = function (e) { if (this.overscaledZ >= e) return [new Fa(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; const t = this.canonical.z + 1; const n = 2 * this.canonical.x; const r = 2 * this.canonical.y; return [new Fa(t, this.wrap, t, n, r), new Fa(t, this.wrap, t, n + 1, r), new Fa(t, this.wrap, t, n, r + 1), new Fa(t, this.wrap, t, n + 1, r + 1)]; }, Fa.prototype.isLessThan = function (e) { return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y)); }, Fa.prototype.wrapped = function () { return new Fa(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y); }, Fa.prototype.unwrapTo = function (e) { return new Fa(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y); }, Fa.prototype.overscaleFactor = function () { return Math.pow(2, this.overscaledZ - this.canonical.z); }, Fa.prototype.toUnwrapped = function () { return new Ba(this.wrap, this.canonical); }, Fa.prototype.toString = function () { return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`; }, Fa.prototype.toCoordinate = function () { return new jn(this.canonical.x + Math.pow(2, this.wrap), this.canonical.y, this.canonical.z); }, Fe('CanonicalTileID', ja), Fe('OverscaledTileID', Fa, { omit: ['posMatrix'] }); const Ua = function (e, t, n) { if (e <= 0) throw new RangeError('Level must have positive dimension'); this.dim = e, this.border = t, this.stride = this.dim + 2 * this.border, this.data = n || new Int32Array((this.dim + 2 * this.border) * (this.dim + 2 * this.border)); }; Ua.prototype.set = function (e, t, n) { this.data[this._idx(e, t)] = n + 65536; }, Ua.prototype.get = function (e, t) { return this.data[this._idx(e, t)] - 65536; }, Ua.prototype._idx = function (e, t) { if (e < -this.border || e >= this.dim + this.border || t < -this.border || t >= this.dim + this.border) throw new RangeError('out of range source coordinates for DEM data'); return (t + this.border) * this.stride + (e + this.border); }, Fe('Level', Ua); const Va = function (e, t, n) { this.uid = e, this.scale = t || 1, this.level = n || new Ua(256, 512), this.loaded = !!n; }; Va.prototype.loadFromImage = function (e, t) { if (e.height !== e.width) throw new RangeError('DEM tiles must be square'); if (t && t !== 'mapbox' && t !== 'terrarium') return d(`"${t}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`); const n = this.level = new Ua(e.width, e.width / 2); const r = e.data; this._unpackData(n, r, t || 'mapbox'); for (let i = 0; i < n.dim; i++)n.set(-1, i, n.get(0, i)), n.set(n.dim, i, n.get(n.dim - 1, i)), n.set(i, -1, n.get(i, 0)), n.set(i, n.dim, n.get(i, n.dim - 1)); n.set(-1, -1, n.get(0, 0)), n.set(n.dim, -1, n.get(n.dim - 1, 0)), n.set(-1, n.dim, n.get(0, n.dim - 1)), n.set(n.dim, n.dim, n.get(n.dim - 1, n.dim - 1)), this.loaded = !0; }, Va.prototype._unpackMapbox = function (e, t, n) { return (256 * e * 256 + 256 * t + n) / 10 - 1e4; }, Va.prototype._unpackTerrarium = function (e, t, n) { return 256 * e + t + n / 256 - 32768; }, Va.prototype._unpackData = function (e, t, n) { for (let r = { mapbox: this._unpackMapbox, terrarium: this._unpackTerrarium }[n], i = 0; i < e.dim; i++) for (let o = 0; o < e.dim; o++) { const a = 4 * (i * e.dim + o); e.set(o, i, this.scale * r(t[a], t[a + 1], t[a + 2])); } }, Va.prototype.getPixels = function () { return new Io({ width: this.level.dim + 2 * this.level.border, height: this.level.dim + 2 * this.level.border }, new Uint8Array(this.level.data.buffer)); }, Va.prototype.backfillBorder = function (e, t, n) { const r = this.level; const i = e.level; if (r.dim !== i.dim) throw new Error('level mismatch (dem dimension)'); let o = t * r.dim; let a = t * r.dim + r.dim; let l = n * r.dim; let u = n * r.dim + r.dim; switch (t) { case -1: o = a - 1; break; case 1: a = o + 1; } switch (n) { case -1: l = u - 1; break; case 1: u = l + 1; } for (let c = s(o, -r.border, r.dim + r.border), p = s(a, -r.border, r.dim + r.border), f = s(l, -r.border, r.dim + r.border), h = s(u, -r.border, r.dim + r.border), d = -t * r.dim, m = -n * r.dim, g = f; g < h; g++) for (let y = c; y < p; y++)r.set(y, g, i.get(y + d, g + m)); }, Fe('DEMData', Va); const qa = function (e) { this._stringToNumber = {}, this._numberToString = []; for (let t = 0; t < e.length; t++) { const n = e[t]; this._stringToNumber[n] = t, this._numberToString[t] = n; } }; qa.prototype.encode = function (e) { return this._stringToNumber[e]; }, qa.prototype.decode = function (e) { return this._numberToString[e]; }; const Ha = function (e, t, n, r) { this.type = 'Feature', this._vectorTileFeature = e, e._z = t, e._x = n, e._y = r, this.properties = e.properties, e.id != null && (this.id = e.id); }; const Wa = { geometry: { configurable: !0 } }; Wa.geometry.get = function () { return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry; }, Wa.geometry.set = function (e) { this._geometry = e; }, Ha.prototype.toJSON = function () { const e = { geometry: this.geometry }; for (const t in this)t !== '_geometry' && t !== '_vectorTileFeature' && (e[t] = this[t]); return e; }, Object.defineProperties(Ha.prototype, Wa); const $a = function (e, t, n) { this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = t || new oi(bo, 16, 0), this.featureIndexArray = n || new uo(); }; $a.prototype.insert = function (e, t, n, r, i) { const o = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(n, r, i); for (let a = 0; a < t.length; a++) { for (var s = t[a], l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], u = 0; u < s.length; u++) { const c = s[u]; l[0] = Math.min(l[0], c.x), l[1] = Math.min(l[1], c.y), l[2] = Math.max(l[2], c.x), l[3] = Math.max(l[3], c.y); }l[0] < bo && l[1] < bo && l[2] >= 0 && l[3] >= 0 && this.grid.insert(o, l[0], l[1], l[2], l[3]); } }, $a.prototype.loadVTLayers = function () { return this.vtLayers || (this.vtLayers = new Yo.VectorTile(new Na(this.rawTileData)).layers, this.sourceLayerCoder = new qa(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer'])), this.vtLayers; }, $a.prototype.query = function (e, t) { const n = this; this.loadVTLayers(); for (var r = e.params || {}, i = bo / e.tileSize / e.scale, o = ve(r.filter), a = e.queryGeometry, s = e.queryPadding * i, l = 1 / 0, u = 1 / 0, c = -1 / 0, p = -1 / 0, f = 0; f < a.length; f++) for (let h = a[f], d = 0; d < h.length; d++) { const m = h[d]; l = Math.min(l, m.x), u = Math.min(u, m.y), c = Math.max(c, m.x), p = Math.max(p, m.y); } const g = this.grid.query(l - s, u - s, c + s, p + s); g.sort(On); for (var y, v = {}, _ = 0; _ < g.length; _++)!(function (s) { const l = g[s]; if (l !== y) { y = l; const u = n.featureIndexArray.get(l); let c = null; n.loadMatchingFeature(v, u.bucketIndex, u.sourceLayerIndex, u.featureIndex, o, r.layers, t, (t, r) => c || (c = Je(t)), r.queryIntersectsFeature(a, t, c, n.z, e.transform, i, e.posMatrix)); } }(_)); return v; }, $a.prototype.loadMatchingFeature = function (e, t, n, r, i, o, a, s) { const l = this.bucketLayerIDs[t]; if (!o || (function (e, t) { for (let n = 0; n < e.length; n++) if (t.indexOf(e[n]) >= 0) return !0; return !1; }(o, l))) { const u = this.sourceLayerCoder.decode(n); const c = this.vtLayers[u].feature(r); if (i(new vi(this.tileID.overscaledZ), c)) for (let p = 0; p < l.length; p++) { const f = l[p]; if (!(o && o.indexOf(f) < 0)) { const h = a[f]; if (h && (!s || s(c, h))) { const d = new Ha(c, this.z, this.x, this.y); d.layer = h.serialize(); let m = e[f]; void 0 === m && (m = e[f] = []), m.push({ featureIndex: r, feature: d }); } } } } }, $a.prototype.lookupSymbolFeatures = function (e, t, n, r, i, o) { const a = {}; this.loadVTLayers(); for (let s = ve(r), l = 0, u = e; l < u.length; l += 1) { const c = u[l]; this.loadMatchingFeature(a, t, n, c, s, i, o); } return a; }, $a.prototype.hasLayer = function (e) { for (let t = 0, n = this.bucketLayerIDs; t < n.length; t += 1) for (let r = 0, i = n[t]; r < i.length; r += 1) if (e === i[r]) return !0; return !1; }, Fe('FeatureIndex', $a, { omit: ['rawTileData', 'sourceLayerCoder'] }); const Ga = { horizontal: 1, vertical: 2, horizontalOnly: 3 }; var Za = {
          9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0,
        }; var Ka = {}; Ka[10] = !0, Ka[32] = !0, Ka[38] = !0, Ka[40] = !0, Ka[41] = !0, Ka[43] = !0, Ka[45] = !0, Ka[47] = !0, Ka[173] = !0, Ka[183] = !0, Ka[8203] = !0, Ka[8208] = !0, Ka[8211] = !0, Ka[8231] = !0, e.commonjsGlobal = zn, e.unwrapExports = n, e.createCommonjsModule = r, e.default = self, e.default$1 = Bn, e.getJSON = function (e, t) { const n = y(e); return n.setRequestHeader('Accept', 'application/json'), n.onerror = function () { t(new Error(n.statusText)); }, n.onload = function () { if (n.status >= 200 && n.status < 300 && n.response) { let r; try { r = JSON.parse(n.response); } catch (e) { return t(e); }t(null, r); } else t(n.status === 401 && e.url.match(/mapbox.com/) ? new Hn(`${n.statusText}: you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens`, n.status, e.url) : new Hn(n.statusText, n.status, e.url)); }, n.send(), n; }, e.getImage = function (e, t) {
          return Wn(e, (e, n) => {
            if (e)t(e); else if (n) {
              const r = new self.Image();


              const i = self.URL || self.webkitURL; r.onload = function () { t(null, r), i.revokeObjectURL(r.src); }; const o = new self.Blob([new Uint8Array(n.data)], { type: 'image/png' }); r.cacheControl = n.cacheControl, r.expires = n.expires, r.src = n.data.byteLength ? i.createObjectURL(o) : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';
            }
          });
        }, e.ResourceType = qn, e.RGBAImage = Io, e.default$2 = Sa, e.ImagePosition = Aa, e.getArrayBuffer = Wn, e.default$3 = function (e) { return new Na(e).readFields(kn, []); }, e.default$4 = fi, e.asyncAll = function (e, t, n) { if (!e.length) return n(null, []); let r = e.length; const i = new Array(e.length); let o = null; e.forEach((e, a) => { t(e, (e, t) => { e && (o = e), i[a] = t, --r == 0 && n(o, i); }); }); }, e.AlphaImage = Oo, e.default$5 = Kn, e.endsWith = c, e.extend = l, e.sphericalToCartesian = function (e) { const t = e[0]; let n = e[1]; let r = e[2]; return n += 90, n *= Math.PI / 180, r *= Math.PI / 180, { x: t * Math.cos(n) * Math.sin(r), y: t * Math.sin(n) * Math.sin(r), z: t * Math.cos(r) }; }, e.Evented = Zn, e.validateStyle = ti, e.validateLight = ni, e.emitValidationErrors = je, e.default$6 = ur, e.number = M, e.Properties = Pi, e.Transitionable = xi, e.Transitioning = Ei, e.PossiblyEvaluated = Ci, e.DataConstantProperty = Si, e.warnOnce = d, e.uniqueId = function () { return Un++; }, e.default$7 = za, e.pick = function (e, t) { for (var n = {}, r = 0; r < t.length; r++) { const i = t[r]; i in e && (n[i] = e[i]); } return n; }, e.wrap = function (e, t, n) { const r = n - t; const i = ((e - t) % r + r) % r + t; return i === t ? n : i; }, e.clamp = s, e.Event = $n, e.ErrorEvent = Gn, e.OverscaledTileID = Fa, e.default$8 = bo, e.createLayout = Ze, e.getCoordinatesCenter = function (e) { for (var t = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0, o = 0; o < e.length; o++)t = Math.min(t, e[o].column), n = Math.min(n, e[o].row), r = Math.max(r, e[o].column), i = Math.max(i, e[o].row); const a = r - t; const s = i - n; const l = Math.max(a, s); const u = Math.max(0, Math.floor(-Math.log(l) / Math.LN2)); return new jn((t + r) / 2, (n + i) / 2, 0).zoomTo(u); }, e.CanonicalTileID = ja, e.RasterBoundsArray = Ri, e.getVideo = function (e, t) { let n; let r; const i = self.document.createElement('video'); i.onloadstart = function () { t(null, i); }; for (let o = 0; o < e.length; o++) { const a = self.document.createElement('source'); n = e[o], r = void 0, (r = self.document.createElement('a')).href = n, (r.protocol !== self.document.location.protocol || r.host !== self.document.location.host) && (i.crossOrigin = 'Anonymous'), a.src = e[o], i.appendChild(a); } return i; }, e.default$9 = Xn, e.bindAll = u, e.default$10 = function e(t, n) { if (Array.isArray(t)) { if (!Array.isArray(n) || t.length !== n.length) return !1; for (let r = 0; r < t.length; r++) if (!e(t[r], n[r])) return !1; return !0; } if (typeof t === 'object' && t !== null && n !== null) { if (typeof n !== 'object') return !1; if (Object.keys(t).length !== Object.keys(n).length) return !1; for (const i in t) if (!e(t[i], n[i])) return !1; return !0; } return t === n; }, e.parseCacheControl = function (e) { const t = {}; if (e.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (e, n, r, i) => { const o = r || i; return t[n] = !o || o.toLowerCase(), ''; }), t['max-age']) { const n = parseInt(t['max-age'], 10); isNaN(n) ? delete t['max-age'] : t['max-age'] = n; } return t; }, e.default$11 = $a, e.default$12 = Ha, e.default$13 = ve, e.default$14 = _a, e.CollisionBoxArray = to, e.default$15 = po, e.TriangleIndexArray = Xi, e.default$16 = vi, e.default$17 = jn, e.keysDifference = function (e, t) { const n = []; for (const r in e)r in t || n.push(r); return n; }, e.default$18 = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'], e.mat4 = Co, e.vec4 = ko, e.getSizeData = an, e.evaluateSizeForFeature = function (e, t, n) { const r = t; return e.functionType === 'source' ? n.lowerSize / 10 : e.functionType === 'composite' ? M(n.lowerSize / 10, n.upperSize / 10, r.uSizeT) : r.uSize; }, e.evaluateSizeForZoom = function (e, t, n) { if (e.functionType === 'constant') return { uSizeT: 0, uSize: e.layoutSize }; if (e.functionType === 'source') return { uSizeT: 0, uSize: 0 }; if (e.functionType === 'camera') { const r = e.propertyValue; const i = e.zoomRange; const o = e.sizeRange; const a = s(ce(r, n.specification).interpolationFactor(t, i.min, i.max), 0, 1); return { uSizeT: 0, uSize: o.min + a * (o.max - o.min) }; } const l = e.propertyValue; const u = e.zoomRange; return { uSizeT: s(ce(l, n.specification).interpolationFactor(t, u.min, u.max), 0, 1), uSize: 0 }; }, e.addDynamicAttributes = ln, e.default$19 = xa, e.WritingMode = Ga, e.multiPolygonIntersectsBufferedPoint = et, e.multiPolygonIntersectsMultiPolygon = tt, e.multiPolygonIntersectsBufferedMultiLine = nt, e.polygonIntersectsPolygon = function (e, t) { for (let n = 0; n < e.length; n++) if (ut(t, e[n])) return !0; for (let r = 0; r < t.length; r++) if (ut(e, t[r])) return !0; return !!it(e, t); }, e.distToSegmentSquared = st, e.default$20 = To, e.default$21 = Mi, e.default$22 = function (e) { return new Ca[e.type](e); }, e.clone = h, e.filterObject = f, e.mapObject = p, e.registerForPluginAvailability = function (e) { return di ? e({ pluginURL: di, completionCallback: pi }) : gi.once('pluginAvailable', e), e; }, e.evented = gi, e.default$23 = ci, e.default$24 = yo, e.PosArray = zi, e.UnwrappedTileID = Ba, e.ease = Fn, e.bezier = a, e.setRTLTextPlugin = function (e, t) { if (hi) throw new Error('setRTLTextPlugin cannot be called multiple times.'); hi = !0, di = e, pi = function (e) { e ? (hi = !1, di = null, t && t(e)) : mi = !0; }, gi.fire(new $n('pluginAvailable', { pluginURL: di, completionCallback: pi })); }, e.values = function (e) { const t = []; for (const n in e)t.push(e[n]); return t; }, e.default$25 = da, e.register = Fe, e.GLYPH_PBF_BORDER = La, e.shapeText = function (e, t, n, r, i, o, a, s, l, u) {
          let c = e.trim(); u === Ga.vertical && (c = (function (e) { for (var t = '', n = 0; n < e.length; n++) { const r = e.charCodeAt(n + 1) || null; const i = e.charCodeAt(n - 1) || null; r && $e(r) && !ha[e[n + 1]] || i && $e(i) && !ha[e[n - 1]] || !ha[e[n]] ? t += e[n] : t += ha[e[n]]; } return t; }(c))); const p = []; const f = {
            positionedGlyphs: p, text: c, top: s[1], bottom: s[1], left: s[0], right: s[0], writingMode: u,
          }; const h = yi.processBidirectionalText; return (function (e, t, n, r, i, o, a, s, l) {
            for (var u = 0, c = -17, p = 0, f = e.positionedGlyphs, h = o === 'right' ? 1 : o === 'left' ? 0 : 0.5, d = 0, m = n; d < m.length; d += 1) {
              let g = m[d]; if ((g = g.trim()).length) {
                for (var y = f.length, v = 0; v < g.length; v++) {
                  const _ = g.charCodeAt(v); const b = t[_]; b && (We(_) && a !== Ga.horizontal ? (f.push({
                    glyph: _, x: u, y: 0, vertical: !0,
                  }), u += l + s) : (f.push({
                    glyph: _, x: u, y: c, vertical: !1,
                  }), u += b.metrics.advance + s));
                } if (f.length !== y) { const x = u - s; p = Math.max(x, p), Ln(f, t, y, f.length - 1, h); }u = 0, c += r;
              } else c += r;
            } const w = Dn(i); const E = w.horizontalAlign; const T = w.verticalAlign; !(function (e, t, n, r, i, o, a) { for (let s = (t - n) * i, l = (-r * a + 0.5) * o, u = 0; u < e.length; u++)e[u].x += s, e[u].y += l; }(f, h, E, T, p, r, n.length)); const k = n.length * r; e.top += -T * k, e.bottom = e.top + k, e.left += -E * p, e.right = e.left + p;
          }(f, t, h ? h(c, Nn(c, a, n, t)) : (function (e, t) { for (var n = [], r = 0, i = 0, o = t; i < o.length; i += 1) { const a = o[i]; n.push(e.substring(r, a)), r = a; } return r < e.length && n.push(e.substring(r, e.length)), n; }(c, Nn(c, a, n, t))), r, i, o, u, a, l)), !!p.length && f;
        }, e.shapeIcon = function (e, t, n) {
          const r = Dn(n); const i = r.horizontalAlign; const o = r.verticalAlign; const a = t[0]; const s = t[1]; const l = a - e.displaySize[0] * i; const u = l + e.displaySize[0]; const c = s - e.displaySize[1] * o; return {
            image: e, top: c, bottom: c + e.displaySize[1], left: l, right: u,
          };
        }, e.allowsVerticalWritingMode = qe, e.allowsLetterSpacing = function (e) { for (let t = 0, n = e; t < n.length; t += 1) if (!He(n[t].charCodeAt(0))) return !1; return !0; }, e.default$26 = Ht, e.default$27 = qa, e.default$28 = Ia, e.default$29 = Yo, e.default$30 = Na, e.default$31 = Va, e.__moduleExports = Yo, e.default$32 = Bn, e.__moduleExports$1 = Na, e.plugin = yi;
      }), e(['./chunk1.js'], (e) => {
        function t(e) { const n = typeof e; if (n === 'number' || n === 'boolean' || n === 'string' || e == null) return JSON.stringify(e); if (Array.isArray(e)) { for (var r = '[', i = 0, o = e; i < o.length; i += 1)r += `${t(o[i])},`; return `${r}]`; } for (var a = Object.keys(e).sort(), s = '{', l = 0; l < a.length; l++)s += `${JSON.stringify(a[l])}:${t(e[a[l]])},`; return `${s}}`; } function n(n) { for (var r = '', i = 0, o = e.default$18; i < o.length; i += 1)r += `/${t(n[o[i]])}`; return r; } function r(e, t, n, r, i) { if (void 0 === t.segment) return !0; for (var o = t, a = t.segment + 1, s = 0; s > -n / 2;) { if (--a < 0) return !1; s -= e[a].dist(o), o = e[a]; }s += e[a].dist(e[a + 1]), a++; for (let l = [], u = 0; s < n / 2;) { const c = e[a - 1]; const p = e[a]; const f = e[a + 1]; if (!f) return !1; let h = c.angleTo(p) - p.angleTo(f); for (h = Math.abs((h + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({ distance: s, angleDelta: h }), u += h; s - l[0].distance > r;)u -= l.shift().angleDelta; if (u > i) return !1; a++, s += p.dist(f); } return !0; } function i(t, n, i, o, a, s, l, u, c) { const p = o ? 0.6 * s * l : 0; const f = Math.max(o ? o.right - o.left : 0, a ? a.right - a.left : 0); const h = t[0].x === 0 || t[0].x === c || t[0].y === 0 || t[0].y === c; return n - f * l < n / 4 && (n = f * l + n / 4), (function t(n, i, o, a, s, l, u, c, p) { for (var f = l / 2, h = 0, d = 0; d < n.length - 1; d++)h += n[d].dist(n[d + 1]); for (var m = 0, g = i - o, y = [], v = 0; v < n.length - 1; v++) { for (var _ = n[v], b = n[v + 1], x = _.dist(b), w = b.angleTo(_); g + o < m + x;) { const E = ((g += o) - m) / x; const T = e.number(_.x, b.x, E); const k = e.number(_.y, b.y, E); if (T >= 0 && T < p && k >= 0 && k < p && g - f >= 0 && g + f <= h) { const C = new e.default$25(T, k, w, v); C._round(), a && !r(n, C, l, a, s) || y.push(C); } }m += x; } return c || y.length || u || (y = t(n, m / 2, o, a, s, l, u, !0, p)), y; }(t, h ? n / 2 * u % n : (f / 2 + 2 * s) * l * u % n, n, p, i, f * l, h, !1, c)); } function o(e, t) { if (!(this instanceof o)) return new o(e, t); if (this.data = e || [], this.length = this.data.length, this.compare = t || a, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n); } function a(e, t) { return e < t ? -1 : e > t ? 1 : 0; } function s(t, n, r) { void 0 === n && (n = 1), void 0 === r && (r = !1); for (var i = 1 / 0, o = 1 / 0, a = -1 / 0, s = -1 / 0, c = t[0], p = 0; p < c.length; p++) { const f = c[p]; (!p || f.x < i) && (i = f.x), (!p || f.y < o) && (o = f.y), (!p || f.x > a) && (a = f.x), (!p || f.y > s) && (s = f.y); } const h = a - i; const d = s - o; const m = Math.min(h, d); let g = m / 2; const y = new Te(null, l); if (m === 0) return new e.default$1(i, o); for (let v = i; v < a; v += m) for (let _ = o; _ < s; _ += m)y.push(new u(v + g, _ + g, g, t)); for (var b = (function (e) { for (var t = 0, n = 0, r = 0, i = e[0], o = 0, a = i.length, s = a - 1; o < a; s = o++) { const l = i[o]; const c = i[s]; const p = l.x * c.y - c.x * l.y; n += (l.x + c.x) * p, r += (l.y + c.y) * p, t += 3 * p; } return new u(n / t, r / t, 0, e); }(t)), x = y.length; y.length;) { const w = y.pop(); (w.d > b.d || !b.d) && (b = w, r && console.log('found best %d after %d probes', Math.round(1e4 * w.d) / 1e4, x)), w.max - b.d <= n || (g = w.h / 2, y.push(new u(w.p.x - g, w.p.y - g, g, t)), y.push(new u(w.p.x + g, w.p.y - g, g, t)), y.push(new u(w.p.x - g, w.p.y + g, g, t)), y.push(new u(w.p.x + g, w.p.y + g, g, t)), x += 4); } return r && (console.log(`num probes: ${x}`), console.log(`best distance: ${b.d}`)), b.p; } function l(e, t) { return t.max - e.max; } function u(t, n, r, i) { this.p = new e.default$1(t, n), this.h = r, this.d = (function (t, n) { for (var r = !1, i = 1 / 0, o = 0; o < n.length; o++) for (let a = n[o], s = 0, l = a.length, u = l - 1; s < l; u = s++) { const c = a[s]; const p = a[u]; c.y > t.y != p.y > t.y && t.x < (p.x - c.x) * (t.y - c.y) / (p.y - c.y) + c.x && (r = !r), i = Math.min(i, e.distToSegmentSquared(t, c, p)); } return (r ? 1 : -1) * Math.sqrt(i); }(this.p, i)), this.max = this.d + this.h * Math.SQRT2; } function c(t, n, r, i, o, a) { t.createArrays(), t.symbolInstances = []; const s = 512 * t.overscaling; t.tilePixelRatio = e.default$8 / s, t.compareText = {}, t.iconsNeedLinear = !1; const l = t.layers[0].layout; const u = t.layers[0]._unevaluatedLayout._values; const c = {}; if (t.textSizeData.functionType === 'composite') { const f = t.textSizeData.zoomRange; const h = f.min; const d = f.max; c.compositeTextSizes = [u['text-size'].possiblyEvaluate(new e.default$16(h)), u['text-size'].possiblyEvaluate(new e.default$16(d))]; } if (t.iconSizeData.functionType === 'composite') { const m = t.iconSizeData.zoomRange; const g = m.min; const y = m.max; c.compositeIconSizes = [u['icon-size'].possiblyEvaluate(new e.default$16(g)), u['icon-size'].possiblyEvaluate(new e.default$16(y))]; }c.layoutTextSize = u['text-size'].possiblyEvaluate(new e.default$16(t.zoom + 1)), c.layoutIconSize = u['icon-size'].possiblyEvaluate(new e.default$16(t.zoom + 1)), c.textMaxSize = u['text-size'].possiblyEvaluate(new e.default$16(18)); for (let v = 24 * l.get('text-line-height'), _ = l.get('text-rotation-alignment') === 'map' && l.get('symbol-placement') === 'line', b = l.get('text-keep-upright'), x = 0, w = t.features; x < w.length; x += 1) { const E = w[x]; const T = l.get('text-font').evaluate(E).join(','); const k = n[T] || {}; const C = r[T] || {}; const S = {}; const A = E.text; if (A) { const O = l.get('text-offset').evaluate(E).map(e => 24 * e); const I = 24 * l.get('text-letter-spacing').evaluate(E); const P = e.allowsLetterSpacing(A) ? I : 0; const M = l.get('text-anchor').evaluate(E); const N = l.get('text-justify').evaluate(E); const D = l.get('symbol-placement') !== 'line' ? 24 * l.get('text-max-width').evaluate(E) : 0; S.horizontal = e.shapeText(A, k, D, v, M, N, P, O, 24, e.WritingMode.horizontal), e.allowsVerticalWritingMode(A) && _ && b && (S.vertical = e.shapeText(A, k, D, v, M, N, P, O, 24, e.WritingMode.vertical)); } let L = void 0; if (E.icon) { const z = i[E.icon]; z && (L = e.shapeIcon(o[E.icon], l.get('icon-offset').evaluate(E), l.get('icon-anchor').evaluate(E)), void 0 === t.sdfIcons ? t.sdfIcons = z.sdf : t.sdfIcons !== z.sdf && e.warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer'), z.pixelRatio !== t.pixelRatio ? t.iconsNeedLinear = !0 : l.get('icon-rotate').constantOr(1) !== 0 && (t.iconsNeedLinear = !0)); }(S.horizontal || L) && p(t, E, S, L, C, c); }a && t.generateCollisionDebugBuffers(); } function p(t, n, r, o, a, l) {
          const u = l.layoutTextSize.evaluate(n); const c = l.layoutIconSize.evaluate(n); let p = l.textMaxSize.evaluate(n); void 0 === p && (p = u); const d = t.layers[0].layout; const m = d.get('text-offset').evaluate(n); const g = d.get('icon-offset').evaluate(n); const y = u / 24; const v = t.tilePixelRatio * y; const _ = t.tilePixelRatio * p / 24; const b = t.tilePixelRatio * c; const x = t.tilePixelRatio * d.get('symbol-spacing'); const w = d.get('text-padding') * t.tilePixelRatio; const E = d.get('icon-padding') * t.tilePixelRatio; const T = d.get('text-max-angle') / 180 * Math.PI; const k = d.get('text-rotation-alignment') === 'map' && d.get('symbol-placement') === 'line'; const C = d.get('icon-rotation-alignment') === 'map' && d.get('symbol-placement') === 'line'; const S = x / 2; const A = function (i, s) {
            s.x < 0 || s.x >= e.default$8 || s.y < 0 || s.y >= e.default$8 || t.symbolInstances.push(function (t, n, r, i, o, a, s, l, u, c, p, h, d, m, g, y, v, _, b, x, w) {
              let E; let T; const k = t.addToLineVertexArray(n, r); let C = 0; let S = 0; let A = 0; const O = i.horizontal ? i.horizontal.text : ''; const I = []; i.horizontal && (E = new Ee(s, r, n, l, u, c, i.horizontal, p, h, d, t.overscaling), S += f(t, n, i.horizontal, a, d, b, m, k, i.vertical ? e.WritingMode.horizontal : e.WritingMode.horizontalOnly, I, x, w), i.vertical && (A += f(t, n, i.vertical, a, d, b, m, k, e.WritingMode.vertical, I, x, w))); const P = E ? E.boxStartIndex : t.collisionBoxArray.length; const M = E ? E.boxEndIndex : t.collisionBoxArray.length; if (o) {
                const N = (function (t, n, r, i, o, a) {
                  let s; let l; let u; let c; const p = n.image; const f = r.layout; const h = n.top - 1 / p.pixelRatio; const d = n.left - 1 / p.pixelRatio; const m = n.bottom + 1 / p.pixelRatio; const g = n.right + 1 / p.pixelRatio; if (f.get('icon-text-fit') !== 'none' && o) { const y = g - d; const v = m - h; const _ = f.get('text-size').evaluate(a) / 24; const b = o.left * _; const x = o.right * _; const w = o.top * _; const E = x - b; const T = o.bottom * _ - w; const k = f.get('icon-text-fit-padding')[0]; const C = f.get('icon-text-fit-padding')[1]; const S = f.get('icon-text-fit-padding')[2]; const A = f.get('icon-text-fit-padding')[3]; const O = f.get('icon-text-fit') === 'width' ? 0.5 * (T - v) : 0; const I = f.get('icon-text-fit') === 'height' ? 0.5 * (E - y) : 0; const P = f.get('icon-text-fit') === 'width' || f.get('icon-text-fit') === 'both' ? E : y; const M = f.get('icon-text-fit') === 'height' || f.get('icon-text-fit') === 'both' ? T : v; s = new e.default$1(b + I - A, w + O - k), l = new e.default$1(b + I + C + P, w + O - k), u = new e.default$1(b + I + C + P, w + O + S + M), c = new e.default$1(b + I - A, w + O + S + M); } else s = new e.default$1(d, h), l = new e.default$1(g, h), u = new e.default$1(g, m), c = new e.default$1(d, m); const N = r.layout.get('icon-rotate').evaluate(a) * Math.PI / 180; if (N) { const D = Math.sin(N); const L = Math.cos(N); const z = [L, -D, D, L]; s._matMult(z), l._matMult(z), c._matMult(z), u._matMult(z); } return [{
                    tl: s, tr: l, bl: c, br: u, tex: p.paddedRect, writingMode: void 0, glyphOffset: [0, 0],
                  }];
                }(0, o, a, 0, i.horizontal, b)); T = new Ee(s, r, n, l, u, c, o, g, y, !1, t.overscaling), C = 4 * N.length; const D = t.iconSizeData; let L = null; D.functionType === 'source' ? L = [10 * a.layout.get('icon-size').evaluate(b)] : D.functionType === 'composite' && (L = [10 * w.compositeIconSizes[0].evaluate(b), 10 * w.compositeIconSizes[1].evaluate(b)]), t.addSymbols(t.icon, N, L, _, v, b, !1, n, k.lineStartIndex, k.lineLength);
              } const z = T ? T.boxStartIndex : t.collisionBoxArray.length; const R = T ? T.boxEndIndex : t.collisionBoxArray.length; return t.glyphOffsetArray.length >= e.default$14.MAX_GLYPHS && e.warnOnce('Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907'), {
                key: O, textBoxStartIndex: P, textBoxEndIndex: M, iconBoxStartIndex: z, iconBoxEndIndex: R, textOffset: m, iconOffset: _, anchor: n, line: r, featureIndex: l, feature: b, numGlyphVertices: S, numVerticalGlyphVertices: A, numIconVertices: C, textOpacityState: new we(), iconOpacityState: new we(), isDuplicate: !1, placedTextSymbolIndices: I, crossTileID: 0,
              };
            }(t, s, i, r, o, t.layers[0], t.collisionBoxArray, n.index, n.sourceLayerIndex, t.index, v, w, k, m, b, E, C, g, n, a, l));
          }; if (d.get('symbol-placement') === 'line') for (let O = 0, I = (function (t, n, r, i, o) { for (var a = [], s = 0; s < t.length; s++) for (let l = t[s], u = void 0, c = 0; c < l.length - 1; c++) { let p = l[c]; let f = l[c + 1]; p.x < 0 && f.x < 0 || (p.x < 0 ? p = new e.default$1(0, p.y + (f.y - p.y) * ((0 - p.x) / (f.x - p.x)))._round() : f.x < 0 && (f = new e.default$1(0, p.y + (f.y - p.y) * ((0 - p.x) / (f.x - p.x)))._round()), p.y < 0 && f.y < 0 || (p.y < 0 ? p = new e.default$1(p.x + (f.x - p.x) * ((0 - p.y) / (f.y - p.y)), 0)._round() : f.y < 0 && (f = new e.default$1(p.x + (f.x - p.x) * ((0 - p.y) / (f.y - p.y)), 0)._round()), p.x >= i && f.x >= i || (p.x >= i ? p = new e.default$1(i, p.y + (f.y - p.y) * ((i - p.x) / (f.x - p.x)))._round() : f.x >= i && (f = new e.default$1(i, p.y + (f.y - p.y) * ((i - p.x) / (f.x - p.x)))._round()), p.y >= o && f.y >= o || (p.y >= o ? p = new e.default$1(p.x + (f.x - p.x) * ((o - p.y) / (f.y - p.y)), o)._round() : f.y >= o && (f = new e.default$1(p.x + (f.x - p.x) * ((o - p.y) / (f.y - p.y)), o)._round()), u && p.equals(u[u.length - 1]) || (u = [p], a.push(u)), u.push(f))))); } return a; }(n.geometry, 0, 0, e.default$8, e.default$8)); O < I.length; O += 1) for (let P = I[O], M = 0, N = i(P, x, T, r.vertical || r.horizontal, o, 24, _, t.overscaling, e.default$8); M < N.length; M += 1) { const D = N[M]; const L = r.horizontal; L && h(t, L.text, S, D) || A(P, D); } else if (n.type === 'Polygon') for (let z = 0, R = e.default$26(n.geometry, 0); z < R.length; z += 1) { const j = R[z]; const B = s(j, 16); A(j[0], new e.default$25(B.x, B.y, 0)); } else if (n.type === 'LineString') for (let F = 0, U = n.geometry; F < U.length; F += 1) { const V = U[F]; A(V, new e.default$25(V[0].x, V[0].y, 0)); } else if (n.type === 'Point') for (let q = 0, H = n.geometry; q < H.length; q += 1) for (let W = 0, $ = H[q]; W < $.length; W += 1) { const G = $[W]; A([G], new e.default$25(G.x, G.y, 0)); }
        } function f(t, n, r, i, o, a, s, l, u, c, p, f) {
          const h = (function (t, n, r, i, o, a) {
            for (var s = r.layout.get('text-rotate').evaluate(o) * Math.PI / 180, l = r.layout.get('text-offset').evaluate(o).map(e => 24 * e), u = n.positionedGlyphs, c = [], p = 0; p < u.length; p++) {
              const f = u[p]; const h = a[f.glyph]; if (h) {
                const d = h.rect; if (d) {
                  const m = e.GLYPH_PBF_BORDER + 1; const g = h.metrics.advance / 2; const y = i ? [f.x + g, f.y] : [0, 0]; const v = i ? [0, 0] : [f.x + g + l[0], f.y + l[1]]; const _ = h.metrics.left - m - g + v[0]; const b = -h.metrics.top - m + v[1]; const x = _ + d.w; const w = b + d.h; const E = new e.default$1(_, b); const T = new e.default$1(x, b); const k = new e.default$1(_, w); const C = new e.default$1(x, w); if (i && f.vertical) { const S = new e.default$1(-g, g); const A = -Math.PI / 2; const O = new e.default$1(5, 0); E._rotateAround(A, S)._add(O), T._rotateAround(A, S)._add(O), k._rotateAround(A, S)._add(O), C._rotateAround(A, S)._add(O); } if (s) { const I = Math.sin(s); const P = Math.cos(s); const M = [P, -I, I, P]; E._matMult(M), T._matMult(M), k._matMult(M), C._matMult(M); }c.push({
                    tl: E, tr: T, bl: k, br: C, tex: d, writingMode: n.writingMode, glyphOffset: y,
                  });
                }
              }
            } return c;
          }(0, r, i, o, a, p)); const d = t.textSizeData; let m = null; return d.functionType === 'source' ? m = [10 * i.layout.get('text-size').evaluate(a)] : d.functionType === 'composite' && (m = [10 * f.compositeTextSizes[0].evaluate(a), 10 * f.compositeTextSizes[1].evaluate(a)]), t.addSymbols(t.text, h, m, s, o, a, u, n, l.lineStartIndex, l.lineLength), c.push(t.text.placedSymbolArray.length - 1), 4 * h.length;
        } function h(e, t, n, r) { const i = e.compareText; if (t in i) { for (let o = i[t], a = o.length - 1; a >= 0; a--) if (r.dist(o[a]) < n) return !0; } else i[t] = []; return i[t].push(r), !1; } function d(t, n) { for (let r = new e.default$16(n), i = 0, o = t; i < o.length; i += 1)o[i].recalculate(r); } function m(t, n) {
          const r = e.getArrayBuffer(t.request, (t, r) => {
            t ? n(t) : r && n(null, {
              vectorTile: new e.default$29.VectorTile(new e.default$30(r.data)), rawData: r.data, cacheControl: r.cacheControl, expires: r.expires,
            });
          }); return function () { r.abort(), n(); };
        } function g(e) { let t = 0; if (e && e.length > 0) { t += Math.abs(y(e[0])); for (let n = 1; n < e.length; n++)t -= Math.abs(y(e[n])); } return t; } function y(e) { let t; let n; let r; let i; let o; let a; let s = 0; const l = e.length; if (l > 2) { for (a = 0; a < l; a++)a === l - 2 ? (r = l - 2, i = l - 1, o = 0) : a === l - 1 ? (r = l - 1, i = 0, o = 1) : (r = a, i = a + 1, o = a + 2), t = e[r], n = e[i], s += (v(e[o][0]) - v(t[0])) * Math.sin(v(n[1])); s = s * Pe.RADIUS * Pe.RADIUS / 2; } return s; } function v(e) { return e * Math.PI / 180; } function _(e, t) { return function (n) { return e(n, t); }; } function b(e, t) { t = !!t, e[0] = x(e[0], t); for (let n = 1; n < e.length; n++)e[n] = x(e[n], !t); return e; } function x(e, t) { return (function (e) { return Me.ring(e) >= 0; }(e)) === t ? e : e.reverse(); } function w(e, t) { this.options = t || {}, this.features = e, this.length = e.length; } function E(e, t) { this.id = typeof e.id === 'number' ? e.id : void 0, this.type = e.type, this.rawGeometry = e.type === 1 ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096; } function T(t) { const n = new e.__moduleExports$1(); return (function (e, t) { for (const n in e.layers)t.writeMessage(3, k, e.layers[n]); }(t, n)), n.finish(); } function k(e, t) {
          let n; t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ''), t.writeVarintField(5, e.extent || 4096); const r = {
            keys: [], values: [], keycache: {}, valuecache: {},
          }; for (n = 0; n < e.length; n++)r.feature = e.feature(n), t.writeMessage(2, C, r); const i = r.keys; for (n = 0; n < i.length; n++)t.writeStringField(3, i[n]); const o = r.values; for (n = 0; n < o.length; n++)t.writeMessage(4, P, o[n]);
        } function C(e, t) { const n = e.feature; void 0 !== n.id && t.writeVarintField(1, n.id), t.writeMessage(2, S, e), t.writeVarintField(3, n.type), t.writeMessage(4, I, n); } function S(e, t) { const n = e.feature; const r = e.keys; const i = e.values; const o = e.keycache; const a = e.valuecache; for (const s in n.properties) { let l = o[s]; void 0 === l && (r.push(s), l = r.length - 1, o[s] = l), t.writeVarint(l); let u = n.properties[s]; const c = typeof u; c !== 'string' && c !== 'boolean' && c !== 'number' && (u = JSON.stringify(u)); const p = `${c}:${u}`; let f = a[p]; void 0 === f && (i.push(u), f = i.length - 1, a[p] = f), t.writeVarint(f); } } function A(e, t) { return (t << 3) + (7 & e); } function O(e) { return e << 1 ^ e >> 31; } function I(e, t) { for (let n = e.loadGeometry(), r = e.type, i = 0, o = 0, a = n.length, s = 0; s < a; s++) { const l = n[s]; let u = 1; r === 1 && (u = l.length), t.writeVarint(A(1, u)); for (let c = r === 3 ? l.length - 1 : l.length, p = 0; p < c; p++) { p === 1 && r !== 1 && t.writeVarint(A(2, c - 1)); const f = l[p].x - i; const h = l[p].y - o; t.writeVarint(O(f)), t.writeVarint(O(h)), i += f, o += h; }r === 3 && t.writeVarint(A(7, 0)); } } function P(e, t) { const n = typeof e; n === 'string' ? t.writeStringField(1, e) : n === 'boolean' ? t.writeBooleanField(7, e) : n === 'number' && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e)); } function M(e, t, n, r) { N(e, n, r), N(t, 2 * n, 2 * r), N(t, 2 * n + 1, 2 * r + 1); } function N(e, t, n) { const r = e[t]; e[t] = e[n], e[n] = r; } function D(e, t, n, r) { const i = e - n; const o = t - r; return i * i + o * o; } function L(e, t, n, r, i) { t = t || z, n = n || R, i = i || Array, this.nodeSize = r || 64, this.points = e, this.ids = new i(e.length), this.coords = new i(2 * e.length); for (let o = 0; o < e.length; o++) this.ids[o] = o, this.coords[2 * o] = t(e[o]), this.coords[2 * o + 1] = n(e[o]); qe(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0); } function z(e) { return e[0]; } function R(e) { return e[1]; } function j(e) { this.options = W(Object.create(this.options), e), this.trees = new Array(this.options.maxZoom + 1); } function B(e, t, n, r, i) {
          return {
            x: e, y: t, zoom: 1 / 0, id: r, properties: i, parentId: -1, numPoints: n,
          };
        } function F(e, t) {
          const n = e.geometry.coordinates; return {
            x: q(n[0]), y: H(n[1]), zoom: 1 / 0, id: t, parentId: -1,
          };
        } function U(e) { return { type: 'Feature', properties: V(e), geometry: { type: 'Point', coordinates: [360 * (e.x - 0.5), (t = e.y, n = (180 - 360 * t) * Math.PI / 180, 360 * Math.atan(Math.exp(n)) / Math.PI - 90)] } }; let t; let n; } function V(e) {
          const t = e.numPoints; const n = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? `${Math.round(t / 100) / 10}k` : t; return W(W({}, e.properties), {
            cluster: !0, cluster_id: e.id, point_count: t, point_count_abbreviated: n,
          });
        } function q(e) { return e / 360 + 0.5; } function H(e) { const t = Math.sin(e * Math.PI / 180); const n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI; return n < 0 ? 0 : n > 1 ? 1 : n; } function W(e, t) { for (const n in t)e[n] = t[n]; return e; } function $(e) { return e.x; } function G(e) { return e.y; } function Z(e, t, n, r, i, o) { let a = i - n; let s = o - r; if (a !== 0 || s !== 0) { const l = ((e - n) * a + (t - r) * s) / (a * a + s * s); l > 1 ? (n = i, r = o) : l > 0 && (n += a * l, r += s * l); } return (a = e - n) * a + (s = t - r) * s; } function K(e, t, n, r) {
          const i = {
            id: e || null, type: t, geometry: n, tags: r, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0,
          }; return (function (e) { const t = e.geometry; const n = e.type; if (n === 'Point' || n === 'MultiPoint' || n === 'LineString')X(e, t); else if (n === 'Polygon' || n === 'MultiLineString') for (var r = 0; r < t.length; r++)X(e, t[r]); else if (n === 'MultiPolygon') for (r = 0; r < t.length; r++) for (let i = 0; i < t[r].length; i++)X(e, t[r][i]); }(i)), i;
        } function X(e, t) { for (let n = 0; n < t.length; n += 3)e.minX = Math.min(e.minX, t[n]), e.minY = Math.min(e.minY, t[n + 1]), e.maxX = Math.max(e.maxX, t[n]), e.maxY = Math.max(e.maxY, t[n + 1]); } function Y(e, t, n) { if (t.geometry) { const r = t.geometry.coordinates; const i = t.geometry.type; const o = Math.pow(n.tolerance / ((1 << n.maxZoom) * n.extent), 2); let a = []; if (i === 'Point')J(r, a); else if (i === 'MultiPoint') for (var s = 0; s < r.length; s++)J(r[s], a); else if (i === 'LineString')Q(r, a, o, !1); else if (i === 'MultiLineString') if (n.lineMetrics) for (s = 0; s < r.length; s++) return a = [], Q(r[s], a, o, !1), void e.push(K(t.id, 'LineString', a, t.properties)); else ee(r, a, o, !1); else if (i === 'Polygon')ee(r, a, o, !0); else { if (i !== 'MultiPolygon') { if (i === 'GeometryCollection') { for (s = 0; s < t.geometry.geometries.length; s++)Y(e, { id: t.id, geometry: t.geometry.geometries[s], properties: t.properties }, n); return; } throw new Error('Input data is not a valid GeoJSON object.'); } for (s = 0; s < r.length; s++) { const l = []; ee(r[s], l, o, !0), a.push(l); } }e.push(K(t.id, i, a, t.properties)); } } function J(e, t) { t.push(te(e[0])), t.push(ne(e[1])), t.push(0); } function Q(e, t, n, r) { for (var i, o, a = 0, s = 0; s < e.length; s++) { const l = te(e[s][0]); const u = ne(e[s][1]); t.push(l), t.push(u), t.push(0), s > 0 && (a += r ? (i * u - l * o) / 2 : Math.sqrt(Math.pow(l - i, 2) + Math.pow(u - o, 2))), i = l, o = u; } const c = t.length - 3; t[2] = 1, (function e(t, n, r, i) { for (var o, a = i, s = t[n], l = t[n + 1], u = t[r], c = t[r + 1], p = n + 3; p < r; p += 3) { const f = Z(t[p], t[p + 1], s, l, u, c); f > a && (o = p, a = f); }a > i && (o - n > 3 && e(t, n, o, i), t[o + 2] = a, r - o > 3 && e(t, o, r, i)); }(t, 0, c, n)), t[c + 2] = 1, t.size = Math.abs(a), t.start = 0, t.end = t.size; } function ee(e, t, n, r) { for (let i = 0; i < e.length; i++) { const o = []; Q(e[i], o, n, r), t.push(o); } } function te(e) { return e / 360 + 0.5; } function ne(e) { const t = Math.sin(e * Math.PI / 180); const n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI; return n < 0 ? 0 : n > 1 ? 1 : n; } function re(e, t, n, r, i, o, a, s) { if (r /= t, o >= (n /= t) && a <= r) return e; if (o > r || a < n) return null; for (var l = [], u = 0; u < e.length; u++) { const c = e[u]; const p = c.geometry; let f = c.type; const h = i === 0 ? c.minX : c.minY; const d = i === 0 ? c.maxX : c.maxY; if (h >= n && d <= r)l.push(c); else if (!(h > r || d < n)) { let m = []; if (f === 'Point' || f === 'MultiPoint')ie(p, m, n, r, i); else if (f === 'LineString')oe(p, m, n, r, i, !1, s.lineMetrics); else if (f === 'MultiLineString')se(p, m, n, r, i, !1); else if (f === 'Polygon')se(p, m, n, r, i, !0); else if (f === 'MultiPolygon') for (var g = 0; g < p.length; g++) { const y = []; se(p[g], y, n, r, i, !0), y.length && m.push(y); } if (m.length) { if (s.lineMetrics && f === 'LineString') { for (g = 0; g < m.length; g++)l.push(K(c.id, f, m[g], c.tags)); continue; }f !== 'LineString' && f !== 'MultiLineString' || (m.length === 1 ? (f = 'LineString', m = m[0]) : f = 'MultiLineString'), f !== 'Point' && f !== 'MultiPoint' || (f = m.length === 3 ? 'Point' : 'MultiPoint'), l.push(K(c.id, f, m, c.tags)); } } } return l.length ? l : null; } function ie(e, t, n, r, i) { for (let o = 0; o < e.length; o += 3) { const a = e[o + i]; a >= n && a <= r && (t.push(e[o]), t.push(e[o + 1]), t.push(e[o + 2])); } } function oe(e, t, n, r, i, o, a) { for (var s, l, u = ae(e), c = i === 0 ? ue : ce, p = e.start, f = 0; f < e.length - 3; f += 3) { var h = e[f]; var d = e[f + 1]; var m = e[f + 2]; const g = e[f + 3]; const y = e[f + 4]; var v = i === 0 ? h : d; const _ = i === 0 ? g : y; let b = !1; a && (s = Math.sqrt(Math.pow(h - g, 2) + Math.pow(d - y, 2))), v < n ? _ >= n && (l = c(u, h, d, g, y, n), a && (u.start = p + s * l)) : v > r ? _ <= r && (l = c(u, h, d, g, y, r), a && (u.start = p + s * l)) : le(u, h, d, m), _ < n && v >= n && (l = c(u, h, d, g, y, n), b = !0), _ > r && v <= r && (l = c(u, h, d, g, y, r), b = !0), !o && b && (a && (u.end = p + s * l), t.push(u), u = ae(e)), a && (p += s); } let x = e.length - 3; h = e[x], d = e[x + 1], m = e[x + 2], (v = i === 0 ? h : d) >= n && v <= r && le(u, h, d, m), x = u.length - 3, o && x >= 3 && (u[x] !== u[0] || u[x + 1] !== u[1]) && le(u, u[0], u[1], u[2]), u.length && t.push(u); } function ae(e) { const t = []; return t.size = e.size, t.start = e.start, t.end = e.end, t; } function se(e, t, n, r, i, o) { for (let a = 0; a < e.length; a++)oe(e[a], t, n, r, i, o, !1); } function le(e, t, n, r) { e.push(t), e.push(n), e.push(r); } function ue(e, t, n, r, i, o) { const a = (o - t) / (r - t); return e.push(o), e.push(n + (i - n) * a), e.push(1), a; } function ce(e, t, n, r, i, o) { const a = (o - n) / (i - n); return e.push(t + (r - t) * a), e.push(o), e.push(1), a; } function pe(e, t) { for (var n = [], r = 0; r < e.length; r++) { var i; const o = e[r]; const a = o.type; if (a === 'Point' || a === 'MultiPoint' || a === 'LineString')i = fe(o.geometry, t); else if (a === 'MultiLineString' || a === 'Polygon') { i = []; for (var s = 0; s < o.geometry.length; s++)i.push(fe(o.geometry[s], t)); } else if (a === 'MultiPolygon') for (i = [], s = 0; s < o.geometry.length; s++) { for (var l = [], u = 0; u < o.geometry[s].length; u++)l.push(fe(o.geometry[s][u], t)); i.push(l); }n.push(K(o.id, a, i, o.tags)); } return n; } function fe(e, t) { const n = []; n.size = e.size, void 0 !== e.start && (n.start = e.start, n.end = e.end); for (let r = 0; r < e.length; r += 3)n.push(e[r] + t, e[r + 1], e[r + 2]); return n; } function he(e, t) { if (e.transformed) return e; let n; let r; let i; const o = 1 << e.z; const a = e.x; const s = e.y; for (n = 0; n < e.features.length; n++) { const l = e.features[n]; const u = l.geometry; const c = l.type; if (l.geometry = [], c === 1) for (r = 0; r < u.length; r += 2)l.geometry.push(de(u[r], u[r + 1], t, o, a, s)); else for (r = 0; r < u.length; r++) { const p = []; for (i = 0; i < u[r].length; i += 2)p.push(de(u[r][i], u[r][i + 1], t, o, a, s)); l.geometry.push(p); } } return e.transformed = !0, e; } function de(e, t, n, r, i, o) { return [Math.round(n * (e * r - i)), Math.round(n * (t * r - o))]; } function me(e, t, n, r, i) {
          for (var o = t === i.maxZoom ? 0 : i.tolerance / ((1 << t) * i.extent), a = {
              features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: n, y: r, z: t, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0,
            }, s = 0; s < e.length; s++) { a.numFeatures++, ge(a, e[s], o, i); const l = e[s].minX; const u = e[s].minY; const c = e[s].maxX; const p = e[s].maxY; l < a.minX && (a.minX = l), u < a.minY && (a.minY = u), c > a.maxX && (a.maxX = c), p > a.maxY && (a.maxY = p); } return a;
        } function ge(e, t, n, r) { const i = t.geometry; const o = t.type; const a = []; if (o === 'Point' || o === 'MultiPoint') for (var s = 0; s < i.length; s += 3)a.push(i[s]), a.push(i[s + 1]), e.numPoints++, e.numSimplified++; else if (o === 'LineString')ye(a, i, e, n, !1, !1); else if (o === 'MultiLineString' || o === 'Polygon') for (s = 0; s < i.length; s++)ye(a, i[s], e, n, o === 'Polygon', s === 0); else if (o === 'MultiPolygon') for (let l = 0; l < i.length; l++) { const u = i[l]; for (s = 0; s < u.length; s++)ye(a, u[s], e, n, !0, s === 0); } if (a.length) { let c = t.tags || null; if (o === 'LineString' && r.lineMetrics) { for (const p in c = {}, t.tags)c[p] = t.tags[p]; c.mapbox_clip_start = i.start / i.size, c.mapbox_clip_end = i.end / i.size; } const f = { geometry: a, type: o === 'Polygon' || o === 'MultiPolygon' ? 3 : o === 'LineString' || o === 'MultiLineString' ? 2 : 1, tags: c }; t.id !== null && (f.id = t.id), e.features.push(f); } } function ye(e, t, n, r, i, o) { const a = r * r; if (r > 0 && t.size < (i ? a : r))n.numPoints += t.length / 3; else { for (var s = [], l = 0; l < t.length; l += 3)(r === 0 || t[l + 2] > a) && (n.numSimplified++, s.push(t[l]), s.push(t[l + 1])), n.numPoints++; i && (function (e, t) { for (var n = 0, r = 0, i = e.length, o = i - 2; r < i; o = r, r += 2)n += (e[r] - e[o]) * (e[r + 1] + e[o + 1]); if (n > 0 === t) for (r = 0, i = e.length; r < i / 2; r += 2) { const a = e[r]; const s = e[r + 1]; e[r] = e[i - 2 - r], e[r + 1] = e[i - 1 - r], e[i - 2 - r] = a, e[i - 1 - r] = s; } }(s, o)), e.push(s); } } function ve(e, t) { const n = (t = this.options = (function (e, t) { for (const n in t)e[n] = t[n]; return e; }(Object.create(this.options), t))).debug; if (n && console.time('preprocess data'), t.maxZoom < 0 || t.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range'); let r = (function (e, t) { const n = []; if (e.type === 'FeatureCollection') for (let r = 0; r < e.features.length; r++)Y(n, e.features[r], t); else e.type === 'Feature' ? Y(n, e, t) : Y(n, { geometry: e }, t); return n; }(e, t)); this.tiles = {}, this.tileCoords = [], n && (console.timeEnd('preprocess data'), console.log('index: maxZoom: %d, maxPoints: %d', t.indexMaxZoom, t.indexMaxPoints), console.time('generate tiles'), this.stats = {}, this.total = 0), (r = (function (e, t) { const n = t.buffer / t.extent; let r = e; const i = re(e, 1, -1 - n, n, 0, -1, 2, t); const o = re(e, 1, 1 - n, 2 + n, 0, -1, 2, t); return (i || o) && (r = re(e, 1, -n, 1 + n, 0, -1, 2, t) || [], i && (r = pe(i, 1).concat(r)), o && (r = r.concat(pe(o, -1)))), r; }(r, t))).length && this.splitTile(r, 0, 0, 0), n && (r.length && console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd('generate tiles'), console.log('tiles generated:', this.total, JSON.stringify(this.stats))); } function _e(e, t, n) { return 32 * ((1 << e) * n + t) + e; } function be(e, t) { const n = e.tileID.canonical; if (!this._geoJSONIndex) return t(null, null); const r = this._geoJSONIndex.getTile(n.z, n.x, n.y); if (!r) return t(null, null); const i = new ze(r.features); let o = Be(i); o.byteOffset === 0 && o.byteLength === o.buffer.byteLength || (o = new Uint8Array(o)), t(null, { vectorTile: i, rawData: o.buffer }); } const xe = function (e) { e && this.replace(e); }; xe.prototype.replace = function (e) { this._layerConfigs = {}, this._layers = {}, this.update(e, []); }, xe.prototype.update = function (t, r) { for (var i = this, o = 0, a = t; o < a.length; o += 1) { const s = a[o]; i._layerConfigs[s.id] = s; const l = i._layers[s.id] = e.default$22(s); l._featureFilter = e.default$13(l.filter); } for (let u = 0, c = r; u < c.length; u += 1) { const p = c[u]; delete i._layerConfigs[p], delete i._layers[p]; } this.familiesBySource = {}; for (let f = 0, h = (function (e) { for (var t = {}, r = 0; r < e.length; r++) { const i = n(e[r]); let o = t[i]; o || (o = t[i] = []), o.push(e[r]); } const a = []; for (const s in t)a.push(t[s]); return a; }(e.values(this._layerConfigs))); f < h.length; f += 1) { const d = h[f].map(e => i._layers[e.id]); const m = d[0]; if (m.visibility !== 'none') { const g = m.source || ''; let y = i.familiesBySource[g]; y || (y = i.familiesBySource[g] = {}); const v = m.sourceLayer || '_geojsonTileLayer'; let _ = y[v]; _ || (_ = y[v] = []), _.push(d); } } }; var we = function () { this.opacity = 0, this.targetOpacity = 0, this.time = 0; }; we.prototype.clone = function () { const e = new we(); return e.opacity = this.opacity, e.targetOpacity = this.targetOpacity, e.time = this.time, e; }, e.register('OpacityState', we); var Ee = function (e, t, n, r, i, o, a, s, l, u, c) { const p = a.top * s - l; const f = a.bottom * s + l; const h = a.left * s - l; const d = a.right * s + l; if (this.boxStartIndex = e.length, u) { let m = f - p; const g = d - h; m > 0 && (m = Math.max(10 * s, m), this._addLineCollisionCircles(e, t, n, n.segment, g, m, r, i, o, c)); } else e.emplaceBack(n.x, n.y, h, p, d, f, r, i, o, 0, 0); this.boxEndIndex = e.length; }; Ee.prototype._addLineCollisionCircles = function (e, t, n, r, i, o, a, s, l, u) {
          const c = o / 2; const p = Math.floor(i / c); const f = 1 + 0.4 * Math.log(u) / Math.LN2; const h = Math.floor(p * f / 2); const d = -o / 2; let m = n; let g = r + 1; let y = d; const v = -i / 2; const _ = v - i / 4; do { if (--g < 0) { if (y > v) return; g = 0; break; }y -= t[g].dist(m), m = t[g]; } while (y > _);for (let b = t[g].dist(t[g + 1]), x = -h; x < p + h; x++) {
            const w = x * c; let E = v + w; if (w < 0 && (E += w), w > i && (E += w - i), !(E < y)) {
              for (;y + b < E;) { if (y += b, ++g + 1 >= t.length) return; b = t[g].dist(t[g + 1]); } const T = E - y; const k = t[g]; const C = t[g + 1].sub(k)._unit()._mult(T)._add(k)
                ._round(); const S = Math.abs(E - d) < c ? 0 : 0.8 * (E - d); e.emplaceBack(C.x, C.y, -o / 2, -o / 2, o / 2, o / 2, a, s, l, o / 2, S);
            }
          }
        }; var Te = o; const ke = o; o.prototype = {
          push(e) { this.data.push(e), this.length++, this._up(this.length - 1); }, pop() { if (this.length !== 0) { const e = this.data[0]; return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), e; } }, peek() { return this.data[0]; }, _up(e) { for (var t = this.data, n = this.compare, r = t[e]; e > 0;) { const i = e - 1 >> 1; const o = t[i]; if (n(r, o) >= 0) break; t[e] = o, e = i; }t[e] = r; }, _down(e) { for (var t = this.data, n = this.compare, r = this.length >> 1, i = t[e]; e < r;) { let o = 1 + (e << 1); const a = o + 1; let s = t[o]; if (a < this.length && n(t[a], s) < 0 && (o = a, s = t[a]), n(s, i) >= 0) break; t[e] = s, e = o; }t[e] = i; },
        }, Te.default = ke; const Ce = function (t) { const n = new e.AlphaImage({ width: 0, height: 0 }); const r = {}; const i = new e.default$2(0, 0, { autoResize: !0 }); for (const o in t) { const a = t[o]; const s = r[o] = {}; for (const l in a) { const u = a[+l]; if (u && u.bitmap.width !== 0 && u.bitmap.height !== 0) { const c = i.packOne(u.bitmap.width + 2, u.bitmap.height + 2); n.resize({ width: i.w, height: i.h }), e.AlphaImage.copy(u.bitmap, n, { x: 0, y: 0 }, { x: c.x + 1, y: c.y + 1 }, u.bitmap), s[l] = { rect: c, metrics: u.metrics }; } } }i.shrink(), n.resize({ width: i.w, height: i.h }), this.image = n, this.positions = r; }; e.register('GlyphAtlas', Ce); const Se = function (t) { this.tileID = new e.OverscaledTileID(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming; }; Se.prototype.parse = function (t, n, r, i) {
          function o() {
            if (u) return i(u); if (p && f) {
              const t = new Ce(p); const n = new e.default$28(f); for (const r in h) { const o = h[r]; o instanceof e.default$14 && (d(o.layers, this.zoom), c(o, p, t.positions, f, n.positions, this.showCollisionBoxes)); } this.status = 'done', i(null, {
                buckets: e.values(h).filter(e => !e.isEmpty()), featureIndex: l, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t.image, iconAtlasImage: n.image,
              });
            }
          } const a = this; this.status = 'parsing', this.data = t, this.collisionBoxArray = new e.CollisionBoxArray(); const s = new e.default$27(Object.keys(t.layers).sort()); var l = new e.default$11(this.tileID); l.bucketLayerIDs = []; let u; let p; let f; var h = {}; const m = { featureIndex: l, iconDependencies: {}, glyphDependencies: {} }; const g = n.familiesBySource[this.source]; for (const y in g) {
            const v = t.layers[y]; if (v) {
              v.version === 1 && e.warnOnce(`Vector tile source "${a.source}" layer "${y}" does not use vector tile spec v2 and therefore may have some rendering errors.`); for (var _ = s.encode(y), b = [], x = 0; x < v.length; x++) { const w = v.feature(x); b.push({ feature: w, index: x, sourceLayerIndex: _ }); } for (let E = 0, T = g[y]; E < T.length; E += 1) {
                const k = T[E]; const C = k[0]; C.minzoom && a.zoom < Math.floor(C.minzoom) || C.maxzoom && a.zoom >= C.maxzoom || C.visibility !== 'none' && (d(k, a.zoom), (h[C.id] = C.createBucket({
                  index: l.bucketLayerIDs.length, layers: k, zoom: a.zoom, pixelRatio: a.pixelRatio, overscaling: a.overscaling, collisionBoxArray: a.collisionBoxArray, sourceLayerIndex: _,
                })).populate(b, m), l.bucketLayerIDs.push(k.map(e => e.id)));
              }
            }
          } const S = e.mapObject(m.glyphDependencies, e => Object.keys(e).map(Number)); Object.keys(S).length ? r.send('getGlyphs', { uid: this.uid, stacks: S }, (e, t) => { u || (u = e, p = t, o.call(a)); }) : p = {}; const A = Object.keys(m.iconDependencies); A.length ? r.send('getImages', { icons: A }, (e, t) => { u || (u = e, f = t, o.call(a)); }) : f = {}, o.call(this);
        }; const Ae = function (e) { return !(!performance || !performance.getEntriesByName) && performance.getEntriesByName(e); }; const Oe = function (e, t, n) { this.actor = e, this.layerIndex = t, this.loadVectorData = n || m, this.loading = {}, this.loaded = {}; }; Oe.prototype.loadTile = function (t, n) { const r = this; const i = t.uid; this.loading || (this.loading = {}); const o = this.loading[i] = new Se(t); o.abort = this.loadVectorData(t, (a, s) => { if (delete r.loading[i], a || !s) return n(a); const l = s.rawData; const u = {}; s.expires && (u.expires = s.expires), s.cacheControl && (u.cacheControl = s.cacheControl); const c = {}; if (t.request && t.request.collectResourceTiming) { const p = Ae(t.request.url); p && (c.resourceTiming = JSON.parse(JSON.stringify(p))); }o.vectorTile = s.vectorTile, o.parse(s.vectorTile, r.layerIndex, r.actor, (t, r) => { if (t || !r) return n(t); n(null, e.extend({ rawTileData: l.slice(0) }, r, u, c)); }), r.loaded = r.loaded || {}, r.loaded[i] = o; }); }, Oe.prototype.reloadTile = function (e, t) { const n = this.loaded; const r = e.uid; const i = this; if (n && n[r]) { const o = n[r]; o.showCollisionBoxes = e.showCollisionBoxes; const a = function (e, n) { const r = o.reloadCallback; r && (delete o.reloadCallback, o.parse(o.vectorTile, i.layerIndex, i.actor, r)), t(e, n); }; o.status === 'parsing' ? o.reloadCallback = a : o.status === 'done' && o.parse(o.vectorTile, this.layerIndex, this.actor, a); } }, Oe.prototype.abortTile = function (e, t) { const n = this.loading; const r = e.uid; n && n[r] && n[r].abort && (n[r].abort(), delete n[r]), t(); }, Oe.prototype.removeTile = function (e, t) { const n = this.loaded; const r = e.uid; n && n[r] && delete n[r], t(); }; const Ie = function () { this.loading = {}, this.loaded = {}; }; Ie.prototype.loadTile = function (t, n) { const r = t.uid; const i = t.encoding; const o = new e.default$31(r); this.loading[r] = o, o.loadFromImage(t.rawImageData, i), delete this.loading[r], this.loaded = this.loaded || {}, this.loaded[r] = o, n(null, o); }, Ie.prototype.removeTile = function (e) { const t = this.loaded; const n = e.uid; t && t[n] && delete t[n]; }; var Pe = { RADIUS: 6378137, FLATTENING: 1 / 298.257223563, POLAR_RADIUS: 6356752.3142 }; var Me = { geometry: function e(t) { let n; let r = 0; switch (t.type) { case 'Polygon': return g(t.coordinates); case 'MultiPolygon': for (n = 0; n < t.coordinates.length; n++)r += g(t.coordinates[n]); return r; case 'Point': case 'MultiPoint': case 'LineString': case 'MultiLineString': return 0; case 'GeometryCollection': for (n = 0; n < t.geometries.length; n++)r += e(t.geometries[n]); return r; } }, ring: y }; const Ne = function e(t, n) { switch (t && t.type || null) { case 'FeatureCollection': return t.features = t.features.map(_(e, n)), t; case 'Feature': return t.geometry = e(t.geometry, n), t; case 'Polygon': case 'MultiPolygon': return (function (e, t) { return e.type === 'Polygon' ? e.coordinates = b(e.coordinates, t) : e.type === 'MultiPolygon' && (e.coordinates = e.coordinates.map(_(b, t))), e; }(t, n)); default: return t; } }; const De = e.default$29.VectorTileFeature.prototype.toGeoJSON; const Le = function (t) { this._feature = t, this.extent = e.default$8, this.type = t.type, this.properties = t.tags, 'id' in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10)); }; Le.prototype.loadGeometry = function () { if (this._feature.type === 1) { for (var t = [], n = 0, r = this._feature.geometry; n < r.length; n += 1) { const i = r[n]; t.push([new e.default$1(i[0], i[1])]); } return t; } for (var o = [], a = 0, s = this._feature.geometry; a < s.length; a += 1) { for (var l = [], u = 0, c = s[a]; u < c.length; u += 1) { const p = c[u]; l.push(new e.default$1(p[0], p[1])); }o.push(l); } return o; }, Le.prototype.toGeoJSON = function (e, t, n) { return De.call(this, e, t, n); }; var ze = function (t) { this.layers = { _geojsonTileLayer: this }, this.name = '_geojsonTileLayer', this.extent = e.default$8, this.length = t.length, this._features = t; }; ze.prototype.feature = function (e) { return new Le(this._features[e]); }; const Re = e.__moduleExports.VectorTileFeature; const je = w; w.prototype.feature = function (e) { return new E(this.features[e], this.options.extent); }, E.prototype.loadGeometry = function () { const t = this.rawGeometry; this.geometry = []; for (let n = 0; n < t.length; n++) { for (var r = t[n], i = [], o = 0; o < r.length; o++)i.push(new e.default$32(r[o][0], r[o][1])); this.geometry.push(i); } return this.geometry; }, E.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var e = this.geometry, t = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0, o = 0; o < e.length; o++) for (let a = e[o], s = 0; s < a.length; s++) { const l = a[s]; t = Math.min(t, l.x), n = Math.max(n, l.x), r = Math.min(r, l.y), i = Math.max(i, l.y); } return [t, r, n, i]; }, E.prototype.toGeoJSON = Re.prototype.toGeoJSON; var Be = T; const Fe = T; const Ue = function (e, t) { t = t || {}; const n = {}; for (const r in e)n[r] = new je(e[r].features, t), n[r].name = r, n[r].version = t.version, n[r].extent = t.extent; return T({ layers: n }); }; const Ve = je; Be.fromVectorTileJs = Fe, Be.fromGeojsonVt = Ue, Be.GeoJSONWrapper = Ve; var qe = function e(t, n, r, i, o, a) { if (!(o - i <= r)) { const s = Math.floor((i + o) / 2); !(function e(t, n, r, i, o, a) { for (;o > i;) { if (o - i > 600) { const s = o - i + 1; const l = r - i + 1; const u = Math.log(s); const c = 0.5 * Math.exp(2 * u / 3); const p = 0.5 * Math.sqrt(u * c * (s - c) / s) * (l - s / 2 < 0 ? -1 : 1); e(t, n, r, Math.max(i, Math.floor(r - l * c / s + p)), Math.min(o, Math.floor(r + (s - l) * c / s + p)), a); } const f = n[2 * r + a]; let h = i; let d = o; for (M(t, n, i, r), n[2 * o + a] > f && M(t, n, i, o); h < d;) { for (M(t, n, h, d), h++, d--; n[2 * h + a] < f;)h++; for (;n[2 * d + a] > f;)d--; }n[2 * i + a] === f ? M(t, n, i, d) : M(t, n, ++d, o), d <= r && (i = d + 1), r <= d && (o = d - 1); } }(t, n, s, i, o, a % 2)), e(t, n, r, i, s - 1, a + 1), e(t, n, r, s + 1, o, a + 1); } }; const He = function (e, t, n, r, i, o, a) { for (var s, l, u = [0, e.length - 1, 0], c = []; u.length;) { const p = u.pop(); const f = u.pop(); const h = u.pop(); if (f - h <= a) for (let d = h; d <= f; d++)s = t[2 * d], l = t[2 * d + 1], s >= n && s <= i && l >= r && l <= o && c.push(e[d]); else { const m = Math.floor((h + f) / 2); s = t[2 * m], l = t[2 * m + 1], s >= n && s <= i && l >= r && l <= o && c.push(e[m]); const g = (p + 1) % 2; (p === 0 ? n <= s : r <= l) && (u.push(h), u.push(m - 1), u.push(g)), (p === 0 ? i >= s : o >= l) && (u.push(m + 1), u.push(f), u.push(g)); } } return c; }; const We = function (e, t, n, r, i, o) { for (var a = [0, e.length - 1, 0], s = [], l = i * i; a.length;) { const u = a.pop(); const c = a.pop(); const p = a.pop(); if (c - p <= o) for (let f = p; f <= c; f++)D(t[2 * f], t[2 * f + 1], n, r) <= l && s.push(e[f]); else { const h = Math.floor((p + c) / 2); const d = t[2 * h]; const m = t[2 * h + 1]; D(d, m, n, r) <= l && s.push(e[h]); const g = (u + 1) % 2; (u === 0 ? n - i <= d : r - i <= m) && (a.push(p), a.push(h - 1), a.push(g)), (u === 0 ? n + i >= d : r + i >= m) && (a.push(h + 1), a.push(c), a.push(g)); } } return s; }; const $e = function (e, t, n, r, i) { return new L(e, t, n, r, i); }; L.prototype = { range(e, t, n, r) { return He(this.ids, this.coords, e, t, n, r, this.nodeSize); }, within(e, t, n) { return We(this.ids, this.coords, e, t, n, this.nodeSize); } }; const Ge = function (e) { return new j(e); }; j.prototype = {
          options: {
            minZoom: 0, maxZoom: 16, radius: 40, extent: 512, nodeSize: 64, log: !1, reduce: null, initial() { return {}; }, map(e) { return e; },
          },
          load(e) { const t = this.options.log; t && console.time('total time'); const n = `prepare ${e.length} points`; t && console.time(n), this.points = e; let r = e.map(F); t && console.timeEnd(n); for (let i = this.options.maxZoom; i >= this.options.minZoom; i--) { const o = +Date.now(); this.trees[i + 1] = $e(r, $, G, this.options.nodeSize, Float32Array), r = this._cluster(r, i), t && console.log('z%d: %d clusters in %dms', i, r.length, +Date.now() - o); } return this.trees[this.options.minZoom] = $e(r, $, G, this.options.nodeSize, Float32Array), t && console.timeEnd('total time'), this; },
          getClusters(e, t) { for (var n = this.trees[this._limitZoom(t)], r = n.range(q(e[0]), H(e[3]), q(e[2]), H(e[1])), i = [], o = 0; o < r.length; o++) { const a = n.points[r[o]]; i.push(a.numPoints ? U(a) : this.points[a.id]); } return i; },
          getChildren(e, t) { for (var n = this.trees[t + 1].points[e], r = this.options.radius / (this.options.extent * Math.pow(2, t)), i = this.trees[t + 1].within(n.x, n.y, r), o = [], a = 0; a < i.length; a++) { const s = this.trees[t + 1].points[i[a]]; s.parentId === e && o.push(s.numPoints ? U(s) : this.points[s.id]); } return o; },
          getLeaves(e, t, n, r) { n = n || 10, r = r || 0; const i = []; return this._appendLeaves(i, e, t, n, r, 0), i; },
          getTile(e, t, n) { const r = this.trees[this._limitZoom(e)]; const i = Math.pow(2, e); const o = this.options.extent; const a = this.options.radius / o; const s = (n - a) / i; const l = (n + 1 + a) / i; const u = { features: [] }; return this._addTileFeatures(r.range((t - a) / i, s, (t + 1 + a) / i, l), r.points, t, n, i, u), t === 0 && this._addTileFeatures(r.range(1 - a / i, s, 1, l), r.points, i, n, i, u), t === i - 1 && this._addTileFeatures(r.range(0, s, a / i, l), r.points, -1, n, i, u), u.features.length ? u : null; },
          getClusterExpansionZoom(e, t) { for (;t < this.options.maxZoom;) { const n = this.getChildren(e, t); if (t++, n.length !== 1) break; e = n[0].properties.cluster_id; } return t; },
          _appendLeaves(e, t, n, r, i, o) { for (let a = this.getChildren(t, n), s = 0; s < a.length; s++) { const l = a[s].properties; if (l.cluster ? o + l.point_count <= i ? o += l.point_count : o = this._appendLeaves(e, l.cluster_id, n + 1, r, i, o) : o < i ? o++ : e.push(a[s]), e.length === r) break; } return o; },
          _addTileFeatures(e, t, n, r, i, o) { for (let a = 0; a < e.length; a++) { const s = t[e[a]]; o.features.push({ type: 1, geometry: [[Math.round(this.options.extent * (s.x * i - n)), Math.round(this.options.extent * (s.y * i - r))]], tags: s.numPoints ? V(s) : this.points[s.id].properties }); } },
          _limitZoom(e) { return Math.max(this.options.minZoom, Math.min(e, this.options.maxZoom + 1)); },
          _cluster(e, t) { for (var n = [], r = this.options.radius / (this.options.extent * Math.pow(2, t)), i = 0; i < e.length; i++) { const o = e[i]; if (!(o.zoom <= t)) { o.zoom = t; const a = this.trees[t + 1]; const s = a.within(o.x, o.y, r); let l = o.numPoints || 1; let u = o.x * l; let c = o.y * l; let p = null; this.options.reduce && (p = this.options.initial(), this._accumulate(p, o)); for (let f = 0; f < s.length; f++) { const h = a.points[s[f]]; if (t < h.zoom) { const d = h.numPoints || 1; h.zoom = t, u += h.x * d, c += h.y * d, l += d, h.parentId = i, this.options.reduce && this._accumulate(p, h); } }l === 1 ? n.push(o) : (o.parentId = i, n.push(B(u / l, c / l, l, i, p))); } } return n; },
          _accumulate(e, t) { const n = t.numPoints ? t.properties : this.options.map(this.points[t.id].properties); this.options.reduce(e, n); },
        }, ve.prototype.options = {
          maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, debug: 0,
        }, ve.prototype.splitTile = function (e, t, n, r, i, o, a) { for (let s = [e, t, n, r], l = this.options, u = l.debug; s.length;) { r = s.pop(), n = s.pop(), t = s.pop(), e = s.pop(); const c = 1 << t; const p = _e(t, n, r); let f = this.tiles[p]; if (!f && (u > 1 && console.time('creation'), f = this.tiles[p] = me(e, t, n, r, l), this.tileCoords.push({ z: t, x: n, y: r }), u)) { u > 1 && (console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', t, n, r, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd('creation')); const h = `z${t}`; this.stats[h] = (this.stats[h] || 0) + 1, this.total++; } if (f.source = e, i) { if (t === l.maxZoom || t === i) continue; const d = 1 << i - t; if (n !== Math.floor(o / d) || r !== Math.floor(a / d)) continue; } else if (t === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue; if (f.source = null, e.length !== 0) { u > 1 && console.time('clipping'); var m; var g; var y; var v; var _; var b; const x = 0.5 * l.buffer / l.extent; const w = 0.5 - x; const E = 0.5 + x; const T = 1 + x; m = g = y = v = null, _ = re(e, c, n - x, n + E, 0, f.minX, f.maxX, l), b = re(e, c, n + w, n + T, 0, f.minX, f.maxX, l), e = null, _ && (m = re(_, c, r - x, r + E, 1, f.minY, f.maxY, l), g = re(_, c, r + w, r + T, 1, f.minY, f.maxY, l), _ = null), b && (y = re(b, c, r - x, r + E, 1, f.minY, f.maxY, l), v = re(b, c, r + w, r + T, 1, f.minY, f.maxY, l), b = null), u > 1 && console.timeEnd('clipping'), s.push(m || [], t + 1, 2 * n, 2 * r), s.push(g || [], t + 1, 2 * n, 2 * r + 1), s.push(y || [], t + 1, 2 * n + 1, 2 * r), s.push(v || [], t + 1, 2 * n + 1, 2 * r + 1); } } }, ve.prototype.getTile = function (e, t, n) { const r = this.options; const i = r.extent; const o = r.debug; if (e < 0 || e > 24) return null; const a = 1 << e; const s = _e(e, t = (t % a + a) % a, n); if (this.tiles[s]) return he(this.tiles[s], i); o > 1 && console.log('drilling down to z%d-%d-%d', e, t, n); for (var l, u = e, c = t, p = n; !l && u > 0;)u--, c = Math.floor(c / 2), p = Math.floor(p / 2), l = this.tiles[_e(u, c, p)]; return l && l.source ? (o > 1 && console.log('found parent tile z%d-%d-%d', u, c, p), o > 1 && console.time('drilling down'), this.splitTile(l.source, u, c, p, e, t, n), o > 1 && console.timeEnd('drilling down'), this.tiles[s] ? he(this.tiles[s], i) : null) : null; }; const Ze = (function (t) { function n(e, n, r) { t.call(this, e, n, be), r && (this.loadGeoJSON = r); } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.loadData = function (e, t) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = t, this._pendingLoadDataParams = e, this._state && this._state !== 'Idle' ? this._state = 'NeedsLoadData' : (this._state = 'Coalescing', this._loadData()); }, n.prototype._loadData = function () { const e = this; if (this._pendingCallback && this._pendingLoadDataParams) { const t = this._pendingCallback; const n = this._pendingLoadDataParams; delete this._pendingCallback, delete this._pendingLoadDataParams, this.loadGeoJSON(n, (r, i) => { if (r || !i) return t(r); if (typeof i !== 'object') return t(new Error('Input data is not a valid GeoJSON object.')); Ne(i, !0); try { e._geoJSONIndex = n.cluster ? Ge(n.superclusterOptions).load(i.features) : (function (e, t) { return new ve(e, t); }(i, n.geojsonVtOptions)); } catch (r) { return t(r); }e.loaded = {}; const o = {}; if (n.request && n.request.collectResourceTiming) { const a = Ae(n.request.url); a && (o.resourceTiming = {}, o.resourceTiming[n.source] = JSON.parse(JSON.stringify(a))); }t(null, o); }); } }, n.prototype.coalesce = function () { this._state === 'Coalescing' ? this._state = 'Idle' : this._state === 'NeedsLoadData' && (this._state = 'Coalescing', this._loadData()); }, n.prototype.reloadTile = function (e, n) { const r = this.loaded; const i = e.uid; return r && r[i] ? t.prototype.reloadTile.call(this, e, n) : this.loadTile(e, n); }, n.prototype.loadGeoJSON = function (t, n) { if (t.request)e.getJSON(t.request, n); else { if (typeof t.data !== 'string') return n(new Error('Input data is not a valid GeoJSON object.')); try { return n(null, JSON.parse(t.data)); } catch (e) { return n(new Error('Input data is not a valid GeoJSON object.')); } } }, n.prototype.removeSource = function (e, t) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), t(); }, n; }(Oe)); const Ke = function (t) { const n = this; this.self = t, this.actor = new e.default$7(t, this), this.layerIndexes = {}, this.workerSourceTypes = { vector: Oe, geojson: Ze }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function (e, t) { if (n.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`); n.workerSourceTypes[e] = t; }, this.self.registerRTLTextPlugin = function (t) { if (e.plugin.isLoaded()) throw new Error('RTL text plugin already registered.'); e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText; }; }; return Ke.prototype.setLayers = function (e, t, n) { this.getLayerIndex(e).replace(t), n(); }, Ke.prototype.updateLayers = function (e, t, n) { this.getLayerIndex(e).update(t.layers, t.removedIds), n(); }, Ke.prototype.loadTile = function (e, t, n) { this.getWorkerSource(e, t.type, t.source).loadTile(t, n); }, Ke.prototype.loadDEMTile = function (e, t, n) { this.getDEMWorkerSource(e, t.source).loadTile(t, n); }, Ke.prototype.reloadTile = function (e, t, n) { this.getWorkerSource(e, t.type, t.source).reloadTile(t, n); }, Ke.prototype.abortTile = function (e, t, n) { this.getWorkerSource(e, t.type, t.source).abortTile(t, n); }, Ke.prototype.removeTile = function (e, t, n) { this.getWorkerSource(e, t.type, t.source).removeTile(t, n); }, Ke.prototype.removeDEMTile = function (e, t) { this.getDEMWorkerSource(e, t.source).removeTile(t); }, Ke.prototype.removeSource = function (e, t, n) { if (this.workerSources[e] && this.workerSources[e][t.type] && this.workerSources[e][t.type][t.source]) { const r = this.workerSources[e][t.type][t.source]; delete this.workerSources[e][t.type][t.source], void 0 !== r.removeSource ? r.removeSource(t, n) : n(); } }, Ke.prototype.loadWorkerSource = function (e, t, n) { try { this.self.importScripts(t.url), n(); } catch (e) { n(e.toString()); } }, Ke.prototype.loadRTLTextPlugin = function (t, n, r) { try { e.plugin.isLoaded() || (this.self.importScripts(n), r(e.plugin.isLoaded() ? null : new Error(`RTL Text Plugin failed to import scripts from ${n}`))); } catch (e) { r(e.toString()); } }, Ke.prototype.getLayerIndex = function (e) { let t = this.layerIndexes[e]; return t || (t = this.layerIndexes[e] = new xe()), t; }, Ke.prototype.getWorkerSource = function (e, t, n) { const r = this; if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][n]) { const i = { send(t, n, i) { r.actor.send(t, n, i, e); } }; this.workerSources[e][t][n] = new this.workerSourceTypes[t](i, this.getLayerIndex(e)); } return this.workerSources[e][t][n]; }, Ke.prototype.getDEMWorkerSource = function (e, t) { return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new Ie()), this.demWorkerSources[e][t]; }, typeof WorkerGlobalScope !== 'undefined' && typeof self !== 'undefined' && self instanceof WorkerGlobalScope && new Ke(self), Ke;
      }), e(['./chunk1.js'], (e) => {
        function t(e) { if (!be) return null; for (let t = 0; t < e.length; t++) if (e[t] in be) return e[t]; return e[0]; } function n(e, t) { const n = i(Ce.API_URL); if (e.protocol = n.protocol, e.authority = n.authority, n.path !== '/' && (e.path = `${n.path}${e.path}`), !Ce.REQUIRE_ACCESS_TOKEN) return o(e); if (!(t = t || Ce.ACCESS_TOKEN)) throw new Error(`An API access token is required to use Mapbox GL. ${Se}`); if (t[0] === 's') throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${Se}`); return e.params.push(`access_token=${t}`), o(e); } function r(e) { return e.indexOf('mapbox:') === 0; } function i(e) {
          const t = e.match(Ne); if (!t) throw new Error('Unable to parse URL object'); return {
            protocol: t[1], authority: t[2], path: t[3] || '/', params: t[4] ? t[4].split('&') : [],
          };
        } function o(e) { const t = e.params.length ? `?${e.params.join('&')}` : ''; return `${e.protocol}://${e.authority}${e.path}${t}`; } function a(e, t, n, r, i, o) { this.fontSize = e || 24, this.buffer = void 0 === t ? 3 : t, this.cutoff = r || 0.25, this.fontFamily = i || 'sans-serif', this.fontWeight = o || 'normal', this.radius = n || 8; const a = this.size = this.fontSize + 2 * this.buffer; this.canvas = document.createElement('canvas'), this.canvas.width = this.canvas.height = a, this.ctx = this.canvas.getContext('2d'), this.ctx.font = `${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`, this.ctx.textBaseline = 'middle', this.ctx.fillStyle = 'black', this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.d = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Int16Array(a), this.middle = Math.round(a / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1)); } function s(e, t, n, r, i, o, a) { for (var s = 0; s < t; s++) { for (var u = 0; u < n; u++)r[u] = e[u * t + s]; for (l(r, i, o, a, n), u = 0; u < n; u++)e[u * t + s] = i[u]; } for (u = 0; u < n; u++) { for (s = 0; s < t; s++)r[s] = e[u * t + s]; for (l(r, i, o, a, t), s = 0; s < t; s++)e[u * t + s] = Math.sqrt(i[s]); } } function l(e, t, n, r, i) { n[0] = 0, r[0] = -Ue, r[1] = +Ue; for (var o = 1, a = 0; o < i; o++) { for (var s = (e[o] + o * o - (e[n[a]] + n[a] * n[a])) / (2 * o - 2 * n[a]); s <= r[a];)a--, s = (e[o] + o * o - (e[n[a]] + n[a] * n[a])) / (2 * o - 2 * n[a]); n[++a] = o, r[a] = s, r[a + 1] = +Ue; } for (o = 0, a = 0; o < i; o++) { for (;r[a + 1] < o;)a++; t[o] = (o - n[a]) * (o - n[a]) + e[n[a]]; } } function u(t, n, r) { const i = function (t, n) { if (t) return r(t); if (n) { const i = e.pick(n, ['tiles', 'minzoom', 'maxzoom', 'attribution', 'mapbox_logo', 'bounds']); n.vector_layers && (i.vectorLayers = n.vector_layers, i.vectorLayerIds = i.vectorLayers.map(e => e.id)), r(null, i); } }; t.url ? e.getJSON(n(Oe(t.url), e.ResourceType.Source), i) : ge.frame(() => i(null, t)); } function c(e, t, n, r, i) { const o = i.maxPitchScaleFactor(); const a = e.tilesIn(n, o); a.sort(p); for (var s = [], l = 0, u = a; l < u.length; l += 1) { const c = u[l]; s.push({ wrappedTileID: c.tileID.wrapped().key, queryResults: c.tile.queryRenderedFeatures(t, c.queryGeometry, c.scale, r, i, o, e.transform.calculatePosMatrix(c.tileID.toUnwrapped())) }); } return (function (e) { for (var t = {}, n = {}, r = 0, i = e; r < i.length; r += 1) { const o = i[r]; const a = o.queryResults; const s = o.wrappedTileID; const l = n[s] = n[s] || {}; for (const u in a) for (let c = a[u], p = l[u] = l[u] || {}, f = t[u] = t[u] || [], h = 0, d = c; h < d.length; h += 1) { const m = d[h]; p[m.featureIndex] || (p[m.featureIndex] = !0, f.push(m.feature)); } } return t; }(s)); } function p(e, t) { const n = e.tileID; const r = t.tileID; return n.overscaledZ - r.overscaledZ || n.canonical.y - r.canonical.y || n.wrap - r.wrap || n.canonical.x - r.canonical.x; } function f(t, n) { const r = n.zoomTo(t.canonical.z); return new e.default$1((r.column - (t.canonical.x + t.wrap * Math.pow(2, t.canonical.z))) * e.default$8, (r.row - t.canonical.y) * e.default$8); } function h(e) { return e === 'raster' || e === 'image' || e === 'video'; } function d() { return new e.default.Worker(Or.workerUrl); } function m(t, n) { const r = {}; for (const i in t)i !== 'ref' && (r[i] = t[i]); return e.default$18.forEach((e) => { e in n && (r[e] = n[e]); }), r; } function g(e) { e = e.slice(); for (var t = Object.create(null), n = 0; n < e.length; n++)t[e[n].id] = e[n]; for (let r = 0; r < e.length; r++)'ref' in e[r] && (e[r] = m(e[r], t[e[r].ref])); return e; } function y(e, t, n) { n.push({ command: Yt.addSource, args: [e, t[e]] }); } function v(e, t, n) { t.push({ command: Yt.removeSource, args: [e] }), n[e] = !0; } function _(e, t, n, r) { v(e, n, r), y(e, t, n); } function b(t, n, r) { let i; for (i in t[r]) if (t[r].hasOwnProperty(i) && i !== 'data' && !e.default$10(t[r][i], n[r][i])) return !1; for (i in n[r]) if (n[r].hasOwnProperty(i) && i !== 'data' && !e.default$10(t[r][i], n[r][i])) return !1; return !0; } function x(t, n, r, i, o, a) { let s; for (s in n = n || {}, t = t || {})t.hasOwnProperty(s) && (e.default$10(t[s], n[s]) || r.push({ command: a, args: [i, s, n[s], o] })); for (s in n)n.hasOwnProperty(s) && !t.hasOwnProperty(s) && (e.default$10(t[s], n[s]) || r.push({ command: a, args: [i, s, n[s], o] })); } function w(e) { return e.id; } function E(e, t) { return e[t.id] = t, e; } function T(t, n) { if (!t) return [{ command: Yt.setStyle, args: [n] }]; let r = []; try { if (!e.default$10(t.version, n.version)) return [{ command: Yt.setStyle, args: [n] }]; e.default$10(t.center, n.center) || r.push({ command: Yt.setCenter, args: [n.center] }), e.default$10(t.zoom, n.zoom) || r.push({ command: Yt.setZoom, args: [n.zoom] }), e.default$10(t.bearing, n.bearing) || r.push({ command: Yt.setBearing, args: [n.bearing] }), e.default$10(t.pitch, n.pitch) || r.push({ command: Yt.setPitch, args: [n.pitch] }), e.default$10(t.sprite, n.sprite) || r.push({ command: Yt.setSprite, args: [n.sprite] }), e.default$10(t.glyphs, n.glyphs) || r.push({ command: Yt.setGlyphs, args: [n.glyphs] }), e.default$10(t.transition, n.transition) || r.push({ command: Yt.setTransition, args: [n.transition] }), e.default$10(t.light, n.light) || r.push({ command: Yt.setLight, args: [n.light] }); const i = {}; const o = []; !(function (t, n, r, i) { let o; for (o in n = n || {}, t = t || {})t.hasOwnProperty(o) && (n.hasOwnProperty(o) || v(o, r, i)); for (o in n)n.hasOwnProperty(o) && (t.hasOwnProperty(o) ? e.default$10(t[o], n[o]) || (t[o].type === 'geojson' && n[o].type === 'geojson' && b(t, n, o) ? r.push({ command: Yt.setGeoJSONSourceData, args: [o, n[o].data] }) : _(o, n, r, i)) : y(o, n, r)); }(t.sources, n.sources, o, i)); const a = []; t.layers && t.layers.forEach((e) => { i[e.source] ? r.push({ command: Yt.removeLayer, args: [e.id] }) : a.push(e); }), r = r.concat(o), (function (t, n, r) { n = n || []; let i; let o; let a; let s; let l; let u; let c; const p = (t = t || []).map(w); const f = n.map(w); const h = t.reduce(E, {}); const d = n.reduce(E, {}); const m = p.slice(); const g = Object.create(null); for (i = 0, o = 0; i < p.length; i++)a = p[i], d.hasOwnProperty(a) ? o++ : (r.push({ command: Yt.removeLayer, args: [a] }), m.splice(m.indexOf(a, o), 1)); for (i = 0, o = 0; i < f.length; i++)a = f[f.length - 1 - i], m[m.length - 1 - i] !== a && (h.hasOwnProperty(a) ? (r.push({ command: Yt.removeLayer, args: [a] }), m.splice(m.lastIndexOf(a, m.length - o), 1)) : o++, u = m[m.length - i], r.push({ command: Yt.addLayer, args: [d[a], u] }), m.splice(m.length - i, 0, a), g[a] = !0); for (i = 0; i < f.length; i++) if (s = h[a = f[i]], l = d[a], !g[a] && !e.default$10(s, l)) if (e.default$10(s.source, l.source) && e.default$10(s['source-layer'], l['source-layer']) && e.default$10(s.type, l.type)) { for (c in x(s.layout, l.layout, r, a, null, Yt.setLayoutProperty), x(s.paint, l.paint, r, a, null, Yt.setPaintProperty), e.default$10(s.filter, l.filter) || r.push({ command: Yt.setFilter, args: [a, l.filter] }), e.default$10(s.minzoom, l.minzoom) && e.default$10(s.maxzoom, l.maxzoom) || r.push({ command: Yt.setLayerZoomRange, args: [a, l.minzoom, l.maxzoom] }), s)s.hasOwnProperty(c) && c !== 'layout' && c !== 'paint' && c !== 'filter' && c !== 'metadata' && c !== 'minzoom' && c !== 'maxzoom' && (c.indexOf('paint.') === 0 ? x(s[c], l[c], r, a, c.slice(6), Yt.setPaintProperty) : e.default$10(s[c], l[c]) || r.push({ command: Yt.setLayerProperty, args: [a, c, l[c]] })); for (c in l)l.hasOwnProperty(c) && !s.hasOwnProperty(c) && c !== 'layout' && c !== 'paint' && c !== 'filter' && c !== 'metadata' && c !== 'minzoom' && c !== 'maxzoom' && (c.indexOf('paint.') === 0 ? x(s[c], l[c], r, a, c.slice(6), Yt.setPaintProperty) : e.default$10(s[c], l[c]) || r.push({ command: Yt.setLayerProperty, args: [a, c, l[c]] })); } else r.push({ command: Yt.removeLayer, args: [a] }), u = m[m.lastIndexOf(a) + 1], r.push({ command: Yt.addLayer, args: [l, u] }); }(a, n.layers, r)); } catch (e) { console.warn('Unable to compute style diff:', e), r = [{ command: Yt.setStyle, args: [n] }]; } return r; } function k(t, n, r, i, o) { const a = e.mat4.identity(new Float32Array(16)); return n ? (e.mat4.identity(a), e.mat4.scale(a, a, [1 / o, 1 / o, 1]), r || e.mat4.rotateZ(a, a, i.angle)) : (e.mat4.scale(a, a, [i.width / 2, -i.height / 2, 1]), e.mat4.translate(a, a, [1, -1, 0]), e.mat4.multiply(a, a, t)), a; } function C(t, n, r, i, o) { const a = e.mat4.identity(new Float32Array(16)); return n ? (e.mat4.multiply(a, a, t), e.mat4.scale(a, a, [o, o, 1]), r || e.mat4.rotateZ(a, a, -i.angle)) : (e.mat4.scale(a, a, [1, -1, 1]), e.mat4.translate(a, a, [-1, -1, 0]), e.mat4.scale(a, a, [2 / i.width, 2 / i.height, 1])), a; } function S(t, n) { const r = [t.x, t.y, 0, 1]; z(r, r, n); const i = r[3]; return { point: new e.default$1(r[0] / i, r[1] / i), signedDistanceFromCamera: i }; } function A(e, t) { const n = e[0] / e[3]; const r = e[1] / e[3]; return n >= -t[0] && n <= t[0] && r >= -t[1] && r <= t[1]; } function O(t, n, r, i, o, a, s, l) { const u = i ? t.textSizeData : t.iconSizeData; const c = e.evaluateSizeForZoom(u, r.transform.zoom, Qt.properties[i ? 'text-size' : 'icon-size']); const p = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1]; const f = i ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray; f.clear(); for (let h = t.lineVertexArray, d = i ? t.text.placedSymbolArray : t.icon.placedSymbolArray, m = r.transform.width / r.transform.height, g = !1, y = 0; y < d.length; y++) { const v = d.get(y); if (v.hidden || v.writingMode === e.WritingMode.vertical && !g)L(v.numGlyphs, f); else { g = !1; const _ = [v.anchorX, v.anchorY, 0, 1]; if (e.vec4.transformMat4(_, _, n), A(_, p)) { const b = 0.5 + _[3] / r.transform.cameraToCenterDistance * 0.5; const x = e.evaluateSizeForFeature(u, c, v); const w = s ? x * b : x / b; const E = new e.default$1(v.anchorX, v.anchorY); const T = S(E, o).point; const k = {}; const C = M(v, w, !1, l, n, o, a, t.glyphOffsetArray, h, f, T, E, k, m); g = C.useVertical, (C.notEnoughRoom || g || C.needsFlipping && M(v, w, !0, l, n, o, a, t.glyphOffsetArray, h, f, T, E, k, m).notEnoughRoom) && L(v.numGlyphs, f); } else L(v.numGlyphs, f); } }i ? t.text.dynamicLayoutVertexBuffer.updateData(f) : t.icon.dynamicLayoutVertexBuffer.updateData(f); } function I(e, t, n, r, i, o, a, s, l, u, c, p) { const f = s.glyphStartIndex + s.numGlyphs; const h = s.lineStartIndex; const d = s.lineStartIndex + s.lineLength; const m = t.getoffsetX(s.glyphStartIndex); const g = t.getoffsetX(f - 1); const y = D(e * m, n, r, i, o, a, s.segment, h, d, l, u, c, p); if (!y) return null; const v = D(e * g, n, r, i, o, a, s.segment, h, d, l, u, c, p); return v ? { first: y, last: v } : null; } function P(t, n, r, i) { return t === e.WritingMode.horizontal && Math.abs(r.y - n.y) > Math.abs(r.x - n.x) * i ? { useVertical: !0 } : (t === e.WritingMode.vertical ? n.y < r.y : n.x > r.x) ? { needsFlipping: !0 } : null; } function M(t, n, r, i, o, a, s, l, u, c, p, f, h, d) { let m; const g = n / 24; const y = t.lineOffsetX * n; const v = t.lineOffsetY * n; if (t.numGlyphs > 1) { const _ = t.glyphStartIndex + t.numGlyphs; const b = t.lineStartIndex; const x = t.lineStartIndex + t.lineLength; const w = I(g, l, y, v, r, p, f, t, u, a, h, !1); if (!w) return { notEnoughRoom: !0 }; const E = S(w.first.point, s).point; const T = S(w.last.point, s).point; if (i && !r) { const k = P(t.writingMode, E, T, d); if (k) return k; }m = [w.first]; for (let C = t.glyphStartIndex + 1; C < _ - 1; C++)m.push(D(g * l.getoffsetX(C), y, v, r, p, f, t.segment, b, x, u, a, h, !1)); m.push(w.last); } else { if (i && !r) { const A = S(f, o).point; const O = t.lineStartIndex + t.segment + 1; const M = new e.default$1(u.getx(O), u.gety(O)); const L = S(M, o); const z = L.signedDistanceFromCamera > 0 ? L.point : N(f, M, A, 1, o); const R = P(t.writingMode, A, z, d); if (R) return R; } const j = D(g * l.getoffsetX(t.glyphStartIndex), y, v, r, p, f, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, u, a, h, !1); if (!j) return { notEnoughRoom: !0 }; m = [j]; } for (let B = 0, F = m; B < F.length; B += 1) { const U = F[B]; e.addDynamicAttributes(c, U.point, U.angle); } return {}; } function N(e, t, n, r, i) { const o = S(e.add(e.sub(t)._unit()), i).point; const a = n.sub(o); return n.add(a._mult(r / a.mag())); } function D(t, n, r, i, o, a, s, l, u, c, p, f, h) { const d = i ? t - n : t + n; let m = d > 0 ? 1 : -1; let g = 0; i && (m *= -1, g = Math.PI), m < 0 && (g += Math.PI); for (var y = m > 0 ? l + s : l + s + 1, v = y, _ = o, b = o, x = 0, w = 0, E = Math.abs(d); x + w <= E;) { if ((y += m) < l || y >= u) return null; if (b = _, void 0 === (_ = f[y])) { const T = new e.default$1(c.getx(y), c.gety(y)); const k = S(T, p); if (k.signedDistanceFromCamera > 0)_ = f[y] = k.point; else { const C = y - m; _ = N(x === 0 ? a : new e.default$1(c.getx(C), c.gety(C)), T, b, E - x + 1, p); } }x += w, w = b.dist(_); } const A = (E - x) / w; const O = _.sub(b); const I = O.mult(A)._add(b); return I._add(O._unit()._perp()._mult(r * m)), { point: I, angle: g + Math.atan2(_.y - b.y, _.x - b.x), tileDistance: h ? { prevTileDistance: y - m === v ? 0 : c.gettileUnitDistanceFromAnchor(y - m), lastSegmentViewportDistance: E - x } : null }; } function L(e, t) { for (let n = 0; n < e; n++) { const r = t.length; t.resize(r + 4), t.float32.set(en, 3 * r); } } function z(e, t, n) { const r = t[0]; const i = t[1]; return e[0] = n[0] * r + n[4] * i + n[12], e[1] = n[1] * r + n[5] * i + n[13], e[3] = n[3] * r + n[7] * i + n[15], e; } function R(e, t, n) { e[t + 4] = n ? 1 : 0; } function j(t, n, r) { return n * (e.default$8 / (t.tileSize * Math.pow(2, r - t.tileID.overscaledZ))); } function B(e, t, n) { e.emplaceBack(t ? 1 : 0, n ? 1 : 0), e.emplaceBack(t ? 1 : 0, n ? 1 : 0), e.emplaceBack(t ? 1 : 0, n ? 1 : 0), e.emplaceBack(t ? 1 : 0, n ? 1 : 0); } function F(e) { if (e.opacity === 0 && !e.placed) return 0; if (e.opacity === 1 && e.placed) return 4294967295; const t = e.placed ? 1 : 0; const n = Math.floor(127 * e.opacity); return n * ln + t * un + n * cn + t * pn + n * fn + t * hn + n * dn + t; } function U(t, n, r, i, o) { for (let a = 0; a < r.length; a++) { const s = r[a]; if (i.isLessThan(s.tileID)) break; if (n.key === s.tileID.key) return; if (s.tileID.isChildOf(n)) { for (let l = n.children(1 / 0), u = 0; u < l.length; u++)U(t, l[u], r.slice(a), i, o); return; } } const c = n.overscaledZ - t.overscaledZ; const p = new e.CanonicalTileID(c, n.canonical.x - (t.canonical.x << c), n.canonical.y - (t.canonical.y << c)); o[p.key] = o[p.key] || p; } function V(e, t, n, r, i) { const o = e.context; const a = o.gl; const s = i ? e.useProgram('collisionCircle') : e.useProgram('collisionBox'); o.setDepthMode(Ht.disabled), o.setStencilMode(Wt.disabled), o.setColorMode(e.colorModeForRenderPass()); for (let l = 0; l < r.length; l++) { const u = r[l]; const c = t.getTile(u); const p = c.getBucket(n); if (p) { const f = i ? p.collisionCircle : p.collisionBox; if (f) { a.uniformMatrix4fv(s.uniforms.u_matrix, !1, u.posMatrix), i || o.lineWidth.set(1), a.uniform1f(s.uniforms.u_camera_to_center_distance, e.transform.cameraToCenterDistance); const h = j(c, 1, e.transform.zoom); const d = Math.pow(2, e.transform.zoom - c.tileID.overscaledZ); a.uniform1f(s.uniforms.u_pixels_to_tile_units, h), a.uniform2f(s.uniforms.u_extrude_scale, e.transform.pixelsToGLUnits[0] / (h * d), e.transform.pixelsToGLUnits[1] / (h * d)), a.uniform1f(s.uniforms.u_overscale_factor, c.tileID.overscaleFactor()), s.draw(o, i ? a.TRIANGLES : a.LINES, n.id, f.layoutVertexBuffer, f.indexBuffer, f.segments, null, f.collisionVertexBuffer, null); } } } } function q(e, t, n, r, i, o, a, s, l, u) { let c; const p = e.context; const f = p.gl; const h = e.transform; const d = s === 'map'; const m = l === 'map'; const g = d && n.layout.get('symbol-placement') === 'line'; const y = d && !m && !g; const v = m; p.setDepthMode(v ? e.depthModeForSublayer(0, Ht.ReadOnly) : Ht.disabled); for (let _ = 0, b = r; _ < b.length; _ += 1) { const x = b[_]; const w = t.getTile(x); const E = w.getBucket(n); if (E) { const T = i ? E.text : E.icon; if (T && T.segments.get().length) { const S = T.programConfigurations.get(n.id); const A = i || E.sdfIcons; const I = i ? E.textSizeData : E.iconSizeData; if (c || (c = e.useProgram(A ? 'symbolSDF' : 'symbolIcon', S), S.setUniforms(e.context, c, n.paint, { zoom: e.transform.zoom }), H(c, e, n, i, y, m, I)), p.activeTexture.set(f.TEXTURE0), f.uniform1i(c.uniforms.u_texture, 0), i)w.glyphAtlasTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE), f.uniform2fv(c.uniforms.u_texsize, w.glyphAtlasTexture.size); else { const P = n.layout.get('icon-size').constantOr(0) !== 1 || E.iconsNeedLinear; const M = m || h.pitch !== 0; w.iconAtlasTexture.bind(A || e.options.rotating || e.options.zooming || P || M ? f.LINEAR : f.NEAREST, f.CLAMP_TO_EDGE), f.uniform2fv(c.uniforms.u_texsize, w.iconAtlasTexture.size); }f.uniformMatrix4fv(c.uniforms.u_matrix, !1, e.translatePosMatrix(x.posMatrix, w, o, a)); const N = j(w, 1, e.transform.zoom); const D = k(x.posMatrix, m, d, e.transform, N); const L = C(x.posMatrix, m, d, e.transform, N); f.uniformMatrix4fv(c.uniforms.u_gl_coord_matrix, !1, e.translatePosMatrix(L, w, o, a, !0)), g ? (f.uniformMatrix4fv(c.uniforms.u_label_plane_matrix, !1, Mn), O(E, x.posMatrix, e, i, D, L, m, u)) : f.uniformMatrix4fv(c.uniforms.u_label_plane_matrix, !1, D), f.uniform1f(c.uniforms.u_fade_change, e.options.fadeDuration ? e.symbolFadeChange : 1), W(c, S, e, n, w, T, i, A, m); } } } } function H(t, n, r, i, o, a, s) { const l = n.context.gl; const u = n.transform; l.uniform1i(t.uniforms.u_pitch_with_map, a ? 1 : 0), l.uniform1f(t.uniforms.u_is_text, i ? 1 : 0), l.uniform1f(t.uniforms.u_pitch, u.pitch / 360 * 2 * Math.PI); const c = s.functionType === 'constant' || s.functionType === 'source'; const p = s.functionType === 'constant' || s.functionType === 'camera'; l.uniform1i(t.uniforms.u_is_size_zoom_constant, c ? 1 : 0), l.uniform1i(t.uniforms.u_is_size_feature_constant, p ? 1 : 0), l.uniform1f(t.uniforms.u_camera_to_center_distance, u.cameraToCenterDistance); const f = e.evaluateSizeForZoom(s, u.zoom, Nn.properties[i ? 'text-size' : 'icon-size']); void 0 !== f.uSizeT && l.uniform1f(t.uniforms.u_size_t, f.uSizeT), void 0 !== f.uSize && l.uniform1f(t.uniforms.u_size, f.uSize), l.uniform1f(t.uniforms.u_aspect_ratio, u.width / u.height), l.uniform1i(t.uniforms.u_rotate_symbol, o ? 1 : 0); } function W(e, t, n, r, i, o, a, s, l) { const u = n.context; const c = u.gl; const p = n.transform; if (s) { const f = r.paint.get(a ? 'text-halo-width' : 'icon-halo-width').constantOr(1) !== 0; const h = l ? Math.cos(p._pitch) * p.cameraToCenterDistance : 1; c.uniform1f(e.uniforms.u_gamma_scale, h), f && (c.uniform1f(e.uniforms.u_is_halo, 1), $(o, r, u, e)), c.uniform1f(e.uniforms.u_is_halo, 0); }$(o, r, u, e); } function $(e, t, n, r) { r.draw(n, n.gl.TRIANGLES, t.id, e.layoutVertexBuffer, e.indexBuffer, e.segments, e.programConfigurations.get(t.id), e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer); } function G(e, t, n, r, i, o, a, s, l) { let u; let c; let p; let f; const h = t.context; const d = h.gl; const m = i.paint.get('line-dasharray'); const g = i.paint.get('line-pattern'); if (s || l) { const y = 1 / j(n, 1, t.transform.tileZoom); if (m) { u = t.lineAtlas.getDash(m.from, i.layout.get('line-cap') === 'round'), c = t.lineAtlas.getDash(m.to, i.layout.get('line-cap') === 'round'); const v = u.width * m.fromScale; const _ = c.width * m.toScale; d.uniform2f(e.uniforms.u_patternscale_a, y / v, -u.height / 2), d.uniform2f(e.uniforms.u_patternscale_b, y / _, -c.height / 2), d.uniform1f(e.uniforms.u_sdfgamma, t.lineAtlas.width / (256 * Math.min(v, _) * ge.devicePixelRatio) / 2); } else if (g) { if (p = t.imageManager.getPattern(g.from), f = t.imageManager.getPattern(g.to), !p || !f) return; d.uniform2f(e.uniforms.u_pattern_size_a, p.displaySize[0] * g.fromScale / y, p.displaySize[1]), d.uniform2f(e.uniforms.u_pattern_size_b, f.displaySize[0] * g.toScale / y, f.displaySize[1]); const b = t.imageManager.getPixelSize(); const x = b.width; const w = b.height; d.uniform2fv(e.uniforms.u_texsize, [x, w]); }d.uniform2f(e.uniforms.u_gl_units_to_pixels, 1 / t.transform.pixelsToGLUnits[0], 1 / t.transform.pixelsToGLUnits[1]); }s && (m ? (d.uniform1i(e.uniforms.u_image, 0), h.activeTexture.set(d.TEXTURE0), t.lineAtlas.bind(h), d.uniform1f(e.uniforms.u_tex_y_a, u.y), d.uniform1f(e.uniforms.u_tex_y_b, c.y), d.uniform1f(e.uniforms.u_mix, m.t)) : g && (d.uniform1i(e.uniforms.u_image, 0), h.activeTexture.set(d.TEXTURE0), t.imageManager.bind(h), d.uniform2fv(e.uniforms.u_pattern_tl_a, p.tl), d.uniform2fv(e.uniforms.u_pattern_br_a, p.br), d.uniform2fv(e.uniforms.u_pattern_tl_b, f.tl), d.uniform2fv(e.uniforms.u_pattern_br_b, f.br), d.uniform1f(e.uniforms.u_fade, g.t))), h.setStencilMode(t.stencilModeForClipping(o)); const E = t.translatePosMatrix(o.posMatrix, n, i.paint.get('line-translate'), i.paint.get('line-translate-anchor')); if (d.uniformMatrix4fv(e.uniforms.u_matrix, !1, E), d.uniform1f(e.uniforms.u_ratio, 1 / j(n, 1, t.transform.zoom)), i.paint.get('line-gradient')) { h.activeTexture.set(d.TEXTURE0); let T = i.gradientTexture; if (!i.gradient) return; T || (T = i.gradientTexture = new je(h, i.gradient, d.RGBA)), T.bind(d.LINEAR, d.CLAMP_TO_EDGE), d.uniform1i(e.uniforms.u_image, 0); }e.draw(h, d.TRIANGLES, i.id, r.layoutVertexBuffer, r.indexBuffer, r.segments, a); } function Z(e, t, n, r, i) { if (!Dn(n.paint.get('fill-pattern'), e)) for (let o = !0, a = 0, s = r; a < s.length; a += 1) { const l = s[a]; const u = t.getTile(l); const c = u.getBucket(n); c && (e.context.setStencilMode(e.stencilModeForClipping(l)), i(e, t, n, u, l, c, o), o = !1); } } function K(e, t, n, r, i, o, a) { const s = e.context.gl; const l = o.programConfigurations.get(n.id); Y('fill', n.paint.get('fill-pattern'), e, l, n, r, i, a).draw(e.context, s.TRIANGLES, n.id, o.layoutVertexBuffer, o.indexBuffer, o.segments, l); } function X(e, t, n, r, i, o, a) { const s = e.context.gl; const l = o.programConfigurations.get(n.id); const u = Y('fillOutline', n.getPaintProperty('fill-outline-color') ? null : n.paint.get('fill-pattern'), e, l, n, r, i, a); s.uniform2f(u.uniforms.u_world, s.drawingBufferWidth, s.drawingBufferHeight), u.draw(e.context, s.LINES, n.id, o.layoutVertexBuffer, o.indexBuffer2, o.segments2, l); } function Y(e, t, n, r, i, o, a, s) { let l; const u = n.context.program.get(); return t ? (l = n.useProgram(`${e}Pattern`, r), (s || l.program !== u) && (r.setUniforms(n.context, l, i.paint, { zoom: n.transform.zoom }), Ln(t, n, l)), zn(o, n, l)) : (l = n.useProgram(e, r), (s || l.program !== u) && r.setUniforms(n.context, l, i.paint, { zoom: n.transform.zoom })), n.context.gl.uniformMatrix4fv(l.uniforms.u_matrix, !1, n.translatePosMatrix(a.posMatrix, o, i.paint.get('fill-translate'), i.paint.get('fill-translate-anchor'))), l; } function J(e, t, n, r, i, o, a) { const s = e.context; const l = s.gl; const u = n.paint.get('fill-extrusion-pattern'); const c = e.context.program.get(); const p = o.programConfigurations.get(n.id); const f = e.useProgram(u ? 'fillExtrusionPattern' : 'fillExtrusion', p); if ((a || f.program !== c) && p.setUniforms(s, f, n.paint, { zoom: e.transform.zoom }), u) { if (Dn(u, e)) return; Ln(u, e, f), zn(r, e, f), l.uniform1f(f.uniforms.u_height_factor, -Math.pow(2, i.overscaledZ) / r.tileSize / 8); }e.context.gl.uniformMatrix4fv(f.uniforms.u_matrix, !1, e.translatePosMatrix(i.posMatrix, r, n.paint.get('fill-extrusion-translate'), n.paint.get('fill-extrusion-translate-anchor'))), (function (e, t) { const n = t.context.gl; const r = t.style.light; const i = r.properties.get('position'); const o = [i.x, i.y, i.z]; const a = Rn.create(); r.properties.get('anchor') === 'viewport' && Rn.fromRotation(a, -t.transform.angle), Bn.transformMat3(o, o, a); const s = r.properties.get('color'); n.uniform3fv(e.uniforms.u_lightpos, o), n.uniform1f(e.uniforms.u_lightintensity, r.properties.get('intensity')), n.uniform3f(e.uniforms.u_lightcolor, s.r, s.g, s.b); }(f, e)), f.draw(s, l.TRIANGLES, n.id, o.layoutVertexBuffer, o.indexBuffer, o.segments, p); } function Q(t, n, r) { const i = t.context; const o = i.gl; const a = n.fbo; if (a) { const s = t.useProgram('hillshade'); const l = t.transform.calculatePosMatrix(n.tileID.toUnwrapped(), !0); !(function (e, t, n) { let r = n.paint.get('hillshade-illumination-direction') * (Math.PI / 180); n.paint.get('hillshade-illumination-anchor') === 'viewport' && (r -= t.transform.angle), t.context.gl.uniform2f(e.uniforms.u_light, n.paint.get('hillshade-exaggeration'), r); }(s, t, r)); const u = (function (t, n) { const r = n.toCoordinate(); const i = new e.default$17(r.column, r.row + 1, r.zoom); return [t.transform.coordinateLocation(r).lat, t.transform.coordinateLocation(i).lat]; }(t, n.tileID)); i.activeTexture.set(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, a.colorAttachment.get()), o.uniformMatrix4fv(s.uniforms.u_matrix, !1, l), o.uniform2fv(s.uniforms.u_latrange, u), o.uniform1i(s.uniforms.u_image, 0); const c = r.paint.get('hillshade-shadow-color'); o.uniform4f(s.uniforms.u_shadow, c.r, c.g, c.b, c.a); const p = r.paint.get('hillshade-highlight-color'); o.uniform4f(s.uniforms.u_highlight, p.r, p.g, p.b, p.a); const f = r.paint.get('hillshade-accent-color'); if (o.uniform4f(s.uniforms.u_accent, f.r, f.g, f.b, f.a), n.maskedBoundsBuffer && n.maskedIndexBuffer && n.segments)s.draw(i, o.TRIANGLES, r.id, n.maskedBoundsBuffer, n.maskedIndexBuffer, n.segments); else { const h = t.rasterBoundsBuffer; t.rasterBoundsVAO.bind(i, s, h, []), o.drawArrays(o.TRIANGLE_STRIP, 0, h.length); } } } function ee(t, n, r) { const i = t.context; const o = i.gl; if (n.dem && n.dem.level) { const a = n.dem.level.dim; const s = n.dem.getPixels(); if (i.activeTexture.set(o.TEXTURE1), i.pixelStoreUnpackPremultiplyAlpha.set(!1), n.demTexture = n.demTexture || t.getTileTexture(n.tileSize), n.demTexture) { const l = n.demTexture; l.update(s, { premultiply: !1 }), l.bind(o.NEAREST, o.CLAMP_TO_EDGE); } else n.demTexture = new je(i, s, o.RGBA, { premultiply: !1 }), n.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE); i.activeTexture.set(o.TEXTURE0); let u = n.fbo; if (!u) { const c = new je(i, { width: a, height: a, data: null }, o.RGBA); c.bind(o.LINEAR, o.CLAMP_TO_EDGE), (u = n.fbo = i.createFramebuffer(a, a)).colorAttachment.set(c.texture); }i.bindFramebuffer.set(u.framebuffer), i.viewport.set([0, 0, a, a]); const p = e.mat4.create(); e.mat4.ortho(p, 0, e.default$8, -e.default$8, 0, 0, 1), e.mat4.translate(p, p, [0, -e.default$8, 0]); const f = t.useProgram('hillshadePrepare'); o.uniformMatrix4fv(f.uniforms.u_matrix, !1, p), o.uniform1f(f.uniforms.u_zoom, n.tileID.overscaledZ), o.uniform2fv(f.uniforms.u_dimension, [2 * a, 2 * a]), o.uniform1i(f.uniforms.u_image, 1), o.uniform1f(f.uniforms.u_maxzoom, r); const h = t.rasterBoundsBuffer; t.rasterBoundsVAO.bind(i, f, h, []), o.drawArrays(o.TRIANGLE_STRIP, 0, h.length), n.needsHillshadePrepare = !1; } } function te(t, n, r, i, o) { const a = i.paint.get('raster-fade-duration'); if (a > 0) { const s = ge.now(); const l = (s - t.timeAdded) / a; const u = n ? (s - n.timeAdded) / a : -1; const c = r.getSource(); const p = o.coveringZoomLevel({ tileSize: c.tileSize, roundZoom: c.roundZoom }); const f = !n || Math.abs(n.tileID.overscaledZ - p) > Math.abs(t.tileID.overscaledZ - p); const h = f && t.refreshedUponExpiration ? 1 : e.clamp(f ? l : 1 - u, 0, 1); return t.refreshedUponExpiration && l >= 1 && (t.refreshedUponExpiration = !1), n ? { opacity: 1, mix: 1 - h } : { opacity: h, mix: 0 }; } return { opacity: 1, mix: 0 }; } function ne(t, n, r) { const i = t.context; const o = i.gl; i.lineWidth.set(1 * ge.devicePixelRatio); const a = r.posMatrix; const s = t.useProgram('debug'); i.setDepthMode(Ht.disabled), i.setStencilMode(Wt.disabled), i.setColorMode(t.colorModeForRenderPass()), o.uniformMatrix4fv(s.uniforms.u_matrix, !1, a), o.uniform4f(s.uniforms.u_color, 1, 0, 0, 1), t.debugVAO.bind(i, s, t.debugBuffer, []), o.drawArrays(o.LINE_STRIP, 0, t.debugBuffer.length); for (var l = (function (e, t, n, r) { r = r || 1; let i; let o; let a; let s; let l; let u; let c; let p; const f = []; for (i = 0, o = e.length; i < o; i++) if (l = Fn[e[i]]) { for (p = null, a = 0, s = l[1].length; a < s; a += 2)l[1][a] === -1 && l[1][a + 1] === -1 ? p = null : (u = t + l[1][a] * r, c = 200 - l[1][a + 1] * r, p && f.push(p.x, p.y, u, c), p = { x: u, y: c }); t += l[0] * r; } return f; }(r.toString(), 50, 0, 5)), u = new e.PosArray(), c = 0; c < l.length; c += 2)u.emplaceBack(l[c], l[c + 1]); const p = i.createVertexBuffer(u, Cn.members); (new nt()).bind(i, s, p, []), o.uniform4f(s.uniforms.u_color, 1, 1, 1, 1); for (let f = n.getTile(r).tileSize, h = e.default$8 / (Math.pow(2, t.transform.zoom - r.overscaledZ) * f), d = [[-1, -1], [-1, 1], [1, -1], [1, 1]], m = 0; m < d.length; m++) { const g = d[m]; o.uniformMatrix4fv(s.uniforms.u_matrix, !1, e.mat4.translate([], a, [h * g[0], h * g[1], 0])), o.drawArrays(o.LINES, 0, p.length); }o.uniform4f(s.uniforms.u_color, 0, 0, 0, 1), o.uniformMatrix4fv(s.uniforms.u_matrix, !1, a), o.drawArrays(o.LINES, 0, p.length); } function re(e, t) {
          if (e.row > t.row) { const n = e; e = t, t = n; } return {
            x0: e.column, y0: e.row, x1: t.column, y1: t.row, dx: t.column - e.column, dy: t.row - e.row,
          };
        } function ie(e, t, n, r, i) { const o = Math.max(n, Math.floor(t.y0)); const a = Math.min(r, Math.ceil(t.y1)); if (e.x0 === t.x0 && e.y0 === t.y0 ? e.x0 + t.dy / e.dy * e.dx < t.x1 : e.x1 - t.dy / e.dy * e.dx < t.x0) { const s = e; e = t, t = s; } for (let l = e.dx / e.dy, u = t.dx / t.dy, c = e.dx > 0, p = t.dx < 0, f = o; f < a; f++) { const h = l * Math.max(0, Math.min(e.dy, f + c - e.y0)) + e.x0; const d = u * Math.max(0, Math.min(t.dy, f + p - t.y0)) + t.x0; i(Math.floor(d), Math.ceil(h), f); } } function oe(e, t, n, r, i, o) { let a; let s = re(e, t); let l = re(t, n); let u = re(n, e); s.dy > l.dy && (a = s, s = l, l = a), s.dy > u.dy && (a = s, s = u, u = a), l.dy > u.dy && (a = l, l = u, u = a), s.dy && ie(u, s, r, i, o), l.dy && ie(u, l, r, i, o); } function ae(e) { return e * (2 - e); } function se(e) { e.parentNode && e.parentNode.removeChild(e); } function le(e, t, n) { if (e = new Ze(e.lng, e.lat), t) { const r = new Ze(e.lng - 360, e.lat); const i = new Ze(e.lng + 360, e.lat); const o = n.locationPoint(e).distSqr(t); n.locationPoint(r).distSqr(t) < o ? e = r : n.locationPoint(i).distSqr(t) < o && (e = i); } for (;Math.abs(e.lng - n.center.lng) > 180;) { const a = n.locationPoint(e); if (a.x >= 0 && a.y >= 0 && a.x <= n.width && a.y <= n.height) break; e.lng > n.center.lng ? e.lng -= 360 : e.lng += 360; } return e; } function ue(e, t, n) { const r = e.classList; for (const i in _r)r.remove(`mapboxgl-${n}-anchor-${i}`); r.add(`mapboxgl-${n}-anchor-${t}`); } function ce(e, t, n) { let r; let i; let o; let a; let s; let l; const u = n && n.maxWidth || 100; const c = e._container.clientHeight / 2; const p = (r = e.unproject([0, c]), i = e.unproject([u, c]), o = Math.PI / 180, a = r.lat * o, s = i.lat * o, l = Math.sin(a) * Math.sin(s) + Math.cos(a) * Math.cos(s) * Math.cos((i.lng - r.lng) * o), 6371e3 * Math.acos(Math.min(l, 1))); if (n && n.unit === 'imperial') { const f = 3.2808 * p; f > 5280 ? pe(t, u, f / 5280, 'mi') : pe(t, u, f, 'ft'); } else n && n.unit === 'nautical' ? pe(t, u, p / 1852, 'nm') : pe(t, u, p, 'm'); } function pe(e, t, n, r) { let i; let o; let a; let s = (i = n, (o = Math.pow(10, (`${Math.floor(i)}`).length - 1)) * (a = (a = i / o) >= 10 ? 10 : a >= 5 ? 5 : a >= 3 ? 3 : a >= 2 ? 2 : 1)); const l = s / n; r === 'm' && s >= 1e3 && (s /= 1e3, r = 'km'), e.style.width = `${t * l}px`, e.innerHTML = s + r; } const fe = e.createCommonjsModule((e) => {
          function t(e) { return !!(typeof window !== 'undefined' && typeof document !== 'undefined' && Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray && Function.prototype && Function.prototype.bind && Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions && 'JSON' in window && 'parse' in JSON && 'stringify' in JSON && (function () { if (!('Worker' in window && 'Blob' in window && 'URL' in window)) return !1; let e; let t; const n = new Blob([''], { type: 'text/javascript' }); const r = URL.createObjectURL(n); try { t = new Worker(r), e = !0; } catch (t) { e = !1; } return t && t.terminate(), URL.revokeObjectURL(r), e; }()) && 'Uint8ClampedArray' in window && (function (e) { return void 0 === n[e] && (n[e] = (function (e) { const n = document.createElement('canvas'); const r = Object.create(t.webGLContextAttributes); return r.failIfMajorPerformanceCaveat = e, n.probablySupportsContext ? n.probablySupportsContext('webgl', r) || n.probablySupportsContext('experimental-webgl', r) : n.supportsContext ? n.supportsContext('webgl', r) || n.supportsContext('experimental-webgl', r) : n.getContext('webgl', r) || n.getContext('experimental-webgl', r); }(e))), n[e]; }(e && e.failIfMajorPerformanceCaveat))); }e.exports ? e.exports = t : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = t); var n = {}; t.webGLContextAttributes = {
            antialias: !1, alpha: !0, stencil: !0, depth: !0,
          };
        }); const he = e.default.performance && e.default.performance.now ? e.default.performance.now.bind(e.default.performance) : Date.now.bind(Date); const de = e.default.requestAnimationFrame || e.default.mozRequestAnimationFrame || e.default.webkitRequestAnimationFrame || e.default.msRequestAnimationFrame; const me = e.default.cancelAnimationFrame || e.default.mozCancelAnimationFrame || e.default.webkitCancelAnimationFrame || e.default.msCancelAnimationFrame; var ge = {
          now: he, frame(e) { return de(e); }, cancelFrame(e) { return me(e); }, getImageData(t) { const n = e.default.document.createElement('canvas'); const r = n.getContext('2d'); if (!r) throw new Error('failed to create canvas 2d context'); return n.width = t.width, n.height = t.height, r.drawImage(t, 0, 0, t.width, t.height), r.getImageData(0, 0, t.width, t.height); }, hardwareConcurrency: e.default.navigator.hardwareConcurrency || 4, get devicePixelRatio() { return e.default.devicePixelRatio; }, supportsWebp: !1,
        }; if (e.default.document) { const ye = e.default.document.createElement('img'); ye.onload = function () { ge.supportsWebp = !0; }, ye.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA='; } let ve; const _e = { create(t, n, r) { const i = e.default.document.createElement(t); return n && (i.className = n), r && r.appendChild(i), i; }, createNS(t, n) { return e.default.document.createElementNS(t, n); } }; var be = e.default.document ? e.default.document.documentElement.style : null; const xe = t(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']); _e.disableDrag = function () { be && xe && (ve = be[xe], be[xe] = 'none'); }, _e.enableDrag = function () { be && xe && (be[xe] = ve); }; const we = t(['transform', 'WebkitTransform']); _e.setTransform = function (e, t) { e.style[we] = t; }; let Ee = !1; try { const Te = Object.defineProperty({}, 'passive', { get() { Ee = !0; } }); e.default.addEventListener('test', Te, Te), e.default.removeEventListener('test', Te, Te); } catch (e) { Ee = !1; }_e.addEventListener = function (e, t, n, r) { void 0 === r && (r = {}), 'passive' in r && Ee ? e.addEventListener(t, n, r) : e.addEventListener(t, n, r.capture); }, _e.removeEventListener = function (e, t, n, r) { void 0 === r && (r = {}), 'passive' in r && Ee ? e.removeEventListener(t, n, r) : e.removeEventListener(t, n, r.capture); }; var ke = function (t) { t.preventDefault(), t.stopPropagation(), e.default.removeEventListener('click', ke, !0); }; _e.suppressClick = function () { e.default.addEventListener('click', ke, !0), e.default.setTimeout(() => { e.default.removeEventListener('click', ke, !0); }, 0); }, _e.mousePos = function (t, n) { const r = t.getBoundingClientRect(); return n = n.touches ? n.touches[0] : n, new e.default$1(n.clientX - r.left - t.clientLeft, n.clientY - r.top - t.clientTop); }, _e.touchPos = function (t, n) { for (var r = t.getBoundingClientRect(), i = [], o = n.type === 'touchend' ? n.changedTouches : n.touches, a = 0; a < o.length; a++)i.push(new e.default$1(o[a].clientX - r.left - t.clientLeft, o[a].clientY - r.top - t.clientTop)); return i; }, _e.mouseButton = function (t) { return void 0 !== e.default.InstallTrigger && t.button === 2 && t.ctrlKey && e.default.navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 0 : t.button; }, _e.remove = function (e) { e.parentNode && e.parentNode.removeChild(e); }; var Ce = { API_URL: 'https://api.mapbox.com', REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null }; var Se = 'See https://www.mapbox.com/api-documentation/#access-tokens'; const Ae = function (e, t) { if (!r(e)) return e; const o = i(e); return o.path = `/fonts/v1${o.path}`, n(o, t); }; var Oe = function (e, t) { if (!r(e)) return e; const o = i(e); return o.path = `/v4/${o.authority}.json`, o.params.push('secure'), n(o, t); }; const Ie = function (e, t, a, s) { const l = i(e); return r(e) ? (l.path = `/styles/v1${l.path}/sprite${t}${a}`, n(l, s)) : (l.path += `${t}${a}`, o(l)); }; const Pe = /(\.(png|jpg)\d*)(?=$)/; const Me = function (e, t, n) { if (!t || !r(t)) return e; const a = i(e); const s = ge.devicePixelRatio >= 2 || n === 512 ? '@2x' : ''; const l = ge.supportsWebp ? '.webp' : '$1'; return a.path = a.path.replace(Pe, `${s}${l}`), (function (e) { for (let t = 0; t < e.length; t++)e[t].indexOf('access_token=tk.') === 0 && (e[t] = `access_token=${Ce.ACCESS_TOKEN || ''}`); }(a.params)), o(a); }; var Ne = /^(\w+):\/\/([^\/?]*)(\/[^?]+)?\??(.+)?/; const De = e.default.HTMLImageElement; const Le = e.default.HTMLCanvasElement; const ze = e.default.HTMLVideoElement; const Re = e.default.ImageData; var je = function (e, t, n, r) { this.context = e, this.format = n, this.texture = e.gl.createTexture(), this.update(t, r); }; je.prototype.update = function (e, t) { const n = e.width; const r = e.height; const i = !this.size || this.size[0] !== n || this.size[1] !== r; const o = this.context; const a = o.gl; this.useMipmap = Boolean(t && t.useMipmap), a.bindTexture(a.TEXTURE_2D, this.texture), i ? (this.size = [n, r], o.pixelStoreUnpack.set(1), this.format !== a.RGBA || t && !1 === t.premultiply || o.pixelStoreUnpackPremultiplyAlpha.set(!0), e instanceof De || e instanceof Le || e instanceof ze || e instanceof Re ? a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, a.UNSIGNED_BYTE, e) : a.texImage2D(a.TEXTURE_2D, 0, this.format, n, r, 0, this.format, a.UNSIGNED_BYTE, e.data)) : e instanceof De || e instanceof Le || e instanceof ze || e instanceof Re ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, e) : a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, n, r, a.RGBA, a.UNSIGNED_BYTE, e.data), this.useMipmap && this.isSizePowerOfTwo() && a.generateMipmap(a.TEXTURE_2D); }, je.prototype.bind = function (e, t, n) { const r = this.context.gl; r.bindTexture(r.TEXTURE_2D, this.texture), n !== r.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n = r.LINEAR), e !== this.filter && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, e), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, n || e), this.filter = e), t !== this.wrap && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, t), this.wrap = t); }, je.prototype.isSizePowerOfTwo = function () { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0; }, je.prototype.destroy = function () { this.context.gl.deleteTexture(this.texture), this.texture = null; }; const Be = function () { this.images = {}, this.loaded = !1, this.requestors = [], this.shelfPack = new e.default$2(64, 64, { autoResize: !0 }), this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 64, height: 64 }), this.dirty = !0; }; Be.prototype.isLoaded = function () { return this.loaded; }, Be.prototype.setLoaded = function (e) { if (this.loaded !== e && (this.loaded = e, e)) { for (let t = 0, n = this.requestors; t < n.length; t += 1) { const r = n[t]; const i = r.ids; const o = r.callback; this._notify(i, o); } this.requestors = []; } }, Be.prototype.getImage = function (e) { return this.images[e]; }, Be.prototype.addImage = function (e, t) { this.images[e] = t; }, Be.prototype.removeImage = function (e) { delete this.images[e]; const t = this.patterns[e]; t && (this.shelfPack.unref(t.bin), delete this.patterns[e]); }, Be.prototype.getImages = function (e, t) { let n = !0; if (!this.isLoaded()) for (let r = 0, i = e; r < i.length; r += 1) { const o = i[r]; this.images[o] || (n = !1); } this.isLoaded() || n ? this._notify(e, t) : this.requestors.push({ ids: e, callback: t }); }, Be.prototype._notify = function (e, t) { for (var n = {}, r = 0, i = e; r < i.length; r += 1) { const o = i[r]; const a = this.images[o]; a && (n[o] = { data: a.data.clone(), pixelRatio: a.pixelRatio, sdf: a.sdf }); }t(null, n); }, Be.prototype.getPixelSize = function () { return { width: this.shelfPack.w, height: this.shelfPack.h }; }, Be.prototype.getPattern = function (t) { const n = this.patterns[t]; if (n) return n.position; const r = this.getImage(t); if (!r) return null; const i = r.data.width + 2; const o = r.data.height + 2; const a = this.shelfPack.packOne(i, o); if (!a) return null; this.atlasImage.resize(this.getPixelSize()); const s = r.data; const l = this.atlasImage; const u = a.x + 1; const c = a.y + 1; const p = s.width; const f = s.height; e.RGBAImage.copy(s, l, { x: 0, y: 0 }, { x: u, y: c }, { width: p, height: f }), e.RGBAImage.copy(s, l, { x: 0, y: f - 1 }, { x: u, y: c - 1 }, { width: p, height: 1 }), e.RGBAImage.copy(s, l, { x: 0, y: 0 }, { x: u, y: c + f }, { width: p, height: 1 }), e.RGBAImage.copy(s, l, { x: p - 1, y: 0 }, { x: u - 1, y: c }, { width: 1, height: f }), e.RGBAImage.copy(s, l, { x: 0, y: 0 }, { x: u + p, y: c }, { width: 1, height: f }), this.dirty = !0; const h = new e.ImagePosition(a, r); return this.patterns[t] = { bin: a, position: h }, h; }, Be.prototype.bind = function (e) { const t = e.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new je(e, this.atlasImage, t.RGBA), this.atlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE); }; const Fe = a; var Ue = 1e20; a.prototype.draw = function (e) { this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(e, this.buffer, this.middle); for (var t = this.ctx.getImageData(0, 0, this.size, this.size), n = new Uint8ClampedArray(this.size * this.size), r = 0; r < this.size * this.size; r++) { const i = t.data[4 * r + 3] / 255; this.gridOuter[r] = i === 1 ? 0 : i === 0 ? Ue : Math.pow(Math.max(0, 0.5 - i), 2), this.gridInner[r] = i === 1 ? Ue : i === 0 ? 0 : Math.pow(Math.max(0, i - 0.5), 2); } for (s(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), s(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), r = 0; r < this.size * this.size; r++) { const o = this.gridOuter[r] - this.gridInner[r]; n[r] = Math.max(0, Math.min(255, Math.round(255 - 255 * (o / this.radius + this.cutoff)))); } return n; }; const Ve = function (e, t) { this.requestTransform = e, this.localIdeographFontFamily = t, this.entries = {}; }; Ve.prototype.setURL = function (e) { this.url = e; }, Ve.prototype.getGlyphs = function (t, n) { const r = this; const i = []; for (const o in t) for (let a = 0, s = t[o]; a < s.length; a += 1) { const l = s[a]; i.push({ stack: o, id: l }); }e.asyncAll(i, (e, t) => { const n = e.stack; const i = e.id; let o = r.entries[n]; o || (o = r.entries[n] = { glyphs: {}, requests: {} }); let a = o.glyphs[i]; if (void 0 === a) if (a = r._tinySDF(o, n, i))t(null, { stack: n, id: i, glyph: a }); else { const s = Math.floor(i / 256); if (256 * s > 65535)t(new Error('glyphs > 65535 not supported')); else { let l = o.requests[s]; l || (l = o.requests[s] = [], Ve.loadGlyphRange(n, s, r.url, r.requestTransform, (e, t) => { if (t) for (const n in t)o.glyphs[+n] = t[+n]; for (let r = 0, i = l; r < i.length; r += 1)(0, i[r])(e, t); delete o.requests[s]; })), l.push((e, r) => { e ? t(e) : r && t(null, { stack: n, id: i, glyph: r[i] || null }); }); } } else t(null, { stack: n, id: i, glyph: a }); }, (e, t) => { if (e)n(e); else if (t) { for (var r = {}, i = 0, o = t; i < o.length; i += 1) { const a = o[i]; const s = a.stack; const l = a.id; const u = a.glyph; (r[s] || (r[s] = {}))[l] = u && { id: u.id, bitmap: u.bitmap.clone(), metrics: u.metrics }; }n(null, r); } }); }, Ve.prototype._tinySDF = function (t, n, r) {
          const i = this.localIdeographFontFamily; if (i && (e.default$4['CJK Unified Ideographs'](r) || e.default$4['Hangul Syllables'](r))) {
            let o = t.tinySDF; if (!o) { let a = '400'; /bold/i.test(n) ? a = '900' : /medium/i.test(n) ? a = '500' : /light/i.test(n) && (a = '200'), o = t.tinySDF = new Ve.TinySDF(24, 3, 8, 0.25, i, a); } return {
              id: r,
              bitmap: new e.AlphaImage({ width: 30, height: 30 }, o.draw(String.fromCharCode(r))),
              metrics: {
                width: 24, height: 24, left: 0, top: -8, advance: 24,
              },
            };
          }
        }, Ve.loadGlyphRange = function (t, n, r, i, o) { const a = 256 * n; const s = a + 255; const l = i(Ae(r).replace('{fontstack}', t).replace('{range}', `${a}-${s}`), e.ResourceType.Glyphs); e.getArrayBuffer(l, (t, n) => { if (t)o(t); else if (n) { for (var r = {}, i = 0, a = e.default$3(n.data); i < a.length; i += 1) { const s = a[i]; r[s.id] = s; }o(null, r); } }); }, Ve.TinySDF = Fe; const qe = function () { this.specification = e.default$5.light.position; }; qe.prototype.possiblyEvaluate = function (t, n) { return e.sphericalToCartesian(t.expression.evaluate(n)); }, qe.prototype.interpolate = function (t, n, r) { return { x: e.number(t.x, n.x, r), y: e.number(t.y, n.y, r), z: e.number(t.z, n.z, r) }; }; const He = new e.Properties({
          anchor: new e.DataConstantProperty(e.default$5.light.anchor), position: new qe(), color: new e.DataConstantProperty(e.default$5.light.color), intensity: new e.DataConstantProperty(e.default$5.light.intensity),
        }); const We = (function (t) { function n(n) { t.call(this), this._transitionable = new e.Transitionable(He), this.setLight(n), this._transitioning = this._transitionable.untransitioned(); } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.getLight = function () { return this._transitionable.serialize(); }, n.prototype.setLight = function (t) { if (!this._validate(e.validateLight, t)) for (const n in t) { const r = t[n]; e.endsWith(n, '-transition') ? this._transitionable.setTransition(n.slice(0, -'-transition'.length), r) : this._transitionable.setValue(n, r); } }, n.prototype.updateTransitions = function (e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning); }, n.prototype.hasTransition = function () { return this._transitioning.hasTransition(); }, n.prototype.recalculate = function (e) { this.properties = this._transitioning.possiblyEvaluate(e); }, n.prototype._validate = function (t, n) { return e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: e.default$5 }))); }, n; }(e.Evented)); const $e = function (e, t) { this.width = e, this.height = t, this.nextRow = 0, this.bytes = 4, this.data = new Uint8Array(this.width * this.height * this.bytes), this.positions = {}; }; $e.prototype.getDash = function (e, t) { const n = e.join(',') + String(t); return this.positions[n] || (this.positions[n] = this.addDash(e, t)), this.positions[n]; }, $e.prototype.addDash = function (t, n) { const r = n ? 7 : 0; const i = 2 * r + 1; if (this.nextRow + i > this.height) return e.warnOnce('LineAtlas out of space'), null; for (var o = 0, a = 0; a < t.length; a++)o += t[a]; for (let s = this.width / o, l = s / 2, u = t.length % 2 == 1, c = -r; c <= r; c++) for (let p = this.nextRow + r + c, f = this.width * p, h = u ? -t[t.length - 1] : 0, d = t[0], m = 1, g = 0; g < this.width; g++) { for (;d < g / s;)h = d, d += t[m], u && m === t.length - 1 && (d += t[0]), m++; const y = Math.abs(g - h * s); const v = Math.abs(g - d * s); const _ = Math.min(y, v); const b = m % 2 == 1; let x = void 0; if (n) { const w = r ? c / r * (l + 1) : 0; if (b) { const E = l - Math.abs(w); x = Math.sqrt(_ * _ + E * E); } else x = l - Math.sqrt(_ * _ + w * w); } else x = (b ? 1 : -1) * _; this.data[3 + 4 * (f + g)] = Math.max(0, Math.min(255, x + 128)); } const T = { y: (this.nextRow + r + 0.5) / this.height, height: 2 * r / this.height, width: o }; return this.nextRow += i, this.dirty = !0, T; }, $e.prototype.bind = function (e) { const t = e.gl; this.texture ? (t.bindTexture(t.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, this.width, this.height, t.RGBA, t.UNSIGNED_BYTE, this.data))) : (this.texture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.width, this.height, 0, t.RGBA, t.UNSIGNED_BYTE, this.data)); }; const Ge = function t(n, r) { this.workerPool = n, this.actors = [], this.currentActor = 0, this.id = e.uniqueId(); for (let i = this.workerPool.acquire(this.id), o = 0; o < i.length; o++) { const a = i[o]; const s = new t.Actor(a, r, this.id); s.name = `Worker ${o}`, this.actors.push(s); } }; Ge.prototype.broadcast = function (t, n, r) { r = r || function () {}, e.asyncAll(this.actors, (e, r) => { e.send(t, n, r); }, r); }, Ge.prototype.send = function (e, t, n, r) { return (typeof r !== 'number' || isNaN(r)) && (r = this.currentActor = (this.currentActor + 1) % this.actors.length), this.actors[r].send(e, t, n), r; }, Ge.prototype.remove = function () { this.actors.forEach((e) => { e.remove(); }), this.actors = [], this.workerPool.release(this.id); }, Ge.Actor = e.default$7; var Ze = function (e, t) { if (isNaN(e) || isNaN(t)) throw new Error(`Invalid LngLat object: (${e}, ${t})`); if (this.lng = +e, this.lat = +t, this.lat > 90 || this.lat < -90) throw new Error('Invalid LngLat latitude value: must be between -90 and 90'); }; Ze.prototype.wrap = function () { return new Ze(e.wrap(this.lng, -180, 180), this.lat); }, Ze.prototype.toArray = function () { return [this.lng, this.lat]; }, Ze.prototype.toString = function () { return `LngLat(${this.lng}, ${this.lat})`; }, Ze.prototype.toBounds = function (e) { const t = 360 * e / 40075017; const n = t / Math.cos(Math.PI / 180 * this.lat); return new Ke(new Ze(this.lng - n, this.lat - t), new Ze(this.lng + n, this.lat + t)); }, Ze.convert = function (e) { if (e instanceof Ze) return e; if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new Ze(Number(e[0]), Number(e[1])); if (!Array.isArray(e) && typeof e === 'object' && e !== null) return new Ze(Number(e.lng), Number(e.lat)); throw new Error('`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'); }; var Ke = function (e, t) { e && (t ? this.setSouthWest(e).setNorthEast(t) : e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])); }; Ke.prototype.setNorthEast = function (e) { return this._ne = e instanceof Ze ? new Ze(e.lng, e.lat) : Ze.convert(e), this; }, Ke.prototype.setSouthWest = function (e) { return this._sw = e instanceof Ze ? new Ze(e.lng, e.lat) : Ze.convert(e), this; }, Ke.prototype.extend = function (e) { let t; let n; const r = this._sw; const i = this._ne; if (e instanceof Ze)t = e, n = e; else { if (!(e instanceof Ke)) return Array.isArray(e) ? e.every(Array.isArray) ? this.extend(Ke.convert(e)) : this.extend(Ze.convert(e)) : this; if (t = e._sw, n = e._ne, !t || !n) return this; } return r || i ? (r.lng = Math.min(t.lng, r.lng), r.lat = Math.min(t.lat, r.lat), i.lng = Math.max(n.lng, i.lng), i.lat = Math.max(n.lat, i.lat)) : (this._sw = new Ze(t.lng, t.lat), this._ne = new Ze(n.lng, n.lat)), this; }, Ke.prototype.getCenter = function () { return new Ze((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2); }, Ke.prototype.getSouthWest = function () { return this._sw; }, Ke.prototype.getNorthEast = function () { return this._ne; }, Ke.prototype.getNorthWest = function () { return new Ze(this.getWest(), this.getNorth()); }, Ke.prototype.getSouthEast = function () { return new Ze(this.getEast(), this.getSouth()); }, Ke.prototype.getWest = function () { return this._sw.lng; }, Ke.prototype.getSouth = function () { return this._sw.lat; }, Ke.prototype.getEast = function () { return this._ne.lng; }, Ke.prototype.getNorth = function () { return this._ne.lat; }, Ke.prototype.toArray = function () { return [this._sw.toArray(), this._ne.toArray()]; }, Ke.prototype.toString = function () { return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`; }, Ke.prototype.isEmpty = function () { return !(this._sw && this._ne); }, Ke.convert = function (e) { return !e || e instanceof Ke ? e : new Ke(e); }; const Xe = function (e, t, n) { this.bounds = Ke.convert(this.validateBounds(e)), this.minzoom = t || 0, this.maxzoom = n || 24; }; Xe.prototype.validateBounds = function (e) { return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]; }, Xe.prototype.contains = function (e) { const t = Math.floor(this.lngX(this.bounds.getWest(), e.z)); const n = Math.floor(this.latY(this.bounds.getNorth(), e.z)); const r = Math.ceil(this.lngX(this.bounds.getEast(), e.z)); const i = Math.ceil(this.latY(this.bounds.getSouth(), e.z)); return e.x >= t && e.x < r && e.y >= n && e.y < i; }, Xe.prototype.lngX = function (e, t) { return (e + 180) * (Math.pow(2, t) / 360); }, Xe.prototype.latY = function (t, n) { const r = e.clamp(Math.sin(Math.PI / 180 * t), -0.9999, 0.9999); const i = Math.pow(2, n) / (2 * Math.PI); return Math.pow(2, n - 1) + 0.5 * Math.log((1 + r) / (1 - r)) * -i; }; const Ye = (function (t) {
          function n(n, r, i, o) { if (t.call(this), this.id = n, this.dispatcher = i, this.type = 'vector', this.minzoom = 0, this.maxzoom = 22, this.scheme = 'xyz', this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, e.extend(this, e.pick(r, ['url', 'scheme', 'tileSize'])), this._options = e.extend({ type: 'vector' }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error('vector tile sources must have a tileSize of 512'); this.setEventedParent(o); } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.load = function () { const t = this; this.fire(new e.Event('dataloading', { dataType: 'source' })), u(this._options, this.map._transformRequest, (n, r) => { n ? t.fire(new e.ErrorEvent(n)) : r && (e.extend(t, r), r.bounds && (t.tileBounds = new Xe(r.bounds, t.minzoom, t.maxzoom)), t.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' })), t.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'content' }))); }); }, n.prototype.hasTile = function (e) { return !this.tileBounds || this.tileBounds.contains(e.canonical); }, n.prototype.onAdd = function (e) { this.map = e, this.load(); }, n.prototype.serialize = function () { return e.extend({}, this._options); }, n.prototype.loadTile = function (t, n) {
            function r(e, r) { return t.aborted ? n(null) : e ? n(e) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), n(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null))); } const i = Me(t.tileID.canonical.url(this.tiles, this.scheme), this.url); const o = {
              request: this.map._transformRequest(i, e.ResourceType.Tile), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: ge.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes,
            }; o.request.collectResourceTiming = this._collectResourceTiming, void 0 === t.workerID || t.state === 'expired' ? t.workerID = this.dispatcher.send('loadTile', o, r.bind(this)) : t.state === 'loading' ? t.reloadCallback = n : this.dispatcher.send('reloadTile', o, r.bind(this), t.workerID);
          }, n.prototype.abortTile = function (e) { this.dispatcher.send('abortTile', { uid: e.uid, type: this.type, source: this.id }, void 0, e.workerID); }, n.prototype.unloadTile = function (e) { e.unloadVectorData(), this.dispatcher.send('removeTile', { uid: e.uid, type: this.type, source: this.id }, void 0, e.workerID); }, n.prototype.hasTransition = function () { return !1; }, n;
        }(e.Evented)); const Je = (function (t) { function n(n, r, i, o) { t.call(this), this.id = n, this.dispatcher = i, this.setEventedParent(o), this.type = 'raster', this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = 'xyz', this.tileSize = 512, this._loaded = !1, this._options = e.extend({}, r), e.extend(this, e.pick(r, ['url', 'scheme', 'tileSize'])); } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.load = function () { const t = this; this.fire(new e.Event('dataloading', { dataType: 'source' })), u(this._options, this.map._transformRequest, (n, r) => { n ? t.fire(new e.ErrorEvent(n)) : r && (e.extend(t, r), r.bounds && (t.tileBounds = new Xe(r.bounds, t.minzoom, t.maxzoom)), t.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' })), t.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'content' }))); }); }, n.prototype.onAdd = function (e) { this.map = e, this.load(); }, n.prototype.serialize = function () { return e.extend({}, this._options); }, n.prototype.hasTile = function (e) { return !this.tileBounds || this.tileBounds.contains(e.canonical); }, n.prototype.loadTile = function (t, n) { const r = this; const i = Me(t.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize); t.request = e.getImage(this.map._transformRequest(i, e.ResourceType.Tile), (e, i) => { if (delete t.request, t.aborted)t.state = 'unloaded', n(null); else if (e)t.state = 'errored', n(e); else if (i) { r.map._refreshExpiredTiles && t.setExpiryData(i), delete i.cacheControl, delete i.expires; const o = r.map.painter.context; const a = o.gl; t.texture = r.map.painter.getTileTexture(i.width), t.texture ? t.texture.update(i, { useMipmap: !0 }) : (t.texture = new je(o, i, a.RGBA, { useMipmap: !0 }), t.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), o.extTextureFilterAnisotropic && a.texParameterf(a.TEXTURE_2D, o.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o.extTextureFilterAnisotropicMax)), t.state = 'loaded', n(null); } }); }, n.prototype.abortTile = function (e, t) { e.request && (e.request.abort(), delete e.request), t(); }, n.prototype.unloadTile = function (e, t) { e.texture && this.map.painter.saveTileTexture(e.texture), t(); }, n.prototype.hasTransition = function () { return !1; }, n; }(e.Evented)); const Qe = (function (t) {
          function n(n, r, i, o) { t.call(this, n, r, i, o), this.type = 'raster-dem', this.maxzoom = 22, this._options = e.extend({}, r), this.encoding = r.encoding || 'mapbox'; } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.serialize = function () {
            return {
              type: 'raster-dem', url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding,
            };
          }, n.prototype.loadTile = function (t, n) {
            const r = Me(t.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize); t.request = e.getImage(this.map._transformRequest(r, e.ResourceType.Tile), (e, r) => {
              if (delete t.request, t.aborted)t.state = 'unloaded', n(null); else if (e)t.state = 'errored', n(e); else if (r) {
                this.map._refreshExpiredTiles && t.setExpiryData(r), delete r.cacheControl, delete r.expires; const i = ge.getImageData(r); const o = {
                  uid: t.uid, coord: t.tileID, source: this.id, rawImageData: i, encoding: this.encoding,
                }; t.workerID && t.state !== 'expired' || (t.workerID = this.dispatcher.send('loadDEMTile', o, (e, r) => { e && (t.state = 'errored', n(e)), r && (t.dem = r, t.needsHillshadePrepare = !0, t.state = 'loaded', n(null)); }));
              }
            }), t.neighboringTiles = this._getNeighboringTiles(t.tileID);
          }, n.prototype._getNeighboringTiles = function (t) { const n = t.canonical; const r = Math.pow(2, n.z); const i = (n.x - 1 + r) % r; const o = n.x === 0 ? t.wrap - 1 : t.wrap; const a = (n.x + 1 + r) % r; const s = n.x + 1 === r ? t.wrap + 1 : t.wrap; const l = {}; return l[new e.OverscaledTileID(t.overscaledZ, o, n.z, i, n.y).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, s, n.z, a, n.y).key] = { backfilled: !1 }, n.y > 0 && (l[new e.OverscaledTileID(t.overscaledZ, o, n.z, i, n.y - 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, n.z, n.x, n.y - 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, s, n.z, a, n.y - 1).key] = { backfilled: !1 }), n.y + 1 < r && (l[new e.OverscaledTileID(t.overscaledZ, o, n.z, i, n.y + 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, n.z, n.x, n.y + 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, s, n.z, a, n.y + 1).key] = { backfilled: !1 }), l; }, n.prototype.unloadTile = function (e) { e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = 'unloaded', this.dispatcher.send('removeDEMTile', { uid: e.uid, source: this.id }, void 0, e.workerID); }, n;
        }(Je)); const et = (function (t) {
          function n(n, r, i, o) {
            t.call(this), this.id = n, this.type = 'geojson', this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this.dispatcher = i, this.setEventedParent(o), this._data = r.data, this._options = e.extend({}, r), this._collectResourceTiming = r.collectResourceTiming, this._resourceTiming = [], void 0 !== r.maxzoom && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type); const a = e.default$8 / this.tileSize; this.workerOptions = e.extend({
              source: this.id,
              cluster: r.cluster || !1,
              geojsonVtOptions: {
                buffer: (void 0 !== r.buffer ? r.buffer : 128) * a, tolerance: (void 0 !== r.tolerance ? r.tolerance : 0.375) * a, extent: e.default$8, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1,
              },
              superclusterOptions: {
                maxZoom: void 0 !== r.clusterMaxZoom ? Math.min(r.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, extent: e.default$8, radius: (r.clusterRadius || 50) * a, log: !1,
              },
            }, r.workerOptions);
          } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.load = function () { const t = this; this.fire(new e.Event('dataloading', { dataType: 'source' })), this._updateWorkerData((n) => { if (n)t.fire(new e.ErrorEvent(n)); else { const r = { dataType: 'source', sourceDataType: 'metadata' }; t._collectResourceTiming && t._resourceTiming && t._resourceTiming.length > 0 && (r.resourceTiming = t._resourceTiming, t._resourceTiming = []), t.fire(new e.Event('data', r)); } }); }, n.prototype.onAdd = function (e) { this.map = e, this.load(); }, n.prototype.setData = function (t) { const n = this; return this._data = t, this.fire(new e.Event('dataloading', { dataType: 'source' })), this._updateWorkerData((t) => { if (t) return n.fire(new e.ErrorEvent(t)); const r = { dataType: 'source', sourceDataType: 'content' }; n._collectResourceTiming && n._resourceTiming && n._resourceTiming.length > 0 && (r.resourceTiming = n._resourceTiming, n._resourceTiming = []), n.fire(new e.Event('data', r)); }), this; }, n.prototype._updateWorkerData = function (t) { let n; let r; const i = this; const o = e.extend({}, this.workerOptions); const a = this._data; typeof a === 'string' ? (o.request = this.map._transformRequest((n = a, (r = e.default.document.createElement('a')).href = n, r.href), e.ResourceType.Source), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = JSON.stringify(a), this.workerID = this.dispatcher.send(`${this.type}.${o.source}.loadData`, o, (e, n) => { i._removed || n && n.abandoned || (i._loaded = !0, n && n.resourceTiming && n.resourceTiming[i.id] && (i._resourceTiming = n.resourceTiming[i.id].slice(0)), i.dispatcher.send(`${i.type}.${o.source}.coalesce`, null, null, i.workerID), t(e)); }, this.workerID); }, n.prototype.loadTile = function (e, t) {
            const n = this; const r = void 0 === e.workerID ? 'loadTile' : 'reloadTile'; const i = {
              type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: ge.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes,
            }; e.workerID = this.dispatcher.send(r, i, (i, o) => e.unloadVectorData(), e.aborted ? t(null) : i ? t(i) : (e.loadVectorData(o, n.map.painter, 'reloadTile' === r), t(null)), this.workerID);
          }, n.prototype.abortTile = function (e) { e.aborted = !0; }, n.prototype.unloadTile = function (e) { e.unloadVectorData(), this.dispatcher.send('removeTile', { uid: e.uid, type: this.type, source: this.id }, null, e.workerID); }, n.prototype.onRemove = function () { this._removed = !0, this.dispatcher.send('removeSource', { type: this.type, source: this.id }, null, this.workerID); }, n.prototype.serialize = function () { return e.extend({}, this._options, { type: this.type, data: this._data }); }, n.prototype.hasTransition = function () { return !1; }, n;
        }(e.Evented)); const tt = e.createLayout([{ name: 'a_pos', type: 'Int16', components: 2 }, { name: 'a_texture_pos', type: 'Int16', components: 2 }]); var nt = function () { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null; }; nt.prototype.bind = function (e, t, n, r, i, o, a, s) { this.context = e; for (var l = this.boundPaintVertexBuffers.length !== r.length, u = 0; !l && u < r.length; u++) this.boundPaintVertexBuffers[u] !== r[u] && (l = !0); const c = !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== n || l || this.boundIndexBuffer !== i || this.boundVertexOffset !== o || this.boundDynamicVertexBuffer !== a || this.boundDynamicVertexBuffer2 !== s; !e.extVertexArrayObject || c ? this.freshBind(t, n, r, i, o, a, s) : (e.bindVertexArrayOES.set(this.vao), a && a.bind(), i && i.dynamicDraw && i.bind(), s && s.bind()); }, nt.prototype.freshBind = function (e, t, n, r, i, o, a) { let s; const l = e.numAttributes; const u = this.context; const c = u.gl; if (u.extVertexArrayObject) this.vao && this.destroy(), this.vao = u.extVertexArrayObject.createVertexArrayOES(), u.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = n, this.boundIndexBuffer = r, this.boundVertexOffset = i, this.boundDynamicVertexBuffer = o, this.boundDynamicVertexBuffer2 = a; else { s = u.currentNumAttributes || 0; for (let p = l; p < s; p++)c.disableVertexAttribArray(p); }t.enableAttributes(c, e); for (let f = 0, h = n; f < h.length; f += 1)h[f].enableAttributes(c, e); o && o.enableAttributes(c, e), a && a.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, i); for (let d = 0, m = n; d < m.length; d += 1) { const g = m[d]; g.bind(), g.setVertexAttribPointers(c, e, i); }o && (o.bind(), o.setVertexAttribPointers(c, e, i)), r && r.bind(), a && (a.bind(), a.setVertexAttribPointers(c, e, i)), u.currentNumAttributes = l; }, nt.prototype.destroy = function () { this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null); }; const rt = (function (t) { function n(e, n, r, i) { t.call(this), this.id = e, this.dispatcher = r, this.coordinates = n.coordinates, this.type = 'image', this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this.setEventedParent(i), this.options = n; } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.load = function () { const t = this; this.fire(new e.Event('dataloading', { dataType: 'source' })), this.url = this.options.url, e.getImage(this.map._transformRequest(this.url, e.ResourceType.Image), (n, r) => { n ? t.fire(new e.ErrorEvent(n)) : r && (t.image = ge.getImageData(r), t._finishLoading()); }); }, n.prototype._finishLoading = function () { this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'metadata' }))); }, n.prototype.onAdd = function (e) { this.map = e, this.load(); }, n.prototype.setCoordinates = function (t) { this.coordinates = t; const n = this.map; const r = t.map(e => n.transform.locationCoordinate(Ze.convert(e)).zoomTo(0)); const i = this.centerCoord = e.getCoordinatesCenter(r); i.column = Math.floor(i.column), i.row = Math.floor(i.row), this.tileID = new e.CanonicalTileID(i.zoom, i.column, i.row), this.minzoom = this.maxzoom = i.zoom; const o = r.map((t) => { const n = t.zoomTo(i.zoom); return new e.default$1(Math.round((n.column - i.column) * e.default$8), Math.round((n.row - i.row) * e.default$8)); }); return this._boundsArray = new e.RasterBoundsArray(), this._boundsArray.emplaceBack(o[0].x, o[0].y, 0, 0), this._boundsArray.emplaceBack(o[1].x, o[1].y, e.default$8, 0), this._boundsArray.emplaceBack(o[3].x, o[3].y, 0, e.default$8), this._boundsArray.emplaceBack(o[2].x, o[2].y, e.default$8, e.default$8), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new e.Event('data', { dataType: 'source', sourceDataType: 'content' })), this; }, n.prototype.prepare = function () { if (Object.keys(this.tiles).length !== 0 && this.image) { const e = this.map.painter.context; const t = e.gl; for (const n in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, tt.members)), this.boundsVAO || (this.boundsVAO = new nt()), this.texture || (this.texture = new je(e, this.image, t.RGBA), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE)), this.tiles) { const r = this.tiles[n]; r.state !== 'loaded' && (r.state = 'loaded', r.texture = this.texture); } } }, n.prototype.loadTile = function (e, t) { this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = 'errored', t(null)); }, n.prototype.serialize = function () { return { type: 'image', url: this.options.url, coordinates: this.coordinates }; }, n.prototype.hasTransition = function () { return !1; }, n; }(e.Evented)); const it = (function (t) { function n(e, n, r, i) { t.call(this, e, n, r, i), this.roundZoom = !0, this.type = 'video', this.options = n; } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.load = function () { const t = this; const n = this.options; this.urls = []; for (let r = 0, i = n.urls; r < i.length; r += 1) { const o = i[r]; t.urls.push(t.map._transformRequest(o, e.ResourceType.Source).url); }e.getVideo(this.urls, (n, r) => { n ? t.fire(new e.ErrorEvent(n)) : r && (t.video = r, t.video.loop = !0, t.video.addEventListener('playing', () => { t.map._rerender(); }), t.map && t.video.play(), t._finishLoading()); }); }, n.prototype.getVideo = function () { return this.video; }, n.prototype.onAdd = function (e) { this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))); }, n.prototype.prepare = function () { if (!(Object.keys(this.tiles).length === 0 || this.video.readyState < 2)) { const e = this.map.painter.context; const t = e.gl; for (const n in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, tt.members)), this.boundsVAO || (this.boundsVAO = new nt()), this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new je(e, this.video, t.RGBA), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE)), this.tiles) { const r = this.tiles[n]; r.state !== 'loaded' && (r.state = 'loaded', r.texture = this.texture); } } }, n.prototype.serialize = function () { return { type: 'video', urls: this.urls, coordinates: this.coordinates }; }, n.prototype.hasTransition = function () { return this.video && !this.video.paused; }, n; }(rt)); const ot = (function (t) { function n(n, r, i, o) { t.call(this, n, r, i, o), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some(e => !Array.isArray(e) || e.length !== 2 || e.some((e) => "number"!=typeof e)) || this.fire(new e.ErrorEvent(new e.default$9(`sources.${n}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.default$9(`sources.${n}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate !== 'boolean' && this.fire(new e.ErrorEvent(new e.default$9(`sources.${n}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas === 'string' || r.canvas instanceof e.default.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.default$9(`sources.${n}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.default$9(`sources.${n}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = void 0 === r.animate || r.animate; } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.load = function () { this.canvas || (this.canvas = this.options.canvas instanceof e.default.HTMLCanvasElement ? this.options.canvas : e.default.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error('Canvas dimensions cannot be less than or equal to zero.'))) : (this.play = function () { this._playing = !0, this.map._rerender(); }, this.pause = function () { this._playing = !1; }, this._finishLoading()); }, n.prototype.getCanvas = function () { return this.canvas; }, n.prototype.onAdd = function (e) { this.map = e, this.load(), this.canvas && this.animate && this.play(); }, n.prototype.onRemove = function () { this.pause(); }, n.prototype.prepare = function () { let e = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), !this._hasInvalidDimensions() && Object.keys(this.tiles).length !== 0) { const t = this.map.painter.context; const n = t.gl; for (const r in this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, tt.members)), this.boundsVAO || (this.boundsVAO = new nt()), this.texture ? e ? this.texture.update(this.canvas) : this._playing && (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.canvas)) : (this.texture = new je(t, this.canvas, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE)), this.tiles) { const i = this.tiles[r]; i.state !== 'loaded' && (i.state = 'loaded', i.texture = this.texture); } } }, n.prototype.serialize = function () { return { type: 'canvas', coordinates: this.coordinates }; }, n.prototype.hasTransition = function () { return this._playing; }, n.prototype._hasInvalidDimensions = function () { for (let e = 0, t = [this.canvas.width, this.canvas.height]; e < t.length; e += 1) { const n = t[e]; if (isNaN(n) || n <= 0) return !0; } return !1; }, n; }(rt)); const at = {
          vector: Ye, raster: Je, 'raster-dem': Qe, geojson: et, video: it, image: rt, canvas: ot,
        }; const st = function (t, n, r, i) { const o = new at[n.type](t, n, r, i); if (o.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${o.id}`); return e.bindAll(['load', 'abort', 'unload', 'serialize', 'prepare'], o), o; }; const lt = function (t, n) { this.tileID = t, this.uid = e.uniqueId(), this.uses = 0, this.tileSize = n, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.expiredRequestCount = 0, this.state = 'loading'; }; lt.prototype.registerFadeDuration = function (e) { const t = e + this.timeAdded; t < ge.now() || this.fadeEndTime && t < this.fadeEndTime || (this.fadeEndTime = t); }, lt.prototype.wasRequested = function () { return this.state === 'errored' || this.state === 'loaded' || this.state === 'reloading'; }, lt.prototype.loadVectorData = function (t, n, r) { if (this.hasData() && this.unloadVectorData(), this.state = 'loaded', t) { if (t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = (function (e, t) { const n = {}; if (!t) return n; for (let r = 0, i = e; r < i.length; r += 1) { const o = i[r]; const a = o.layerIds.map(e => t.getLayer(e)).filter(Boolean); if (a.length !== 0) { o.layers = a; for (let s = 0, l = a; s < l.length; s += 1)n[l[s].id] = o; } } return n; }(t.buckets, n.style)), r) for (const i in this.buckets) { const o = this.buckets[i]; o instanceof e.default$14 && (o.justReloaded = !0); } for (const a in this.queryPadding = 0, this.buckets) { const s = this.buckets[a]; this.queryPadding = Math.max(this.queryPadding, n.style.getLayer(s.layerIds[0]).queryRadius(s)); }t.iconAtlasImage && (this.iconAtlasImage = t.iconAtlasImage), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage); } else this.collisionBoxArray = new e.CollisionBoxArray(); }, lt.prototype.unloadVectorData = function () { for (const e in this.buckets) this.buckets[e].destroy(); this.buckets = {}, this.iconAtlasTexture && this.iconAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = 'unloaded'; }, lt.prototype.unloadDEMData = function () { this.dem = null, this.neighboringTiles = null, this.state = 'unloaded'; }, lt.prototype.getBucket = function (e) { return this.buckets[e.id]; }, lt.prototype.upload = function (e) { for (const t in this.buckets) { const n = this.buckets[t]; n.uploaded || (n.upload(e), n.uploaded = !0); } const r = e.gl; this.iconAtlasImage && (this.iconAtlasTexture = new je(e, this.iconAtlasImage, r.RGBA), this.iconAtlasImage = null), this.glyphAtlasImage && (this.glyphAtlasTexture = new je(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null); }, lt.prototype.queryRenderedFeatures = function (e, t, n, r, i, o, a) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
            queryGeometry: t, scale: n, tileSize: this.tileSize, posMatrix: a, transform: i, params: r, queryPadding: this.queryPadding * o,
          }, e) : {};
        }, lt.prototype.querySourceFeatures = function (t, n) { if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData) { const r = this.latestFeatureIndex.loadVTLayers(); const i = n ? n.sourceLayer : ''; const o = r._geojsonTileLayer || r[i]; if (o) for (let a = e.default$13(n && n.filter), s = { z: this.tileID.overscaledZ, x: this.tileID.canonical.x, y: this.tileID.canonical.y }, l = 0; l < o.length; l++) { const u = o.feature(l); if (a(new e.default$16(this.tileID.overscaledZ), u)) { const c = new e.default$12(u, s.z, s.x, s.y); c.tile = s, t.push(c); } } } }, lt.prototype.clearMask = function () { this.segments && (this.segments.destroy(), delete this.segments), this.maskedBoundsBuffer && (this.maskedBoundsBuffer.destroy(), delete this.maskedBoundsBuffer), this.maskedIndexBuffer && (this.maskedIndexBuffer.destroy(), delete this.maskedIndexBuffer); }, lt.prototype.setMask = function (t, n) {
          if (!e.default$10(this.mask, t) && (this.mask = t, this.clearMask(), !e.default$10(t, { 0: !0 }))) {
            const r = new e.RasterBoundsArray();


            const i = new e.TriangleIndexArray(); this.segments = new e.default$15(), this.segments.prepareSegment(0, r, i); for (let o = Object.keys(t), a = 0; a < o.length; a++) { const s = t[o[a]]; const l = e.default$8 >> s.z; const u = new e.default$1(s.x * l, s.y * l); const c = new e.default$1(u.x + l, u.y + l); const p = this.segments.prepareSegment(4, r, i); r.emplaceBack(u.x, u.y, u.x, u.y), r.emplaceBack(c.x, u.y, c.x, u.y), r.emplaceBack(u.x, c.y, u.x, c.y), r.emplaceBack(c.x, c.y, c.x, c.y); const f = p.vertexLength; i.emplaceBack(f, f + 1, f + 2), i.emplaceBack(f + 1, f + 2, f + 3), p.vertexLength += 4, p.primitiveLength += 2; } this.maskedBoundsBuffer = n.createVertexBuffer(r, tt.members), this.maskedIndexBuffer = n.createIndexBuffer(i);
          }
        }, lt.prototype.hasData = function () { return this.state === 'loaded' || this.state === 'reloading' || this.state === 'expired'; }, lt.prototype.setExpiryData = function (t) { const n = this.expirationTime; if (t.cacheControl) { const r = e.parseCacheControl(t.cacheControl); r['max-age'] && (this.expirationTime = Date.now() + 1e3 * r['max-age']); } else t.expires && (this.expirationTime = new Date(t.expires).getTime()); if (this.expirationTime) { const i = Date.now(); let o = !1; if (this.expirationTime > i)o = !1; else if (n) if (this.expirationTime < n)o = !0; else { const a = this.expirationTime - n; a ? this.expirationTime = i + Math.max(a, 3e4) : o = !0; } else o = !0; o ? (this.expiredRequestCount++, this.state = 'expired') : this.expiredRequestCount = 0; } }, lt.prototype.getExpiryTimeout = function () { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date()).getTime(), Math.pow(2, 31) - 1); }; const ut = function (e, t) { this.max = e, this.onRemove = t, this.reset(); }; ut.prototype.reset = function () { for (const e in this.data) for (let t = 0, n = this.data[e]; t < n.length; t += 1) { const r = n[t]; r.timeout && clearTimeout(r.timeout), this.onRemove(r.value); } return this.data = {}, this.order = [], this; }, ut.prototype.add = function (e, t, n) { const r = this; const i = e.wrapped().key; void 0 === this.data[i] && (this.data[i] = []); const o = { value: t, timeout: void 0 }; if (void 0 !== n && (o.timeout = setTimeout(() => { r.remove(e, o); }, n)), this.data[i].push(o), this.order.push(i), this.order.length > this.max) { const a = this._getAndRemoveByKey(this.order[0]); a && this.onRemove(a); } return this; }, ut.prototype.has = function (e) { return e.wrapped().key in this.data; }, ut.prototype.getAndRemove = function (e) { return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null; }, ut.prototype._getAndRemoveByKey = function (e) { const t = this.data[e].shift(); return t.timeout && clearTimeout(t.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value; }, ut.prototype.get = function (e) { return this.has(e) ? this.data[e.wrapped().key][0].value : null; }, ut.prototype.remove = function (e, t) { if (!this.has(e)) return this; const n = e.wrapped().key; const r = void 0 === t ? 0 : this.data[n].indexOf(t); const i = this.data[n][r]; return this.data[n].splice(r, 1), i.timeout && clearTimeout(i.timeout), this.data[n].length === 0 && delete this.data[n], this.onRemove(i.value), this.order.splice(this.order.indexOf(n), 1), this; }, ut.prototype.setMaxSize = function (e) { for (this.max = e; this.order.length > this.max;) { const t = this._getAndRemoveByKey(this.order[0]); t && this.onRemove(t); } return this; }; const ct = function (e, t, n) { this.context = e; const r = e.gl; this.buffer = r.createBuffer(), this.dynamicDraw = Boolean(n), this.unbindVAO(), e.bindElementBuffer.set(this.buffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer; }; ct.prototype.unbindVAO = function () { this.context.extVertexArrayObject && this.context.bindVertexArrayOES.set(null); }, ct.prototype.bind = function () { this.context.bindElementBuffer.set(this.buffer); }, ct.prototype.updateData = function (e) { const t = this.context.gl; this.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer); }, ct.prototype.destroy = function () { const e = this.context.gl; this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer); }; const pt = {
          Int8: 'BYTE', Uint8: 'UNSIGNED_BYTE', Int16: 'SHORT', Uint16: 'UNSIGNED_SHORT', Int32: 'INT', Uint32: 'UNSIGNED_INT', Float32: 'FLOAT',
        }; const ft = function (e, t, n, r) { this.length = t.length, this.attributes = n, this.itemSize = t.bytesPerElement, this.dynamicDraw = r, this.context = e; const i = e.gl; this.buffer = i.createBuffer(), e.bindVertexBuffer.set(this.buffer), i.bufferData(i.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer; }; ft.prototype.bind = function () { this.context.bindVertexBuffer.set(this.buffer); }, ft.prototype.updateData = function (e) { const t = this.context.gl; this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer); }, ft.prototype.enableAttributes = function (e, t) { for (let n = 0; n < this.attributes.length; n++) { const r = this.attributes[n]; const i = t.attributes[r.name]; void 0 !== i && e.enableVertexAttribArray(i); } }, ft.prototype.setVertexAttribPointers = function (e, t, n) { for (let r = 0; r < this.attributes.length; r++) { const i = this.attributes[r]; const o = t.attributes[i.name]; void 0 !== o && e.vertexAttribPointer(o, i.components, e[pt[i.type]], !1, this.itemSize, i.offset + this.itemSize * (n || 0)); } }, ft.prototype.destroy = function () { const e = this.context.gl; this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer); }; const ht = function (t) { this.context = t, this.current = e.default$6.transparent; }; ht.prototype.get = function () { return this.current; }, ht.prototype.set = function (e) { const t = this.current; e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a || (this.context.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e); }; const dt = function (e) { this.context = e, this.current = 1; }; dt.prototype.get = function () { return this.current; }, dt.prototype.set = function (e) { this.current !== e && (this.context.gl.clearDepth(e), this.current = e); }; const mt = function (e) { this.context = e, this.current = 0; }; mt.prototype.get = function () { return this.current; }, mt.prototype.set = function (e) { this.current !== e && (this.context.gl.clearStencil(e), this.current = e); }; const gt = function (e) { this.context = e, this.current = [!0, !0, !0, !0]; }; gt.prototype.get = function () { return this.current; }, gt.prototype.set = function (e) { const t = this.current; e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] || (this.context.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e); }; const yt = function (e) { this.context = e, this.current = !0; }; yt.prototype.get = function () { return this.current; }, yt.prototype.set = function (e) { this.current !== e && (this.context.gl.depthMask(e), this.current = e); }; const vt = function (e) { this.context = e, this.current = 255; }; vt.prototype.get = function () { return this.current; }, vt.prototype.set = function (e) { this.current !== e && (this.context.gl.stencilMask(e), this.current = e); }; const _t = function (e) { this.context = e, this.current = { func: e.gl.ALWAYS, ref: 0, mask: 255 }; }; _t.prototype.get = function () { return this.current; }, _t.prototype.set = function (e) { const t = this.current; e.func === t.func && e.ref === t.ref && e.mask === t.mask || (this.context.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e); }; const bt = function (e) { this.context = e; const t = this.context.gl; this.current = [t.KEEP, t.KEEP, t.KEEP]; }; bt.prototype.get = function () { return this.current; }, bt.prototype.set = function (e) { const t = this.current; e[0] === t[0] && e[1] === t[1] && e[2] === t[2] || (this.context.gl.stencilOp(e[0], e[1], e[2]), this.current = e); }; const xt = function (e) { this.context = e, this.current = !1; }; xt.prototype.get = function () { return this.current; }, xt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e; } }; const wt = function (e) { this.context = e, this.current = [0, 1]; }; wt.prototype.get = function () { return this.current; }, wt.prototype.set = function (e) { const t = this.current; e[0] === t[0] && e[1] === t[1] || (this.context.gl.depthRange(e[0], e[1]), this.current = e); }; const Et = function (e) { this.context = e, this.current = !1; }; Et.prototype.get = function () { return this.current; }, Et.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e; } }; const Tt = function (e) { this.context = e, this.current = e.gl.LESS; }; Tt.prototype.get = function () { return this.current; }, Tt.prototype.set = function (e) { this.current !== e && (this.context.gl.depthFunc(e), this.current = e); }; const kt = function (e) { this.context = e, this.current = !1; }; kt.prototype.get = function () { return this.current; }, kt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e; } }; const Ct = function (e) { this.context = e; const t = this.context.gl; this.current = [t.ONE, t.ZERO]; }; Ct.prototype.get = function () { return this.current; }, Ct.prototype.set = function (e) { const t = this.current; e[0] === t[0] && e[1] === t[1] || (this.context.gl.blendFunc(e[0], e[1]), this.current = e); }; const St = function (t) { this.context = t, this.current = e.default$6.transparent; }; St.prototype.get = function () { return this.current; }, St.prototype.set = function (e) { const t = this.current; e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a || (this.context.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e); }; const At = function (e) { this.context = e, this.current = null; }; At.prototype.get = function () { return this.current; }, At.prototype.set = function (e) { this.current !== e && (this.context.gl.useProgram(e), this.current = e); }; const Ot = function (e) { this.context = e, this.current = 1; }; Ot.prototype.get = function () { return this.current; }, Ot.prototype.set = function (t) { const n = this.context.lineWidthRange; const r = e.clamp(t, n[0], n[1]); this.current !== r && (this.context.gl.lineWidth(r), this.current = t); }; const It = function (e) { this.context = e, this.current = e.gl.TEXTURE0; }; It.prototype.get = function () { return this.current; }, It.prototype.set = function (e) { this.current !== e && (this.context.gl.activeTexture(e), this.current = e); }; const Pt = function (e) { this.context = e; const t = this.context.gl; this.current = [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]; }; Pt.prototype.get = function () { return this.current; }, Pt.prototype.set = function (e) { const t = this.current; e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] || (this.context.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e); }; const Mt = function (e) { this.context = e, this.current = null; }; Mt.prototype.get = function () { return this.current; }, Mt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e; } }; const Nt = function (e) { this.context = e, this.current = null; }; Nt.prototype.get = function () { return this.current; }, Nt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e; } }; const Dt = function (e) { this.context = e, this.current = null; }; Dt.prototype.get = function () { return this.current; }, Dt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; t.bindTexture(t.TEXTURE_2D, e), this.current = e; } }; const Lt = function (e) { this.context = e, this.current = null; }; Lt.prototype.get = function () { return this.current; }, Lt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e; } }; const zt = function (e) { this.context = e, this.current = null; }; zt.prototype.get = function () { return this.current; }, zt.prototype.set = function (e) { const t = this.context.gl; t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e; }; const Rt = function (e) { this.context = e, this.current = null; }; Rt.prototype.get = function () { return this.current; }, Rt.prototype.set = function (e) { this.current !== e && this.context.extVertexArrayObject && (this.context.extVertexArrayObject.bindVertexArrayOES(e), this.current = e); }; const jt = function (e) { this.context = e, this.current = 4; }; jt.prototype.get = function () { return this.current; }, jt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e; } }; const Bt = function (e) { this.context = e, this.current = !1; }; Bt.prototype.get = function () { return this.current; }, Bt.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e; } }; const Ft = function (e, t) { this.context = e, this.current = null, this.parent = t; }; Ft.prototype.get = function () { return this.current; }; const Ut = (function (e) { function t(t, n) { e.call(this, t, n), this.dirty = !1; } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.set = function (e) { if (this.dirty || this.current !== e) { const t = this.context.gl; this.context.bindFramebuffer.set(this.parent), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1; } }, t.prototype.setDirty = function () { this.dirty = !0; }, t; }(Ft)); const Vt = (function (e) { function t() { e.apply(this, arguments); } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.set = function (e) { if (this.current !== e) { const t = this.context.gl; this.context.bindFramebuffer.set(this.parent), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e), this.current = e; } }, t; }(Ft)); const qt = function (e, t, n) { this.context = e, this.width = t, this.height = n; const r = e.gl; const i = this.framebuffer = r.createFramebuffer(); this.colorAttachment = new Ut(e, i), this.depthAttachment = new Vt(e, i); }; qt.prototype.destroy = function () { const e = this.context.gl; const t = this.colorAttachment.get(); t && e.deleteTexture(t); const n = this.depthAttachment.get(); n && e.deleteRenderbuffer(n), e.deleteFramebuffer(this.framebuffer); }; var Ht = function (e, t, n) { this.func = e, this.mask = t, this.range = n; }; Ht.ReadOnly = !1, Ht.ReadWrite = !0, Ht.disabled = new Ht(519, Ht.ReadOnly, [0, 1]); var Wt = function (e, t, n, r, i, o) { this.test = e, this.ref = t, this.mask = n, this.fail = r, this.depthFail = i, this.pass = o; }; Wt.disabled = new Wt({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680); const $t = function (e, t, n) { this.blendFunction = e, this.blendColor = t, this.mask = n; }; $t.Replace = [1, 0], $t.disabled = new $t($t.Replace, e.default$6.transparent, [!1, !1, !1, !1]), $t.unblended = new $t($t.Replace, e.default$6.transparent, [!0, !0, !0, !0]), $t.alphaBlended = new $t([1, 771], e.default$6.transparent, [!0, !0, !0, !0]); const Gt = function (e) { this.gl = e, this.extVertexArrayObject = this.gl.getExtension('OES_vertex_array_object'), this.lineWidthRange = e.getParameter(e.ALIASED_LINE_WIDTH_RANGE), this.clearColor = new ht(this), this.clearDepth = new dt(this), this.clearStencil = new mt(this), this.colorMask = new gt(this), this.depthMask = new yt(this), this.stencilMask = new vt(this), this.stencilFunc = new _t(this), this.stencilOp = new bt(this), this.stencilTest = new xt(this), this.depthRange = new wt(this), this.depthTest = new Et(this), this.depthFunc = new Tt(this), this.blend = new kt(this), this.blendFunc = new Ct(this), this.blendColor = new St(this), this.program = new At(this), this.lineWidth = new Ot(this), this.activeTexture = new It(this), this.viewport = new Pt(this), this.bindFramebuffer = new Mt(this), this.bindRenderbuffer = new Nt(this), this.bindTexture = new Dt(this), this.bindVertexBuffer = new Lt(this), this.bindElementBuffer = new zt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new Rt(this), this.pixelStoreUnpack = new jt(this), this.pixelStoreUnpackPremultiplyAlpha = new Bt(this), this.extTextureFilterAnisotropic = e.getExtension('EXT_texture_filter_anisotropic') || e.getExtension('MOZ_EXT_texture_filter_anisotropic') || e.getExtension('WEBKIT_EXT_texture_filter_anisotropic'), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = e.getExtension('OES_texture_half_float'), this.extTextureHalfFloat && e.getExtension('OES_texture_half_float_linear'); }; Gt.prototype.createIndexBuffer = function (e, t) { return new ct(this, e, t); }, Gt.prototype.createVertexBuffer = function (e, t, n) { return new ft(this, e, t, n); }, Gt.prototype.createRenderbuffer = function (e, t, n) { const r = this.gl; const i = r.createRenderbuffer(); return this.bindRenderbuffer.set(i), r.renderbufferStorage(r.RENDERBUFFER, e, t, n), this.bindRenderbuffer.set(null), i; }, Gt.prototype.createFramebuffer = function (e, t) { return new qt(this, e, t); }, Gt.prototype.clear = function (e) { const t = e.color; const n = e.depth; const r = this.gl; let i = 0; t && (i |= r.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), void 0 !== n && (i |= r.DEPTH_BUFFER_BIT, this.clearDepth.set(n), this.depthMask.set(!0)), r.clear(i); }, Gt.prototype.setDepthMode = function (e) { e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1); }, Gt.prototype.setStencilMode = function (e) { e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1); }, Gt.prototype.setColorMode = function (t) { e.default$10(t.blendFunction, $t.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask); }; const Zt = (function (t) {
          function n(e, n, r) { const i = this; t.call(this), this.id = e, this.dispatcher = r, this.on('data', (e) => { e.dataType === 'source' && e.sourceDataType === 'metadata' && (i._sourceLoaded = !0), i._sourceLoaded && !i._paused && e.dataType === 'source' && e.sourceDataType === 'content' && (i.reload(), i.transform && i.update(i.transform)); }), this.on('error', () => { i._sourceErrored = !0; }), this._source = st(e, n, r, this), this._tiles = {}, this._cache = new ut(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._isIdRenderable = this._isIdRenderable.bind(this), this._coveredTiles = {}; } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.onAdd = function (e) { this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(e); }, n.prototype.onRemove = function (e) { this._source && this._source.onRemove && this._source.onRemove(e); }, n.prototype.loaded = function () { if (this._sourceErrored) return !0; if (!this._sourceLoaded) return !1; for (const e in this._tiles) { const t = this._tiles[e]; if (t.state !== 'loaded' && t.state !== 'errored') return !1; } return !0; }, n.prototype.getSource = function () { return this._source; }, n.prototype.pause = function () { this._paused = !0; }, n.prototype.resume = function () { if (this._paused) { const e = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform); } }, n.prototype._loadTile = function (e, t) { return this._source.loadTile(e, t); }, n.prototype._unloadTile = function (e) { if (this._source.unloadTile) return this._source.unloadTile(e, () => {}); }, n.prototype._abortTile = function (e) { if (this._source.abortTile) return this._source.abortTile(e, () => {}); }, n.prototype.serialize = function () { return this._source.serialize(); }, n.prototype.prepare = function (e) { for (const t in this._source.prepare && this._source.prepare(), this._tiles) this._tiles[t].upload(e); }, n.prototype.getIds = function () { const t = this; return Object.keys(this._tiles).map(Number).sort((n, r) => { const i = t._tiles[n].tileID; const o = t._tiles[r].tileID; const a = new e.default$1(i.canonical.x, i.canonical.y).rotate(t.transform.angle); const s = new e.default$1(o.canonical.x, o.canonical.y).rotate(t.transform.angle); return i.overscaledZ - o.overscaledZ || s.y - a.y || s.x - a.x; }); }, n.prototype.getRenderableIds = function () { return this.getIds().filter(this._isIdRenderable); }, n.prototype.hasRenderableParent = function (e) { const t = this.findLoadedParent(e, 0, {}); return !!t && this._isIdRenderable(t.tileID.key); }, n.prototype._isIdRenderable = function (e) { return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e]; }, n.prototype.reload = function () { if (this._paused) this._shouldReloadOnResume = !0; else for (const e in this._cache.reset(), this._tiles) this._reloadTile(e, 'reloading'); }, n.prototype._reloadTile = function (e, t) { const n = this._tiles[e]; n && (n.state !== 'loading' && (n.state = t), this._loadTile(n, this._tileLoaded.bind(this, n, e, t))); }, n.prototype._tileLoaded = function (t, n, r, i) { if (i) return t.state = 'errored', void (i.status !== 404 ? this._source.fire(new e.ErrorEvent(i, { tile: t })) : this.update(this.transform)); t.timeAdded = ge.now(), r === 'expired' && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(n, t), this.getSource().type === 'raster-dem' && t.dem && this._backfillDEM(t), this._source.fire(new e.Event('data', { dataType: 'source', tile: t, coord: t.tileID })), this.map && (this.map.painter.tileExtentVAO.vao = null); }, n.prototype._backfillDEM = function (e) { function t(e, t) { e.needsHillshadePrepare = !0; let n = t.tileID.canonical.x - e.tileID.canonical.x; const r = t.tileID.canonical.y - e.tileID.canonical.y; const i = Math.pow(2, e.tileID.canonical.z); const o = t.tileID.key; n === 0 && r === 0 || Math.abs(r) > 1 || (Math.abs(n) > 1 && (Math.abs(n + i) === 1 ? n += i : Math.abs(n - i) === 1 && (n -= i)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, n, r), e.neighboringTiles && e.neighboringTiles[o] && (e.neighboringTiles[o].backfilled = !0))); } for (let n = this.getRenderableIds(), r = 0; r < n.length; r++) { const i = n[r]; if (e.neighboringTiles && e.neighboringTiles[i]) { const o = this.getTileByID(i); t(e, o), t(o, e); } } }, n.prototype.getTile = function (e) { return this.getTileByID(e.key); }, n.prototype.getTileByID = function (e) { return this._tiles[e]; }, n.prototype.getZoom = function (e) { return e.zoom + e.scaleZoom(e.tileSize / this._source.tileSize); }, n.prototype._findLoadedChildren = function (e, t, n) { let r = !1; for (const i in this._tiles) { let o = this._tiles[i]; if (!(n[i] || !o.hasData() || o.tileID.overscaledZ <= e.overscaledZ || o.tileID.overscaledZ > t)) { const a = Math.pow(2, o.tileID.canonical.z - e.canonical.z); if (Math.floor(o.tileID.canonical.x / a) === e.canonical.x && Math.floor(o.tileID.canonical.y / a) === e.canonical.y) for (n[i] = o.tileID, r = !0; o && o.tileID.overscaledZ - 1 > e.overscaledZ;) { const s = o.tileID.scaledTo(o.tileID.overscaledZ - 1); if (!s) break; (o = this._tiles[s.key]) && o.hasData() && (delete n[i], n[s.key] = s); } } } return r; }, n.prototype.findLoadedParent = function (e, t, n) { for (let r = e.overscaledZ - 1; r >= t; r--) { const i = e.scaledTo(r); if (!i) return; const o = String(i.key); const a = this._tiles[o]; if (a && a.hasData()) return n[o] = i, a; if (this._cache.has(i)) return n[o] = i, this._cache.get(i); } }, n.prototype.updateCacheSize = function (e) { const t = (Math.ceil(e.width / this._source.tileSize) + 1) * (Math.ceil(e.height / this._source.tileSize) + 1); const n = Math.floor(5 * t); const r = typeof this._maxTileCacheSize === 'number' ? Math.min(this._maxTileCacheSize, n) : n; this._cache.setMaxSize(r); }, n.prototype.handleWrapJump = function (e) { const t = (e - (void 0 === this._prevLng ? e : this._prevLng)) / 360; const n = Math.round(t); if (this._prevLng = e, n) { const r = {}; for (const i in this._tiles) { const o = this._tiles[i]; o.tileID = o.tileID.unwrapTo(o.tileID.wrap + n), r[o.tileID.key] = o; } for (const a in this._tiles = r, this._timers)clearTimeout(this._timers[a]), delete this._timers[a]; for (const s in this._tiles) { const l = this._tiles[s]; this._setTileReloadTimer(s, l); } } }, n.prototype.update = function (t) {
            const r = this; if (this.transform = t, this._sourceLoaded && !this._paused) {
              let i; this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? i = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new e.OverscaledTileID(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y)) : (i = t.coveringTiles({
                tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled,
              }), this._source.hasTile && (i = i.filter(e => r._source.hasTile(e)))) : i = []; let o; const a = (this._source.roundZoom ? Math.round : Math.floor)(this.getZoom(t)); const s = Math.max(a - n.maxOverzooming, this._source.minzoom); const l = Math.max(a + n.maxUnderzooming, this._source.minzoom); const u = this._updateRetainedTiles(i, a); const c = {}; if (h(this._source.type)) for (let p = Object.keys(u), f = 0; f < p.length; f++) { const d = p[f]; const m = u[d]; const g = r._tiles[d]; if (g && (void 0 === g.fadeEndTime || g.fadeEndTime >= ge.now())) { r._findLoadedChildren(m, l, u) && (u[d] = m); const y = r.findLoadedParent(m, s, c); y && r._addTile(y.tileID); } } for (o in c)u[o] || (r._coveredTiles[o] = !0); for (o in c)u[o] = c[o]; for (let v = e.keysDifference(this._tiles, u), _ = 0; _ < v.length; _++)r._removeTile(v[_]);
            }
          }, n.prototype._updateRetainedTiles = function (e, t) { for (var r = {}, i = {}, o = Math.max(t - n.maxOverzooming, this._source.minzoom), a = Math.max(t + n.maxUnderzooming, this._source.minzoom), s = 0; s < e.length; s++) { const l = e[s]; let u = this._addTile(l); let c = !1; if (u.hasData())r[l.key] = l; else { c = u.wasRequested(), r[l.key] = l; let p = !0; if (t + 1 > this._source.maxzoom) { const f = l.children(this._source.maxzoom)[0]; const h = this.getTile(f); h && h.hasData() ? r[f.key] = f : p = !1; } else { this._findLoadedChildren(l, a, r); for (let d = l.children(this._source.maxzoom), m = 0; m < d.length; m++) if (!r[d[m].key]) { p = !1; break; } } if (!p) for (let g = l.overscaledZ - 1; g >= o; --g) { const y = l.scaledTo(g); if (i[y.key]) break; if (i[y.key] = !0, !(u = this.getTile(y)) && c && (u = this._addTile(y)), u && (r[y.key] = y, c = u.wasRequested(), u.hasData())) break; } } } return r; }, n.prototype._addTile = function (t) { let n = this._tiles[t.key]; if (n) return n; (n = this._cache.getAndRemove(t)) && (this._setTileReloadTimer(t.key, n), n.tileID = t); const r = Boolean(n); return r || (n = new lt(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(n, this._tileLoaded.bind(this, n, t.key, n.state))), n ? (n.uses++, this._tiles[t.key] = n, r || this._source.fire(new e.Event('dataloading', { tile: n, coord: n.tileID, dataType: 'source' })), n) : null; }, n.prototype._setTileReloadTimer = function (e, t) { const n = this; e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]); const r = t.getExpiryTimeout(); r && (this._timers[e] = setTimeout(() => { n._reloadTile(e, 'expired'), delete n._timers[e]; }, r)); }, n.prototype._removeTile = function (e) { const t = this._tiles[e]; t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t.uses > 0 || (t.hasData() ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t)))); }, n.prototype.clearTiles = function () { for (const e in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) this._removeTile(e); this._cache.reset(); }, n.prototype.tilesIn = function (t, n) {
            for (var r = [], i = this.getIds(), o = 1 / 0, a = 1 / 0, s = -1 / 0, l = -1 / 0, u = t[0].zoom, c = 0; c < t.length; c++) { const p = t[c]; o = Math.min(o, p.column), a = Math.min(a, p.row), s = Math.max(s, p.column), l = Math.max(l, p.row); } for (let h = 0; h < i.length; h++) {
              const d = this._tiles[i[h]]; const m = d.tileID; const g = Math.pow(2, this.transform.zoom - d.tileID.overscaledZ); const y = n * d.queryPadding * e.default$8 / d.tileSize / g; const v = [f(m, new e.default$17(o, a, u)), f(m, new e.default$17(s, l, u))]; if (v[0].x - y < e.default$8 && v[0].y - y < e.default$8 && v[1].x + y >= 0 && v[1].y + y >= 0) {
                for (var _ = [], b = 0; b < t.length; b++)_.push(f(m, t[b])); r.push({
                  tile: d, tileID: m, queryGeometry: [_], scale: g,
                });
              }
            } return r;
          }, n.prototype.getVisibleCoordinates = function () { for (var e = this, t = this.getRenderableIds().map(t => e._tiles[t].tileID), n = 0, r = t; n < r.length; n += 1) { const i = r[n]; i.posMatrix = e.transform.calculatePosMatrix(i.toUnwrapped()); } return t; }, n.prototype.hasTransition = function () { if (this._source.hasTransition()) return !0; if (h(this._source.type)) for (const e in this._tiles) { const t = this._tiles[e]; if (void 0 !== t.fadeEndTime && t.fadeEndTime >= ge.now()) return !0; } return !1; }, n;
        }(e.Evented)); Zt.maxOverzooming = 10, Zt.maxUnderzooming = 3; let Kt; const Xt = function () { this.active = {}; }; Xt.prototype.acquire = function (e) { if (!this.workers) { const t = Or.workerCount; for (this.workers = []; this.workers.length < t;) this.workers.push(new d()); } return this.active[e] = !0, this.workers.slice(); }, Xt.prototype.release = function (e) { delete this.active[e], Object.keys(this.active).length === 0 && (this.workers.forEach((e) => { e.terminate(); }), this.workers = null); }; var Yt = {
          setStyle: 'setStyle', addLayer: 'addLayer', removeLayer: 'removeLayer', setPaintProperty: 'setPaintProperty', setLayoutProperty: 'setLayoutProperty', setFilter: 'setFilter', addSource: 'addSource', removeSource: 'removeSource', setGeoJSONSourceData: 'setGeoJSONSourceData', setLayerZoomRange: 'setLayerZoomRange', setLayerProperty: 'setLayerProperty', setCenter: 'setCenter', setZoom: 'setZoom', setBearing: 'setBearing', setPitch: 'setPitch', setSprite: 'setSprite', setGlyphs: 'setGlyphs', setTransition: 'setTransition', setLight: 'setLight',
        }; const Jt = function (e, t, n) { const r = this.boxCells = []; const i = this.circleCells = []; this.xCellCount = Math.ceil(e / n), this.yCellCount = Math.ceil(t / n); for (let o = 0; o < this.xCellCount * this.yCellCount; o++)r.push([]), i.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0; }; Jt.prototype.keysLength = function () { return this.boxKeys.length + this.circleKeys.length; }, Jt.prototype.insert = function (e, t, n, r, i) { this._forEachCell(t, n, r, i, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(n), this.bboxes.push(r), this.bboxes.push(i); }, Jt.prototype.insertCircle = function (e, t, n, r) { this._forEachCell(t - r, n - r, t + r, n + r, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(n), this.circles.push(r); }, Jt.prototype._insertBoxCell = function (e, t, n, r, i, o) { this.boxCells[i].push(o); }, Jt.prototype._insertCircleCell = function (e, t, n, r, i, o) { this.circleCells[i].push(o); }, Jt.prototype._query = function (e, t, n, r, i) {
          if (n < 0 || e > this.width || r < 0 || t > this.height) return !i && []; const o = []; if (e <= 0 && t <= 0 && this.width <= n && this.height <= r) {
            if (i) return !0; for (let a = 0; a < this.boxKeys.length; a++) {
              o.push({
                key: this.boxKeys[a], x1: this.bboxes[4 * a], y1: this.bboxes[4 * a + 1], x2: this.bboxes[4 * a + 2], y2: this.bboxes[4 * a + 3],
              });
            } for (let s = 0; s < this.circleKeys.length; s++) {
              const l = this.circles[3 * s]; const u = this.circles[3 * s + 1]; const c = this.circles[3 * s + 2]; o.push({
                key: this.circleKeys[s], x1: l - c, y1: u - c, x2: l + c, y2: u + c,
              });
            }
          } else { const p = { hitTest: i, seenUids: { box: {}, circle: {} } }; this._forEachCell(e, t, n, r, this._queryCell, o, p); } return i ? o.length > 0 : o;
        }, Jt.prototype._queryCircle = function (e, t, n, r) { const i = e - n; const o = e + n; const a = t - n; const s = t + n; if (o < 0 || i > this.width || s < 0 || a > this.height) return !r && []; const l = []; const u = { hitTest: r, circle: { x: e, y: t, radius: n }, seenUids: { box: {}, circle: {} } }; return this._forEachCell(i, a, o, s, this._queryCellCircle, l, u), r ? l.length > 0 : l; }, Jt.prototype.query = function (e, t, n, r) { return this._query(e, t, n, r, !1); }, Jt.prototype.hitTest = function (e, t, n, r) { return this._query(e, t, n, r, !0); }, Jt.prototype.hitTestCircle = function (e, t, n) { return this._queryCircle(e, t, n, !0); }, Jt.prototype._queryCell = function (e, t, n, r, i, o, a) {
          const s = a.seenUids; const l = this.boxCells[i]; if (l !== null) {
            for (let u = this.bboxes, c = 0, p = l; c < p.length; c += 1) {
              const f = p[c]; if (!s.box[f]) {
                s.box[f] = !0; const h = 4 * f; if (e <= u[h + 2] && t <= u[h + 3] && n >= u[h + 0] && r >= u[h + 1]) {
                  if (a.hitTest) return o.push(!0), !0; o.push({
                    key: this.boxKeys[f], x1: u[h], y1: u[h + 1], x2: u[h + 2], y2: u[h + 3],
                  });
                }
              }
            }
          } const d = this.circleCells[i]; if (d !== null) {
            for (let m = this.circles, g = 0, y = d; g < y.length; g += 1) {
              const v = y[g]; if (!s.circle[v]) {
                s.circle[v] = !0; const _ = 3 * v; if (this._circleAndRectCollide(m[_], m[_ + 1], m[_ + 2], e, t, n, r)) {
                  if (a.hitTest) return o.push(!0), !0; const b = m[_]; const x = m[_ + 1]; const w = m[_ + 2]; o.push({
                    key: this.circleKeys[v], x1: b - w, y1: x - w, x2: b + w, y2: x + w,
                  });
                }
              }
            }
          }
        }, Jt.prototype._queryCellCircle = function (e, t, n, r, i, o, a) { const s = a.circle; const l = a.seenUids; const u = this.boxCells[i]; if (u !== null) for (let c = this.bboxes, p = 0, f = u; p < f.length; p += 1) { const h = f[p]; if (!l.box[h]) { l.box[h] = !0; const d = 4 * h; if (this._circleAndRectCollide(s.x, s.y, s.radius, c[d + 0], c[d + 1], c[d + 2], c[d + 3])) return o.push(!0), !0; } } const m = this.circleCells[i]; if (m !== null) for (let g = this.circles, y = 0, v = m; y < v.length; y += 1) { const _ = v[y]; if (!l.circle[_]) { l.circle[_] = !0; const b = 3 * _; if (this._circlesCollide(g[b], g[b + 1], g[b + 2], s.x, s.y, s.radius)) return o.push(!0), !0; } } }, Jt.prototype._forEachCell = function (e, t, n, r, i, o, a) { for (let s = this._convertToXCellCoord(e), l = this._convertToYCellCoord(t), u = this._convertToXCellCoord(n), c = this._convertToYCellCoord(r), p = s; p <= u; p++) for (let f = l; f <= c; f++) { const h = this.xCellCount * f + p; if (i.call(this, e, t, n, r, h, o, a)) return; } }, Jt.prototype._convertToXCellCoord = function (e) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale))); }, Jt.prototype._convertToYCellCoord = function (e) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale))); }, Jt.prototype._circlesCollide = function (e, t, n, r, i, o) { const a = r - e; const s = i - t; const l = n + o; return l * l > a * a + s * s; }, Jt.prototype._circleAndRectCollide = function (e, t, n, r, i, o, a) { const s = (o - r) / 2; const l = Math.abs(e - (r + s)); if (l > s + n) return !1; const u = (a - i) / 2; const c = Math.abs(t - (i + u)); if (c > u + n) return !1; if (l <= s || c <= u) return !0; const p = l - s; const f = c - u; return p * p + f * f <= n * n; }; var Qt = e.default$19.layout; var en = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]); e.default$20.mat4; const tn = function (e, t, n) { void 0 === t && (t = new Jt(e.width + 200, e.height + 200, 25)), void 0 === n && (n = new Jt(e.width + 200, e.height + 200, 25)), this.transform = e, this.grid = t, this.ignoredGrid = n, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + 100, this.screenBottomBoundary = e.height + 100; }; tn.prototype.placeCollisionBox = function (e, t, n, r) { const i = this.projectAndGetPerspectiveRatio(r, e.anchorPointX, e.anchorPointY); const o = n * i.perspectiveRatio; const a = e.x1 * o + i.point.x; const s = e.y1 * o + i.point.y; const l = e.x2 * o + i.point.x; const u = e.y2 * o + i.point.y; return !t && this.grid.hitTest(a, s, l, u) ? { box: [], offscreen: !1 } : { box: [a, s, l, u], offscreen: this.isOffscreen(a, s, l, u) }; }, tn.prototype.approximateTileDistance = function (e, t, n, r, i) { const o = i ? 1 : r / this.pitchfactor; const a = e.lastSegmentViewportDistance * n; return e.prevTileDistance + a + (o - 1) * a * Math.abs(Math.sin(t)); }, tn.prototype.placeCollisionCircles = function (t, n, r, i, o, a, s, l, u, c, p, f, h) { const d = []; const m = this.projectAnchor(c, a.anchorX, a.anchorY); const g = u / 24; const y = a.lineOffsetX * u; const v = a.lineOffsetY * u; const _ = new e.default$1(a.anchorX, a.anchorY); const b = I(g, l, y, v, !1, S(_, p).point, _, a, s, p, {}, !0); let x = !1; let w = !0; const E = m.perspectiveRatio * i; const T = 1 / (i * r); let k = 0; let C = 0; b && (k = this.approximateTileDistance(b.first.tileDistance, b.first.angle, T, m.cameraDistance, h), C = this.approximateTileDistance(b.last.tileDistance, b.last.angle, T, m.cameraDistance, h)); for (let A = 0; A < t.length; A += 5) { const O = t[A]; const P = t[A + 1]; const M = t[A + 2]; const N = t[A + 3]; if (!b || N < -k || N > C)R(t, A, !1); else { const D = this.projectPoint(c, O, P); const L = M * E; if (d.length > 0) { const z = D.x - d[d.length - 4]; const j = D.y - d[d.length - 3]; if (L * L * 2 > z * z + j * j && A + 8 < t.length) { const B = t[A + 8]; if (B > -k && B < C) { R(t, A, !1); continue; } } } const F = A / 5; if (d.push(D.x, D.y, L, F), R(t, A, !0), w = w && this.isOffscreen(D.x - L, D.y - L, D.x + L, D.y + L), !n && this.grid.hitTestCircle(D.x, D.y, L)) { if (!f) return { circles: [], offscreen: !1 }; x = !0; } } } return { circles: x ? [] : d, offscreen: w }; }, tn.prototype.queryRenderedSymbols = function (t) { if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {}; for (var n = [], r = 1 / 0, i = 1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t; s < l.length; s += 1) { const u = l[s]; const c = new e.default$1(u.x + 100, u.y + 100); r = Math.min(r, c.x), i = Math.min(i, c.y), o = Math.max(o, c.x), a = Math.max(a, c.y), n.push(c); } for (var p = {}, f = {}, h = 0, d = this.grid.query(r, i, o, a).concat(this.ignoredGrid.query(r, i, o, a)); h < d.length; h += 1) { const m = d[h]; const g = m.key; if (void 0 === p[g.bucketInstanceId] && (p[g.bucketInstanceId] = {}), !p[g.bucketInstanceId][g.featureIndex]) { const y = [new e.default$1(m.x1, m.y1), new e.default$1(m.x2, m.y1), new e.default$1(m.x2, m.y2), new e.default$1(m.x1, m.y2)]; e.polygonIntersectsPolygon(n, y) && (p[g.bucketInstanceId][g.featureIndex] = !0, void 0 === f[g.bucketInstanceId] && (f[g.bucketInstanceId] = []), f[g.bucketInstanceId].push(g.featureIndex)); } } return f; }, tn.prototype.insertCollisionBox = function (e, t, n, r) { const i = { bucketInstanceId: n, featureIndex: r }; (t ? this.ignoredGrid : this.grid).insert(i, e[0], e[1], e[2], e[3]); }, tn.prototype.insertCollisionCircles = function (e, t, n, r) { for (let i = t ? this.ignoredGrid : this.grid, o = { bucketInstanceId: n, featureIndex: r }, a = 0; a < e.length; a += 4)i.insertCircle(o, e[a], e[a + 1], e[a + 2]); }, tn.prototype.projectAnchor = function (e, t, n) { const r = [t, n, 0, 1]; return z(r, r, e), { perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / r[3] * 0.5, cameraDistance: r[3] }; }, tn.prototype.projectPoint = function (t, n, r) { const i = [n, r, 0, 1]; return z(i, i, t), new e.default$1((i[0] / i[3] + 1) / 2 * this.transform.width + 100, (-i[1] / i[3] + 1) / 2 * this.transform.height + 100); }, tn.prototype.projectAndGetPerspectiveRatio = function (t, n, r) { const i = [n, r, 0, 1]; return z(i, i, t), { point: new e.default$1((i[0] / i[3] + 1) / 2 * this.transform.width + 100, (-i[1] / i[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / i[3] * 0.5 }; }, tn.prototype.isOffscreen = function (e, t, n, r) { return n < 100 || e >= this.screenRightBoundary || r < 100 || t > this.screenBottomBoundary; }; const nn = e.default$19.layout; const rn = function (e, t, n, r) { this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : r && n ? 1 : 0, this.placed = n; }; rn.prototype.isHidden = function () { return this.opacity === 0 && !this.placed; }; const on = function (e, t, n, r, i) { this.text = new rn(e ? e.text : null, t, n, i), this.icon = new rn(e ? e.icon : null, t, r, i); }; on.prototype.isHidden = function () { return this.text.isHidden() && this.icon.isHidden(); }; const an = function (e, t, n) { this.text = e, this.icon = t, this.skipFade = n; }; const sn = function (e, t) { this.transform = e.clone(), this.collisionIndex = new tn(this.transform), this.placements = {}, this.opacities = {}, this.stale = !1, this.fadeDuration = t, this.retainedQueryData = {}; }; sn.prototype.placeLayerTile = function (t, n, r, i) { const o = n.getBucket(t); const a = n.latestFeatureIndex; if (o && a && t.id === o.layerIds[0]) { const s = n.collisionBoxArray; const l = o.layers[0].layout; const u = Math.pow(2, this.transform.zoom - n.tileID.overscaledZ); const c = n.tileSize / e.default$8; const p = this.transform.calculatePosMatrix(n.tileID.toUnwrapped()); const f = k(p, l.get('text-pitch-alignment') === 'map', l.get('text-rotation-alignment') === 'map', this.transform, j(n, 1, this.transform.zoom)); const h = k(p, l.get('icon-pitch-alignment') === 'map', l.get('icon-rotation-alignment') === 'map', this.transform, j(n, 1, this.transform.zoom)); this.retainedQueryData[o.bucketInstanceId] = new function (e, t, n, r, i) { this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = n, this.bucketIndex = r, this.tileID = i; }(o.bucketInstanceId, a, o.sourceLayerIndex, o.index, n.tileID), this.placeLayerBucket(o, p, f, h, u, c, r, i, s); } }, sn.prototype.placeLayerBucket = function (t, n, r, i, o, a, s, l, u) { for (let c = t.layers[0].layout, p = e.evaluateSizeForZoom(t.textSizeData, this.transform.zoom, nn.properties['text-size']), f = !t.hasTextData() || c.get('text-optional'), h = !t.hasIconData() || c.get('icon-optional'), d = 0, m = t.symbolInstances; d < m.length; d += 1) { const g = m[d]; if (!l[g.crossTileID]) { let y = void 0 !== g.feature.text; let v = void 0 !== g.feature.icon; let _ = !0; let b = null; let x = null; let w = null; let E = 0; let T = 0; g.collisionArrays || (g.collisionArrays = t.deserializeCollisionBoxes(u, g.textBoxStartIndex, g.textBoxEndIndex, g.iconBoxStartIndex, g.iconBoxEndIndex)), g.collisionArrays.textFeatureIndex && (E = g.collisionArrays.textFeatureIndex), g.collisionArrays.textBox && (y = (b = this.collisionIndex.placeCollisionBox(g.collisionArrays.textBox, c.get('text-allow-overlap'), a, n)).box.length > 0, _ = _ && b.offscreen); const k = g.collisionArrays.textCircles; if (k) { const C = t.text.placedSymbolArray.get(g.placedTextSymbolIndices[0]); const S = e.evaluateSizeForFeature(t.textSizeData, p, C); x = this.collisionIndex.placeCollisionCircles(k, c.get('text-allow-overlap'), o, a, g.key, C, t.lineVertexArray, t.glyphOffsetArray, S, n, r, s, c.get('text-pitch-alignment') === 'map'), y = c.get('text-allow-overlap') || x.circles.length > 0, _ = _ && x.offscreen; }g.collisionArrays.iconFeatureIndex && (T = g.collisionArrays.iconFeatureIndex), g.collisionArrays.iconBox && (v = (w = this.collisionIndex.placeCollisionBox(g.collisionArrays.iconBox, c.get('icon-allow-overlap'), a, n)).box.length > 0, _ = _ && w.offscreen), f || h ? h ? f || (v = v && y) : y = v && y : v = y = v && y, y && b && this.collisionIndex.insertCollisionBox(b.box, c.get('text-ignore-placement'), t.bucketInstanceId, E), v && w && this.collisionIndex.insertCollisionBox(w.box, c.get('icon-ignore-placement'), t.bucketInstanceId, T), y && x && this.collisionIndex.insertCollisionCircles(x.circles, c.get('text-ignore-placement'), t.bucketInstanceId, E), this.placements[g.crossTileID] = new an(y, v, _ || t.justReloaded), l[g.crossTileID] = !0; } }t.justReloaded = !1; }, sn.prototype.commit = function (e, t) { this.commitTime = t; let n = !1; const r = e && this.fadeDuration !== 0 ? (this.commitTime - e.commitTime) / this.fadeDuration : 1; const i = e ? e.opacities : {}; for (const o in this.placements) { const a = this.placements[o]; const s = i[o]; s ? (this.opacities[o] = new on(s, r, a.text, a.icon), n = n || a.text !== s.text.placed || a.icon !== s.icon.placed) : (this.opacities[o] = new on(null, r, a.text, a.icon, a.skipFade), n = n || a.text || a.icon); } for (const l in i) { const u = i[l]; if (!this.opacities[l]) { const c = new on(u, r, !1, !1); c.isHidden() || (this.opacities[l] = c, n = n || u.text.placed || u.icon.placed); } }n ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime !== 'number' && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t); }, sn.prototype.updateLayerOpacities = function (e, t) { for (let n = {}, r = 0, i = t; r < i.length; r += 1) { const o = i[r]; const a = o.getBucket(e); a && o.latestFeatureIndex && e.id === a.layerIds[0] && this.updateBucketOpacities(a, n, o.collisionBoxArray); } }, sn.prototype.updateBucketOpacities = function (e, t, n) { e.hasTextData() && e.text.opacityVertexArray.clear(), e.hasIconData() && e.icon.opacityVertexArray.clear(), e.hasCollisionBoxData() && e.collisionBox.collisionVertexArray.clear(), e.hasCollisionCircleData() && e.collisionCircle.collisionVertexArray.clear(); for (let r = e.layers[0].layout, i = new on(null, 0, !1, !1, !0), o = new on(null, 0, r.get('text-allow-overlap'), r.get('icon-allow-overlap'), !0), a = 0; a < e.symbolInstances.length; a++) { const s = e.symbolInstances[a]; const l = t[s.crossTileID]; let u = this.opacities[s.crossTileID]; l ? u = i : u || (u = o, this.opacities[s.crossTileID] = u), t[s.crossTileID] = !0; const c = s.numGlyphVertices > 0 || s.numVerticalGlyphVertices > 0; const p = s.numIconVertices > 0; if (c) { for (let f = F(u.text), h = (s.numGlyphVertices + s.numVerticalGlyphVertices) / 4, d = 0; d < h; d++)e.text.opacityVertexArray.emplaceBack(f); for (let m = 0, g = s.placedTextSymbolIndices; m < g.length; m += 1) { const y = g[m]; e.text.placedSymbolArray.get(y).hidden = u.text.isHidden(); } } if (p) { for (let v = F(u.icon), _ = 0; _ < s.numIconVertices / 4; _++)e.icon.opacityVertexArray.emplaceBack(v); e.icon.placedSymbolArray.get(a).hidden = u.icon.isHidden(); }s.collisionArrays || (s.collisionArrays = e.deserializeCollisionBoxes(n, s.textBoxStartIndex, s.textBoxEndIndex, s.iconBoxStartIndex, s.iconBoxEndIndex)); const b = s.collisionArrays; if (b) { b.textBox && e.hasCollisionBoxData() && B(e.collisionBox.collisionVertexArray, u.text.placed, !1), b.iconBox && e.hasCollisionBoxData() && B(e.collisionBox.collisionVertexArray, u.icon.placed, !1); const x = b.textCircles; if (x && e.hasCollisionCircleData()) for (let w = 0; w < x.length; w += 5) { const E = l || x[w + 4] === 0; B(e.collisionCircle.collisionVertexArray, u.text.placed, E); } } }e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasCollisionBoxData() && e.collisionBox.collisionVertexBuffer && e.collisionBox.collisionVertexBuffer.updateData(e.collisionBox.collisionVertexArray), e.hasCollisionCircleData() && e.collisionCircle.collisionVertexBuffer && e.collisionCircle.collisionVertexBuffer.updateData(e.collisionCircle.collisionVertexArray); }, sn.prototype.symbolFadeChange = function (e) { return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration; }, sn.prototype.hasTransitions = function (e) { return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration; }, sn.prototype.stillRecent = function (e) { return this.commitTime !== 'undefined' && this.commitTime + this.fadeDuration > e; }, sn.prototype.setStale = function () { this.stale = !0; }; var ln = Math.pow(2, 25); var un = Math.pow(2, 24); var cn = Math.pow(2, 17); var pn = Math.pow(2, 16); var fn = Math.pow(2, 9); var hn = Math.pow(2, 8); var dn = Math.pow(2, 1); const mn = function () { this._currentTileIndex = 0, this._seenCrossTileIDs = {}; }; mn.prototype.continuePlacement = function (e, t, n, r, i) { for (;this._currentTileIndex < e.length;) { const o = e[this._currentTileIndex]; if (t.placeLayerTile(r, o, n, this._seenCrossTileIDs), this._currentTileIndex++, i()) return !0; } }; const gn = function (e, t, n, r, i) { this.placement = new sn(e, i), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = n, this._showCollisionBoxes = r, this._done = !1; }; gn.prototype.isDone = function () { return this._done; }, gn.prototype.continuePlacement = function (e, t, n) { for (var r = this, i = ge.now(), o = function () { const e = ge.now() - i; return !r._forceFullPlacement && e > 2; }; this._currentPlacementIndex >= 0;) { const a = t[e[r._currentPlacementIndex]]; const s = r.placement.collisionIndex.transform.zoom; if (a.type === 'symbol' && (!a.minzoom || a.minzoom <= s) && (!a.maxzoom || a.maxzoom > s)) { if (r._inProgressLayer || (r._inProgressLayer = new mn()), r._inProgressLayer.continuePlacement(n[a.source], r.placement, r._showCollisionBoxes, a, o)) return; delete r._inProgressLayer; }r._currentPlacementIndex--; } this._done = !0; }, gn.prototype.commit = function (e, t) { return this.placement.commit(e, t), this.placement; }; const yn = 512 / e.default$8 / 2; const vn = function (e, t, n) { this.tileID = e, this.indexedSymbolInstances = {}, this.bucketInstanceId = n; for (let r = 0, i = t; r < i.length; r += 1) { const o = i[r]; const a = o.key; this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({ crossTileID: o.crossTileID, coord: this.getScaledCoordinates(o, e) }); } }; vn.prototype.getScaledCoordinates = function (t, n) { const r = n.canonical.z - this.tileID.canonical.z; const i = yn / Math.pow(2, r); const o = t.anchor; return { x: Math.floor((n.canonical.x * e.default$8 + o.x) * i), y: Math.floor((n.canonical.y * e.default$8 + o.y) * i) }; }, vn.prototype.findMatches = function (e, t, n) { for (let r = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z), i = 0, o = e; i < o.length; i += 1) { const a = o[i]; if (!a.crossTileID) { const s = this.indexedSymbolInstances[a.key]; if (s) for (let l = this.getScaledCoordinates(a, t), u = 0, c = s; u < c.length; u += 1) { const p = c[u]; if (Math.abs(p.coord.x - l.x) <= r && Math.abs(p.coord.y - l.y) <= r && !n[p.crossTileID]) { n[p.crossTileID] = !0, a.crossTileID = p.crossTileID; break; } } } } }; const _n = function () { this.maxCrossTileID = 0; }; _n.prototype.generate = function () { return ++this.maxCrossTileID; }; const bn = function () { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0; }; bn.prototype.handleWrapJump = function (e) { const t = Math.round((e - this.lng) / 360); if (t !== 0) for (const n in this.indexes) { const r = this.indexes[n]; const i = {}; for (const o in r) { const a = r[o]; a.tileID = a.tileID.unwrapTo(a.tileID.wrap + t), i[a.tileID.key] = a; } this.indexes[n] = i; } this.lng = e; }, bn.prototype.addBucket = function (e, t, n) { if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) { if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]); } for (let r = 0, i = t.symbolInstances; r < i.length; r += 1)i[r].crossTileID = 0; this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {}); const o = this.usedCrossTileIDs[e.overscaledZ]; for (const a in this.indexes) { const s = this.indexes[a]; if (Number(a) > e.overscaledZ) for (const l in s) { const u = s[l]; u.tileID.isChildOf(e) && u.findMatches(t.symbolInstances, e, o); } else { const c = s[e.scaledTo(Number(a)).key]; c && c.findMatches(t.symbolInstances, e, o); } } for (let p = 0, f = t.symbolInstances; p < f.length; p += 1) { const h = f[p]; h.crossTileID || (h.crossTileID = n.generate(), o[h.crossTileID] = !0); } return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new vn(e, t.symbolInstances, t.bucketInstanceId), !0; }, bn.prototype.removeBucketCrossTileIDs = function (e, t) { for (const n in t.indexedSymbolInstances) for (let r = 0, i = t.indexedSymbolInstances[n]; r < i.length; r += 1) { const o = i[r]; delete this.usedCrossTileIDs[e][o.crossTileID]; } }, bn.prototype.removeStaleBuckets = function (e) { let t = !1; for (const n in this.indexes) { const r = this.indexes[n]; for (const i in r)e[r[i].bucketInstanceId] || (this.removeBucketCrossTileIDs(n, r[i]), delete r[i], t = !0); } return t; }; const xn = function () { this.layerIndexes = {}, this.crossTileIDs = new _n(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}; }; xn.prototype.addLayer = function (e, t, n) { let r = this.layerIndexes[e.id]; void 0 === r && (r = this.layerIndexes[e.id] = new bn()); let i = !1; const o = {}; r.handleWrapJump(n); for (let a = 0, s = t; a < s.length; a += 1) { const l = s[a]; const u = l.getBucket(e); u && e.id === u.layerIds[0] && (u.bucketInstanceId || (u.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(l.tileID, u, this.crossTileIDs) && (i = !0), o[u.bucketInstanceId] = !0); } return r.removeStaleBuckets(o) && (i = !0), i; }, xn.prototype.pruneUnusedLayers = function (e) { const t = {}; for (const n in e.forEach((e) => { t[e] = !0; }), this.layerIndexes)t[n] || delete this.layerIndexes[n]; }; const wn = function (t, n) { return e.emitValidationErrors(t, n && n.filter(e => e.identifier !== 'source.canvas')); }; const En = e.pick(Yt, ['addLayer', 'removeLayer', 'setPaintProperty', 'setLayoutProperty', 'setFilter', 'addSource', 'removeSource', 'setLayerZoomRange', 'setLight', 'setTransition', 'setGeoJSONSourceData']); const Tn = e.pick(Yt, ['setCenter', 'setZoom', 'setBearing', 'setPitch']); const kn = (function (t) {
          function o(n, r) { const i = this; void 0 === r && (r = {}), t.call(this), this.map = n, this.dispatcher = new Ge((Kt || (Kt = new Xt()), Kt), this), this.imageManager = new Be(), this.glyphManager = new Ve(n._transformRequest, r.localIdeographFontFamily), this.lineAtlas = new $e(256, 512), this.crossTileSymbolIndex = new xn(), this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new e.default$23(), this._loaded = !1, this._resetUpdates(); const a = this; this._rtlTextPluginCallback = o.registerForPluginAvailability((e) => { for (const t in a.dispatcher.broadcast('loadRTLTextPlugin', e.pluginURL, e.completionCallback), a.sourceCaches)a.sourceCaches[t].reload(); }), this.on('data', (e) => { if (e.dataType === 'source' && e.sourceDataType === 'metadata') { const t = i.sourceCaches[e.sourceId]; if (t) { const n = t.getSource(); if (n && n.vectorLayerIds) for (const r in i._layers) { const o = i._layers[r]; o.source === n.id && i._validateLayer(o); } } } }); } return t && (o.__proto__ = t), o.prototype = Object.create(t && t.prototype), o.prototype.constructor = o, o.prototype.loadURL = function (t, o) { const a = this; void 0 === o && (o = {}), this.fire(new e.Event('dataloading', { dataType: 'style' })); const s = typeof o.validate === 'boolean' ? o.validate : !r(t); t = (function (e, t) { if (!r(e)) return e; const o = i(e); return o.path = `/styles/v1${o.path}`, n(o, t); }(t, o.accessToken)); const l = this.map._transformRequest(t, e.ResourceType.Style); e.getJSON(l, (t, n) => { t ? a.fire(new e.ErrorEvent(t)) : n && a._load(n, s); }); }, o.prototype.loadJSON = function (t, n) { const r = this; void 0 === n && (n = {}), this.fire(new e.Event('dataloading', { dataType: 'style' })), ge.frame(() => { r._load(t, !1 !== n.validate); }); }, o.prototype._load = function (t, n) { const r = this; if (!n || !wn(this, e.validateStyle(t))) { for (const i in this._loaded = !0, this.stylesheet = t, t.sources)r.addSource(i, t.sources[i], { validate: !1 }); t.sprite ? (function (t, n, r) { function i() { if (s)r(s); else if (o && a) { const t = ge.getImageData(a); const n = {}; for (const i in o) { const l = o[i]; const u = l.width; const c = l.height; const p = l.x; const f = l.y; const h = l.sdf; const d = l.pixelRatio; const m = new e.RGBAImage({ width: u, height: c }); e.RGBAImage.copy(t, m, { x: p, y: f }, { x: 0, y: 0 }, { width: u, height: c }), n[i] = { data: m, pixelRatio: d, sdf: h }; }r(null, n); } } let o; let a; let s; const l = ge.devicePixelRatio > 1 ? '@2x' : ''; e.getJSON(n(Ie(t, l, '.json'), e.ResourceType.SpriteJSON), (e, t) => { s || (s = e, o = t, i()); }), e.getImage(n(Ie(t, l, '.png'), e.ResourceType.SpriteImage), (e, t) => { s || (s = e, a = t, i()); }); }(t.sprite, this.map._transformRequest, (t, n) => { if (t)r.fire(new e.ErrorEvent(t)); else if (n) for (const i in n)r.imageManager.addImage(i, n[i]); r.imageManager.setLoaded(!0), r.fire(new e.Event('data', { dataType: 'style' })); })) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(t.glyphs); const o = g(this.stylesheet.layers); this._order = o.map(e => e.id), this._layers = {}; for (let a = 0, s = o; a < s.length; a += 1) { let l = s[a]; (l = e.default$22(l)).setEventedParent(r, { layer: { id: l.id } }), r._layers[l.id] = l; } this.dispatcher.broadcast('setLayers', this._serializeLayers(this._order)), this.light = new We(this.stylesheet.light), this.fire(new e.Event('data', { dataType: 'style' })), this.fire(new e.Event('style.load')); } }, o.prototype._validateLayer = function (t) { const n = this.sourceCaches[t.source]; if (n) { const r = t.sourceLayer; if (r) { const i = n.getSource(); (i.type === 'geojson' || i.vectorLayerIds && i.vectorLayerIds.indexOf(r) === -1) && this.fire(new e.ErrorEvent(new Error(`Source layer "${r}" does not exist on source "${i.id}" as specified by style layer "${t.id}"`))); } } }, o.prototype.loaded = function () { if (!this._loaded) return !1; if (Object.keys(this._updatedSources).length) return !1; for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1; return !!this.imageManager.isLoaded(); }, o.prototype._serializeLayers = function (e) { const t = this; return e.map(e => t._layers[e].serialize()); }, o.prototype.hasTransitions = function () { if (this.light && this.light.hasTransition()) return !0; for (const e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0; for (const t in this._layers) if (this._layers[t].hasTransition()) return !0; return !1; }, o.prototype._checkLoaded = function () { if (!this._loaded) throw new Error('Style is not done loading'); }, o.prototype.update = function (t) { if (this._loaded) { if (this._changed) { const n = Object.keys(this._updatedLayers); const r = Object.keys(this._removedLayers); for (const i in (n.length || r.length) && this._updateWorkerLayers(n, r), this._updatedSources) { const o = this._updatedSources[i]; o === 'reload' ? this._reloadSource(i) : o === 'clear' && this._clearSource(i); } for (const a in this._updatedPaintProps) this._layers[a].updateTransitions(t); this.light.updateTransitions(t), this._resetUpdates(), this.fire(new e.Event('data', { dataType: 'style' })); } for (const s in this.sourceCaches) this.sourceCaches[s].used = !1; for (let l = 0, u = this._order; l < u.length; l += 1) { const c = u[l]; const p = this._layers[c]; p.recalculate(t), !p.isHidden(t.zoom) && p.source && (this.sourceCaches[p.source].used = !0); } this.light.recalculate(t), this.z = t.zoom; } }, o.prototype._updateWorkerLayers = function (e, t) { this.dispatcher.broadcast('updateLayers', { layers: this._serializeLayers(e), removedIds: t }); }, o.prototype._resetUpdates = function () { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}; }, o.prototype.setState = function (t) { const n = this; if (this._checkLoaded(), wn(this, e.validateStyle(t))) return !1; (t = e.clone(t)).layers = g(t.layers); const r = T(this.serialize(), t).filter(e => !(e.command in Tn)); if (r.length === 0) return !1; const i = r.filter(e => !(e.command in En)); if (i.length > 0) throw new Error(`Unimplemented: ${i.map(e => e.command).join(', ')}.`); return r.forEach((e) => { e.command !== 'setTransition' && n[e.command](...e.args); }), this.stylesheet = t, !0; }, o.prototype.addImage = function (t, n) { if (this.getImage(t)) return this.fire(new e.ErrorEvent(new Error('An image with this name already exists.'))); this.imageManager.addImage(t, n), this.fire(new e.Event('data', { dataType: 'style' })); }, o.prototype.getImage = function (e) { return this.imageManager.getImage(e); }, o.prototype.removeImage = function (t) { if (!this.getImage(t)) return this.fire(new e.ErrorEvent(new Error('No image with this name exists.'))); this.imageManager.removeImage(t), this.fire(new e.Event('data', { dataType: 'style' })); }, o.prototype.addSource = function (t, n, r) { const i = this; if (this._checkLoaded(), void 0 !== this.sourceCaches[t]) throw new Error('There is already a source with this ID'); if (!n.type) throw new Error(`The type property must be defined, but the only the following properties were given: ${Object.keys(n).join(', ')}.`); if (!(['vector', 'raster', 'geojson', 'video', 'image'].indexOf(n.type) >= 0) || !this._validate(e.validateStyle.source, `sources.${t}`, n, null, r)) { this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0); const o = this.sourceCaches[t] = new Zt(t, n, this.dispatcher); o.style = this, o.setEventedParent(this, () => ({ isSourceLoaded: i.loaded(), source: o.serialize(), sourceId: t })), o.onAdd(this.map), this._changed = !0; } }, o.prototype.removeSource = function (t) { if (this._checkLoaded(), void 0 === this.sourceCaches[t]) throw new Error('There is no source with this ID'); for (const n in this._layers) if (this._layers[n].source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${n}" is using it.`))); const r = this.sourceCaches[t]; delete this.sourceCaches[t], delete this._updatedSources[t], r.fire(new e.Event('data', { sourceDataType: 'metadata', dataType: 'source', sourceId: t })), r.setEventedParent(null), r.clearTiles(), r.onRemove && r.onRemove(this.map), this._changed = !0; }, o.prototype.setGeoJSONSourceData = function (e, t) { this._checkLoaded(), this.sourceCaches[e].getSource().setData(t), this._changed = !0; }, o.prototype.getSource = function (e) { return this.sourceCaches[e] && this.sourceCaches[e].getSource(); }, o.prototype.addLayer = function (t, n, r) { this._checkLoaded(); const i = t.id; if (this.getLayer(i)) this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" already exists on this map`))); else if (typeof t.source === 'object' && (this.addSource(i, t.source), t = e.clone(t), t = e.extend(t, { source: i })), !this._validate(e.validateStyle.layer, `layers.${i}`, t, { arrayIndex: -1 }, r)) { const o = e.default$22(t); this._validateLayer(o), o.setEventedParent(this, { layer: { id: i } }); const a = n ? this._order.indexOf(n) : this._order.length; if (n && a === -1) this.fire(new e.ErrorEvent(new Error(`Layer with id "${n}" does not exist on this map.`))); else { if (this._order.splice(a, 0, i), this._layerOrderChanged = !0, this._layers[i] = o, this._removedLayers[i] && o.source) { const s = this._removedLayers[i]; delete this._removedLayers[i], s.type !== o.type ? this._updatedSources[o.source] = 'clear' : (this._updatedSources[o.source] = 'reload', this.sourceCaches[o.source].pause()); } this._updateLayer(o); } } }, o.prototype.moveLayer = function (t, n) { if (this._checkLoaded(), this._changed = !0, this._layers[t]) { if (t !== n) { const r = this._order.indexOf(t); this._order.splice(r, 1); const i = n ? this._order.indexOf(n) : this._order.length; n && i === -1 ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${n}" does not exist on this map.`))) : (this._order.splice(i, 0, t), this._layerOrderChanged = !0); } } else this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`))); }, o.prototype.removeLayer = function (t) { this._checkLoaded(); const n = this._layers[t]; if (n) { n.setEventedParent(null); const r = this._order.indexOf(t); this._order.splice(r, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = n, delete this._layers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t]; } else this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`))); }, o.prototype.getLayer = function (e) { return this._layers[e]; }, o.prototype.setLayerZoomRange = function (t, n, r) { this._checkLoaded(); const i = this.getLayer(t); i ? i.minzoom === n && i.maxzoom === r || (n != null && (i.minzoom = n), r != null && (i.maxzoom = r), this._updateLayer(i)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`))); }, o.prototype.setFilter = function (t, n) { this._checkLoaded(); const r = this.getLayer(t); if (r) { if (!e.default$10(r.filter, n)) return n == null ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(e.validateStyle.filter, `layers.${r.id}.filter`, n) || (r.filter = e.clone(n), this._updateLayer(r))); } else this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be filtered.`))); }, o.prototype.getFilter = function (t) { return e.clone(this.getLayer(t).filter); }, o.prototype.setLayoutProperty = function (t, n, r) { this._checkLoaded(); const i = this.getLayer(t); i ? e.default$10(i.getLayoutProperty(n), r) || (i.setLayoutProperty(n, r), this._updateLayer(i)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`))); }, o.prototype.getLayoutProperty = function (e, t) { return this.getLayer(e).getLayoutProperty(t); }, o.prototype.setPaintProperty = function (t, n, r) { this._checkLoaded(); const i = this.getLayer(t); if (i) { if (!e.default$10(i.getPaintProperty(n), r)) { const o = i._transitionablePaint._values[n].value.isDataDriven(); i.setPaintProperty(n, r), (i._transitionablePaint._values[n].value.isDataDriven() || o) && this._updateLayer(i), this._changed = !0, this._updatedPaintProps[t] = !0; } } else this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`))); }, o.prototype.getPaintProperty = function (e, t) { return this.getLayer(e).getPaintProperty(t); }, o.prototype.getTransition = function () { return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition); }, o.prototype.serialize = function () {
            const t = this; return e.filterObject({
              version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: e.mapObject(this.sourceCaches, e => e.serialize()), layers: this._order.map(e => t._layers[e].serialize()),
            }, e => void 0 !== e);
          }, o.prototype._updateLayer = function (e) { this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && (this._updatedSources[e.source] = 'reload', this.sourceCaches[e.source].pause()), this._changed = !0; }, o.prototype._flattenRenderedFeatures = function (e) { for (var t = [], n = this._order.length - 1; n >= 0; n--) for (let r = this._order[n], i = 0, o = e; i < o.length; i += 1) { const a = o[i][r]; if (a) for (let s = 0, l = a; s < l.length; s += 1) { const u = l[s]; t.push(u); } } return t; }, o.prototype.queryRenderedFeatures = function (t, n, r) { n && n.filter && this._validate(e.validateStyle.filter, 'queryRenderedFeatures.filter', n.filter); const i = {}; if (n && n.layers) { if (!Array.isArray(n.layers)) return this.fire(new e.ErrorEvent(new Error('parameters.layers must be an Array.'))), []; for (let o = 0, a = n.layers; o < a.length; o += 1) { const s = a[o]; const l = this._layers[s]; if (!l) return this.fire(new e.ErrorEvent(new Error(`The layer '${s}' does not exist in the map's style and cannot be queried for features.`))), []; i[l.source] = !0; } } const u = []; for (const f in this.sourceCaches)n.layers && !i[f] || u.push(c(this.sourceCaches[f], this._layers, t.worldCoordinate, n, r)); return this.placement && u.push(function (e, t, n, r, i) { for (var o = {}, a = r.queryRenderedSymbols(t), s = [], l = 0, u = Object.keys(a).map(Number); l < u.length; l += 1) { const c = u[l]; s.push(i[c]); }s.sort(p); for (var f = 0, h = s; f < h.length; f += 1)!(function () { const t = h[f]; const r = t.featureIndex.lookupSymbolFeatures(a[t.bucketInstanceId], t.bucketIndex, t.sourceLayerIndex, n.filter, n.layers, e); for (const i in r) { const s = o[i] = o[i] || []; const l = r[i]; l.sort((e, n) => { const r = t.featureSortOrder; if (r) { const i = r.indexOf(e.featureIndex); return r.indexOf(n.featureIndex) - i; } return n.featureIndex - e.featureIndex; }); for (let u = 0, c = l; u < c.length; u += 1) { const p = c[u]; s.push(p.feature); } } }()); return o; }(this._layers, t.viewport, n, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenRenderedFeatures(u); }, o.prototype.querySourceFeatures = function (t, n) { n && n.filter && this._validate(e.validateStyle.filter, 'querySourceFeatures.filter', n.filter); const r = this.sourceCaches[t]; return r ? (function (e, t) { for (var n = e.getRenderableIds().map(t => e.getTileByID(t)), r = [], i = {}, o = 0; o < n.length; o++) { const a = n[o]; const s = a.tileID.canonical.key; i[s] || (i[s] = !0, a.querySourceFeatures(r, t)); } return r; }(r, n)) : []; }, o.prototype.addSourceType = function (e, t, n) { return o.getSourceType(e) ? n(new Error(`A source type called "${e}" already exists.`)) : (o.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast('loadWorkerSource', { name: e, url: t.workerSourceURL }, n) : n(null, null)); }, o.prototype.getLight = function () { return this.light.getLight(); }, o.prototype.setLight = function (t) { this._checkLoaded(); const n = this.light.getLight(); let r = !1; for (const i in t) if (!e.default$10(t[i], n[i])) { r = !0; break; } if (r) { const o = { now: ge.now(), transition: e.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.light.setLight(t), this.light.updateTransitions(o); } }, o.prototype._validate = function (t, n, r, i, o) {
            return (!o || !1 !== o.validate) && wn(this, t.call(e.validateStyle, e.extend({
              key: n, style: this.serialize(), value: r, styleSpec: e.default$5,
            }, i)));
          }, o.prototype._remove = function () { for (const t in e.evented.off('pluginAvailable', this._rtlTextPluginCallback), this.sourceCaches) this.sourceCaches[t].clearTiles(); this.dispatcher.remove(); }, o.prototype._clearSource = function (e) { this.sourceCaches[e].clearTiles(); }, o.prototype._reloadSource = function (e) { this.sourceCaches[e].resume(), this.sourceCaches[e].reload(); }, o.prototype._updateSources = function (e) { for (const t in this.sourceCaches) this.sourceCaches[t].update(e); }, o.prototype._generateCollisionBoxes = function () { for (const e in this.sourceCaches) this._reloadSource(e); }, o.prototype._updatePlacement = function (e, t, n) { for (var r = !1, i = !1, o = {}, a = 0, s = this._order; a < s.length; a += 1) { const l = s[a]; const u = this._layers[l]; if (u.type === 'symbol') { if (!o[u.source]) { var c = this.sourceCaches[u.source]; o[u.source] = c.getRenderableIds().map(e => c.getTileByID(e)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1)); } const p = this.crossTileSymbolIndex.addLayer(u, o[u.source], e.center.lng); r = r || p; } } this.crossTileSymbolIndex.pruneUnusedLayers(this._order); const f = this._layerOrderChanged; if ((f || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(ge.now())) && (this.pauseablePlacement = new gn(e, this._order, f, t, n), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, o), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(this.placement, ge.now()), i = !0), r && this.pauseablePlacement.placement.setStale()), i || r) for (let h = 0, d = this._order; h < d.length; h += 1) { const m = d[h]; const g = this._layers[m]; g.type === 'symbol' && this.placement.updateLayerOpacities(g, o[g.source]); } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(ge.now()); }, o.prototype.getImages = function (e, t, n) { this.imageManager.getImages(t.icons, n); }, o.prototype.getGlyphs = function (e, t, n) { this.glyphManager.getGlyphs(t.stacks, n); }, o;
        }(e.Evented)); kn.getSourceType = function (e) { return at[e]; }, kn.setSourceType = function (e, t) { at[e] = t; }, kn.registerForPluginAvailability = e.registerForPluginAvailability; var Cn = e.createLayout([{ name: 'a_pos', type: 'Int16', components: 2 }]); const Sn = {
          prelude: { fragmentSource: '#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n', vertexSource: '#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n\n// Unpack a pair of values that have been packed into a single float.\n// The packed values are assumed to be 8-bit unsigned integers, and are\n// packed like so:\n// packedValue = floor(input[0]) * 256 + input[1],\nvec2 unpack_float(const float packedValue) {\n    int packedIntValue = int(packedValue);\n    int v0 = packedIntValue / 256;\n    return vec2(v0, packedIntValue - v0 * 256);\n}\n\nvec2 unpack_opacity(const float packedOpacity) {\n    int intOpacity = int(packedOpacity) / 2;\n    return vec2(float(intOpacity) / 127.0, mod(packedOpacity, 2.0));\n}\n\n// To minimize the number of attributes needed, we encode a 4-component\n// color into a pair of floats (i.e. a vec2) as follows:\n// [ floor(color.r * 255) * 256 + color.g * 255,\n//   floor(color.b * 255) * 256 + color.g * 255 ]\nvec4 decode_color(const vec2 encodedColor) {\n    return vec4(\n        unpack_float(encodedColor[0]) / 255.0,\n        unpack_float(encodedColor[1]) / 255.0\n    );\n}\n\n// Unpack a pair of paint values and interpolate between them.\nfloat unpack_mix_vec2(const vec2 packedValue, const float t) {\n    return mix(packedValue[0], packedValue[1], t);\n}\n\n// Unpack a pair of paint values and interpolate between them.\nvec4 unpack_mix_vec4(const vec4 packedColors, const float t) {\n    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n    return mix(minColor, maxColor, t);\n}\n\n// The offset depends on how many pixels are between the world origin and the edge of the tile:\n// vec2 offset = mod(pixel_coord, size)\n//\n// At high zoom levels there are a ton of pixels between the world origin and the edge of the tile.\n// The glsl spec only guarantees 16 bits of precision for highp floats. We need more than that.\n//\n// The pixel_coord is passed in as two 16 bit values:\n// pixel_coord_upper = floor(pixel_coord / 2^16)\n// pixel_coord_lower = mod(pixel_coord, 2^16)\n//\n// The offset is calculated in a series of steps that should preserve this precision:\nvec2 get_pattern_pos(const vec2 pixel_coord_upper, const vec2 pixel_coord_lower,\n    const vec2 pattern_size, const float tile_units_to_pixels, const vec2 pos) {\n\n    vec2 offset = mod(mod(mod(pixel_coord_upper, pattern_size) * 256.0, pattern_size) * 256.0 + pixel_coord_lower, pattern_size);\n    return (tile_units_to_pixels * pos + offset) / pattern_size;\n}\n' }, background: { fragmentSource: 'uniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main() {\n    gl_FragColor = u_color * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n' }, backgroundPattern: { fragmentSource: 'uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\nuniform float u_opacity;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n}\n' }, circle: { fragmentSource: '#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\n\nvarying vec3 v_data;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize mediump float radius\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize highp vec4 stroke_color\n    #pragma mapbox: initialize mediump float stroke_width\n    #pragma mapbox: initialize lowp float stroke_opacity\n\n    vec2 extrude = v_data.xy;\n    float extrude_length = length(extrude);\n\n    lowp float antialiasblur = v_data.z;\n    float antialiased_blur = -max(blur, antialiasblur);\n\n    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n\n    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n        antialiased_blur,\n        0.0,\n        extrude_length - radius / (radius + stroke_width)\n    );\n\n    gl_FragColor = opacity_t * mix(color * opacity, stroke_color * stroke_opacity, color_t);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: "uniform mat4 u_matrix;\nuniform bool u_scale_with_map;\nuniform bool u_pitch_with_map;\nuniform vec2 u_extrude_scale;\nuniform highp float u_camera_to_center_distance;\n\nattribute vec2 a_pos;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\n\nvarying vec3 v_data;\n\nvoid main(void) {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize mediump float radius\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize highp vec4 stroke_color\n    #pragma mapbox: initialize mediump float stroke_width\n    #pragma mapbox: initialize lowp float stroke_opacity\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    vec2 extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    vec2 circle_center = floor(a_pos * 0.5);\n    if (u_pitch_with_map) {\n        vec2 corner_position = circle_center;\n        if (u_scale_with_map) {\n            corner_position += extrude * (radius + stroke_width) * u_extrude_scale;\n        } else {\n            // Pitching the circle with the map effectively scales it with the map\n            // To counteract the effect for pitch-scale: viewport, we rescale the\n            // whole circle based on the pitch scaling effect at its central point\n            vec4 projected_center = u_matrix * vec4(circle_center, 0, 1);\n            corner_position += extrude * (radius + stroke_width) * u_extrude_scale * (projected_center.w / u_camera_to_center_distance);\n        }\n\n        gl_Position = u_matrix * vec4(corner_position, 0, 1);\n    } else {\n        gl_Position = u_matrix * vec4(circle_center, 0, 1);\n\n        if (u_scale_with_map) {\n            gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * u_camera_to_center_distance;\n        } else {\n            gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * gl_Position.w;\n        }\n    }\n\n    // This is a minimum blur distance that serves as a faux-antialiasing for\n    // the circle. since blur is a ratio of the circle's size and the intent is\n    // to keep the blur at roughly 1px, the two are inversely related.\n    lowp float antialiasblur = 1.0 / DEVICE_PIXEL_RATIO / (radius + stroke_width);\n\n    v_data = vec3(extrude.x, extrude.y, antialiasblur);\n}\n" }, clippingMask: { fragmentSource: 'void main() {\n    gl_FragColor = vec4(1.0);\n}\n', vertexSource: 'attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n' }, heatmap: { fragmentSource: '#pragma mapbox: define highp float weight\n\nuniform highp float u_intensity;\nvarying vec2 v_extrude;\n\n// Gaussian kernel coefficient: 1 / sqrt(2 * PI)\n#define GAUSS_COEF 0.3989422804014327\n\nvoid main() {\n    #pragma mapbox: initialize highp float weight\n\n    // Kernel density estimation with a Gaussian kernel of size 5x5\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\n    float val = weight * u_intensity * GAUSS_COEF * exp(d);\n\n    gl_FragColor = vec4(val, 1.0, 1.0, 1.0);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: "#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\n\nuniform mat4 u_matrix;\nuniform float u_extrude_scale;\nuniform float u_opacity;\nuniform float u_intensity;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_extrude;\n\n// Effective \"0\" in the kernel density texture to adjust the kernel size to;\n// this empirically chosen number minimizes artifacts on overlapping kernels\n// for typical heatmap cases (assuming clustered source)\nconst highp float ZERO = 1.0 / 255.0 / 16.0;\n\n// Gaussian kernel coefficient: 1 / sqrt(2 * PI)\n#define GAUSS_COEF 0.3989422804014327\n\nvoid main(void) {\n    #pragma mapbox: initialize highp float weight\n    #pragma mapbox: initialize mediump float radius\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    vec2 unscaled_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    // This 'extrude' comes in ranging from [-1, -1], to [1, 1].  We'll use\n    // it to produce the vertices of a square mesh framing the point feature\n    // we're adding to the kernel density texture.  We'll also pass it as\n    // a varying, so that the fragment shader can determine the distance of\n    // each fragment from the point feature.\n    // Before we do so, we need to scale it up sufficiently so that the\n    // kernel falls effectively to zero at the edge of the mesh.\n    // That is, we want to know S such that\n    // weight * u_intensity * GAUSS_COEF * exp(-0.5 * 3.0^2 * S^2) == ZERO\n    // Which solves to:\n    // S = sqrt(-2.0 * log(ZERO / (weight * u_intensity * GAUSS_COEF))) / 3.0\n    float S = sqrt(-2.0 * log(ZERO / weight / u_intensity / GAUSS_COEF)) / 3.0;\n\n    // Pass the varying in units of radius\n    v_extrude = S * unscaled_extrude;\n\n    // Scale by radius and the zoom-based scale factor to produce actual\n    // mesh position\n    vec2 extrude = v_extrude * radius * u_extrude_scale;\n\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    vec4 pos = vec4(floor(a_pos * 0.5) + extrude, 0, 1);\n\n    gl_Position = u_matrix * pos;\n}\n" }, heatmapTexture: { fragmentSource: 'uniform sampler2D u_image;\nuniform sampler2D u_color_ramp;\nuniform float u_opacity;\nvarying vec2 v_pos;\n\nvoid main() {\n    float t = texture2D(u_image, v_pos).r;\n    vec4 color = texture2D(u_color_ramp, vec2(t, 0.5));\n    gl_FragColor = color * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(0.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec2 u_world;\nattribute vec2 a_pos;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos * u_world, 0, 1);\n\n    v_pos.x = a_pos.x;\n    v_pos.y = 1.0 - a_pos.y;\n}\n' }, collisionBox: { fragmentSource: '\nvarying float v_placed;\nvarying float v_notUsed;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    // Red = collision, hide label\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n\n    // Blue = no collision, label is showing\n    if (v_placed > 0.5) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 0.5) * alpha;\n    }\n\n    if (v_notUsed > 0.5) {\n        // This box not used, fade it out\n        gl_FragColor *= .1;\n    }\n}', vertexSource: 'attribute vec2 a_pos;\nattribute vec2 a_anchor_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_placed;\n\nuniform mat4 u_matrix;\nuniform vec2 u_extrude_scale;\nuniform float u_camera_to_center_distance;\n\nvarying float v_placed;\nvarying float v_notUsed;\n\nvoid main() {\n    vec4 projectedPoint = u_matrix * vec4(a_anchor_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    highp float collision_perspective_ratio = clamp(\n        0.5 + 0.5 * (u_camera_to_center_distance / camera_to_anchor_distance),\n        0.0, // Prevents oversized near-field boxes in pitched/overzoomed tiles\n        4.0);\n\n    gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\n    gl_Position.xy += a_extrude * u_extrude_scale * gl_Position.w * collision_perspective_ratio;\n\n    v_placed = a_placed.x;\n    v_notUsed = a_placed.y;\n}\n' }, collisionCircle: { fragmentSource: 'uniform float u_overscale_factor;\n\nvarying float v_placed;\nvarying float v_notUsed;\nvarying float v_radius;\nvarying vec2 v_extrude;\nvarying vec2 v_extrude_scale;\n\nvoid main() {\n    float alpha = 0.5;\n\n    // Red = collision, hide label\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n\n    // Blue = no collision, label is showing\n    if (v_placed > 0.5) {\n        color = vec4(0.0, 0.0, 1.0, 0.5) * alpha;\n    }\n\n    if (v_notUsed > 0.5) {\n        // This box not used, fade it out\n        color *= .2;\n    }\n\n    float extrude_scale_length = length(v_extrude_scale);\n    float extrude_length = length(v_extrude) * extrude_scale_length;\n    float stroke_width = 15.0 * extrude_scale_length / u_overscale_factor;\n    float radius = v_radius * extrude_scale_length;\n\n    float distance_to_edge = abs(extrude_length - radius);\n    float opacity_t = smoothstep(-stroke_width, 0.0, -distance_to_edge);\n\n    gl_FragColor = opacity_t * color;\n}\n', vertexSource: "attribute vec2 a_pos;\nattribute vec2 a_anchor_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_placed;\n\nuniform mat4 u_matrix;\nuniform vec2 u_extrude_scale;\nuniform float u_camera_to_center_distance;\n\nvarying float v_placed;\nvarying float v_notUsed;\nvarying float v_radius;\n\nvarying vec2 v_extrude;\nvarying vec2 v_extrude_scale;\n\nvoid main() {\n    vec4 projectedPoint = u_matrix * vec4(a_anchor_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    highp float collision_perspective_ratio = clamp(\n        0.5 + 0.5 * (u_camera_to_center_distance / camera_to_anchor_distance),\n        0.0, // Prevents oversized near-field circles in pitched/overzoomed tiles\n        4.0);\n\n    gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\n\n    highp float padding_factor = 1.2; // Pad the vertices slightly to make room for anti-alias blur\n    gl_Position.xy += a_extrude * u_extrude_scale * padding_factor * gl_Position.w * collision_perspective_ratio;\n\n    v_placed = a_placed.x;\n    v_notUsed = a_placed.y;\n    v_radius = abs(a_extrude.y); // We don't pitch the circles, so both units of the extrusion vector are equal in magnitude to the radius\n\n    v_extrude = a_extrude * padding_factor;\n    v_extrude_scale = u_extrude_scale * u_camera_to_center_distance * collision_perspective_ratio;\n}\n" }, debug: { fragmentSource: 'uniform highp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n', vertexSource: 'attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n' }, fill: { fragmentSource: '#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_FragColor = color * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n' }, fillOutline: { fragmentSource: '#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_pos;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);\n    gl_FragColor = outline_color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n' }, fillOutlinePattern: { fragmentSource: 'uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    // find distance to outline for alpha interpolation\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);\n\n\n    gl_FragColor = mix(color1, color2, u_mix) * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec2 u_world;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n' }, fillPattern: { fragmentSource: 'uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n}\n' }, fillExtrusion: { fragmentSource: 'varying vec4 v_color;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define highp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n    #pragma mapbox: initialize highp vec4 color\n\n    gl_FragColor = v_color;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec3 u_lightcolor;\nuniform lowp vec3 u_lightpos;\nuniform lowp float u_lightintensity;\n\nattribute vec2 a_pos;\nattribute vec4 a_normal_ed;\n\nvarying vec4 v_color;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\n#pragma mapbox: define highp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n    #pragma mapbox: initialize highp vec4 color\n\n    vec3 normal = a_normal_ed.xyz;\n\n    base = max(0.0, base);\n    height = max(0.0, height);\n\n    float t = mod(normal.x, 2.0);\n\n    gl_Position = u_matrix * vec4(a_pos, t > 0.0 ? height : base, 1);\n\n    // Relative luminance (how dark/bright is the surface color?)\n    float colorvalue = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n\n    v_color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Add slight ambient lighting so no extrusions are totally black\n    vec4 ambientlight = vec4(0.03, 0.03, 0.03, 1.0);\n    color += ambientlight;\n\n    // Calculate cos(theta), where theta is the angle between surface normal and diffuse light ray\n    float directional = clamp(dot(normal / 16384.0, u_lightpos), 0.0, 1.0);\n\n    // Adjust directional so that\n    // the range of values for highlight/shading is narrower\n    // with lower light intensity\n    // and with lighter/brighter surface colors\n    directional = mix((1.0 - u_lightintensity), max((1.0 - colorvalue + u_lightintensity), 1.0), directional);\n\n    // Add gradient along z axis of side surfaces\n    if (normal.y != 0.0) {\n        directional *= clamp((t + base) * pow(height / 150.0, 0.5), mix(0.7, 0.98, 1.0 - u_lightintensity), 1.0);\n    }\n\n    // Assign final color based on surface + ambient light color, diffuse light directional, and light color\n    // with lower bounds adjusted to hue of light\n    // so that shading is tinted with the complementary (opposite) color to the light color\n    v_color.r += clamp(color.r * directional * u_lightcolor.r, mix(0.0, 0.3, 1.0 - u_lightcolor.r), 1.0);\n    v_color.g += clamp(color.g * directional * u_lightcolor.g, mix(0.0, 0.3, 1.0 - u_lightcolor.g), 1.0);\n    v_color.b += clamp(color.b * directional * u_lightcolor.b, mix(0.0, 0.3, 1.0 - u_lightcolor.b), 1.0);\n}\n' }, fillExtrusionPattern: { fragmentSource: 'uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_lighting;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    vec4 mixedColor = mix(color1, color2, u_mix);\n\n    gl_FragColor = mixedColor * v_lighting;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\nuniform float u_height_factor;\n\nuniform vec3 u_lightcolor;\nuniform lowp vec3 u_lightpos;\nuniform lowp float u_lightintensity;\n\nattribute vec2 a_pos;\nattribute vec4 a_normal_ed;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_lighting;\nvarying float v_directional;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n\n    vec3 normal = a_normal_ed.xyz;\n    float edgedistance = a_normal_ed.w;\n\n    base = max(0.0, base);\n    height = max(0.0, height);\n\n    float t = mod(normal.x, 2.0);\n    float z = t > 0.0 ? height : base;\n\n    gl_Position = u_matrix * vec4(a_pos, z, 1);\n\n    vec2 pos = normal.x == 1.0 && normal.y == 0.0 && normal.z == 16384.0\n        ? a_pos // extrusion top\n        : vec2(edgedistance, z * u_height_factor); // extrusion side\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, pos);\n\n    v_lighting = vec4(0.0, 0.0, 0.0, 1.0);\n    float directional = clamp(dot(normal / 16383.0, u_lightpos), 0.0, 1.0);\n    directional = mix((1.0 - u_lightintensity), max((0.5 + u_lightintensity), 1.0), directional);\n\n    if (normal.y != 0.0) {\n        directional *= clamp((t + base) * pow(height / 150.0, 0.5), mix(0.7, 0.98, 1.0 - u_lightintensity), 1.0);\n    }\n\n    v_lighting.rgb += clamp(directional * u_lightcolor, mix(vec3(0.0), vec3(0.3), 1.0 - u_lightcolor), vec3(1.0));\n}\n' }, extrusionTexture: { fragmentSource: 'uniform sampler2D u_image;\nuniform float u_opacity;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_FragColor = texture2D(u_image, v_pos) * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(0.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec2 u_world;\nattribute vec2 a_pos;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos * u_world, 0, 1);\n\n    v_pos.x = a_pos.x;\n    v_pos.y = 1.0 - a_pos.y;\n}\n' }, hillshadePrepare: { fragmentSource: "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D u_image;\nvarying vec2 v_pos;\nuniform vec2 u_dimension;\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nfloat getElevation(vec2 coord, float bias) {\n    // Convert encoded elevation value to meters\n    vec4 data = texture2D(u_image, coord) * 255.0;\n    return (data.r + data.g * 256.0 + data.b * 256.0 * 256.0) / 4.0;\n}\n\nvoid main() {\n    vec2 epsilon = 1.0 / u_dimension;\n\n    // queried pixels:\n    // +-----------+\n    // |   |   |   |\n    // | a | b | c |\n    // |   |   |   |\n    // +-----------+\n    // |   |   |   |\n    // | d | e | f |\n    // |   |   |   |\n    // +-----------+\n    // |   |   |   |\n    // | g | h | i |\n    // |   |   |   |\n    // +-----------+\n\n    float a = getElevation(v_pos + vec2(-epsilon.x, -epsilon.y), 0.0);\n    float b = getElevation(v_pos + vec2(0, -epsilon.y), 0.0);\n    float c = getElevation(v_pos + vec2(epsilon.x, -epsilon.y), 0.0);\n    float d = getElevation(v_pos + vec2(-epsilon.x, 0), 0.0);\n    float e = getElevation(v_pos, 0.0);\n    float f = getElevation(v_pos + vec2(epsilon.x, 0), 0.0);\n    float g = getElevation(v_pos + vec2(-epsilon.x, epsilon.y), 0.0);\n    float h = getElevation(v_pos + vec2(0, epsilon.y), 0.0);\n    float i = getElevation(v_pos + vec2(epsilon.x, epsilon.y), 0.0);\n\n    // here we divide the x and y slopes by 8 * pixel size\n    // where pixel size (aka meters/pixel) is:\n    // circumference of the world / (pixels per tile * number of tiles)\n    // which is equivalent to: 8 * 40075016.6855785 / (512 * pow(2, u_zoom))\n    // which can be reduced to: pow(2, 19.25619978527 - u_zoom)\n    // we want to vertically exaggerate the hillshading though, because otherwise\n    // it is barely noticeable at low zooms. to do this, we multiply this by some\n    // scale factor pow(2, (u_zoom - u_maxzoom) * a) where a is an arbitrary value\n    // Here we use a=0.3 which works out to the expression below. see \n    // nickidlugash's awesome breakdown for more info\n    // https://github.com/mapbox/mapbox-gl-js/pull/5286#discussion_r148419556\n    float exaggeration = u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;\n\n    vec2 deriv = vec2(\n        (c + f + f + i) - (a + d + d + g),\n        (g + h + h + i) - (a + b + b + c)\n    ) /  pow(2.0, (u_zoom - u_maxzoom) * exaggeration + 19.2562 - u_zoom);\n\n    gl_FragColor = clamp(vec4(\n        deriv.x / 2.0 + 0.5,\n        deriv.y / 2.0 + 0.5,\n        1.0,\n        1.0), 0.0, 1.0);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: 'uniform mat4 u_matrix;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (a_texture_pos / 8192.0) / 2.0 + 0.25;\n}\n' }, hillshade: { fragmentSource: "uniform sampler2D u_image;\nvarying vec2 v_pos;\n\nuniform vec2 u_latrange;\nuniform vec2 u_light;\nuniform vec4 u_shadow;\nuniform vec4 u_highlight;\nuniform vec4 u_accent;\n\n#define PI 3.141592653589793\n\nvoid main() {\n    vec4 pixel = texture2D(u_image, v_pos);\n\n    vec2 deriv = ((pixel.rg * 2.0) - 1.0);\n\n    // We divide the slope by a scale factor based on the cosin of the pixel's approximate latitude\n    // to account for mercator projection distortion. see #4807 for details\n    float scaleFactor = cos(radians((u_latrange[0] - u_latrange[1]) * (1.0 - v_pos.y) + u_latrange[1]));\n    // We also multiply the slope by an arbitrary z-factor of 1.25\n    float slope = atan(1.25 * length(deriv) / scaleFactor);\n    float aspect = deriv.x != 0.0 ? atan(deriv.y, -deriv.x) : PI / 2.0 * (deriv.y > 0.0 ? 1.0 : -1.0);\n\n    float intensity = u_light.x;\n    // We add PI to make this property match the global light object, which adds PI/2 to the light's azimuthal\n    // position property to account for 0deg corresponding to north/the top of the viewport in the style spec\n    // and the original shader was written to accept (-illuminationDirection - 90) as the azimuthal.\n    float azimuth = u_light.y + PI;\n\n    // We scale the slope exponentially based on intensity, using a calculation similar to\n    // the exponential interpolation function in the style spec:\n    // https://github.com/mapbox/mapbox-gl-js/blob/master/src/style-spec/expression/definitions/interpolate.js#L217-L228\n    // so that higher intensity values create more opaque hillshading.\n    float base = 1.875 - intensity * 1.75;\n    float maxValue = 0.5 * PI;\n    float scaledSlope = intensity != 0.5 ? ((pow(base, slope) - 1.0) / (pow(base, maxValue) - 1.0)) * maxValue : slope;\n\n    // The accent color is calculated with the cosine of the slope while the shade color is calculated with the sine\n    // so that the accent color's rate of change eases in while the shade color's eases out.\n    float accent = cos(scaledSlope);\n    // We multiply both the accent and shade color by a clamped intensity value\n    // so that intensities >= 0.5 do not additionally affect the color values\n    // while intensity values < 0.5 make the overall color more transparent.\n    vec4 accent_color = (1.0 - accent) * u_accent * clamp(intensity * 2.0, 0.0, 1.0);\n    float shade = abs(mod((aspect + azimuth) / PI + 0.5, 2.0) - 1.0);\n    vec4 shade_color = mix(u_shadow, u_highlight, shade) * sin(scaledSlope) * clamp(intensity * 2.0, 0.0, 1.0);\n    gl_FragColor = accent_color * (1.0 - shade_color.a) + shade_color;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: 'uniform mat4 u_matrix;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = a_texture_pos / 8192.0;\n}\n' }, line: { fragmentSource: '#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: "\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_gamma_scale;\nvarying highp float v_linesofar;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float width\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    v_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_width2 = vec2(outset, inset);\n}\n" }, lineGradient: { fragmentSource: '\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nuniform sampler2D u_image;\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\nvarying highp float v_lineprogress;\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    // For gradient lines, v_lineprogress is the ratio along the entire line,\n    // scaled to [0, 2^15), and the gradient ramp is stored in a texture.\n    vec4 color = texture2D(u_image, vec2(v_lineprogress, 0.5));\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: "\n// the attribute conveying progress along a line is scaled to [0, 2^15)\n#define MAX_LINE_DISTANCE 32767.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_gamma_scale;\nvarying highp float v_lineprogress;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float width\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    v_lineprogress = (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0 / MAX_LINE_DISTANCE;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_width2 = vec2(outset, inset);\n}\n" }, linePattern: { fragmentSource: "uniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_fade;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n\n    // v_normal.y is 0 at the midpoint of the line, -1 at the lower edge, 1 at the upper edge\n    // we clamp the line width outset to be between 0 and half the pattern height plus padding (2.0)\n    // to ensure we don't sample outside the designated symbol on the sprite sheet.\n    // 0.5 is added to shift the component to be bounded between 0 and 1 for interpolation of\n    // the texture coordinate\n    float y_a = 0.5 + (v_normal.y * clamp(v_width2.s, 0.0, (u_pattern_size_a.y + 2.0) / 2.0) / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * clamp(v_width2.s, 0.0, (u_pattern_size_b.y + 2.0) / 2.0) / u_pattern_size_b.y);\n    vec2 pos_a = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, vec2(x_a, y_a));\n    vec2 pos_b = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos_a), texture2D(u_image, pos_b), u_fade);\n\n    gl_FragColor = color * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize mediump float width\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_linesofar = a_linesofar;\n    v_width2 = vec2(outset, inset);\n}\n" }, lineSDF: { fragmentSource: '\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float width\n    #pragma mapbox: initialize lowp float floorwidth\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma / floorwidth, 0.5 + u_sdfgamma / floorwidth, sdfdist);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: "// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float width\n    #pragma mapbox: initialize lowp float floorwidth\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist =outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x / floorwidth, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x / floorwidth, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    v_width2 = vec2(outset, inset);\n}\n" }, raster: { fragmentSource: 'uniform float u_fade_t;\nuniform float u_opacity;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    if (color0.a > 0.0) {\n        color0.rgb = color0.rgb / color0.a;\n    }\n    if (color1.a > 0.0) {\n        color1.rgb = color1.rgb / color1.a;\n    }\n    vec4 color = mix(color0, color1, u_fade_t);\n    color.a *= u_opacity;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb) * color.a, color.a);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'uniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    // We are using Int16 for texture position coordinates to give us enough precision for\n    // fractional coordinates. We use 8192 to scale the texture coordinates in the buffer\n    // as an arbitrarily high number to preserve adequate precision when rendering.\n    // This is also the same value as the EXTENT we are using for our tile buffer pos coordinates,\n    // so math for modifying either is consistent.\n    v_pos0 = (((a_texture_pos / 8192.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n' }, symbolIcon: { fragmentSource: 'uniform sampler2D u_texture;\n\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_tex;\nvarying float v_fade_opacity;\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    lowp float alpha = opacity * v_fade_opacity;\n    gl_FragColor = texture2D(u_texture, v_tex) * alpha;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: 'const float PI = 3.141592653589793;\n\nattribute vec4 a_pos_offset;\nattribute vec4 a_data;\nattribute vec3 a_projected_pos;\nattribute float a_fade_opacity;\n\nuniform bool u_is_size_zoom_constant;\nuniform bool u_is_size_feature_constant;\nuniform highp float u_size_t; // used to interpolate between zoom stops when size is a composite function\nuniform highp float u_size; // used when size is both zoom and feature constant\nuniform highp float u_camera_to_center_distance;\nuniform highp float u_pitch;\nuniform bool u_rotate_symbol;\nuniform highp float u_aspect_ratio;\nuniform float u_fade_change;\n\n#pragma mapbox: define lowp float opacity\n\nuniform mat4 u_matrix;\nuniform mat4 u_label_plane_matrix;\nuniform mat4 u_gl_coord_matrix;\n\nuniform bool u_is_text;\nuniform bool u_pitch_with_map;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying float v_fade_opacity;\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 a_pos = a_pos_offset.xy;\n    vec2 a_offset = a_pos_offset.zw;\n\n    vec2 a_tex = a_data.xy;\n    vec2 a_size = a_data.zw;\n\n    highp float segment_angle = -a_projected_pos[2];\n\n    float size;\n    if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = mix(a_size[0], a_size[1], u_size_t) / 10.0;\n    } else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = a_size[0] / 10.0;\n    } else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {\n        size = u_size;\n    } else {\n        size = u_size;\n    }\n\n    vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    // See comments in symbol_sdf.vertex\n    highp float distance_ratio = u_pitch_with_map ?\n        camera_to_anchor_distance / u_camera_to_center_distance :\n        u_camera_to_center_distance / camera_to_anchor_distance;\n    highp float perspective_ratio = clamp(\n            0.5 + 0.5 * distance_ratio,\n            0.0, // Prevents oversized near-field symbols in pitched/overzoomed tiles\n            4.0);\n\n    size *= perspective_ratio;\n\n    float fontScale = u_is_text ? size / 24.0 : size;\n\n    highp float symbol_rotation = 0.0;\n    if (u_rotate_symbol) {\n        // See comments in symbol_sdf.vertex\n        vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);\n\n        vec2 a = projectedPoint.xy / projectedPoint.w;\n        vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;\n\n        symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);\n    }\n\n    highp float angle_sin = sin(segment_angle + symbol_rotation);\n    highp float angle_cos = cos(segment_angle + symbol_rotation);\n    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n\n    vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, 0.0, 1.0);\n    gl_Position = u_gl_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n\n    v_tex = a_tex / u_texsize;\n    vec2 fade_opacity = unpack_opacity(a_fade_opacity);\n    float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;\n    v_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));\n}\n' }, symbolSDF: { fragmentSource: '#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105/DEVICE_PIXEL_RATIO\n\nuniform bool u_is_halo;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n\nuniform sampler2D u_texture;\nuniform highp float u_gamma_scale;\nuniform bool u_is_text;\n\nvarying vec2 v_data0;\nvarying vec3 v_data1;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 fill_color\n    #pragma mapbox: initialize highp vec4 halo_color\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp float halo_width\n    #pragma mapbox: initialize lowp float halo_blur\n\n    vec2 tex = v_data0.xy;\n    float gamma_scale = v_data1.x;\n    float size = v_data1.y;\n    float fade_opacity = v_data1[2];\n\n    float fontScale = u_is_text ? size / 24.0 : size;\n\n    lowp vec4 color = fill_color;\n    highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);\n    lowp float buff = (256.0 - 64.0) / 256.0;\n    if (u_is_halo) {\n        color = halo_color;\n        gamma = (halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale);\n        buff = (6.0 - halo_width / fontScale) / SDF_PX;\n    }\n\n    lowp float dist = texture2D(u_texture, tex).a;\n    highp float gamma_scaled = gamma * gamma_scale;\n    highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n\n    gl_FragColor = color * (alpha * opacity * fade_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n', vertexSource: "const float PI = 3.141592653589793;\n\nattribute vec4 a_pos_offset;\nattribute vec4 a_data;\nattribute vec3 a_projected_pos;\nattribute float a_fade_opacity;\n\n// contents of a_size vary based on the type of property value\n// used for {text,icon}-size.\n// For constants, a_size is disabled.\n// For source functions, we bind only one value per vertex: the value of {text,icon}-size evaluated for the current feature.\n// For composite functions:\n// [ text-size(lowerZoomStop, feature),\n//   text-size(upperZoomStop, feature) ]\nuniform bool u_is_size_zoom_constant;\nuniform bool u_is_size_feature_constant;\nuniform highp float u_size_t; // used to interpolate between zoom stops when size is a composite function\nuniform highp float u_size; // used when size is both zoom and feature constant\n\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n\nuniform mat4 u_matrix;\nuniform mat4 u_label_plane_matrix;\nuniform mat4 u_gl_coord_matrix;\n\nuniform bool u_is_text;\nuniform bool u_pitch_with_map;\nuniform highp float u_pitch;\nuniform bool u_rotate_symbol;\nuniform highp float u_aspect_ratio;\nuniform highp float u_camera_to_center_distance;\nuniform float u_fade_change;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_data0;\nvarying vec3 v_data1;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 fill_color\n    #pragma mapbox: initialize highp vec4 halo_color\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp float halo_width\n    #pragma mapbox: initialize lowp float halo_blur\n\n    vec2 a_pos = a_pos_offset.xy;\n    vec2 a_offset = a_pos_offset.zw;\n\n    vec2 a_tex = a_data.xy;\n    vec2 a_size = a_data.zw;\n\n    highp float segment_angle = -a_projected_pos[2];\n    float size;\n\n    if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = mix(a_size[0], a_size[1], u_size_t) / 10.0;\n    } else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = a_size[0] / 10.0;\n    } else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {\n        size = u_size;\n    } else {\n        size = u_size;\n    }\n\n    vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    // If the label is pitched with the map, layout is done in pitched space,\n    // which makes labels in the distance smaller relative to viewport space.\n    // We counteract part of that effect by multiplying by the perspective ratio.\n    // If the label isn't pitched with the map, we do layout in viewport space,\n    // which makes labels in the distance larger relative to the features around\n    // them. We counteract part of that effect by dividing by the perspective ratio.\n    highp float distance_ratio = u_pitch_with_map ?\n        camera_to_anchor_distance / u_camera_to_center_distance :\n        u_camera_to_center_distance / camera_to_anchor_distance;\n    highp float perspective_ratio = clamp(\n        0.5 + 0.5 * distance_ratio,\n        0.0, // Prevents oversized near-field symbols in pitched/overzoomed tiles\n        4.0);\n\n    size *= perspective_ratio;\n\n    float fontScale = u_is_text ? size / 24.0 : size;\n\n    highp float symbol_rotation = 0.0;\n    if (u_rotate_symbol) {\n        // Point labels with 'rotation-alignment: map' are horizontal with respect to tile units\n        // To figure out that angle in projected space, we draw a short horizontal line in tile\n        // space, project it, and measure its angle in projected space.\n        vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);\n\n        vec2 a = projectedPoint.xy / projectedPoint.w;\n        vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;\n\n        symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);\n    }\n\n    highp float angle_sin = sin(segment_angle + symbol_rotation);\n    highp float angle_cos = cos(segment_angle + symbol_rotation);\n    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n\n    vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, 0.0, 1.0);\n    gl_Position = u_gl_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n    float gamma_scale = gl_Position.w;\n\n    vec2 tex = a_tex / u_texsize;\n    vec2 fade_opacity = unpack_opacity(a_fade_opacity);\n    float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;\n    float interpolated_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));\n\n    v_data0 = vec2(tex.x, tex.y);\n    v_data1 = vec3(gamma_scale, size, interpolated_fade_opacity);\n}\n" },
        }; const An = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g; for (const On in Sn)!(function (e) { const t = Sn[e]; const n = {}; t.fragmentSource = t.fragmentSource.replace(An, (e, t, r, i, o) => n[o] = !0, t === 'define' ? `\n#ifndef HAS_UNIFORM_u_${  o  }\nvarying ${  r  } ${  i  } ${  o  };\n#else\nuniform ${  r  } ${  i  } u_${  o  };\n#endif\n`:`\n#ifdef HAS_UNIFORM_u_${o}\n    ${ r } ${i} ${o} = u_${o };\n#endif\n`), t.vertexSource = t.vertexSource.replace(An, (e, t, r, i, o) => { const a = i === 'float' ? 'vec2' : 'vec4'; return n[o] ? t === 'define' ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float a_${ o}_t;\nattribute ${r} ${a} a_${ o };\nvarying ${r } ${i} ${o};\n#else\nuniform ${r } ${i } u_${o };\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = unpack_mix_${a}(a_${o}, a_${o}_t);\n#else\n    ${r} ${i} ${o} = u_${o};\n#endif\n` : t === 'define' ? `\n#ifndef HAS_UNIFORM_u_${ o}\nuniform lowp float a_${o}_t;\nattribute ${r} ${a} a_${ o};\n#else\nuniform ${r } ${i} u_${ o };\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${r} ${i} ${o} = unpack_mix_${a}(a_${o}, a_${o}_t);\n#else\n    ${r} ${i} ${o} = u_${o};\n#endif\n`; }); }(On)); const In = Sn; const Pn = function (e, t, n, r) { const i = e.gl; this.program = i.createProgram(); const o = n.defines().concat(`#define DEVICE_PIXEL_RATIO ${ge.devicePixelRatio.toFixed(1)}`); r && o.push('#define OVERDRAW_INSPECTOR;'); const a = o.concat(In.prelude.fragmentSource, t.fragmentSource).join('\n'); const s = o.concat(In.prelude.vertexSource, t.vertexSource).join('\n'); const l = i.createShader(i.FRAGMENT_SHADER); i.shaderSource(l, a), i.compileShader(l), i.attachShader(this.program, l); const u = i.createShader(i.VERTEX_SHADER); i.shaderSource(u, s), i.compileShader(u), i.attachShader(this.program, u); for (let c = n.layoutAttributes || [], p = 0; p < c.length; p++)i.bindAttribLocation(this.program, p, c[p].name); i.linkProgram(this.program), this.numAttributes = i.getProgramParameter(this.program, i.ACTIVE_ATTRIBUTES), this.attributes = {}, this.uniforms = {}; for (let f = 0; f < this.numAttributes; f++) { const h = i.getActiveAttrib(this.program, f); h && (this.attributes[h.name] = i.getAttribLocation(this.program, h.name)); } for (let d = i.getProgramParameter(this.program, i.ACTIVE_UNIFORMS), m = 0; m < d; m++) { const g = i.getActiveUniform(this.program, m); g && (this.uniforms[g.name] = i.getUniformLocation(this.program, g.name)); } }; Pn.prototype.draw = function (e, t, n, r, i, o, a, s, l) { for (var u, c = e.gl, p = (u = {}, u[c.LINES] = 2, u[c.TRIANGLES] = 3, u)[t], f = 0, h = o.get(); f < h.length; f += 1) { const d = h[f]; const m = d.vaos || (d.vaos = {}); (m[n] || (m[n] = new nt())).bind(e, this, r, a ? a.getPaintVertexBuffers() : [], i, d.vertexOffset, s, l), c.drawElements(t, d.primitiveLength * p, c.UNSIGNED_SHORT, d.primitiveOffset * p * 2); } }; var Mn = e.mat4.identity(new Float32Array(16)); var Nn = e.default$19.layout; var Dn = function (e, t) { if (!e) return !1; const n = t.imageManager.getPattern(e.from); const r = t.imageManager.getPattern(e.to); return !n || !r; }; var Ln = function (e, t, n) { const r = t.context; const i = r.gl; const o = t.imageManager.getPattern(e.from); const a = t.imageManager.getPattern(e.to); i.uniform1i(n.uniforms.u_image, 0), i.uniform2fv(n.uniforms.u_pattern_tl_a, o.tl), i.uniform2fv(n.uniforms.u_pattern_br_a, o.br), i.uniform2fv(n.uniforms.u_pattern_tl_b, a.tl), i.uniform2fv(n.uniforms.u_pattern_br_b, a.br); const s = t.imageManager.getPixelSize(); const l = s.width; const u = s.height; i.uniform2fv(n.uniforms.u_texsize, [l, u]), i.uniform1f(n.uniforms.u_mix, e.t), i.uniform2fv(n.uniforms.u_pattern_size_a, o.displaySize), i.uniform2fv(n.uniforms.u_pattern_size_b, a.displaySize), i.uniform1f(n.uniforms.u_scale_a, e.fromScale), i.uniform1f(n.uniforms.u_scale_b, e.toScale), r.activeTexture.set(i.TEXTURE0), t.imageManager.bind(t.context); }; var zn = function (e, t, n) { const r = t.context.gl; r.uniform1f(n.uniforms.u_tile_units_to_pixels, 1 / j(e, 1, t.transform.tileZoom)); const i = Math.pow(2, e.tileID.overscaledZ); const o = e.tileSize * Math.pow(2, t.transform.tileZoom) / i; const a = o * (e.tileID.canonical.x + e.tileID.wrap * i); const s = o * e.tileID.canonical.y; r.uniform2f(n.uniforms.u_pixel_coord_upper, a >> 16, s >> 16), r.uniform2f(n.uniforms.u_pixel_coord_lower, 65535 & a, 65535 & s); }; var Rn = e.default$20.mat3; const jn = e.default$20.mat4; var Bn = e.default$20.vec3; var Fn = {
          ' ': [16, []], '!': [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], '"': [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]], '#': [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]], $: [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]], '%': [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]], '&': [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]], "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]], '(': [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]], ')': [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]], '*': [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]], '+': [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]], ',': [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]], '-': [26, [4, 9, 22, 9]], '.': [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], '/': [22, [20, 25, 2, -7]], 0: [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]], 1: [20, [6, 17, 8, 18, 11, 21, 11, 0]], 2: [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]], 3: [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]], 4: [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]], 5: [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]], 6: [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]], 7: [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]], 8: [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]], 9: [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]], ':': [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], ';': [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]], '<': [24, [20, 18, 4, 9, 20, 0]], '=': [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]], '>': [24, [4, 18, 20, 9, 4, 0]], '?': [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]], '@': [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]], A: [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]], B: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]], C: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]], D: [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]], E: [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]], F: [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]], G: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]], H: [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]], I: [8, [4, 21, 4, 0]], J: [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]], K: [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]], L: [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]], M: [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]], N: [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]], O: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]], P: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]], Q: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]], R: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]], S: [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]], T: [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]], U: [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]], V: [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]], W: [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]], X: [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]], Y: [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]], Z: [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]], '[': [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]], '\\': [14, [0, 21, 14, -3]], ']': [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]], '^': [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]], _: [16, [0, -2, 16, -2]], '`': [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]], a: [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], b: [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]], c: [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], d: [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], e: [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], f: [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]], g: [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], h: [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]], i: [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]], j: [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]], k: [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]], l: [8, [4, 21, 4, 0]], m: [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]], n: [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]], o: [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]], p: [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]], q: [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], r: [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]], s: [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]], t: [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]], u: [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]], v: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]], w: [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]], x: [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]], y: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]], z: [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]], '{': [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]], '|': [8, [4, 25, 4, -7]], '}': [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]], '~': [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]],
        }; const Un = {
          symbol(e, t, n, r) { if (e.renderPass === 'translucent') { const i = e.context; i.setStencilMode(Wt.disabled), i.setColorMode(e.colorModeForRenderPass()), n.paint.get('icon-opacity').constantOr(1) !== 0 && q(e, t, n, r, !1, n.paint.get('icon-translate'), n.paint.get('icon-translate-anchor'), n.layout.get('icon-rotation-alignment'), n.layout.get('icon-pitch-alignment'), n.layout.get('icon-keep-upright')), n.paint.get('text-opacity').constantOr(1) !== 0 && q(e, t, n, r, !0, n.paint.get('text-translate'), n.paint.get('text-translate-anchor'), n.layout.get('text-rotation-alignment'), n.layout.get('text-pitch-alignment'), n.layout.get('text-keep-upright')), t.map.showCollisionBoxes && (function (e, t, n, r) { V(e, t, n, r, !1), V(e, t, n, r, !0); }(e, t, n, r)); } }, circle(e, t, n, r) { if (e.renderPass === 'translucent') { const i = n.paint.get('circle-opacity'); const o = n.paint.get('circle-stroke-width'); const a = n.paint.get('circle-stroke-opacity'); if (i.constantOr(1) !== 0 || o.constantOr(1) !== 0 && a.constantOr(1) !== 0) { const s = e.context; const l = s.gl; s.setDepthMode(e.depthModeForSublayer(0, Ht.ReadOnly)), s.setStencilMode(Wt.disabled), s.setColorMode(e.colorModeForRenderPass()); for (let u = !0, c = 0; c < r.length; c++) { const p = r[c]; const f = t.getTile(p); const h = f.getBucket(n); if (h) { const d = e.context.program.get(); const m = h.programConfigurations.get(n.id); const g = e.useProgram('circle', m); if ((u || g.program !== d) && (m.setUniforms(s, g, n.paint, { zoom: e.transform.zoom }), u = !1), l.uniform1f(g.uniforms.u_camera_to_center_distance, e.transform.cameraToCenterDistance), l.uniform1i(g.uniforms.u_scale_with_map, n.paint.get('circle-pitch-scale') === 'map' ? 1 : 0), n.paint.get('circle-pitch-alignment') === 'map') { l.uniform1i(g.uniforms.u_pitch_with_map, 1); const y = j(f, 1, e.transform.zoom); l.uniform2f(g.uniforms.u_extrude_scale, y, y); } else l.uniform1i(g.uniforms.u_pitch_with_map, 0), l.uniform2fv(g.uniforms.u_extrude_scale, e.transform.pixelsToGLUnits); l.uniformMatrix4fv(g.uniforms.u_matrix, !1, e.translatePosMatrix(p.posMatrix, f, n.paint.get('circle-translate'), n.paint.get('circle-translate-anchor'))), g.draw(s, l.TRIANGLES, n.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, m); } } } } }, heatmap(t, n, r, i) { if (r.paint.get('heatmap-opacity') !== 0) if (t.renderPass === 'offscreen') { const o = t.context; const a = o.gl; o.setDepthMode(t.depthModeForSublayer(0, Ht.ReadOnly)), o.setStencilMode(Wt.disabled), (function (e, t, n) { const r = e.gl; e.activeTexture.set(r.TEXTURE1), e.viewport.set([0, 0, t.width / 4, t.height / 4]); let i = n.heatmapFbo; if (i)r.bindTexture(r.TEXTURE_2D, i.colorAttachment.get()), e.bindFramebuffer.set(i.framebuffer); else { const o = r.createTexture(); r.bindTexture(r.TEXTURE_2D, o), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), i = n.heatmapFbo = e.createFramebuffer(t.width / 4, t.height / 4), (function e(t, n, r, i) { let o = t.gl; o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, n.width / 4, n.height / 4, 0, o.RGBA, t.extTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : o.UNSIGNED_BYTE, null), i.colorAttachment.set(r), t.extTextureHalfFloat && o.checkFramebufferStatus(o.FRAMEBUFFER) !== o.FRAMEBUFFER_COMPLETE && (t.extTextureHalfFloat = null, i.colorAttachment.setDirty(), e(t, n, r, i)); }(e, t, o, i)); } }(o, t, r)), o.clear({ color: e.default$6.transparent }), o.setColorMode(new $t([a.ONE, a.ONE], e.default$6.transparent, [!0, !0, !0, !0])); for (let s = !0, l = 0; l < i.length; l++) { const u = i[l]; if (!n.hasRenderableParent(u)) { const c = n.getTile(u); const p = c.getBucket(r); if (p) { const f = t.context.program.get(); const h = p.programConfigurations.get(r.id); const d = t.useProgram('heatmap', h); const m = t.transform.zoom; (s || d.program !== f) && (h.setUniforms(t.context, d, r.paint, { zoom: m }), s = !1), a.uniform1f(d.uniforms.u_extrude_scale, j(c, 1, m)), a.uniform1f(d.uniforms.u_intensity, r.paint.get('heatmap-intensity')), a.uniformMatrix4fv(d.uniforms.u_matrix, !1, u.posMatrix), d.draw(o, a.TRIANGLES, r.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, h); } } }o.viewport.set([0, 0, t.width, t.height]); } else t.renderPass === 'translucent' && (t.context.setColorMode(t.colorModeForRenderPass()), (function (t, n) { const r = t.context; const i = r.gl; const o = n.heatmapFbo; if (o) { r.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, o.colorAttachment.get()), r.activeTexture.set(i.TEXTURE1); let a = n.colorRampTexture; a || (a = n.colorRampTexture = new je(r, n.colorRamp, i.RGBA)), a.bind(i.LINEAR, i.CLAMP_TO_EDGE), r.setDepthMode(Ht.disabled); const s = t.useProgram('heatmapTexture'); const l = n.paint.get('heatmap-opacity'); i.uniform1f(s.uniforms.u_opacity, l), i.uniform1i(s.uniforms.u_image, 0), i.uniform1i(s.uniforms.u_color_ramp, 1); const u = e.mat4.create(); e.mat4.ortho(u, 0, t.width, t.height, 0, 0, 1), i.uniformMatrix4fv(s.uniforms.u_matrix, !1, u), i.uniform2f(s.uniforms.u_world, i.drawingBufferWidth, i.drawingBufferHeight), t.viewportVAO.bind(t.context, s, t.viewportBuffer, []), i.drawArrays(i.TRIANGLE_STRIP, 0, 4); } }(t, r))); }, line(e, t, n, r) { if (e.renderPass === 'translucent' && n.paint.get('line-opacity').constantOr(1) !== 0) { const i = e.context; i.setDepthMode(e.depthModeForSublayer(0, Ht.ReadOnly)), i.setColorMode(e.colorModeForRenderPass()); for (var o, a = n.paint.get('line-dasharray') ? 'lineSDF' : n.paint.get('line-pattern') ? 'linePattern' : n.paint.get('line-gradient') ? 'lineGradient' : 'line', s = !0, l = 0, u = r; l < u.length; l += 1) { const c = u[l]; const p = t.getTile(c); const f = p.getBucket(n); if (f) { const h = f.programConfigurations.get(n.id); const d = e.context.program.get(); const m = e.useProgram(a, h); const g = s || m.program !== d; const y = o !== p.tileID.overscaledZ; g && h.setUniforms(e.context, m, n.paint, { zoom: e.transform.zoom }), G(m, e, p, f, n, c, h, g, y), o = p.tileID.overscaledZ, s = !1; } } } }, fill(t, n, r, i) { const o = r.paint.get('fill-color'); const a = r.paint.get('fill-opacity'); if (a.constantOr(1) !== 0) { const s = t.context; s.setColorMode(t.colorModeForRenderPass()); const l = r.paint.get('fill-pattern') || o.constantOr(e.default$6.transparent).a !== 1 || a.constantOr(0) !== 1 ? 'translucent' : 'opaque'; t.renderPass === l && (s.setDepthMode(t.depthModeForSublayer(1, t.renderPass === 'opaque' ? Ht.ReadWrite : Ht.ReadOnly)), Z(t, n, r, i, K)), t.renderPass === 'translucent' && r.paint.get('fill-antialias') && (s.lineWidth.set(2), s.setDepthMode(t.depthModeForSublayer(r.getPaintProperty('fill-outline-color') ? 2 : 0, Ht.ReadOnly)), Z(t, n, r, i, X)); } }, 'fill-extrusion': function (t, n, r, i) { if (r.paint.get('fill-extrusion-opacity') !== 0) if (t.renderPass === 'offscreen') { !(function (t, n) { const r = t.context; const i = r.gl; let o = n.viewportFrame; if (t.depthRboNeedsClear && t.setupOffscreenDepthRenderbuffer(), !o) { const a = new je(r, { width: t.width, height: t.height, data: null }, i.RGBA); a.bind(i.LINEAR, i.CLAMP_TO_EDGE), (o = n.viewportFrame = r.createFramebuffer(t.width, t.height)).colorAttachment.set(a.texture); }r.bindFramebuffer.set(o.framebuffer), o.depthAttachment.set(t.depthRbo), t.depthRboNeedsClear && (r.clear({ depth: 1 }), t.depthRboNeedsClear = !1), r.clear({ color: e.default$6.transparent }), r.setStencilMode(Wt.disabled), r.setDepthMode(new Ht(i.LEQUAL, Ht.ReadWrite, [0, 1])), r.setColorMode(t.colorModeForRenderPass()); }(t, r)); for (let o = !0, a = 0, s = i; a < s.length; a += 1) { const l = s[a]; const u = n.getTile(l); const c = u.getBucket(r); c && (J(t, 0, r, u, l, c, o), o = !1); } } else t.renderPass === 'translucent' && (function (e, t) { const n = t.viewportFrame; if (n) { const r = e.context; const i = r.gl; const o = e.useProgram('extrusionTexture'); r.setStencilMode(Wt.disabled), r.setDepthMode(Ht.disabled), r.setColorMode(e.colorModeForRenderPass()), r.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, n.colorAttachment.get()), i.uniform1f(o.uniforms.u_opacity, t.paint.get('fill-extrusion-opacity')), i.uniform1i(o.uniforms.u_image, 0); const a = jn.create(); jn.ortho(a, 0, e.width, e.height, 0, 0, 1), i.uniformMatrix4fv(o.uniforms.u_matrix, !1, a), i.uniform2f(o.uniforms.u_world, i.drawingBufferWidth, i.drawingBufferHeight), e.viewportVAO.bind(r, o, e.viewportBuffer, []), i.drawArrays(i.TRIANGLE_STRIP, 0, 4); } }(t, r)); }, hillshade(e, t, n, r) { if (e.renderPass === 'offscreen' || e.renderPass === 'translucent') { const i = e.context; const o = t.getSource().maxzoom; i.setDepthMode(e.depthModeForSublayer(0, Ht.ReadOnly)), i.setStencilMode(Wt.disabled), i.setColorMode(e.colorModeForRenderPass()); for (let a = 0, s = r; a < s.length; a += 1) { const l = s[a]; const u = t.getTile(l); u.needsHillshadePrepare && e.renderPass === 'offscreen' ? ee(e, u, o) : e.renderPass === 'translucent' && Q(e, u, n); }i.viewport.set([0, 0, e.width, e.height]); } }, raster(e, t, n, r) { if (e.renderPass === 'translucent' && n.paint.get('raster-opacity') !== 0) { let i; let o; const a = e.context; const s = a.gl; const l = t.getSource(); const u = e.useProgram('raster'); a.setStencilMode(Wt.disabled), a.setColorMode(e.colorModeForRenderPass()), s.uniform1f(u.uniforms.u_brightness_low, n.paint.get('raster-brightness-min')), s.uniform1f(u.uniforms.u_brightness_high, n.paint.get('raster-brightness-max')), s.uniform1f(u.uniforms.u_saturation_factor, (i = n.paint.get('raster-saturation')) > 0 ? 1 - 1 / (1.001 - i) : -i), s.uniform1f(u.uniforms.u_contrast_factor, (o = n.paint.get('raster-contrast')) > 0 ? 1 / (1 - o) : 1 + o), s.uniform3fv(u.uniforms.u_spin_weights, (function (e) { e *= Math.PI / 180; const t = Math.sin(e); const n = Math.cos(e); return [(2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3]; }(n.paint.get('raster-hue-rotate')))), s.uniform1f(u.uniforms.u_buffer_scale, 1), s.uniform1i(u.uniforms.u_image0, 0), s.uniform1i(u.uniforms.u_image1, 1); for (let c = r.length && r[0].overscaledZ, p = 0, f = r; p < f.length; p += 1) { const h = f[p]; a.setDepthMode(e.depthModeForSublayer(h.overscaledZ - c, n.paint.get('raster-opacity') === 1 ? Ht.ReadWrite : Ht.ReadOnly, s.LESS)); const d = t.getTile(h); const m = e.transform.calculatePosMatrix(h.toUnwrapped(), !0); d.registerFadeDuration(n.paint.get('raster-fade-duration')), s.uniformMatrix4fv(u.uniforms.u_matrix, !1, m); const g = t.findLoadedParent(h, 0, {}); const y = te(d, g, t, n, e.transform); let v = void 0; let _ = void 0; if (a.activeTexture.set(s.TEXTURE0), d.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), a.activeTexture.set(s.TEXTURE1), g ? (g.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), v = Math.pow(2, g.tileID.overscaledZ - d.tileID.overscaledZ), _ = [d.tileID.canonical.x * v % 1, d.tileID.canonical.y * v % 1]) : d.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), s.uniform2fv(u.uniforms.u_tl_parent, _ || [0, 0]), s.uniform1f(u.uniforms.u_scale_parent, v || 1), s.uniform1f(u.uniforms.u_fade_t, y.mix), s.uniform1f(u.uniforms.u_opacity, y.opacity * n.paint.get('raster-opacity')), l instanceof rt) { const b = l.boundsBuffer; l.boundsVAO.bind(a, u, b, []), s.drawArrays(s.TRIANGLE_STRIP, 0, b.length); } else if (d.maskedBoundsBuffer && d.maskedIndexBuffer && d.segments)u.draw(a, s.TRIANGLES, n.id, d.maskedBoundsBuffer, d.maskedIndexBuffer, d.segments); else { const x = e.rasterBoundsBuffer; e.rasterBoundsVAO.bind(a, u, x, []), s.drawArrays(s.TRIANGLE_STRIP, 0, x.length); } } } }, background(e, t, n) { const r = n.paint.get('background-color'); const i = n.paint.get('background-opacity'); if (i !== 0) { const o = e.context; const a = o.gl; const s = e.transform; const l = s.tileSize; const u = n.paint.get('background-pattern'); const c = u || r.a !== 1 || i !== 1 ? 'translucent' : 'opaque'; if (e.renderPass === c) { let p; if (o.setStencilMode(Wt.disabled), o.setDepthMode(e.depthModeForSublayer(0, c === 'opaque' ? Ht.ReadWrite : Ht.ReadOnly)), o.setColorMode(e.colorModeForRenderPass()), u) { if (Dn(u, e)) return; p = e.useProgram('backgroundPattern'), Ln(u, e, p), e.tileExtentPatternVAO.bind(o, p, e.tileExtentBuffer, []); } else p = e.useProgram('background'), a.uniform4fv(p.uniforms.u_color, [r.r, r.g, r.b, r.a]), e.tileExtentVAO.bind(o, p, e.tileExtentBuffer, []); a.uniform1f(p.uniforms.u_opacity, i); for (let f = 0, h = s.coveringTiles({ tileSize: l }); f < h.length; f += 1) { const d = h[f]; u && zn({ tileID: d, tileSize: l }, e, p), a.uniformMatrix4fv(p.uniforms.u_matrix, !1, e.transform.calculatePosMatrix(d.toUnwrapped())), a.drawArrays(a.TRIANGLE_STRIP, 0, e.tileExtentBuffer.length); } } } }, debug(e, t, n) { for (let r = 0; r < n.length; r++)ne(e, t, n[r]); },
        }; const Vn = function (t, n) { this.context = new Gt(t), this.transform = n, this._tileTextures = {}, this.setup(), this.numSublayers = Zt.maxUnderzooming + Zt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.depthRboNeedsClear = !0, this.emptyProgramConfiguration = new e.default$24(), this.crossTileSymbolIndex = new xn(); }; Vn.prototype.resize = function (e, t) { const n = this.context.gl; if (this.width = e * ge.devicePixelRatio, this.height = t * ge.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (let r = 0, i = this.style._order; r < i.length; r += 1) { const o = i[r]; this.style._layers[o].resize(); } this.depthRbo && (n.deleteRenderbuffer(this.depthRbo), this.depthRbo = null); }, Vn.prototype.setup = function () { const t = this.context; const n = new e.PosArray(); n.emplaceBack(0, 0), n.emplaceBack(e.default$8, 0), n.emplaceBack(0, e.default$8), n.emplaceBack(e.default$8, e.default$8), this.tileExtentBuffer = t.createVertexBuffer(n, Cn.members), this.tileExtentVAO = new nt(), this.tileExtentPatternVAO = new nt(); const r = new e.PosArray(); r.emplaceBack(0, 0), r.emplaceBack(e.default$8, 0), r.emplaceBack(e.default$8, e.default$8), r.emplaceBack(0, e.default$8), r.emplaceBack(0, 0), this.debugBuffer = t.createVertexBuffer(r, Cn.members), this.debugVAO = new nt(); const i = new e.RasterBoundsArray(); i.emplaceBack(0, 0, 0, 0), i.emplaceBack(e.default$8, 0, e.default$8, 0), i.emplaceBack(0, e.default$8, 0, e.default$8), i.emplaceBack(e.default$8, e.default$8, e.default$8, e.default$8), this.rasterBoundsBuffer = t.createVertexBuffer(i, tt.members), this.rasterBoundsVAO = new nt(); const o = new e.PosArray(); o.emplaceBack(0, 0), o.emplaceBack(1, 0), o.emplaceBack(0, 1), o.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(o, Cn.members), this.viewportVAO = new nt(); }, Vn.prototype.clearStencil = function () { const t = this.context; const n = t.gl; t.setColorMode($t.disabled), t.setDepthMode(Ht.disabled), t.setStencilMode(new Wt({ func: n.ALWAYS, mask: 0 }, 0, 255, n.ZERO, n.ZERO, n.ZERO)); const r = e.mat4.create(); e.mat4.ortho(r, 0, this.width, this.height, 0, 0, 1), e.mat4.scale(r, r, [n.drawingBufferWidth, n.drawingBufferHeight, 0]); const i = this.useProgram('clippingMask'); n.uniformMatrix4fv(i.uniforms.u_matrix, !1, r), this.viewportVAO.bind(t, i, this.viewportBuffer, []), n.drawArrays(n.TRIANGLE_STRIP, 0, 4); }, Vn.prototype._renderTileClippingMasks = function (e) { const t = this.context; const n = t.gl; t.setColorMode($t.disabled), t.setDepthMode(Ht.disabled); let r = 1; this._tileClippingMaskIDs = {}; for (let i = 0, o = e; i < o.length; i += 1) { const a = o[i]; const s = this._tileClippingMaskIDs[a.key] = r++; t.setStencilMode(new Wt({ func: n.ALWAYS, mask: 0 }, s, 255, n.KEEP, n.KEEP, n.REPLACE)); const l = this.useProgram('clippingMask'); n.uniformMatrix4fv(l.uniforms.u_matrix, !1, a.posMatrix), this.tileExtentVAO.bind(this.context, l, this.tileExtentBuffer, []), n.drawArrays(n.TRIANGLE_STRIP, 0, this.tileExtentBuffer.length); } }, Vn.prototype.stencilModeForClipping = function (e) { const t = this.context.gl; return new Wt({ func: t.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE); }, Vn.prototype.colorModeForRenderPass = function () { const t = this.context.gl; return this._showOverdrawInspector ? new $t([t.CONSTANT_COLOR, t.ONE], new e.default$6(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : this.renderPass === 'opaque' ? $t.unblended : $t.alphaBlended; }, Vn.prototype.depthModeForSublayer = function (e, t, n) { const r = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon; const i = r - 1 + this.depthRange; return new Ht(n || this.context.gl.LEQUAL, t, [i, r]); }, Vn.prototype.render = function (t, n) { const r = this; for (const i in this.style = t, this.options = n, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(ge.now()), t.sourceCaches) { const o = r.style.sourceCaches[i]; o.used && o.prepare(r.context); } const a = this.style._order; const s = e.filterObject(this.style.sourceCaches, e => e.getSource().type === 'raster' || e.getSource().type === 'raster-dem'); for (const l in s)!(function (t) { const n = s[t]; !(function (t, n) { for (let r = t.sort((e, t) => (e.tileID.isLessThan(t.tileID) ? -1:t.tileID.isLessThan(e.tileID) ? 1:0)), i = 0; i < r.length; i++) { const o = {}; const a = r[i]; const s = r.slice(i + 1); U(a.tileID.wrapped(), a.tileID, s, new e.OverscaledTileID(0, a.tileID.wrap + 1, 0, 0, 0), o), a.setMask(o, n); } }(n.getVisibleCoordinates().map(e => n.getTile(e)), r.context)); }(l)); this.renderPass = 'offscreen'; let u; let c = []; this.depthRboNeedsClear = !0; for (let p = 0; p < a.length; p++) { const f = r.style._layers[a[p]]; f.hasOffscreenPass() && !f.isHidden(r.transform.zoom) && (f.source !== (u && u.id) && (c = [], (u = r.style.sourceCaches[f.source]) && (c = u.getVisibleCoordinates()).reverse()), c.length && r.renderLayer(r, u, f, c)); } this.context.bindFramebuffer.set(null), this.context.clear({ color: n.showOverdrawInspector ? e.default$6.black : e.default$6.transparent, depth: 1 }), this._showOverdrawInspector = n.showOverdrawInspector, this.depthRange = (t._order.length + 2) * this.numSublayers * this.depthEpsilon, this.renderPass = 'opaque'; let h; let d = []; for (this.currentLayer = a.length - 1, this.currentLayer; this.currentLayer >= 0; this.currentLayer--) { const m = r.style._layers[a[r.currentLayer]]; m.source !== (h && h.id) && (d = [], (h = r.style.sourceCaches[m.source]) && (r.clearStencil(), d = h.getVisibleCoordinates(), h.getSource().isTileClipped && r._renderTileClippingMasks(d))), r.renderLayer(r, h, m, d); } this.renderPass = 'translucent'; let g; let y = []; for (this.currentLayer = 0, this.currentLayer; this.currentLayer < a.length; this.currentLayer++) { const v = r.style._layers[a[r.currentLayer]]; v.source !== (g && g.id) && (y = [], (g = r.style.sourceCaches[v.source]) && (r.clearStencil(), y = g.getVisibleCoordinates(), g.getSource().isTileClipped && r._renderTileClippingMasks(y)), y.reverse()), r.renderLayer(r, g, v, y); } if (this.options.showTileBoundaries) { const _ = this.style.sourceCaches[Object.keys(this.style.sourceCaches)[0]]; _ && Un.debug(this, _, _.getVisibleCoordinates()); } }, Vn.prototype.setupOffscreenDepthRenderbuffer = function () { const e = this.context; this.depthRbo || (this.depthRbo = e.createRenderbuffer(e.gl.DEPTH_COMPONENT16, this.width, this.height)); }, Vn.prototype.renderLayer = function (e, t, n, r) { n.isHidden(this.transform.zoom) || (n.type === 'background' || r.length) && (this.id = n.id, Un[n.type](e, t, n, r)); }, Vn.prototype.translatePosMatrix = function (t, n, r, i, o) { if (!r[0] && !r[1]) return t; const a = o ? i === 'map' ? this.transform.angle : 0 : i === 'viewport' ? -this.transform.angle : 0; if (a) { const s = Math.sin(a); const l = Math.cos(a); r = [r[0] * l - r[1] * s, r[0] * s + r[1] * l]; } const u = [o ? r[0] : j(n, r[0], this.transform.zoom), o ? r[1] : j(n, r[1], this.transform.zoom), 0]; const c = new Float32Array(16); return e.mat4.translate(c, t, u), c; }, Vn.prototype.saveTileTexture = function (e) { const t = this._tileTextures[e.size[0]]; t ? t.push(e) : this._tileTextures[e.size[0]] = [e]; }, Vn.prototype.getTileTexture = function (e) { const t = this._tileTextures[e]; return t && t.length > 0 ? t.pop() : null; }, Vn.prototype._createProgramCached = function (e, t) { this.cache = this.cache || {}; const n = `${e}${t.cacheKey || ''}${this._showOverdrawInspector ? '/overdraw' : ''}`; return this.cache[n] || (this.cache[n] = new Pn(this.context, In[e], t, this._showOverdrawInspector)), this.cache[n]; }, Vn.prototype.useProgram = function (e, t) { const n = this._createProgramCached(e, t || this.emptyProgramConfiguration); return this.context.program.set(n.program), n; }; const qn = e.default$20.vec4; const Hn = e.default$20.mat4; const Wn = e.default$20.mat2; const $n = function (e, t, n) { this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = e || 0, this._maxZoom = t || 22, this.latRange = [-85.05113, 85.05113], this.width = 0, this.height = 0, this._center = new Ze(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}; }; const Gn = {
          minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerPoint: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, unmodified: { configurable: !0 }, x: { configurable: !0 }, y: { configurable: !0 }, point: { configurable: !0 },
        }; $n.prototype.clone = function () { const e = new $n(this._minZoom, this._maxZoom, this._renderWorldCopies); return e.tileSize = this.tileSize, e.latRange = this.latRange, e.width = this.width, e.height = this.height, e._center = this._center, e.zoom = this.zoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._unmodified = this._unmodified, e._calcMatrices(), e; }, Gn.minZoom.get = function () { return this._minZoom; }, Gn.minZoom.set = function (e) { this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e)); }, Gn.maxZoom.get = function () { return this._maxZoom; }, Gn.maxZoom.set = function (e) { this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e)); }, Gn.renderWorldCopies.get = function () { return this._renderWorldCopies; }, Gn.renderWorldCopies.set = function (e) { void 0 === e ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e; }, Gn.worldSize.get = function () { return this.tileSize * this.scale; }, Gn.centerPoint.get = function () { return this.size._div(2); }, Gn.size.get = function () { return new e.default$1(this.width, this.height); }, Gn.bearing.get = function () { return -this.angle / Math.PI * 180; }, Gn.bearing.set = function (t) { const n = -e.wrap(t, -180, 180) * Math.PI / 180; this.angle !== n && (this._unmodified = !1, this.angle = n, this._calcMatrices(), this.rotationMatrix = Wn.create(), Wn.rotate(this.rotationMatrix, this.rotationMatrix, this.angle)); }, Gn.pitch.get = function () { return this._pitch / Math.PI * 180; }, Gn.pitch.set = function (t) { const n = e.clamp(t, 0, 60) / 180 * Math.PI; this._pitch !== n && (this._unmodified = !1, this._pitch = n, this._calcMatrices()); }, Gn.fov.get = function () { return this._fov / Math.PI * 180; }, Gn.fov.set = function (e) { e = Math.max(0.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices()); }, Gn.zoom.get = function () { return this._zoom; }, Gn.zoom.set = function (e) { const t = Math.min(Math.max(e, this.minZoom), this.maxZoom); this._zoom !== t && (this._unmodified = !1, this._zoom = t, this.scale = this.zoomScale(t), this.tileZoom = Math.floor(t), this.zoomFraction = t - this.tileZoom, this._constrain(), this._calcMatrices()); }, Gn.center.get = function () { return this._center; }, Gn.center.set = function (e) { e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices()); }, $n.prototype.coveringZoomLevel = function (e) { return (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize)); }, $n.prototype.getVisibleUnwrappedCoordinates = function (t) { const n = this.pointCoordinate(new e.default$1(0, 0), 0); const r = this.pointCoordinate(new e.default$1(this.width, 0), 0); const i = Math.floor(n.column); const o = Math.floor(r.column); const a = [new e.UnwrappedTileID(0, t)]; if (this._renderWorldCopies) for (let s = i; s <= o; s++)s !== 0 && a.push(new e.UnwrappedTileID(s, t)); return a; }, $n.prototype.coveringTiles = function (t) { let n = this.coveringZoomLevel(t); const r = n; if (void 0 !== t.minzoom && n < t.minzoom) return []; void 0 !== t.maxzoom && n > t.maxzoom && (n = t.maxzoom); const i = this.pointCoordinate(this.centerPoint, n); const o = new e.default$1(i.column - 0.5, i.row - 0.5); return (function (t, n, r, i) { function o(n, o, l) { let u; let c; let p; let f; if (l >= 0 && l <= a) for (u = n; u < o; u++)c = Math.floor(u / a), p = (u % a + a) % a, c !== 0 && !0 !== i || (f = new e.OverscaledTileID(r, c, t, p, l), s[f.key] = f); } void 0 === i && (i = !0); var a = 1 << t; var s = {}; return oe(n[0], n[1], n[2], 0, a, o), oe(n[2], n[3], n[0], 0, a, o), Object.keys(s).map(e => s[e]); }(n, [this.pointCoordinate(new e.default$1(0, 0), n), this.pointCoordinate(new e.default$1(this.width, 0), n), this.pointCoordinate(new e.default$1(this.width, this.height), n), this.pointCoordinate(new e.default$1(0, this.height), n)], t.reparseOverscaled ? r : n, this._renderWorldCopies)).sort((e, t) => o.dist(e.canonical) - o.dist(t.canonical)); }, $n.prototype.resize = function (e, t) { this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices(); }, Gn.unmodified.get = function () { return this._unmodified; }, $n.prototype.zoomScale = function (e) { return Math.pow(2, e); }, $n.prototype.scaleZoom = function (e) { return Math.log(e) / Math.LN2; }, $n.prototype.project = function (t) { return new e.default$1(this.lngX(t.lng), this.latY(t.lat)); }, $n.prototype.unproject = function (e) { return new Ze(this.xLng(e.x), this.yLat(e.y)); }, Gn.x.get = function () { return this.lngX(this.center.lng); }, Gn.y.get = function () { return this.latY(this.center.lat); }, Gn.point.get = function () { return new e.default$1(this.x, this.y); }, $n.prototype.lngX = function (e) { return (180 + e) * this.worldSize / 360; }, $n.prototype.latY = function (e) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) * this.worldSize / 360; }, $n.prototype.xLng = function (e) { return 360 * e / this.worldSize - 180; }, $n.prototype.yLat = function (e) { const t = 180 - 360 * e / this.worldSize; return 360 / Math.PI * Math.atan(Math.exp(t * Math.PI / 180)) - 90; }, $n.prototype.setLocationAtPoint = function (e, t) { const n = this.pointCoordinate(t)._sub(this.pointCoordinate(this.centerPoint)); this.center = this.coordinateLocation(this.locationCoordinate(e)._sub(n)), this._renderWorldCopies && (this.center = this.center.wrap()); }, $n.prototype.locationPoint = function (e) { return this.coordinatePoint(this.locationCoordinate(e)); }, $n.prototype.pointLocation = function (e) { return this.coordinateLocation(this.pointCoordinate(e)); }, $n.prototype.locationCoordinate = function (t) { return new e.default$17(this.lngX(t.lng) / this.tileSize, this.latY(t.lat) / this.tileSize, this.zoom).zoomTo(this.tileZoom); }, $n.prototype.coordinateLocation = function (e) { const t = e.zoomTo(this.zoom); return new Ze(this.xLng(t.column * this.tileSize), this.yLat(t.row * this.tileSize)); }, $n.prototype.pointCoordinate = function (t, n) { void 0 === n && (n = this.tileZoom); const r = [t.x, t.y, 0, 1]; const i = [t.x, t.y, 1, 1]; qn.transformMat4(r, r, this.pixelMatrixInverse), qn.transformMat4(i, i, this.pixelMatrixInverse); const o = r[3]; const a = i[3]; const s = r[0] / o; const l = i[0] / a; const u = r[1] / o; const c = i[1] / a; const p = r[2] / o; const f = i[2] / a; const h = p === f ? 0 : (0 - p) / (f - p); return new e.default$17(e.number(s, l, h) / this.tileSize, e.number(u, c, h) / this.tileSize, this.zoom)._zoomTo(n); }, $n.prototype.coordinatePoint = function (t) { const n = t.zoomTo(this.zoom); const r = [n.column * this.tileSize, n.row * this.tileSize, 0, 1]; return qn.transformMat4(r, r, this.pixelMatrix), new e.default$1(r[0] / r[3], r[1] / r[3]); }, $n.prototype.calculatePosMatrix = function (t, n) { void 0 === n && (n = !1); const r = t.key; const i = n ? this._alignedPosMatrixCache : this._posMatrixCache; if (i[r]) return i[r]; const o = t.canonical; const a = this.worldSize / this.zoomScale(o.z); const s = o.x + Math.pow(2, o.z) * t.wrap; const l = Hn.identity(new Float64Array(16)); return Hn.translate(l, l, [s * a, o.y * a, 0]), Hn.scale(l, l, [a / e.default$8, a / e.default$8, 1]), Hn.multiply(l, n ? this.alignedProjMatrix : this.projMatrix, l), i[r] = new Float32Array(l), i[r]; }, $n.prototype._constrain = function () { if (this.center && this.width && this.height && !this._constraining) { this._constraining = !0; let t; let n; let r; let i; let o = -90; let a = 90; let s = -180; let l = 180; const u = this.size; const c = this._unmodified; if (this.latRange) { const p = this.latRange; o = this.latY(p[1]), t = (a = this.latY(p[0])) - o < u.y ? u.y / (a - o) : 0; } if (this.lngRange) { const f = this.lngRange; s = this.lngX(f[0]), n = (l = this.lngX(f[1])) - s < u.x ? u.x / (l - s) : 0; } const h = Math.max(n || 0, t || 0); if (h) return this.center = this.unproject(new e.default$1(n ? (l + s) / 2 : this.x, t ? (a + o) / 2 : this.y)), this.zoom += this.scaleZoom(h), this._unmodified = c, void (this._constraining = !1); if (this.latRange) { const d = this.y; const m = u.y / 2; d - m < o && (i = o + m), d + m > a && (i = a - m); } if (this.lngRange) { const g = this.x; const y = u.x / 2; g - y < s && (r = s + y), g + y > l && (r = l - y); } void 0 === r && void 0 === i || (this.center = this.unproject(new e.default$1(void 0 !== r ? r : this.x, void 0 !== i ? i : this.y))), this._unmodified = c, this._constraining = !1; } }, $n.prototype._calcMatrices = function () { if (this.height) { this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height; const e = this._fov / 2; const t = Math.PI / 2 + this._pitch; const n = Math.sin(e) * this.cameraToCenterDistance / Math.sin(Math.PI - t - e); const r = this.x; const i = this.y; const o = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * n + this.cameraToCenterDistance); let a = new Float64Array(16); Hn.perspective(a, this._fov, this.width / this.height, 1, o), Hn.scale(a, a, [1, -1, 1]), Hn.translate(a, a, [0, 0, -this.cameraToCenterDistance]), Hn.rotateX(a, a, this._pitch), Hn.rotateZ(a, a, this.angle), Hn.translate(a, a, [-r, -i, 0]); const s = this.worldSize / (2 * Math.PI * 6378137 * Math.abs(Math.cos(this.center.lat * (Math.PI / 180)))); Hn.scale(a, a, [1, 1, s, 1]), this.projMatrix = a; const l = this.width % 2 / 2; const u = this.height % 2 / 2; const c = Math.cos(this.angle); const p = Math.sin(this.angle); const f = r - Math.round(r) + c * l + p * u; const h = i - Math.round(i) + c * u + p * l; const d = new Float64Array(a); if (Hn.translate(d, d, [f > 0.5 ? f - 1 : f, h > 0.5 ? h - 1 : h, 0]), this.alignedProjMatrix = d, a = Hn.create(), Hn.scale(a, a, [this.width / 2, -this.height / 2, 1]), Hn.translate(a, a, [1, -1, 0]), this.pixelMatrix = Hn.multiply(new Float64Array(16), a, this.projMatrix), !(a = Hn.invert(new Float64Array(16), this.pixelMatrix))) throw new Error('failed to invert matrix'); this.pixelMatrixInverse = a, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}; } }, $n.prototype.maxPitchScaleFactor = function () { if (!this.pixelMatrixInverse) return 1; const t = this.pointCoordinate(new e.default$1(0, 0)).zoomTo(this.zoom); const n = [t.column * this.tileSize, t.row * this.tileSize, 0, 1]; return qn.transformMat4(n, n, this.pixelMatrix)[3] / this.cameraToCenterDistance; }, Object.defineProperties($n.prototype, Gn); const Zn = function () { let t; let n; let r; let i; let o; e.bindAll(['_onHashChange', '_updateHash'], this), this._updateHash = (t = this._updateHashUnthrottled.bind(this), n = 300, r = !1, i = 0, o = function () { i = 0, r && (t(), i = setTimeout(o, n), r = !1); }, function () { return r = !0, i || o(), i; }); }; Zn.prototype.addTo = function (t) { return this._map = t, e.default.addEventListener('hashchange', this._onHashChange, !1), this._map.on('moveend', this._updateHash), this; }, Zn.prototype.remove = function () { return e.default.removeEventListener('hashchange', this._onHashChange, !1), this._map.off('moveend', this._updateHash), clearTimeout(this._updateHash()), delete this._map, this; }, Zn.prototype.getHashString = function (e) { const t = this._map.getCenter(); const n = Math.round(100 * this._map.getZoom()) / 100; const r = Math.ceil((n * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10); const i = Math.pow(10, r); const o = Math.round(t.lng * i) / i; const a = Math.round(t.lat * i) / i; const s = this._map.getBearing(); const l = this._map.getPitch(); let u = ''; return u += e ? `#/${o}/${a}/${n}` : `#${n}/${a}/${o}`, (s || l) && (u += `/${Math.round(10 * s) / 10}`), l && (u += `/${Math.round(l)}`), u; }, Zn.prototype._onHashChange = function () {
          const t = e.default.location.hash.replace('#', '').split('/'); return t.length >= 3 && (this._map.jumpTo({
            center: [+t[2], +t[1]], zoom: +t[0], bearing: +(t[3] || 0), pitch: +(t[4] || 0),
          }), !0);
        }, Zn.prototype._updateHashUnthrottled = function () { const t = this.getHashString(); e.default.history.replaceState(e.default.history.state, '', t); }; const Kn = (function (t) { function n(n, r, i, o) { void 0 === o && (o = {}); const a = _e.mousePos(r.getCanvasContainer(), i); const s = r.unproject(a); t.call(this, n, e.extend({ point: a, lngLat: s, originalEvent: i }, o)), this._defaultPrevented = !1, this.target = r; }t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n; const r = { defaultPrevented: { configurable: !0 } }; return n.prototype.preventDefault = function () { this._defaultPrevented = !0; }, r.defaultPrevented.get = function () { return this._defaultPrevented; }, Object.defineProperties(n.prototype, r), n; }(e.Event)); const Xn = (function (t) {
          function n(n, r, i) {
            const o = _e.touchPos(r.getCanvasContainer(), i); const a = o.map(e => r.unproject(e)); const s = o.reduce((e, t, n, r) => e.add(t.div(r.length)), new e.default$1(0, 0)); const l = r.unproject(s); t.call(this, n, {
              points: o, point: s, lngLats: a, lngLat: l, originalEvent: i,
            }), this._defaultPrevented = !1;
          }t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n; const r = { defaultPrevented: { configurable: !0 } }; return n.prototype.preventDefault = function () { this._defaultPrevented = !0; }, r.defaultPrevented.get = function () { return this._defaultPrevented; }, Object.defineProperties(n.prototype, r), n;
        }(e.Event)); const Yn = (function (e) { function t(t, n, r) { e.call(this, t, { originalEvent: r }), this._defaultPrevented = !1; }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const n = { defaultPrevented: { configurable: !0 } }; return t.prototype.preventDefault = function () { this._defaultPrevented = !0; }, n.defaultPrevented.get = function () { return this._defaultPrevented; }, Object.defineProperties(t.prototype, n), t; }(e.Event)); const Jn = function (t) { this._map = t, this._el = t.getCanvasContainer(), this._delta = 0, e.bindAll(['_onWheel', '_onTimeout', '_onScrollFrame', '_onScrollFinished'], this); }; Jn.prototype.isEnabled = function () { return !!this._enabled; }, Jn.prototype.isActive = function () { return !!this._active; }, Jn.prototype.enable = function (e) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = e && e.around === 'center'); }, Jn.prototype.disable = function () { this.isEnabled() && (this._enabled = !1); }, Jn.prototype.onWheel = function (t) { if (this.isEnabled()) { let n = t.deltaMode === e.default.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY; const r = ge.now(); const i = r - (this._lastWheelEventTime || 0); this._lastWheelEventTime = r, n !== 0 && n % 4.000244140625 == 0 ? this._type = 'wheel' : n !== 0 && Math.abs(n) < 4 ? this._type = 'trackpad' : i > 400 ? (this._type = null, this._lastValue = n, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(i * n) < 200 ? 'trackpad' : 'wheel', this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), t.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = t, this._delta -= n, this.isActive() || this._start(t)), t.preventDefault(); } }, Jn.prototype._onTimeout = function (e) { this._type = 'wheel', this._delta -= this._lastValue, this.isActive() || this._start(e); }, Jn.prototype._start = function (t) { if (this._delta) { this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), this._active = !0, this._map.fire(new e.Event('movestart', { originalEvent: t })), this._map.fire(new e.Event('zoomstart', { originalEvent: t })), this._finishTimeout && clearTimeout(this._finishTimeout); const n = _e.mousePos(this._el, t); this._around = Ze.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(n)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onScrollFrame)); } }, Jn.prototype._onScrollFrame = function () { const t = this; if (this._frameId = null, this.isActive()) { const n = this._map.transform; if (this._delta !== 0) { const r = this._type === 'wheel' && Math.abs(this._delta) > 4.000244140625 ? 1 / 450 : 0.01; let i = 2 / (1 + Math.exp(-Math.abs(this._delta * r))); this._delta < 0 && i !== 0 && (i = 1 / i); const o = typeof this._targetZoom === 'number' ? n.zoomScale(this._targetZoom) : n.scale; this._targetZoom = Math.min(n.maxZoom, Math.max(n.minZoom, n.scaleZoom(o * i))), this._type === 'wheel' && (this._startZoom = n.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0; } let a = !1; if (this._type === 'wheel') { const s = Math.min((ge.now() - this._lastWheelEventTime) / 200, 1); const l = this._easing(s); n.zoom = e.number(this._startZoom, this._targetZoom, l), s < 1 ? this._frameId || (this._frameId = this._map._requestRenderFrame(this._onScrollFrame)) : a = !0; } else n.zoom = this._targetZoom, a = !0; n.setLocationAtPoint(this._around, this._aroundPoint), this._map.fire(new e.Event('move', { originalEvent: this._lastWheelEvent })), this._map.fire(new e.Event('zoom', { originalEvent: this._lastWheelEvent })), a && (this._active = !1, this._finishTimeout = setTimeout(() => { t._map.fire(new e.Event('zoomend', { originalEvent: t._lastWheelEvent })), t._map.fire(new e.Event('moveend', { originalEvent: t._lastWheelEvent })), delete t._targetZoom; }, 200)); } }, Jn.prototype._smoothOutEasing = function (t) { let n = e.ease; if (this._prevEase) { const r = this._prevEase; const i = (ge.now() - r.start) / r.duration; const o = r.easing(i + 0.01) - r.easing(i); const a = 0.27 / Math.sqrt(o * o + 1e-4) * 0.01; const s = Math.sqrt(0.0729 - a * a); n = e.bezier(a, s, 0.25, 1); } return this._prevEase = { start: ge.now(), duration: t, easing: n }, n; }; const Qn = function (t) { this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), e.bindAll(['_onMouseMove', '_onMouseUp', '_onKeyDown'], this); }; Qn.prototype.isEnabled = function () { return !!this._enabled; }, Qn.prototype.isActive = function () { return !!this._active; }, Qn.prototype.enable = function () { this.isEnabled() || (this._enabled = !0); }, Qn.prototype.disable = function () { this.isEnabled() && (this._enabled = !1); }, Qn.prototype.onMouseDown = function (t) { this.isEnabled() && t.shiftKey && t.button === 0 && (e.default.document.addEventListener('mousemove', this._onMouseMove, !1), e.default.document.addEventListener('keydown', this._onKeyDown, !1), e.default.document.addEventListener('mouseup', this._onMouseUp, !1), _e.disableDrag(), this._startPos = _e.mousePos(this._el, t), this._active = !0); }, Qn.prototype._onMouseMove = function (e) { const t = this._startPos; const n = _e.mousePos(this._el, e); this._box || (this._box = _e.create('div', 'mapboxgl-boxzoom', this._container), this._container.classList.add('mapboxgl-crosshair'), this._fireEvent('boxzoomstart', e)); const r = Math.min(t.x, n.x); const i = Math.max(t.x, n.x); const o = Math.min(t.y, n.y); const a = Math.max(t.y, n.y); _e.setTransform(this._box, `translate(${r}px,${o}px)`), this._box.style.width = `${i - r}px`, this._box.style.height = `${a - o}px`; }, Qn.prototype._onMouseUp = function (t) { if (t.button === 0) { const n = this._startPos; const r = _e.mousePos(this._el, t); const i = (new Ke()).extend(this._map.unproject(n)).extend(this._map.unproject(r)); this._finish(), _e.suppressClick(), n.x === r.x && n.y === r.y ? this._fireEvent('boxzoomcancel', t) : this._map.fitBounds(i, { linear: !0 }).fire(new e.Event('boxzoomend', { originalEvent: t, boxZoomBounds: i })); } }, Qn.prototype._onKeyDown = function (e) { e.keyCode === 27 && (this._finish(), this._fireEvent('boxzoomcancel', e)); }, Qn.prototype._finish = function () { this._active = !1, e.default.document.removeEventListener('mousemove', this._onMouseMove, !1), e.default.document.removeEventListener('keydown', this._onKeyDown, !1), e.default.document.removeEventListener('mouseup', this._onMouseUp, !1), this._container.classList.remove('mapboxgl-crosshair'), this._box && (_e.remove(this._box), this._box = null), _e.enableDrag(); }, Qn.prototype._fireEvent = function (t, n) { return this._map.fire(new e.Event(t, { originalEvent: n })); }; const er = e.bezier(0, 0, 0.25, 1); const tr = function (t, n) { this._map = t, this._el = n.element || t.getCanvasContainer(), this._state = 'disabled', this._button = n.button || 'right', this._bearingSnap = n.bearingSnap || 0, this._pitchWithRotate = !1 !== n.pitchWithRotate, e.bindAll(['_onMouseMove', '_onMouseUp', '_onBlur', '_onDragFrame'], this); }; tr.prototype.isEnabled = function () { return this._state !== 'disabled'; }, tr.prototype.isActive = function () { return this._state === 'active'; }, tr.prototype.enable = function () { this.isEnabled() || (this._state = 'enabled'); }, tr.prototype.disable = function () { if (this.isEnabled()) switch (this._state) { case 'active': this._state = 'disabled', this._unbind(), this._deactivate(), this._fireEvent('rotateend'), this._pitchWithRotate && this._fireEvent('pitchend'), this._fireEvent('moveend'); break; case 'pending': this._state = 'disabled', this._unbind(); break; default: this._state = 'disabled'; } }, tr.prototype.onMouseDown = function (t) { if (this._state === 'enabled') { if (this._button === 'right') { if (this._eventButton = _e.mouseButton(t), this._eventButton !== (t.ctrlKey ? 0 : 2)) return; } else { if (t.ctrlKey || _e.mouseButton(t) !== 0) return; this._eventButton = 0; }_e.disableDrag(), e.default.document.addEventListener('mousemove', this._onMouseMove, { capture: !0 }), e.default.document.addEventListener('mouseup', this._onMouseUp), e.default.addEventListener('blur', this._onBlur), this._state = 'pending', this._inertia = [[ge.now(), this._map.getBearing()]], this._previousPos = _e.mousePos(this._el, t), this._center = this._map.transform.centerPoint, t.preventDefault(); } }, tr.prototype._onMouseMove = function (e) { this._lastMoveEvent = e, this._pos = _e.mousePos(this._el, e), this._state === 'pending' && (this._state = 'active', this._fireEvent('rotatestart', e), this._fireEvent('movestart', e), this._pitchWithRotate && this._fireEvent('pitchstart', e)), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onDragFrame)); }, tr.prototype._onDragFrame = function () { this._frameId = null; const e = this._lastMoveEvent; if (e) { const t = this._map.transform; const n = this._previousPos; const r = this._pos; const i = 0.8 * (n.x - r.x); const o = -0.5 * (n.y - r.y); const a = t.bearing - i; const s = t.pitch - o; const l = this._inertia; const u = l[l.length - 1]; this._drainInertiaBuffer(), l.push([ge.now(), this._map._normalizeBearing(a, u[1])]), t.bearing = a, this._pitchWithRotate && (this._fireEvent('pitch', e), t.pitch = s), this._fireEvent('rotate', e), this._fireEvent('move', e), delete this._lastMoveEvent, this._previousPos = this._pos; } }, tr.prototype._onMouseUp = function (e) { if (_e.mouseButton(e) === this._eventButton) switch (this._state) { case 'active': this._state = 'enabled', _e.suppressClick(), this._unbind(), this._deactivate(), this._inertialRotate(e); break; case 'pending': this._state = 'enabled', this._unbind(); } }, tr.prototype._onBlur = function (e) { switch (this._state) { case 'active': this._state = 'enabled', this._unbind(), this._deactivate(), this._fireEvent('rotateend', e), this._pitchWithRotate && this._fireEvent('pitchend', e), this._fireEvent('moveend', e); break; case 'pending': this._state = 'enabled', this._unbind(); } }, tr.prototype._unbind = function () { e.default.document.removeEventListener('mousemove', this._onMouseMove, { capture: !0 }), e.default.document.removeEventListener('mouseup', this._onMouseUp), e.default.removeEventListener('blur', this._onBlur), _e.enableDrag(); }, tr.prototype._deactivate = function () { this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._lastMoveEvent, delete this._previousPos; }, tr.prototype._inertialRotate = function (e) { const t = this; this._fireEvent('rotateend', e), this._drainInertiaBuffer(); const n = this._map; const r = n.getBearing(); const i = this._inertia; const o = function () { Math.abs(r) < t._bearingSnap ? n.resetNorth({ noMoveStart: !0 }, { originalEvent: e }) : t._fireEvent('moveend', e), t._pitchWithRotate && t._fireEvent('pitchend', e); }; if (i.length < 2)o(); else { const a = i[0]; const s = i[i.length - 1]; const l = i[i.length - 2]; let u = n._normalizeBearing(r, l[1]); const c = s[1] - a[1]; const p = c < 0 ? -1 : 1; const f = (s[0] - a[0]) / 1e3; if (c !== 0 && f !== 0) { let h = Math.abs(c * (0.25 / f)); h > 180 && (h = 180); const d = h / 180; u += p * h * (d / 2), Math.abs(n._normalizeBearing(u, 0)) < this._bearingSnap && (u = n._normalizeBearing(0, u)), n.rotateTo(u, { duration: 1e3 * d, easing: er, noMoveStart: !0 }, { originalEvent: e }); } else o(); } }, tr.prototype._fireEvent = function (t, n) { return this._map.fire(new e.Event(t, n ? { originalEvent: n } : {})); }, tr.prototype._drainInertiaBuffer = function () { for (let e = this._inertia, t = ge.now(); e.length > 0 && t - e[0][0] > 160;)e.shift(); }; const nr = e.bezier(0, 0, 0.3, 1); const rr = function (t) { this._map = t, this._el = t.getCanvasContainer(), this._state = 'disabled', e.bindAll(['_onMove', '_onMouseUp', '_onTouchEnd', '_onBlur', '_onDragFrame'], this); }; rr.prototype.isEnabled = function () { return this._state !== 'disabled'; }, rr.prototype.isActive = function () { return this._state === 'active'; }, rr.prototype.enable = function () { this.isEnabled() || (this._el.classList.add('mapboxgl-touch-drag-pan'), this._state = 'enabled'); }, rr.prototype.disable = function () { if (this.isEnabled()) switch (this._el.classList.remove('mapboxgl-touch-drag-pan'), this._state) { case 'active': this._state = 'disabled', this._unbind(), this._deactivate(), this._fireEvent('dragend'), this._fireEvent('moveend'); break; case 'pending': this._state = 'disabled', this._unbind(); break; default: this._state = 'disabled'; } }, rr.prototype.onMouseDown = function (t) { this._state === 'enabled' && (t.ctrlKey || _e.mouseButton(t) !== 0 || (_e.addEventListener(e.default.document, 'mousemove', this._onMove, { capture: !0 }), _e.addEventListener(e.default.document, 'mouseup', this._onMouseUp), this._start(t))); }, rr.prototype.onTouchStart = function (t) { this._state === 'enabled' && (t.touches.length > 1 || (_e.addEventListener(e.default.document, 'touchmove', this._onMove, { capture: !0, passive: !1 }), _e.addEventListener(e.default.document, 'touchend', this._onTouchEnd), this._start(t))); }, rr.prototype._start = function (t) { e.default.addEventListener('blur', this._onBlur), this._state = 'pending', this._previousPos = _e.mousePos(this._el, t), this._inertia = [[ge.now(), this._previousPos]]; }, rr.prototype._onMove = function (e) { this._lastMoveEvent = e, e.preventDefault(), this._pos = _e.mousePos(this._el, e), this._drainInertiaBuffer(), this._inertia.push([ge.now(), this._pos]), this._state === 'pending' && (this._state = 'active', this._fireEvent('dragstart', e), this._fireEvent('movestart', e)), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onDragFrame)); }, rr.prototype._onDragFrame = function () { this._frameId = null; const e = this._lastMoveEvent; if (e) { const t = this._map.transform; t.setLocationAtPoint(t.pointLocation(this._previousPos), this._pos), this._fireEvent('drag', e), this._fireEvent('move', e), this._previousPos = this._pos, delete this._lastMoveEvent; } }, rr.prototype._onMouseUp = function (e) { if (_e.mouseButton(e) === 0) switch (this._state) { case 'active': this._state = 'enabled', _e.suppressClick(), this._unbind(), this._deactivate(), this._inertialPan(e); break; case 'pending': this._state = 'enabled', this._unbind(); } }, rr.prototype._onTouchEnd = function (e) { switch (this._state) { case 'active': this._state = 'enabled', this._unbind(), this._deactivate(), this._inertialPan(e); break; case 'pending': this._state = 'enabled', this._unbind(); } }, rr.prototype._onBlur = function (e) { switch (this._state) { case 'active': this._state = 'enabled', this._unbind(), this._deactivate(), this._fireEvent('dragend', e), this._fireEvent('moveend', e); break; case 'pending': this._state = 'enabled', this._unbind(); } }, rr.prototype._unbind = function () { _e.removeEventListener(e.default.document, 'touchmove', this._onMove, { capture: !0, passive: !1 }), _e.removeEventListener(e.default.document, 'touchend', this._onTouchEnd), _e.removeEventListener(e.default.document, 'mousemove', this._onMove, { capture: !0 }), _e.removeEventListener(e.default.document, 'mouseup', this._onMouseUp), _e.removeEventListener(e.default, 'blur', this._onBlur); }, rr.prototype._deactivate = function () { this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._lastMoveEvent, delete this._previousPos, delete this._pos; }, rr.prototype._inertialPan = function (e) { this._fireEvent('dragend', e), this._drainInertiaBuffer(); const t = this._inertia; if (t.length < 2) this._fireEvent('moveend', e); else { const n = t[t.length - 1]; const r = t[0]; const i = n[1].sub(r[1]); const o = (n[0] - r[0]) / 1e3; if (o === 0 || n[1].equals(r[1])) this._fireEvent('moveend', e); else { const a = i.mult(0.3 / o); let s = a.mag(); s > 1400 && (s = 1400, a._unit()._mult(s)); const l = s / 750; const u = a.mult(-l / 2); this._map.panBy(u, { duration: 1e3 * l, easing: nr, noMoveStart: !0 }, { originalEvent: e }); } } }, rr.prototype._fireEvent = function (t, n) { return this._map.fire(new e.Event(t, n ? { originalEvent: n } : {})); }, rr.prototype._drainInertiaBuffer = function () { for (let e = this._inertia, t = ge.now(); e.length > 0 && t - e[0][0] > 160;)e.shift(); }; const ir = function (t) { this._map = t, this._el = t.getCanvasContainer(), e.bindAll(['_onKeyDown'], this); }; ir.prototype.isEnabled = function () { return !!this._enabled; }, ir.prototype.enable = function () { this.isEnabled() || (this._el.addEventListener('keydown', this._onKeyDown, !1), this._enabled = !0); }, ir.prototype.disable = function () { this.isEnabled() && (this._el.removeEventListener('keydown', this._onKeyDown), this._enabled = !1); }, ir.prototype._onKeyDown = function (e) {
          if (!(e.altKey || e.ctrlKey || e.metaKey)) {
            let t = 0; let n = 0; let r = 0; let i = 0; let o = 0; switch (e.keyCode) { case 61: case 107: case 171: case 187: t = 1; break; case 189: case 109: case 173: t = -1; break; case 37: e.shiftKey ? n = -1 : (e.preventDefault(), i = -1); break; case 39: e.shiftKey ? n = 1 : (e.preventDefault(), i = 1); break; case 38: e.shiftKey ? r = 1 : (e.preventDefault(), o = -1); break; case 40: e.shiftKey ? r = -1 : (o = 1, e.preventDefault()); break; default: return; } const a = this._map; const s = a.getZoom(); const l = {
              duration: 300, delayEndEvents: 500, easing: ae, zoom: t ? Math.round(s) + t * (e.shiftKey ? 2 : 1) : s, bearing: a.getBearing() + 15 * n, pitch: a.getPitch() + 10 * r, offset: [100 * -i, 100 * -o], center: a.getCenter(),
            }; a.easeTo(l, { originalEvent: e });
          }
        }; const or = function (t) { this._map = t, e.bindAll(['_onDblClick', '_onZoomEnd'], this); }; or.prototype.isEnabled = function () { return !!this._enabled; }, or.prototype.isActive = function () { return !!this._active; }, or.prototype.enable = function () { this.isEnabled() || (this._enabled = !0); }, or.prototype.disable = function () { this.isEnabled() && (this._enabled = !1); }, or.prototype.onTouchStart = function (e) { const t = this; this.isEnabled() && (e.points.length > 1 || (this._tapped ? (clearTimeout(this._tapped), this._tapped = null, this._zoom(e)) : this._tapped = setTimeout(() => { t._tapped = null; }, 300))); }, or.prototype.onDblClick = function (e) { this.isEnabled() && (e.originalEvent.preventDefault(), this._zoom(e)); }, or.prototype._zoom = function (e) { this._active = !0, this._map.on('zoomend', this._onZoomEnd), this._map.zoomTo(this._map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1), { around: e.lngLat }, e); }, or.prototype._onZoomEnd = function () { this._active = !1, this._map.off('zoomend', this._onZoomEnd); }; const ar = e.bezier(0, 0, 0.15, 1); const sr = function (t) { this._map = t, this._el = t.getCanvasContainer(), e.bindAll(['_onMove', '_onEnd', '_onTouchFrame'], this); }; sr.prototype.isEnabled = function () { return !!this._enabled; }, sr.prototype.enable = function (e) { this.isEnabled() || (this._el.classList.add('mapboxgl-touch-zoom-rotate'), this._enabled = !0, this._aroundCenter = !!e && e.around === 'center'); }, sr.prototype.disable = function () { this.isEnabled() && (this._el.classList.remove('mapboxgl-touch-zoom-rotate'), this._enabled = !1); }, sr.prototype.disableRotation = function () { this._rotationDisabled = !0; }, sr.prototype.enableRotation = function () { this._rotationDisabled = !1; }, sr.prototype.onStart = function (t) { if (this.isEnabled() && t.touches.length === 2) { const n = _e.mousePos(this._el, t.touches[0]); const r = _e.mousePos(this._el, t.touches[1]); this._startVec = n.sub(r), this._gestureIntent = void 0, this._inertia = [], _e.addEventListener(e.default.document, 'touchmove', this._onMove, { passive: !1 }), _e.addEventListener(e.default.document, 'touchend', this._onEnd); } }, sr.prototype._getTouchEventData = function (e) {
          const t = _e.mousePos(this._el, e.touches[0]); const n = _e.mousePos(this._el, e.touches[1]); const r = t.sub(n); return {
            vec: r, center: t.add(n).div(2), scale: r.mag() / this._startVec.mag(), bearing: this._rotationDisabled ? 0 : 180 * r.angleWith(this._startVec) / Math.PI,
          };
        }, sr.prototype._onMove = function (t) { if (t.touches.length === 2) { const n = this._getTouchEventData(t); const r = n.vec; const i = n.scale; const o = n.bearing; if (!this._gestureIntent) { const a = Math.abs(1 - i) > 0.15; Math.abs(o) > 10 ? this._gestureIntent = 'rotate' : a && (this._gestureIntent = 'zoom'), this._gestureIntent && (this._map.fire(new e.Event(`${this._gestureIntent}start`, { originalEvent: t })), this._map.fire(new e.Event('movestart', { originalEvent: t })), this._startVec = r); } this._lastTouchEvent = t, this._frameId || (this._frameId = this._map._requestRenderFrame(this._onTouchFrame)), t.preventDefault(); } }, sr.prototype._onTouchFrame = function () { this._frameId = null; const t = this._gestureIntent; if (t) { const n = this._map.transform; this._startScale || (this._startScale = n.scale, this._startBearing = n.bearing); const r = this._getTouchEventData(this._lastTouchEvent); const i = r.center; const o = r.bearing; const a = r.scale; const s = n.pointLocation(i); const l = n.locationPoint(s); t === 'rotate' && (n.bearing = this._startBearing + o), n.zoom = n.scaleZoom(this._startScale * a), n.setLocationAtPoint(s, l), this._map.fire(new e.Event(t, { originalEvent: this._lastTouchEvent })), this._map.fire(new e.Event('move', { originalEvent: this._lastTouchEvent })), this._drainInertiaBuffer(), this._inertia.push([ge.now(), a, i]); } }, sr.prototype._onEnd = function (t) {
          _e.removeEventListener(e.default.document, 'touchmove', this._onMove, { passive: !1 }), _e.removeEventListener(e.default.document, 'touchend', this._onEnd); const n = this._gestureIntent; const r = this._startScale; if (this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._gestureIntent, delete this._startScale, delete this._startBearing, delete this._lastTouchEvent, n) {
            this._map.fire(new e.Event(`${n}end`, { originalEvent: t })), this._drainInertiaBuffer(); const i = this._inertia; const o = this._map; if (i.length < 2)o.snapToNorth({}, { originalEvent: t }); else {
              const a = i[i.length - 1]; const s = i[0]; const l = o.transform.scaleZoom(r * a[1]); const u = o.transform.scaleZoom(r * s[1]); const c = l - u; const p = (a[0] - s[0]) / 1e3; const f = a[2]; if (p !== 0 && l !== u) {
                let h = 0.15 * c / p; Math.abs(h) > 2.5 && (h = h > 0 ? 2.5 : -2.5); const d = 1e3 * Math.abs(h / (12 * 0.15)); let m = l + h * d / 2e3; m < 0 && (m = 0), o.easeTo({
                  zoom: m, duration: d, easing: ar, around: this._aroundCenter ? o.getCenter() : o.unproject(f), noMoveStart: !0,
                }, { originalEvent: t });
              } else o.snapToNorth({}, { originalEvent: t });
            }
          }
        }, sr.prototype._drainInertiaBuffer = function () { for (let e = this._inertia, t = ge.now(); e.length > 2 && t - e[0][0] > 160;)e.shift(); }; const lr = {
          scrollZoom: Jn, boxZoom: Qn, dragRotate: tr, dragPan: rr, keyboard: ir, doubleClickZoom: or, touchZoomRotate: sr,
        }; const ur = (function (t) {
          function n(n, r) { t.call(this), this._moving = !1, this._zooming = !1, this.transform = n, this._bearingSnap = r.bearingSnap, e.bindAll(['_renderFrameCallback'], this); } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.getCenter = function () { return this.transform.center; }, n.prototype.setCenter = function (e, t) { return this.jumpTo({ center: e }, t); }, n.prototype.panBy = function (t, n, r) { return t = e.default$1.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t }, n), r); }, n.prototype.panTo = function (t, n, r) { return this.easeTo(e.extend({ center: t }, n), r); }, n.prototype.getZoom = function () { return this.transform.zoom; }, n.prototype.setZoom = function (e, t) { return this.jumpTo({ zoom: e }, t), this; }, n.prototype.zoomTo = function (t, n, r) { return this.easeTo(e.extend({ zoom: t }, n), r); }, n.prototype.zoomIn = function (e, t) { return this.zoomTo(this.getZoom() + 1, e, t), this; }, n.prototype.zoomOut = function (e, t) { return this.zoomTo(this.getZoom() - 1, e, t), this; }, n.prototype.getBearing = function () { return this.transform.bearing; }, n.prototype.setBearing = function (e, t) { return this.jumpTo({ bearing: e }, t), this; }, n.prototype.rotateTo = function (t, n, r) { return this.easeTo(e.extend({ bearing: t }, n), r); }, n.prototype.resetNorth = function (t, n) { return this.rotateTo(0, e.extend({ duration: 1e3 }, t), n), this; }, n.prototype.snapToNorth = function (e, t) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this; }, n.prototype.getPitch = function () { return this.transform.pitch; }, n.prototype.setPitch = function (e, t) { return this.jumpTo({ pitch: e }, t), this; }, n.prototype.fitBounds = function (t, n, r) {
            if (typeof (n = e.extend({
              padding: {
                top: 0, bottom: 0, right: 0, left: 0, 
              },
              offset: [0, 0],
              maxZoom: this.transform.maxZoom, 
            }, n)).padding === 'number') {
              const i = n.padding; n.padding = {
                top: i, bottom: i, right: i, left: i,
              };
            } if (!e.default$10(Object.keys(n.padding).sort((e, t) => (e < t ? -1:e > t ? 1:0)), ['bottom', 'left', 'right', 'top'])) return e.warnOnce("options.padding must be a positive number, or an Object with keys 'bottom', 'left', 'right', 'top'"), this; t = Ke.convert(t); const o = [(n.padding.left - n.padding.right) / 2, (n.padding.top - n.padding.bottom) / 2]; const a = Math.min(n.padding.right, n.padding.left); const s = Math.min(n.padding.top, n.padding.bottom); n.offset = [n.offset[0] + o[0], n.offset[1] + o[1]]; const l = e.default$1.convert(n.offset); const u = this.transform; const c = u.project(t.getNorthWest()); const p = u.project(t.getSouthEast()); const f = p.sub(c); const h = (u.width - 2 * a - 2 * Math.abs(l.x)) / f.x; const d = (u.height - 2 * s - 2 * Math.abs(l.y)) / f.y; return d < 0 || h < 0 ? (e.warnOnce('Map cannot fit within canvas with the given bounds, padding, and/or offset.'), this) : (n.center = u.unproject(c.add(p).div(2)), n.zoom = Math.min(u.scaleZoom(u.scale * Math.min(h, d)), n.maxZoom), n.bearing = 0, n.linear ? this.easeTo(n, r) : this.flyTo(n, r));
          }, n.prototype.jumpTo = function (t, n) { this.stop(); const r = this.transform; let i = !1; let o = !1; let a = !1; return 'zoom' in t && r.zoom !== +t.zoom && (i = !0, r.zoom = +t.zoom), void 0 !== t.center && (r.center = Ze.convert(t.center)), 'bearing' in t && r.bearing !== +t.bearing && (o = !0, r.bearing = +t.bearing), 'pitch' in t && r.pitch !== +t.pitch && (a = !0, r.pitch = +t.pitch), this.fire(new e.Event('movestart', n)).fire(new e.Event('move', n)), i && this.fire(new e.Event('zoomstart', n)).fire(new e.Event('zoom', n)).fire(new e.Event('zoomend', n)), o && this.fire(new e.Event('rotatestart', n)).fire(new e.Event('rotate', n)).fire(new e.Event('rotateend', n)), a && this.fire(new e.Event('pitchstart', n)).fire(new e.Event('pitch', n)).fire(new e.Event('pitchend', n)), this.fire(new e.Event('moveend', n)); }, n.prototype.easeTo = function (t, n) { const r = this; this.stop(), !1 === (t = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t)).animate && (t.duration = 0); const i = this.transform; const o = this.getZoom(); const a = this.getBearing(); const s = this.getPitch(); const l = 'zoom' in t ? +t.zoom : o; const u = 'bearing' in t ? this._normalizeBearing(t.bearing, a) : a; const c = 'pitch' in t ? +t.pitch : s; const p = i.centerPoint.add(e.default$1.convert(t.offset)); const f = i.pointLocation(p); const h = Ze.convert(t.center || f); this._normalizeCenter(h); let d; let m; const g = i.project(f); const y = i.project(h).sub(g); const v = i.zoomScale(l - o); return t.around && (d = Ze.convert(t.around), m = i.locationPoint(d)), this._zooming = l !== o, this._rotating = a !== u, this._pitching = c !== s, this._prepareEase(n, t.noMoveStart), clearTimeout(this._easeEndTimeoutID), this._ease((t) => { if (r._zooming && (i.zoom = e.number(o, l, t)), r._rotating && (i.bearing = e.number(a, u, t)), r._pitching && (i.pitch = e.number(s, c, t)), d)i.setLocationAtPoint(d, m); else { const f = i.zoomScale(i.zoom - o); const h = l > o ? Math.min(2, v) : Math.max(0.5, v); const _ = Math.pow(h, 1 - t); const b = i.unproject(g.add(y.mult(t * _)).mult(f)); i.setLocationAtPoint(i.renderWorldCopies ? b.wrap() : b, p); }r._fireMoveEvents(n); }, () => { t.delayEndEvents ? r._easeEndTimeoutID = setTimeout(() => r._afterEase(n), t.delayEndEvents) : r._afterEase(n); }, t), this; }, n.prototype._prepareEase = function (t, n) { this._moving = !0, n || this.fire(new e.Event('movestart', t)), this._zooming && this.fire(new e.Event('zoomstart', t)), this._rotating && this.fire(new e.Event('rotatestart', t)), this._pitching && this.fire(new e.Event('pitchstart', t)); }, n.prototype._fireMoveEvents = function (t) { this.fire(new e.Event('move', t)), this._zooming && this.fire(new e.Event('zoom', t)), this._rotating && this.fire(new e.Event('rotate', t)), this._pitching && this.fire(new e.Event('pitch', t)); }, n.prototype._afterEase = function (t) { const n = this._zooming; const r = this._rotating; const i = this._pitching; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, n && this.fire(new e.Event('zoomend', t)), r && this.fire(new e.Event('rotateend', t)), i && this.fire(new e.Event('pitchend', t)), this.fire(new e.Event('moveend', t)); }, n.prototype.flyTo = function (t, n) {
            function r(e) { const t = (w * w - x * x + (e ? -1 : 1) * C * C * E * E) / (2 * (e ? w : x) * C * E); return Math.log(Math.sqrt(t * t + 1) - t); } function i(e) { return (Math.exp(e) - Math.exp(-e)) / 2; } function o(e) { return (Math.exp(e) + Math.exp(-e)) / 2; } const a = this; this.stop(), t = e.extend({
              offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease,
            }, t); const s = this.transform; const l = this.getZoom(); const u = this.getBearing(); const c = this.getPitch(); const p = 'zoom' in t ? e.clamp(+t.zoom, s.minZoom, s.maxZoom) : l; const f = 'bearing' in t ? this._normalizeBearing(t.bearing, u) : u; const h = 'pitch' in t ? +t.pitch : c; const d = s.zoomScale(p - l); const m = s.centerPoint.add(e.default$1.convert(t.offset)); const g = s.pointLocation(m); const y = Ze.convert(t.center || g); this._normalizeCenter(y); const v = s.project(g); const _ = s.project(y).sub(v); let b = t.curve; var x = Math.max(s.width, s.height); var w = x / d; var E = _.mag(); if ('minZoom' in t) { const T = e.clamp(Math.min(t.minZoom, l, p), s.minZoom, s.maxZoom); const k = x / s.zoomScale(T - l); b = Math.sqrt(k / E * 2); } var C = b * b; const S = r(0); let A = function (e) { return o(S) / o(S + b * e); }; let O = function (e) { return x * ((o(S) * (i(t = S + b * e) / o(t)) - i(S)) / C) / E; let t; }; let I = (r(1) - S) / b; if (Math.abs(E) < 1e-6 || !isFinite(I)) { if (Math.abs(x - w) < 1e-6) return this.easeTo(t, n); const P = w < x ? -1 : 1; I = Math.abs(Math.log(w / x)) / b, O = function () { return 0; }, A = function (e) { return Math.exp(P * b * e); }; } if ('duration' in t)t.duration = +t.duration; else { const M = 'screenSpeed' in t ? +t.screenSpeed / b : +t.speed; t.duration = 1e3 * I / M; } return t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = u !== f, this._pitching = h !== c, this._prepareEase(n, !1), this._ease((t) => { const r = t * I; const i = 1 / A(r); s.zoom = l + s.scaleZoom(i), a._rotating && (s.bearing = e.number(u, f, t)), a._pitching && (s.pitch = e.number(c, h, t)); const o = s.unproject(v.add(_.mult(O(r))).mult(i)); s.setLocationAtPoint(s.renderWorldCopies ? o.wrap() : o, m), a._fireMoveEvents(n); }, () => a._afterEase(n), t), this;
          }, n.prototype.isEasing = function () { return !!this._easeFrameId; }, n.prototype.stop = function () { if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) { const e = this._onEaseEnd; delete this._onEaseEnd, e.call(this); } return this; }, n.prototype._ease = function (e, t, n) { !1 === n.animate || n.duration === 0 ? (e(1), t()) : (this._easeStart = ge.now(), this._easeOptions = n, this._onEaseFrame = e, this._onEaseEnd = t, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)); }, n.prototype._renderFrameCallback = function () { const e = Math.min((ge.now() - this._easeStart) / this._easeOptions.duration, 1); this._onEaseFrame(this._easeOptions.easing(e)), e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop(); }, n.prototype._normalizeBearing = function (t, n) { t = e.wrap(t, -180, 180); const r = Math.abs(t - n); return Math.abs(t - 360 - n) < r && (t -= 360), Math.abs(t + 360 - n) < r && (t += 360), t; }, n.prototype._normalizeCenter = function (e) { const t = this.transform; if (t.renderWorldCopies && !t.lngRange) { const n = e.lng - t.center.lng; e.lng += n > 180 ? -360 : n < -180 ? 360 : 0; } }, n;
        }(e.Evented)); const cr = function (t) { void 0 === t && (t = {}), this.options = t, e.bindAll(['_updateEditLink', '_updateData', '_updateCompact'], this); }; cr.prototype.getDefaultPosition = function () { return 'bottom-right'; }, cr.prototype.onAdd = function (e) { const t = this.options && this.options.compact; return this._map = e, this._container = _e.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-attrib'), t && this._container.classList.add('mapboxgl-compact'), this._updateAttributions(), this._updateEditLink(), this._map.on('sourcedata', this._updateData), this._map.on('moveend', this._updateEditLink), void 0 === t && (this._map.on('resize', this._updateCompact), this._updateCompact()), this._container; }, cr.prototype.onRemove = function () { _e.remove(this._container), this._map.off('sourcedata', this._updateData), this._map.off('moveend', this._updateEditLink), this._map.off('resize', this._updateCompact), this._map = void 0; }, cr.prototype._updateEditLink = function () { let e = this._editLink; e || (e = this._editLink = this._container.querySelector('.mapbox-improve-map')); const t = [{ key: 'owner', value: this.styleOwner }, { key: 'id', value: this.styleId }, { key: 'access_token', value: Ce.ACCESS_TOKEN }]; if (e) { const n = t.reduce((e, n, r) => n.value && (e += `${n.key}=${n.value}${r < t.length - 1 ? '&' : ''}`), e, '?'); e.href = `https://www.mapbox.com/feedback/${n}${this._map._hash ? this._map._hash.getHashString(!0) : ''}`; } }, cr.prototype._updateData = function (e) { e && e.sourceDataType === 'metadata' && (this._updateAttributions(), this._updateEditLink()); }, cr.prototype._updateAttributions = function () { if (this._map.style) { let e = []; if (this._map.style.stylesheet) { const t = this._map.style.stylesheet; this.styleOwner = t.owner, this.styleId = t.id; } const n = this._map.style.sourceCaches; for (const r in n) { const i = n[r].getSource(); i.attribution && e.indexOf(i.attribution) < 0 && e.push(i.attribution); }e.sort((e, t) => e.length - t.length), (e = e.filter((t, n) => { for (let r = n + 1; r < e.length; r++) if (e[r].indexOf(t) >= 0) return !1; return !0; })).length ? (this._container.innerHTML = e.join(' | '), this._container.classList.remove('mapboxgl-attrib-empty')) : this._container.classList.add('mapboxgl-attrib-empty'), this._editLink = null; } }, cr.prototype._updateCompact = function () { this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add('mapboxgl-compact') : this._container.classList.remove('mapboxgl-compact'); }; const pr = function () { e.bindAll(['_updateLogo'], this); }; pr.prototype.onAdd = function (e) { this._map = e, this._container = _e.create('div', 'mapboxgl-ctrl'); const t = _e.create('a', 'mapboxgl-ctrl-logo'); return t.target = '_blank', t.href = 'https://www.mapbox.com/', t.setAttribute('aria-label', 'Mapbox logo'), this._container.appendChild(t), this._container.style.display = 'none', this._map.on('sourcedata', this._updateLogo), this._updateLogo(), this._container; }, pr.prototype.onRemove = function () { _e.remove(this._container), this._map.off('sourcedata', this._updateLogo); }, pr.prototype.getDefaultPosition = function () { return 'bottom-left'; }, pr.prototype._updateLogo = function (e) { e && e.sourceDataType !== 'metadata' || (this._container.style.display = this._logoRequired() ? 'block' : 'none'); }, pr.prototype._logoRequired = function () { if (this._map.style) { const e = this._map.style.sourceCaches; for (const t in e) if (e[t].getSource().mapbox_logo) return !0; return !1; } }; const fr = function () { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1; }; fr.prototype.add = function (e) { const t = ++this._id; return this._queue.push({ callback: e, id: t, cancelled: !1 }), t; }, fr.prototype.remove = function (e) { for (let t = this._currentlyRunning, n = 0, r = t ? this._queue.concat(t) : this._queue; n < r.length; n += 1) { const i = r[n]; if (i.id === e) return void (i.cancelled = !0); } }, fr.prototype.run = function () { const e = this._currentlyRunning = this._queue; this._queue = []; for (let t = 0, n = e; t < n.length; t += 1) { const r = n[t]; if (!r.cancelled && (r.callback(), this._cleared)) break; } this._cleared = !1, this._currentlyRunning = !1; }, fr.prototype.clear = function () { this._currentlyRunning && (this._cleared = !0), this._queue = []; }; const hr = e.default.HTMLImageElement; const dr = e.default.HTMLElement; const mr = {
          center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: 0, maxZoom: 22, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, bearingSnap: 7, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, transformRequest: null, fadeDuration: 300,
        }; const gr = (function (t) {
          function n(n) {
            if ((n = e.extend({}, mr, n)).minZoom != null && n.maxZoom != null && n.minZoom > n.maxZoom) throw new Error('maxZoom must be greater than minZoom'); const r = new $n(n.minZoom, n.maxZoom, n.renderWorldCopies); t.call(this, r, n), this._interactive = n.interactive, this._maxTileCacheSize = n.maxTileCacheSize, this._failIfMajorPerformanceCaveat = n.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = n.preserveDrawingBuffer, this._trackResize = n.trackResize, this._bearingSnap = n.bearingSnap, this._refreshExpiredTiles = n.refreshExpiredTiles, this._fadeDuration = n.fadeDuration, this._crossFadingFactor = 1, this._collectResourceTiming = n.collectResourceTiming, this._renderTaskQueue = new fr(); const i = n.transformRequest; if (this._transformRequest = i ? function (e, t) { return i(e, t) || { url: e }; } : function (e) { return { url: e }; }, typeof n.container === 'string') { const o = e.default.document.getElementById(n.container); if (!o) throw new Error(`Container '${n.container}' not found.`); this._container = o; } else { if (!(n.container instanceof dr)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = n.container; }n.maxBounds && this.setMaxBounds(n.maxBounds), e.bindAll(['_onWindowOnline', '_onWindowResize', '_contextLost', '_contextRestored', '_update', '_render', '_onData', '_onDataLoading'], this), this._setupContainer(), this._setupPainter(), this.on('move', this._update.bind(this, !1)), this.on('zoom', this._update.bind(this, !0)), void 0 !== e.default && (e.default.addEventListener('online', this._onWindowOnline, !1), e.default.addEventListener('resize', this._onWindowResize, !1)), (function (e, t) { const n = e.getCanvasContainer(); let r = null; let i = !1; for (const o in lr)e[o] = new lr[o](e, t), t.interactive && t[o] && e[o].enable(t[o]); _e.addEventListener(n, 'mouseout', (t) => { e.fire(new Kn('mouseout', e, t)); }), _e.addEventListener(n, 'mousedown', (n) => { i = !0; let r = new Kn('mousedown', e, n); e.fire(r), r.defaultPrevented || (t.interactive && !e.doubleClickZoom.isActive() && e.stop(), e.boxZoom.onMouseDown(n), e.boxZoom.isActive() || e.dragPan.isActive() || e.dragRotate.onMouseDown(n), e.boxZoom.isActive() || e.dragRotate.isActive() || e.dragPan.onMouseDown(n)); }), _e.addEventListener(n, 'mouseup', (t) => { let n = e.dragRotate.isActive(); r && !n && e.fire(new Kn('contextmenu', e, r)), r = null, i = !1, e.fire(new Kn('mouseup', e, t)); }), _e.addEventListener(n, 'mousemove', (t) => { if (!e.dragPan.isActive() && !e.dragRotate.isActive()) { for (var r = t.toElement || t.target; r && r !== n;)r = r.parentNode; r === n && e.fire(new Kn('mousemove', e, t)); } }), _e.addEventListener(n, 'mouseover', (t) => { for (var r = t.toElement || t.target; r && r !== n;)r = r.parentNode; r === n && e.fire(new Kn('mouseover', e, t)); }), _e.addEventListener(n, 'touchstart', (n) => { let r = new Xn('touchstart', e, n); e.fire(r), r.defaultPrevented || (t.interactive && e.stop(), e.boxZoom.isActive() || e.dragRotate.isActive() || e.dragPan.onTouchStart(n), e.touchZoomRotate.onStart(n), e.doubleClickZoom.onTouchStart(r)); }, { passive: !1 }), _e.addEventListener(n, 'touchmove', (t) => { e.fire(new Xn('touchmove', e, t)); }, { passive: !1 }), _e.addEventListener(n, 'touchend', (t) => { e.fire(new Xn('touchend', e, t)); }), _e.addEventListener(n, 'touchcancel', (t) => { e.fire(new Xn('touchcancel', e, t)); }), _e.addEventListener(n, 'click', (t) => { e.fire(new Kn('click', e, t)); }), _e.addEventListener(n, 'dblclick', (t) => { let n = new Kn('dblclick', e, t); e.fire(n), n.defaultPrevented || e.doubleClickZoom.onDblClick(n); }), _e.addEventListener(n, 'contextmenu', (t) => { let n = e.dragRotate.isActive(); i || n ? i && (r = t) : e.fire(new Kn('contextmenu', e, t)), t.preventDefault(); }), _e.addEventListener(n, 'wheel', (t) => { let n = new Yn('wheel', e, t); e.fire(n), n.defaultPrevented || e.scrollZoom.onWheel(t); }, { passive: !1 }); }(this, n)), this._hash = n.hash && (new Zn()).addTo(this), this._hash && this._hash._onHashChange() || this.jumpTo({
              center: n.center, zoom: n.zoom, bearing: n.bearing, pitch: n.pitch,
            }), this.resize(), n.style && this.setStyle(n.style, { localIdeographFontFamily: n.localIdeographFontFamily }), n.attributionControl && this.addControl(new cr()), this.addControl(new pr(), n.logoPosition), this.on('style.load', function () { this.transform.unmodified && this.jumpTo(this.style.stylesheet); }), this.on('data', this._onData), this.on('dataloading', this._onDataLoading);
          }t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n; const r = {
            showTileBoundaries: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 },
          }; return n.prototype.addControl = function (e, t) { void 0 === t && e.getDefaultPosition && (t = e.getDefaultPosition()), void 0 === t && (t = 'top-right'); const n = e.onAdd(this); const r = this._controlPositions[t]; return t.indexOf('bottom') !== -1 ? r.insertBefore(n, r.firstChild) : r.appendChild(n), this; }, n.prototype.removeControl = function (e) { return e.onRemove(this), this; }, n.prototype.resize = function (t) { const n = this._containerDimensions(); const r = n[0]; const i = n[1]; return this._resizeCanvas(r, i), this.transform.resize(r, i), this.painter.resize(r, i), this.fire(new e.Event('movestart', t)).fire(new e.Event('move', t)).fire(new e.Event('resize', t)).fire(new e.Event('moveend', t)); }, n.prototype.getBounds = function () { const t = new Ke(this.transform.pointLocation(new e.default$1(0, this.transform.height)), this.transform.pointLocation(new e.default$1(this.transform.width, 0))); return (this.transform.angle || this.transform.pitch) && (t.extend(this.transform.pointLocation(new e.default$1(this.transform.size.x, 0))), t.extend(this.transform.pointLocation(new e.default$1(0, this.transform.size.y)))), t; }, n.prototype.getMaxBounds = function () { return this.transform.latRange && this.transform.latRange.length === 2 && this.transform.lngRange && this.transform.lngRange.length === 2 ? new Ke([this.transform.lngRange[0], this.transform.latRange[0]], [this.transform.lngRange[1], this.transform.latRange[1]]) : null; }, n.prototype.setMaxBounds = function (e) { if (e) { const t = Ke.convert(e); this.transform.lngRange = [t.getWest(), t.getEast()], this.transform.latRange = [t.getSouth(), t.getNorth()], this.transform._constrain(), this._update(); } else e == null && (this.transform.lngRange = null, this.transform.latRange = null, this._update()); return this; }, n.prototype.setMinZoom = function (e) { if ((e = e == null ? 0 : e) >= 0 && e <= this.transform.maxZoom) return this.transform.minZoom = e, this._update(), this.getZoom() < e && this.setZoom(e), this; throw new Error('minZoom must be between 0 and the current maxZoom, inclusive'); }, n.prototype.getMinZoom = function () { return this.transform.minZoom; }, n.prototype.setMaxZoom = function (e) { if ((e = e == null ? 22 : e) >= this.transform.minZoom) return this.transform.maxZoom = e, this._update(), this.getZoom() > e && this.setZoom(e), this; throw new Error('maxZoom must be greater than the current minZoom'); }, n.prototype.getRenderWorldCopies = function () { return this.transform.renderWorldCopies; }, n.prototype.setRenderWorldCopies = function (e) { return this.transform.renderWorldCopies = e, this._update(), this; }, n.prototype.getMaxZoom = function () { return this.transform.maxZoom; }, n.prototype.project = function (e) { return this.transform.locationPoint(Ze.convert(e)); }, n.prototype.unproject = function (t) { return this.transform.pointLocation(e.default$1.convert(t)); }, n.prototype.isMoving = function () { return this._moving || this.dragPan.isActive() || this.dragRotate.isActive() || this.scrollZoom.isActive(); }, n.prototype.isZooming = function () { return this._zooming || this.scrollZoom.isActive(); }, n.prototype.isRotating = function () { return this._rotating || this.dragRotate.isActive(); }, n.prototype.on = function (e, n, r) { let i; const o = this; if (void 0 === r) return t.prototype.on.call(this, e, n); const a = (function () { if (e === 'mouseenter' || e === 'mouseover') { let t = !1; return { layer: n, listener: r, delegates: { mousemove(i) { let a = o.getLayer(n) ? o.queryRenderedFeatures(i.point, { layers: [n] }) : []; a.length ? t || (t = !0, r.call(o, new Kn(e, o, i.originalEvent, { features: a }))) : t = !1; }, mouseout() { t = !1; } } }; } if (e === 'mouseleave' || e === 'mouseout') { let a = !1; return { layer: n, listener: r, delegates: { mousemove(t) { (o.getLayer(n) ? o.queryRenderedFeatures(t.point, { layers: [n] }) : []).length ? a = !0 : a && (a = !1, r.call(o, new Kn(e, o, t.originalEvent))); }, mouseout(t) { a && (a = !1, r.call(o, new Kn(e, o, t.originalEvent))); } } }; } return { layer: n, listener: r, delegates: (i = {}, i[e] = function (e) { const t = o.getLayer(n) ? o.queryRenderedFeatures(e.point, { layers: [n] }) : []; t.length && (e.features = t, r.call(o, e), delete e.features); }, i) }; }()); for (const s in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(a), a.delegates)o.on(s, a.delegates[s]); return this; }, n.prototype.off = function (e, n, r) { if (void 0 === r) return t.prototype.off.call(this, e, n); if (this._delegatedListeners && this._delegatedListeners[e]) for (let i = this._delegatedListeners[e], o = 0; o < i.length; o++) { const a = i[o]; if (a.layer === n && a.listener === r) { for (const s in a.delegates) this.off(s, a.delegates[s]); return i.splice(o, 1), this; } } return this; }, n.prototype.queryRenderedFeatures = function (t, n) { let r; return arguments.length === 2 ? (t = arguments[0], n = arguments[1]) : arguments.length === 1 && ((r = arguments[0]) instanceof e.default$1 || Array.isArray(r)) ? (t = arguments[0], n = {}) : arguments.length === 1 ? (t = void 0, n = arguments[0]) : (t = void 0, n = {}), this.style ? this.style.queryRenderedFeatures(this._makeQueryGeometry(t), n, this.transform) : []; }, n.prototype._makeQueryGeometry = function (t) { let n; const r = this; if (void 0 === t && (t = [e.default$1.convert([0, 0]), e.default$1.convert([this.transform.width, this.transform.height])]), t instanceof e.default$1 || typeof t[0] === 'number')n = [e.default$1.convert(t)]; else { const i = [e.default$1.convert(t[0]), e.default$1.convert(t[1])]; n = [i[0], new e.default$1(i[1].x, i[0].y), i[1], new e.default$1(i[0].x, i[1].y), i[0]]; } return { viewport: n, worldCoordinate: n.map(e => r.transform.pointCoordinate(e)) }; }, n.prototype.querySourceFeatures = function (e, t) { return this.style.querySourceFeatures(e, t); }, n.prototype.setStyle = function (t, n) { if ((!n || !1 !== n.diff && !n.localIdeographFontFamily) && this.style && t && typeof t === 'object') try { return this.style.setState(t) && this._update(!0), this; } catch (t) { e.warnOnce(`Unable to perform style diff: ${t.message || t.error || t}.  Rebuilding the style from scratch.`); } return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new kn(this, n || {}), this.style.setEventedParent(this, { style: this.style }), typeof t === 'string' ? this.style.loadURL(t) : this.style.loadJSON(t), this) : (delete this.style, this); }, n.prototype.getStyle = function () { if (this.style) return this.style.serialize(); }, n.prototype.isStyleLoaded = function () { return this.style ? this.style.loaded() : e.warnOnce('There is no style added to the map.'); }, n.prototype.addSource = function (e, t) { return this.style.addSource(e, t), this._update(!0), this; }, n.prototype.isSourceLoaded = function (t) { const n = this.style && this.style.sourceCaches[t]; if (void 0 !== n) return n.loaded(); this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))); }, n.prototype.areTilesLoaded = function () { const e = this.style && this.style.sourceCaches; for (const t in e) { const n = e[t]._tiles; for (const r in n) { const i = n[r]; if (i.state !== 'loaded' && i.state !== 'errored') return !1; } } return !0; }, n.prototype.addSourceType = function (e, t, n) { return this.style.addSourceType(e, t, n); }, n.prototype.removeSource = function (e) { return this.style.removeSource(e), this._update(!0), this; }, n.prototype.getSource = function (e) { return this.style.getSource(e); }, n.prototype.addImage = function (t, n, r) { void 0 === r && (r = {}); let i = r.pixelRatio; void 0 === i && (i = 1); let o = r.sdf; if (void 0 === o && (o = !1), n instanceof hr) { const a = ge.getImageData(n); const s = a.width; const l = a.height; const u = a.data; this.style.addImage(t, { data: new e.RGBAImage({ width: s, height: l }, u), pixelRatio: i, sdf: o }); } else { if (void 0 === n.width || void 0 === n.height) return this.fire(new e.ErrorEvent(new Error('Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`'))); const c = n.width; const p = n.height; const f = n.data; this.style.addImage(t, { data: new e.RGBAImage({ width: c, height: p }, f.slice(0)), pixelRatio: i, sdf: o }); } }, n.prototype.hasImage = function (t) { return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error('Missing required image id'))), !1); }, n.prototype.removeImage = function (e) { this.style.removeImage(e); }, n.prototype.loadImage = function (t, n) { e.getImage(this._transformRequest(t, e.ResourceType.Image), n); }, n.prototype.addLayer = function (e, t) { return this.style.addLayer(e, t), this._update(!0), this; }, n.prototype.moveLayer = function (e, t) { return this.style.moveLayer(e, t), this._update(!0), this; }, n.prototype.removeLayer = function (e) { return this.style.removeLayer(e), this._update(!0), this; }, n.prototype.getLayer = function (e) { return this.style.getLayer(e); }, n.prototype.setFilter = function (e, t) { return this.style.setFilter(e, t), this._update(!0), this; }, n.prototype.setLayerZoomRange = function (e, t, n) { return this.style.setLayerZoomRange(e, t, n), this._update(!0), this; }, n.prototype.getFilter = function (e) { return this.style.getFilter(e); }, n.prototype.setPaintProperty = function (e, t, n) { return this.style.setPaintProperty(e, t, n), this._update(!0), this; }, n.prototype.getPaintProperty = function (e, t) { return this.style.getPaintProperty(e, t); }, n.prototype.setLayoutProperty = function (e, t, n) { return this.style.setLayoutProperty(e, t, n), this._update(!0), this; }, n.prototype.getLayoutProperty = function (e, t) { return this.style.getLayoutProperty(e, t); }, n.prototype.setLight = function (e) { return this.style.setLight(e), this._update(!0), this; }, n.prototype.getLight = function () { return this.style.getLight(); }, n.prototype.getContainer = function () { return this._container; }, n.prototype.getCanvasContainer = function () { return this._canvasContainer; }, n.prototype.getCanvas = function () { return this._canvas; }, n.prototype._containerDimensions = function () { let e = 0; let t = 0; return this._container && (e = this._container.offsetWidth || 400, t = this._container.offsetHeight || 300), [e, t]; }, n.prototype._setupContainer = function () { const e = this._container; e.classList.add('mapboxgl-map'), (this._missingCSSContainer = _e.create('div', 'mapboxgl-missing-css', e)).innerHTML = 'Missing Mapbox GL JS CSS'; const t = this._canvasContainer = _e.create('div', 'mapboxgl-canvas-container', e); this._interactive && t.classList.add('mapboxgl-interactive'), this._canvas = _e.create('canvas', 'mapboxgl-canvas', t), this._canvas.style.position = 'absolute', this._canvas.addEventListener('webglcontextlost', this._contextLost, !1), this._canvas.addEventListener('webglcontextrestored', this._contextRestored, !1), this._canvas.setAttribute('tabindex', '0'), this._canvas.setAttribute('aria-label', 'Map'); const n = this._containerDimensions(); this._resizeCanvas(n[0], n[1]); const r = this._controlContainer = _e.create('div', 'mapboxgl-control-container', e); const i = this._controlPositions = {}; ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach((e) => { i[e] = _e.create('div', `mapboxgl-ctrl-${  e}`, r); }); }, n.prototype._resizeCanvas = function (t, n) { const r = e.default.devicePixelRatio || 1; this._canvas.width = r * t, this._canvas.height = r * n, this._canvas.style.width = `${t}px`, this._canvas.style.height = `${n}px`; }, n.prototype._setupPainter = function () { const t = e.extend({ failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer }, fe.webGLContextAttributes); const n = this._canvas.getContext('webgl', t) || this._canvas.getContext('experimental-webgl', t); n ? this.painter = new Vn(n, this.transform) : this.fire(new e.ErrorEvent(new Error('Failed to initialize WebGL'))); }, n.prototype._contextLost = function (t) { t.preventDefault(), this._frameId && (ge.cancelFrame(this._frameId), this._frameId = null), this.fire(new e.Event('webglcontextlost', { originalEvent: t })); }, n.prototype._contextRestored = function (t) { this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event('webglcontextrestored', { originalEvent: t })); }, n.prototype.loaded = function () { return !this._styleDirty && !this._sourcesDirty && !(!this.style || !this.style.loaded()); }, n.prototype._update = function (e) { this.style && (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this._rerender()); }, n.prototype._requestRenderFrame = function (e) { return this._update(), this._renderTaskQueue.add(e); }, n.prototype._cancelRenderFrame = function (e) { this._renderTaskQueue.remove(e); }, n.prototype._render = function () {
            this._renderTaskQueue.run(); let t = !1; if (this.style && this._styleDirty) {
              this._styleDirty = !1; const n = this.transform.zoom; const r = ge.now(); this.style.zoomHistory.update(n, r); const i = new e.default$16(n, {
                now: r, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(),
              }); const o = i.crossFadingFactor(); o === 1 && o === this._crossFadingFactor || (t = !0, this._crossFadingFactor = o), this.style.update(i);
            } return this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), fadeDuration: this._fadeDuration,
            }), this.fire(new e.Event('render')), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event('load'))), this.style && (this.style.hasTransitions() || t) && (this._styleDirty = !0), (this._sourcesDirty || this._repaint || this._styleDirty || this._placementDirty) && this._rerender(), this;
          }, n.prototype.remove = function () { this._hash && this._hash.remove(), ge.cancelFrame(this._frameId), this._renderTaskQueue.clear(), this._frameId = null, this.setStyle(null), void 0 !== e.default && (e.default.removeEventListener('resize', this._onWindowResize, !1), e.default.removeEventListener('online', this._onWindowOnline, !1)); const t = this.painter.context.gl.getExtension('WEBGL_lose_context'); t && t.loseContext(), se(this._canvasContainer), se(this._controlContainer), se(this._missingCSSContainer), this._container.classList.remove('mapboxgl-map'), this.fire(new e.Event('remove')); }, n.prototype._rerender = function () { const e = this; this.style && !this._frameId && (this._frameId = ge.frame(() => { e._frameId = null, e._render(); })); }, n.prototype._onWindowOnline = function () { this._update(); }, n.prototype._onWindowResize = function () { this._trackResize && this.stop().resize()._update(); }, r.showTileBoundaries.get = function () { return !!this._showTileBoundaries; }, r.showTileBoundaries.set = function (e) { this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update()); }, r.showCollisionBoxes.get = function () { return !!this._showCollisionBoxes; }, r.showCollisionBoxes.set = function (e) { this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update()); }, r.showOverdrawInspector.get = function () { return !!this._showOverdrawInspector; }, r.showOverdrawInspector.set = function (e) { this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update()); }, r.repaint.get = function () { return !!this._repaint; }, r.repaint.set = function (e) { this._repaint = e, this._update(); }, r.vertices.get = function () { return !!this._vertices; }, r.vertices.set = function (e) { this._vertices = e, this._update(); }, n.prototype._onData = function (t) { this._update(t.dataType === 'style'), this.fire(new e.Event(`${t.dataType}data`, t)); }, n.prototype._onDataLoading = function (t) { this.fire(new e.Event(`${t.dataType}dataloading`, t)); }, Object.defineProperties(n.prototype, r), n;
        }(ur)); const yr = { showCompass: !0, showZoom: !0 }; const vr = function (t) { const n = this; this.options = e.extend({}, yr, t), this._container = _e.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-group'), this._container.addEventListener('contextmenu', e => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton('mapboxgl-ctrl-icon mapboxgl-ctrl-zoom-in', 'Zoom In', () => n._map.zoomIn()), this._zoomOutButton = this._createButton('mapboxgl-ctrl-icon mapboxgl-ctrl-zoom-out', 'Zoom Out', () => n._map.zoomOut())), this.options.showCompass && (e.bindAll(['_rotateCompassArrow'], this), this._compass = this._createButton('mapboxgl-ctrl-icon mapboxgl-ctrl-compass', 'Reset North', () => n._map.resetNorth()), this._compassArrow = _e.create('span', 'mapboxgl-ctrl-compass-arrow', this._compass)); }; vr.prototype._rotateCompassArrow = function () { const e = `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`; this._compassArrow.style.transform = e; }, vr.prototype.onAdd = function (e) { return this._map = e, this.options.showCompass && (this._map.on('rotate', this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new tr(e, { button: 'left', element: this._compass }), this._handler.enable()), this._container; }, vr.prototype.onRemove = function () { _e.remove(this._container), this.options.showCompass && (this._map.off('rotate', this._rotateCompassArrow), this._handler.disable(), delete this._handler), delete this._map; }, vr.prototype._createButton = function (e, t, n) { const r = _e.create('button', e, this._container); return r.type = 'button', r.setAttribute('aria-label', t), r.addEventListener('click', n), r; }; var _r = {
          center: 'translate(-50%,-50%)', top: 'translate(-50%,0)', 'top-left': 'translate(0,0)', 'top-right': 'translate(-100%,0)', bottom: 'translate(-50%,-100%)', 'bottom-left': 'translate(0,-100%)', 'bottom-right': 'translate(-100%,-100%)', left: 'translate(0,-50%)', right: 'translate(-100%,-50%)',
        }; const br = function (t) { if ((arguments[0] instanceof e.default.HTMLElement || arguments.length === 2) && (t = e.extend({ element: t }, arguments[1])), e.bindAll(['_update', '_onMapClick'], this), this._anchor = t && t.anchor || 'center', this._color = t && t.color || '#3FB1CE', t && t.element) this._element = t.element, this._offset = e.default$1.convert(t && t.offset || [0, 0]); else { this._defaultMarker = !0, this._element = _e.create('div'); const n = _e.createNS('http://www.w3.org/2000/svg', 'svg'); n.setAttributeNS(null, 'height', '41px'), n.setAttributeNS(null, 'width', '27px'), n.setAttributeNS(null, 'viewBox', '0 0 27 41'); const r = _e.createNS('http://www.w3.org/2000/svg', 'g'); r.setAttributeNS(null, 'stroke', 'none'), r.setAttributeNS(null, 'stroke-width', '1'), r.setAttributeNS(null, 'fill', 'none'), r.setAttributeNS(null, 'fill-rule', 'evenodd'); const i = _e.createNS('http://www.w3.org/2000/svg', 'g'); i.setAttributeNS(null, 'fill-rule', 'nonzero'); const o = _e.createNS('http://www.w3.org/2000/svg', 'g'); o.setAttributeNS(null, 'transform', 'translate(3.0, 29.0)'), o.setAttributeNS(null, 'fill', '#000000'); for (let a = 0, s = [{ rx: '10.5', ry: '5.25002273' }, { rx: '10.5', ry: '5.25002273' }, { rx: '9.5', ry: '4.77275007' }, { rx: '8.5', ry: '4.29549936' }, { rx: '7.5', ry: '3.81822308' }, { rx: '6.5', ry: '3.34094679' }, { rx: '5.5', ry: '2.86367051' }, { rx: '4.5', ry: '2.38636864' }]; a < s.length; a += 1) { const l = s[a]; const u = _e.createNS('http://www.w3.org/2000/svg', 'ellipse'); u.setAttributeNS(null, 'opacity', '0.04'), u.setAttributeNS(null, 'cx', '10.5'), u.setAttributeNS(null, 'cy', '5.80029008'), u.setAttributeNS(null, 'rx', l.rx), u.setAttributeNS(null, 'ry', l.ry), o.appendChild(u); } const c = _e.createNS('http://www.w3.org/2000/svg', 'g'); c.setAttributeNS(null, 'fill', this._color); const p = _e.createNS('http://www.w3.org/2000/svg', 'path'); p.setAttributeNS(null, 'd', 'M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z'), c.appendChild(p); const f = _e.createNS('http://www.w3.org/2000/svg', 'g'); f.setAttributeNS(null, 'opacity', '0.25'), f.setAttributeNS(null, 'fill', '#000000'); const h = _e.createNS('http://www.w3.org/2000/svg', 'path'); h.setAttributeNS(null, 'd', 'M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z'), f.appendChild(h); const d = _e.createNS('http://www.w3.org/2000/svg', 'g'); d.setAttributeNS(null, 'transform', 'translate(6.0, 7.0)'), d.setAttributeNS(null, 'fill', '#FFFFFF'); const m = _e.createNS('http://www.w3.org/2000/svg', 'g'); m.setAttributeNS(null, 'transform', 'translate(8.0, 8.0)'); const g = _e.createNS('http://www.w3.org/2000/svg', 'circle'); g.setAttributeNS(null, 'fill', '#000000'), g.setAttributeNS(null, 'opacity', '0.25'), g.setAttributeNS(null, 'cx', '5.5'), g.setAttributeNS(null, 'cy', '5.5'), g.setAttributeNS(null, 'r', '5.4999962'); const y = _e.createNS('http://www.w3.org/2000/svg', 'circle'); y.setAttributeNS(null, 'fill', '#FFFFFF'), y.setAttributeNS(null, 'cx', '5.5'), y.setAttributeNS(null, 'cy', '5.5'), y.setAttributeNS(null, 'r', '5.4999962'), m.appendChild(g), m.appendChild(y), i.appendChild(o), i.appendChild(c), i.appendChild(f), i.appendChild(d), i.appendChild(m), n.appendChild(i), this._element.appendChild(n), this._offset = e.default$1.convert(t && t.offset || [0, -14]); } this._element.classList.add('mapboxgl-marker'), this._popup = null; }; br.prototype.addTo = function (e) { return this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on('move', this._update), e.on('moveend', this._update), this._update(), this._map.on('click', this._onMapClick), this; }, br.prototype.remove = function () { return this._map && (this._map.off('click', this._onMapClick), this._map.off('move', this._update), this._map.off('moveend', this._update), delete this._map), _e.remove(this._element), this._popup && this._popup.remove(), this; }, br.prototype.getLngLat = function () { return this._lngLat; }, br.prototype.setLngLat = function (e) { return this._lngLat = Ze.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this; }, br.prototype.getElement = function () { return this._element; }, br.prototype.setPopup = function (e) {
          if (this._popup && (this._popup.remove(), this._popup = null), e) {
            if (!('offset' in e.options)) {
              const t = Math.sqrt(Math.pow(13.5, 2) / 2); e.options.offset = this._defaultMarker ? {
                top: [0, 0], 'top-left': [0, 0], 'top-right': [0, 0], bottom: [0, -38.1], 'bottom-left': [t, -1 * (24.6 + t)], 'bottom-right': [-t, -1 * (24.6 + t)], left: [13.5, -24.6], right: [-13.5, -24.6],
              } : this._offset;
            } this._popup = e, this._lngLat && this._popup.setLngLat(this._lngLat);
          } return this;
        }, br.prototype._onMapClick = function (e) { const t = e.originalEvent.target; const n = this._element; this._popup && (t === n || n.contains(t)) && this.togglePopup(); }, br.prototype.getPopup = function () { return this._popup; }, br.prototype.togglePopup = function () { const e = this._popup; return e ? (e.isOpen() ? e.remove() : e.addTo(this._map), this) : this; }, br.prototype._update = function (e) { this._map && (this._map.transform.renderWorldCopies && (this._lngLat = le(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset), e && e.type !== 'moveend' || (this._pos = this._pos.round()), _e.setTransform(this._element, `${_r[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px)`), ue(this._element, this._anchor, 'marker')); }, br.prototype.getOffset = function () { return this._offset; }, br.prototype.setOffset = function (t) { return this._offset = e.default$1.convert(t), this._update(), this; }; let xr; const wr = {
          positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showUserLocation: !0,
        }; const Er = (function (t) { function n(n) { t.call(this), this.options = e.extend({}, wr, n), e.bindAll(['_onSuccess', '_onError', '_finish', '_setupUI', '_updateCamera', '_updateMarker'], this); } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.onAdd = function (t) { let n; return this._map = t, this._container = _e.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-group'), n = this._setupUI, void 0 !== xr ? n(xr) : void 0 !== e.default.navigator.permissions ? e.default.navigator.permissions.query({ name: 'geolocation' }).then((e) => { xr = e.state !== 'denied', n(xr); }) : (xr = !!e.default.navigator.geolocation, n(xr)), this._container; }, n.prototype.onRemove = function () { void 0 !== this._geolocationWatchID && (e.default.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker.remove(), _e.remove(this._container), this._map = void 0; }, n.prototype._onSuccess = function (t) { if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) { case 'WAITING_ACTIVE': case 'ACTIVE_LOCK': case 'ACTIVE_ERROR': this._watchState = 'ACTIVE_LOCK', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active'); break; case 'BACKGROUND': case 'BACKGROUND_ERROR': this._watchState = 'BACKGROUND', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background'); } this.options.showUserLocation && this._watchState !== 'OFF' && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== 'ACTIVE_LOCK' || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove('mapboxgl-user-location-dot-stale'), this.fire(new e.Event('geolocate', t)), this._finish(); }, n.prototype._updateCamera = function (e) { const t = new Ze(e.coords.longitude, e.coords.latitude); const n = e.coords.accuracy; this._map.fitBounds(t.toBounds(n), this.options.fitBoundsOptions, { geolocateSource: !0 }); }, n.prototype._updateMarker = function (e) { e ? this._userLocationDotMarker.setLngLat([e.coords.longitude, e.coords.latitude]).addTo(this._map) : this._userLocationDotMarker.remove(); }, n.prototype._onError = function (t) { if (this.options.trackUserLocation) if (t.code === 1) this._watchState = 'OFF', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error'), void 0 !== this._geolocationWatchID && this._clearWatch(); else switch (this._watchState) { case 'WAITING_ACTIVE': this._watchState = 'ACTIVE_ERROR', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error'); break; case 'ACTIVE_LOCK': this._watchState = 'ACTIVE_ERROR', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'); break; case 'BACKGROUND': this._watchState = 'BACKGROUND_ERROR', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'); } this._watchState !== 'OFF' && this.options.showUserLocation && this._dotElement.classList.add('mapboxgl-user-location-dot-stale'), this.fire(new e.Event('error', t)), this._finish(); }, n.prototype._finish = function () { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0; }, n.prototype._setupUI = function (t) { const n = this; !1 !== t && (this._container.addEventListener('contextmenu', e => e.preventDefault()), this._geolocateButton = _e.create('button', 'mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate', this._container), this._geolocateButton.type = 'button', this._geolocateButton.setAttribute('aria-label', 'Geolocate'), this.options.trackUserLocation && (this._geolocateButton.setAttribute('aria-pressed', 'false'), this._watchState = 'OFF'), this.options.showUserLocation && (this._dotElement = _e.create('div', 'mapboxgl-user-location-dot'), this._userLocationDotMarker = new br(this._dotElement), this.options.trackUserLocation && (this._watchState = 'OFF')), this._geolocateButton.addEventListener('click', this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on('movestart', (t) => { t.geolocateSource || n._watchState !== 'ACTIVE_LOCK' || (n._watchState = 'BACKGROUND', n._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background'), n._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), n.fire(new e.Event('trackuserlocationend'))); })); }, n.prototype.trigger = function () { if (!this._setup) return e.warnOnce('Geolocate control triggered before added to a map'), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case 'OFF': this._watchState = 'WAITING_ACTIVE', this.fire(new e.Event('trackuserlocationstart')); break; case 'WAITING_ACTIVE': case 'ACTIVE_LOCK': case 'ACTIVE_ERROR': case 'BACKGROUND_ERROR': this._watchState = 'OFF', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error'), this.fire(new e.Event('trackuserlocationend')); break; case 'BACKGROUND': this._watchState = 'ACTIVE_LOCK', this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event('trackuserlocationstart')); } switch (this._watchState) { case 'WAITING_ACTIVE': this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active'); break; case 'ACTIVE_LOCK': this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active'); break; case 'ACTIVE_ERROR': this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error'); break; case 'BACKGROUND': this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background'); break; case 'BACKGROUND_ERROR': this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error'); } this._watchState === 'OFF' && void 0 !== this._geolocationWatchID ? this._clearWatch() : void 0 === this._geolocationWatchID && (this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.setAttribute('aria-pressed', 'true'), this._geolocationWatchID = e.default.navigator.geolocation.watchPosition(this._onSuccess, this._onError, this.options.positionOptions)); } else e.default.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0; }, n.prototype._clearWatch = function () { e.default.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.setAttribute('aria-pressed', 'false'), this.options.showUserLocation && this._updateMarker(null); }, n; }(e.Evented)); const Tr = { maxWidth: 100, unit: 'metric' }; const kr = function (t) { this.options = e.extend({}, Tr, t), e.bindAll(['_onMove', 'setUnit'], this); }; kr.prototype.getDefaultPosition = function () { return 'bottom-left'; }, kr.prototype._onMove = function () { ce(this._map, this._container, this.options); }, kr.prototype.onAdd = function (e) { return this._map = e, this._container = _e.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-scale', e.getContainer()), this._map.on('move', this._onMove), this._onMove(), this._container; }, kr.prototype.onRemove = function () { _e.remove(this._container), this._map.off('move', this._onMove), this._map = void 0; }, kr.prototype.setUnit = function (e) { this.options.unit = e, ce(this._map, this._container, this.options); }; const Cr = function () { this._fullscreen = !1, e.bindAll(['_onClickFullscreen', '_changeIcon'], this), 'onfullscreenchange' in e.default.document ? this._fullscreenchange = 'fullscreenchange' : 'onmozfullscreenchange' in e.default.document ? this._fullscreenchange = 'mozfullscreenchange' : 'onwebkitfullscreenchange' in e.default.document ? this._fullscreenchange = 'webkitfullscreenchange' : 'onmsfullscreenchange' in e.default.document && (this._fullscreenchange = 'MSFullscreenChange'), this._className = 'mapboxgl-ctrl'; }; Cr.prototype.onAdd = function (t) { return this._map = t, this._mapContainer = this._map.getContainer(), this._container = _e.create('div', `${this._className} mapboxgl-ctrl-group`), this._checkFullscreenSupport() ? this._setupUI() : (this._container.style.display = 'none', e.warnOnce('This device does not support fullscreen mode.')), this._container; }, Cr.prototype.onRemove = function () { _e.remove(this._container), this._map = null, e.default.document.removeEventListener(this._fullscreenchange, this._changeIcon); }, Cr.prototype._checkFullscreenSupport = function () { return !!(e.default.document.fullscreenEnabled || e.default.document.mozFullScreenEnabled || e.default.document.msFullscreenEnabled || e.default.document.webkitFullscreenEnabled); }, Cr.prototype._setupUI = function () { const t = this._fullscreenButton = _e.create('button', `${this._className}-icon ${this._className}-fullscreen`, this._container); t.setAttribute('aria-label', 'Toggle fullscreen'), t.type = 'button', this._fullscreenButton.addEventListener('click', this._onClickFullscreen), e.default.document.addEventListener(this._fullscreenchange, this._changeIcon); }, Cr.prototype._isFullscreen = function () { return this._fullscreen; }, Cr.prototype._changeIcon = function () { (e.default.document.fullscreenElement || e.default.document.mozFullScreenElement || e.default.document.webkitFullscreenElement || e.default.document.msFullscreenElement) === this._mapContainer !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(`${this._className}-shrink`), this._fullscreenButton.classList.toggle(`${this._className}-fullscreen`)); }, Cr.prototype._onClickFullscreen = function () { this._isFullscreen() ? e.default.document.exitFullscreen ? e.default.document.exitFullscreen() : e.default.document.mozCancelFullScreen ? e.default.document.mozCancelFullScreen() : e.default.document.msExitFullscreen ? e.default.document.msExitFullscreen() : e.default.document.webkitCancelFullScreen && e.default.document.webkitCancelFullScreen() : this._mapContainer.requestFullscreen ? this._mapContainer.requestFullscreen() : this._mapContainer.mozRequestFullScreen ? this._mapContainer.mozRequestFullScreen() : this._mapContainer.msRequestFullscreen ? this._mapContainer.msRequestFullscreen() : this._mapContainer.webkitRequestFullscreen && this._mapContainer.webkitRequestFullscreen(); }; const Sr = { closeButton: !0, closeOnClick: !0 }; const Ar = (function (t) {
          function n(n) { t.call(this), this.options = e.extend(Object.create(Sr), n), e.bindAll(['_update', '_onClickClose'], this); } return t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n, n.prototype.addTo = function (t) { return this._map = t, this._map.on('move', this._update), this.options.closeOnClick && this._map.on('click', this._onClickClose), this._update(), this.fire(new e.Event('open')), this; }, n.prototype.isOpen = function () { return !!this._map; }, n.prototype.remove = function () { return this._content && _e.remove(this._content), this._container && (_e.remove(this._container), delete this._container), this._map && (this._map.off('move', this._update), this._map.off('click', this._onClickClose), delete this._map), this.fire(new e.Event('close')), this; }, n.prototype.getLngLat = function () { return this._lngLat; }, n.prototype.setLngLat = function (e) { return this._lngLat = Ze.convert(e), this._pos = null, this._update(), this; }, n.prototype.setText = function (t) { return this.setDOMContent(e.default.document.createTextNode(t)); }, n.prototype.setHTML = function (t) { let n; const r = e.default.document.createDocumentFragment(); const i = e.default.document.createElement('body'); for (i.innerHTML = t; n = i.firstChild;)r.appendChild(n); return this.setDOMContent(r); }, n.prototype.setDOMContent = function (e) { return this._createContent(), this._content.appendChild(e), this._update(), this; }, n.prototype._createContent = function () { this._content && _e.remove(this._content), this._content = _e.create('div', 'mapboxgl-popup-content', this._container), this.options.closeButton && (this._closeButton = _e.create('button', 'mapboxgl-popup-close-button', this._content), this._closeButton.type = 'button', this._closeButton.setAttribute('aria-label', 'Close popup'), this._closeButton.innerHTML = '&#215;', this._closeButton.addEventListener('click', this._onClickClose)); }, n.prototype._update = function () {
            if (this._map && this._lngLat && this._content) {
              this._container || (this._container = _e.create('div', 'mapboxgl-popup', this._map.getContainer()), this._tip = _e.create('div', 'mapboxgl-popup-tip', this._container), this._container.appendChild(this._content)), this._map.transform.renderWorldCopies && (this._lngLat = le(this._lngLat, this._pos, this._map.transform)); const t = this._pos = this._map.project(this._lngLat); let n = this.options.anchor; const r = (function t(n) {
                if (n) {
                  if (typeof n == 'number') {
                    let r = Math.round(Math.sqrt(0.5 * Math.pow(n, 2))); return {
                      center: new e.default$1(0, 0), top: new e.default$1(0, n), 'top-left': new e.default$1(r, r), 'top-right': new e.default$1(-r, r), bottom: new e.default$1(0, -n), 'bottom-left': new e.default$1(r, -r), 'bottom-right': new e.default$1(-r, -r), left: new e.default$1(n, 0), right: new e.default$1(-n, 0), 
                    };
                  } if (n instanceof e.default$1 || Array.isArray(n)) {
                    let i = e.default$1.convert(n); return {
                      center: i, top: i, 'top-left': i, 'top-right': i, bottom: i, 'bottom-left': i, 'bottom-right': i, left: i, right: i,
                    }; 
} return {
                    center: e.default$1.convert(n.center || [0, 0]), top: e.default$1.convert(n.top || [0, 0]), 'top-left': e.default$1.convert(n['top-left'] || [0, 0]), 'top-right': e.default$1.convert(n['top-right'] || [0, 0]), bottom: e.default$1.convert(n.bottom || [0, 0]), 'bottom-left': e.default$1.convert(n['bottom-left'] || [0, 0]), 'bottom-right': e.default$1.convert(n['bottom-right'] || [0, 0]), left: e.default$1.convert(n.left || [0, 0]), right: e.default$1.convert(n.right || [0, 0]),
                  }; 
} return t(new e.default$1(0, 0));
              }(this.options.offset)); if (!n) { let i; const o = this._container.offsetWidth; const a = this._container.offsetHeight; i = t.y + r.bottom.y < a ? ['top'] : t.y > this._map.transform.height - a ? ['bottom'] : [], t.x < o / 2 ? i.push('left') : t.x > this._map.transform.width - o / 2 && i.push('right'), n = i.length === 0 ? 'bottom' : i.join('-'); } const s = t.add(r[n]).round(); _e.setTransform(this._container, `${_r[n]} translate(${s.x}px,${s.y}px)`), ue(this._container, n, 'popup');
            }
          }, n.prototype._onClickClose = function () { this.remove(); }, n;
        }(e.Evented)); var Or = {
          version: '0.45.0', supported: fe, workerCount: Math.max(Math.floor(ge.hardwareConcurrency / 2), 1), setRTLTextPlugin: e.setRTLTextPlugin, Map: gr, NavigationControl: vr, GeolocateControl: Er, AttributionControl: cr, ScaleControl: kr, FullscreenControl: Cr, Popup: Ar, Marker: br, Style: kn, LngLat: Ze, LngLatBounds: Ke, Point: e.default$1, Evented: e.Evented, config: Ce, get accessToken() { return Ce.ACCESS_TOKEN; }, set accessToken(e) { Ce.ACCESS_TOKEN = e; }, workerUrl: '',
        }; return Or;
      }), i;
    }));
  }).call(t, n(4));
}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t, n) {
  function r(e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); } function i(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || typeof t !== 'object' && typeof t !== 'function' ? e : t; } function o(e, t) {
    if (typeof t !== 'function' && t !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof t}`); e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e, enumerable: !1, writable: !0, configurable: !0,
      },
    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
  } const a = n(0); const s = n.n(a); const l = n(110); const u = (n.n(l), (function () { function e(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } return function (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; }; }())); const c = (function (e) {
    function t() { r(this, t); const e = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return e.state = { citiesGeonameid: 109223, recordsGeonameid: 109223, viewsGeonameid: 109223 }, e; } return o(t, e), u(t, [{
      key: 'render',
      value() {
        const e = this; return s.a.createElement('div', { className: 'api' }, s.a.createElement('p', null, s.a.createElement('b', null, 'Base URI. '), 'http://www.hotcities.world/api'), s.a.createElement('table', { className: 'table-sm table-responsive table-hover d-table' }, s.a.createElement('thead', null, s.a.createElement('tr', null, s.a.createElement('th', { scope: 'col', nowrap: 'nowrap' }, 'endpoint'), s.a.createElement('th', { scope: 'col', nowrap: 'nowrap' }, 'method'), s.a.createElement('th', { scope: 'col', nowrap: 'nowrap' }, 'params'), s.a.createElement('th', { scope: 'col', nowrap: 'nowrap' }, 'description'), s.a.createElement('th', { col: 'col', nowrap: 'nowrap' }))), s.a.createElement('tbody', null, s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/cities'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }), s.a.createElement('td', { nowrap: 'nowrap' }, 'all cities in database'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: '/api/cities', target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/cities/:id'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('label', { target: '#citiesGeonameid' }, ':id'), s.a.createElement('input', {
          className: 'form-control d-inline', size: '8', type: 'text', id: 'citiesGeonameid', placeholder: this.state.citiesGeonameid, onChange(t) { e.setState({ citiesGeonameid: t.target.value }); },
        })), s.a.createElement('td', { nowrap: 'nowrap' }, 'info about the city with :id as geonameid'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: `/api/cities/${this.state.citiesGeonameid}`, target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/records'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }), s.a.createElement('td', { nowrap: 'nowrap' }, 'all records info'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: '/api/records', target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/records/current'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }), s.a.createElement('td', { nowrap: 'nowrap' }, 'current record info'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: '/api/records/current', target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/records/:id'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('label', { target: '#recordsGeonameid' }, ':id'), s.a.createElement('input', {
          className: 'form-control d-inline', size: '8', type: 'text', id: 'recordsGeonameid', placeholder: this.state.recordsGeonameid, onChange(t) { e.setState({ recordsGeonameid: t.target.value }); },
        })), s.a.createElement('td', { nowrap: 'nowrap' }, 'records for the city with :id as geonameid'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: `/api/records/${this.state.recordsGeonameid}`, target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/views'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }), s.a.createElement('td', { nowrap: 'nowrap' }, 'all views'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: '/api/views', target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/view/:id'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('label', { target: '#viewsGeonameid' }, ':id'), s.a.createElement('input', {
          className: 'form-control d-inline', size: '8', type: 'text', id: 'viewsGeonameid', placeholder: this.state.viewsGeonameid, onChange(t) { e.setState({ viewsGeonameid: t.target.value }); },
        })), s.a.createElement('td', { nowrap: 'nowrap' }, 'views for the city with :id as geonameid'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: `/api/views/${this.state.viewsGeonameid}`, target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/stats/cities'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }), s.a.createElement('td', { nowrap: 'nowrap' }, 'all record cities with statistics'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: '/api/stats/cities', target: '_blank' }, 'Try it'))), s.a.createElement('tr', null, s.a.createElement('td', { nowrap: 'nowrap' }, '/stats/countries'), s.a.createElement('td', { nowrap: 'nowrap' }, 'GET'), s.a.createElement('td', { nowrap: 'nowrap' }), s.a.createElement('td', { nowrap: 'nowrap' }, 'all record countries with statistics'), s.a.createElement('td', { nowrap: 'nowrap' }, s.a.createElement('a', { href: '/api/stats/countries', target: '_blank' }, 'Try it'))))));
      },
    }]), t;
  }(a.Component)); t.a = c;
}, function (e, t) {}, function (e, t, n) {
  const r = n(0); const i = n.n(r); const o = n(112); const a = (n.n(o), function (e) { return i.a.createElement('div', { className: 'about' }, i.a.createElement('p', null, i.a.createElement('b', null, 'What is it. '), 'Hot Cities monitors world cities temperatures in real time from global weather services to determine the hottest one, right now.'), i.a.createElement('p', null, i.a.createElement('b', null, 'What is a city. '), 'Human settlements with a minimum population of half a milion inhabitants are considered.'), i.a.createElement('p', null, i.a.createElement('b', null, 'What it means real time. '), 'Weather data are fetched every 10 minutes.'), i.a.createElement('p', null, i.a.createElement('b', null, 'Where it fetch data from. '), 'It uses ', i.a.createElement('a', { href: 'http://geonames.org', target: '_blanck' }, 'geonames.org'), ' for geographical data, ', i.a.createElement('a', { href: 'http://openweathermap.org', target: '_blanck' }, 'openweathermap.org'), ' for weather data and ', i.a.createElement('a', { href: 'http://flickr.com', target: '_blanck' }, 'flickr.com'), ' for geolocated images.'), i.a.createElement('p', null, i.a.createElement('b', null, 'Follow. '), 'Hot Cities is on ', i.a.createElement('a', { href: 'https://twitter.com/intent/user?screen_name=hotcitiesworld', target: '_blanck' }, 'twitter (@hotcitiesworld)'), ', ', i.a.createElement('a', { href: 'https://www.instagram.com/hotcitiesworld/', target: '_blanck' }, 'instagram (@hotcitiesworld)'), ' and ', i.a.createElement('a', { href: 'https://www.facebook.com/hotcitiesworld', target: '_blanck' }, 'facebook'), '.'), i.a.createElement('p', null, i.a.createElement('b', null, 'Support. '), 'Like the project on ', i.a.createElement('a', { href: 'http://github.com/bluephlavio/hotcities', target: '_blanck' }, 'github'), '.'), i.a.createElement('p', null, i.a.createElement('b', null, 'Contact. '), 'contact@hotcities.world.')); }); t.a = a;
}, function (e, t) {}, function (e, t) {}, function (e, t, n) {
  const r = n(0); const i = n.n(r); const o = n(115); const a = (n.n(o), function (e) { return i.a.createElement('div', { className: 'footer-social' }, i.a.createElement('ul', { className: 'nav justify-content-center' }, i.a.createElement('li', { className: 'nav-item' }, i.a.createElement('button', { className: 'btn btn-social-icon' }, i.a.createElement('a', { href: 'https://twitter.com/intent/user?screen_name=hotcitiesworld', target: '_blank', rel: 'noopener noreferrer' }, i.a.createElement('span', { className: 'fab fa-twitter' })))), i.a.createElement('li', { className: 'nav-item' }, i.a.createElement('button', { className: 'btn btn-social-icon' }, i.a.createElement('a', { href: 'https://www.instagram.com/hotcitiesworld/', target: '_blank', rel: 'noopener noreferrer' }, i.a.createElement('span', { className: 'fab fa-instagram' })))), i.a.createElement('li', { className: 'nav-item' }, i.a.createElement('button', { className: 'btn btn-social-icon' }, i.a.createElement('a', { href: 'https://www.facebook.com/hotcitiesworld', target: '_blank', rel: 'noopener noreferrer' }, i.a.createElement('span', { className: 'fab fa-facebook' })))), i.a.createElement('li', { className: 'nav-item' }, i.a.createElement('button', { className: 'btn btn-social-icon' }, i.a.createElement('a', { href: 'https://github.com/bluephlavio/hotcities', target: '_blank', rel: 'noopener noreferrer' }, i.a.createElement('span', { className: 'fab fa-github' })))))); }); const s = function (e) { return i.a.createElement('footer', { className: 'footer' }, i.a.createElement('hr', null), i.a.createElement(a, null)); }; t.a = s;
}, function (e, t) {}, function (e, t) {}, function (e, t, n) {
  let r; let i; !(function (t, n) {
    typeof e === 'object' && typeof e.exports === 'object' ? e.exports = t.document ? n(t, !0) : function (e) { if (!e.document) throw new Error('jQuery requires a window with a document'); return n(e); } : n(t);
  }(typeof window !== 'undefined' ? window : this, (o, a) => {
    function s(e, t, n) { let r; const i = (t = t || pe).createElement('script'); if (i.text = e, n) for (r in ke)n[r] && (i[r] = n[r]); t.head.appendChild(i).parentNode.removeChild(i); } function l(e) { return e == null ? `${e}` : typeof e === 'object' || typeof e === 'function' ? ye[ve.call(e)] || 'object' : typeof e; } function u(e) { const t = !!e && 'length' in e && e.length; const n = l(e); return !Ee(e) && !Te(e) && (n === 'array' || t === 0 || typeof t === 'number' && t > 0 && t - 1 in e); } function c(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase(); } function p(e, t, n) { return Ee(t) ? Ce.grep(e, (e, r) => !!t.call(e, r, e) !== n) : t.nodeType ? Ce.grep(e, e => e === t !== n) : typeof t !== 'string' ? Ce.grep(e, e => ge.call(t, e) > -1 !== n) : Ce.filter(t, e, n); } function f(e, t) { for (;(e = e[t]) && e.nodeType !== 1;);return e; } function h(e) { const t = {}; return Ce.each(e.match(Re) || [], (e, n) => { t[n] = !0; }), t; } function d(e) { return e; } function m(e) { throw e; } function g(e, t, n, r) { let i; try { e && Ee(i = e.promise) ? i.call(e).done(t).fail(n) : e && Ee(i = e.then) ? i.call(e, t, n) : t(...[e].slice(r)); } catch (e) { n.apply(void 0, [e]); } } function y() { pe.removeEventListener('DOMContentLoaded', y), o.removeEventListener('load', y), Ce.ready(); } function v(e, t) { return t.toUpperCase(); } function _(e) { return e.replace(Ue, 'ms-').replace(Ve, v); } function b() { this.expando = Ce.expando + b.uid++; } function x(e) { return e === 'true' || e !== 'false' && (e === 'null' ? null : e === `${+e}` ? +e : $e.test(e) ? JSON.parse(e) : e); } function w(e, t, n) { let r; if (void 0 === n && e.nodeType === 1) if (r = `data-${t.replace(Ge, '-$&').toLowerCase()}`, typeof (n = e.getAttribute(r)) === 'string') { try { n = x(n); } catch (e) {}We.set(e, t, n); } else n = void 0; return n; } function E(e, t, n, r) { let i; let o; let a = 20; const s = r ? function () { return r.cur(); } : function () { return Ce.css(e, t, ''); }; let l = s(); let u = n && n[3] || (Ce.cssNumber[t] ? '' : 'px'); let c = (Ce.cssNumber[t] || u !== 'px' && +l) && Ke.exec(Ce.css(e, t)); if (c && c[3] !== u) { for (l /= 2, u = u || c[3], c = +l || 1; a--;)Ce.style(e, t, c + u), (1 - o) * (1 - (o = s() / l || 0.5)) <= 0 && (a = 0), c /= o; c *= 2, Ce.style(e, t, c + u), n = n || []; } return n && (c = +c || +l || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = u, r.start = c, r.end = i)), i; } function T(e) { let t; const n = e.ownerDocument; const r = e.nodeName; let i = Qe[r]; return i || (t = n.body.appendChild(n.createElement(r)), i = Ce.css(t, 'display'), t.parentNode.removeChild(t), i === 'none' && (i = 'block'), Qe[r] = i, i); } function k(e, t) { for (var n, r, i = [], o = 0, a = e.length; o < a; o++)(r = e[o]).style && (n = r.style.display, t ? (n === 'none' && (i[o] = He.get(r, 'display') || null, i[o] || (r.style.display = '')), r.style.display === '' && Ye(r) && (i[o] = T(r))) : n !== 'none' && (i[o] = 'none', He.set(r, 'display', n))); for (o = 0; o < a; o++)i[o] != null && (e[o].style.display = i[o]); return e; } function C(e, t) { let n; return n = typeof e.getElementsByTagName !== 'undefined' ? e.getElementsByTagName(t || '*') : typeof e.querySelectorAll !== 'undefined' ? e.querySelectorAll(t || '*') : [], void 0 === t || t && c(e, t) ? Ce.merge([e], n) : n; } function S(e, t) { for (let n = 0, r = e.length; n < r; n++)He.set(e[n], 'globalEval', !t || He.get(t[n], 'globalEval')); } function A(e, t, n, r, i) { for (var o, a, s, u, c, p, f = t.createDocumentFragment(), h = [], d = 0, m = e.length; d < m; d++) if ((o = e[d]) || o === 0) if (l(o) === 'object')Ce.merge(h, o.nodeType ? [o] : o); else if (it.test(o)) { for (a = a || f.appendChild(t.createElement('div')), s = (tt.exec(o) || ['', ''])[1].toLowerCase(), u = rt[s] || rt._default, a.innerHTML = u[1] + Ce.htmlPrefilter(o) + u[2], p = u[0]; p--;)a = a.lastChild; Ce.merge(h, a.childNodes), (a = f.firstChild).textContent = ''; } else h.push(t.createTextNode(o)); for (f.textContent = '', d = 0; o = h[d++];) if (r && Ce.inArray(o, r) > -1)i && i.push(o); else if (c = Ce.contains(o.ownerDocument, o), a = C(f.appendChild(o), 'script'), c && S(a), n) for (p = 0; o = a[p++];)nt.test(o.type || '') && n.push(o); return f; } function O() { return !0; } function I() { return !1; } function P() { try { return pe.activeElement; } catch (e) {} } function M(e, t, n, r, i, o) { let a; let s; if (typeof t === 'object') { typeof n !== 'string' && (r = r || n, n = void 0); for (s in t)M(e, s, n, r, t[s], o); return e; } if (r == null && i == null ? (i = n, r = n = void 0) : i == null && (typeof n === 'string' ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i)i = I; else if (!i) return e; return o === 1 && (a = i, (i = function (e) { return Ce().off(e), a.apply(this, arguments); }).guid = a.guid || (a.guid = Ce.guid++)), e.each(function () { Ce.event.add(this, t, i, r, n); }); } function N(e, t) { return c(e, 'table') && c(t.nodeType !== 11 ? t : t.firstChild, 'tr') ? Ce(e).children('tbody')[0] || e : e; } function D(e) { return e.type = `${e.getAttribute('type') !== null}/${e.type}`, e; } function L(e) { return (e.type || '').slice(0, 5) === 'true/' ? e.type = e.type.slice(5) : e.removeAttribute('type'), e; } function z(e, t) { let n; let r; let i; let o; let a; let s; let l; let u; if (t.nodeType === 1) { if (He.hasData(e) && (o = He.access(e), a = He.set(t, o), u = o.events)) { delete a.handle, a.events = {}; for (i in u) for (n = 0, r = u[i].length; n < r; n++)Ce.event.add(t, i, u[i][n]); }We.hasData(e) && (s = We.access(e), l = Ce.extend({}, s), We.set(t, l)); } } function R(e, t) { const n = t.nodeName.toLowerCase(); n === 'input' && et.test(e.type) ? t.checked = e.checked : n !== 'input' && n !== 'textarea' || (t.defaultValue = e.defaultValue); } function j(e, t, n, r) { t = de.apply([], t); let i; let o; let a; let l; let u; let c; let p = 0; const f = e.length; const h = f - 1; const d = t[0]; const m = Ee(d); if (m || f > 1 && typeof d === 'string' && !we.checkClone && pt.test(d)) return e.each(function (i) { const o = e.eq(i); m && (t[0] = d.call(this, i, o.html())), j(o, t, n, r); }); if (f && (i = A(t, e[0].ownerDocument, !1, e, r), o = i.firstChild, i.childNodes.length === 1 && (i = o), o || r)) { for (l = (a = Ce.map(C(i, 'script'), D)).length; p < f; p++)u = i, p !== h && (u = Ce.clone(u, !0, !0), l && Ce.merge(a, C(u, 'script'))), n.call(e[p], u, p); if (l) for (c = a[a.length - 1].ownerDocument, Ce.map(a, L), p = 0; p < l; p++)u = a[p], nt.test(u.type || '') && !He.access(u, 'globalEval') && Ce.contains(c, u) && (u.src && (u.type || '').toLowerCase() !== 'module' ? Ce._evalUrl && Ce._evalUrl(u.src) : s(u.textContent.replace(ft, ''), c, u)); } return e; } function B(e, t, n) { for (var r, i = t ? Ce.filter(t, e) : e, o = 0; (r = i[o]) != null; o++)n || r.nodeType !== 1 || Ce.cleanData(C(r)), r.parentNode && (n && Ce.contains(r.ownerDocument, r) && S(C(r, 'script')), r.parentNode.removeChild(r)); return e; } function F(e, t, n) { let r; let i; let o; let a; const s = e.style; return (n = n || dt(e)) && ((a = n.getPropertyValue(t) || n[t]) !== '' || Ce.contains(e.ownerDocument, e) || (a = Ce.style(e, t)), !we.pixelBoxStyles() && ht.test(a) && mt.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? `${a}` : a; } function U(e, t) { return { get() { if (!e()) return (this.get = t).apply(this, arguments); delete this.get; } }; } function V(e) { if (e in xt) return e; for (let t = e[0].toUpperCase() + e.slice(1), n = bt.length; n--;) if ((e = bt[n] + t) in xt) return e; } function q(e) { let t = Ce.cssProps[e]; return t || (t = Ce.cssProps[e] = V(e) || e), t; } function H(e, t, n) { const r = Ke.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || 'px') : t; } function W(e, t, n, r, i, o) { let a = t === 'width' ? 1 : 0; let s = 0; let l = 0; if (n === (r ? 'border' : 'content')) return 0; for (;a < 4; a += 2)n === 'margin' && (l += Ce.css(e, n + Xe[a], !0, i)), r ? (n === 'content' && (l -= Ce.css(e, `padding${Xe[a]}`, !0, i)), n !== 'margin' && (l -= Ce.css(e, `border${Xe[a]}Width`, !0, i))) : (l += Ce.css(e, `padding${Xe[a]}`, !0, i), n !== 'padding' ? l += Ce.css(e, `border${Xe[a]}Width`, !0, i) : s += Ce.css(e, `border${Xe[a]}Width`, !0, i)); return !r && o >= 0 && (l += Math.max(0, Math.ceil(e[`offset${t[0].toUpperCase()}${t.slice(1)}`] - o - l - s - 0.5))), l; } function $(e, t, n) { const r = dt(e); let i = F(e, t, r); const o = Ce.css(e, 'boxSizing', !1, r) === 'border-box'; let a = o; if (ht.test(i)) { if (!n) return i; i = 'auto'; } return a = a && (we.boxSizingReliable() || i === e.style[t]), (i === 'auto' || !parseFloat(i) && Ce.css(e, 'display', !1, r) === 'inline') && (i = e[`offset${t[0].toUpperCase()}${t.slice(1)}`], a = !0), `${(i = parseFloat(i) || 0) + W(e, t, n || (o ? 'border' : 'content'), a, r, i)}px`; } function G(e, t, n, r, i) { return new G.prototype.init(e, t, n, r, i); } function Z() { Et && (!1 === pe.hidden && o.requestAnimationFrame ? o.requestAnimationFrame(Z) : o.setTimeout(Z, Ce.fx.interval), Ce.fx.tick()); } function K() { return o.setTimeout(() => { wt = void 0; }), wt = Date.now(); } function X(e, t) { let n; let r = 0; const i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i[`margin${n = Xe[r]}`] = i[`padding${n}`] = e; return t && (i.opacity = i.width = e), i; } function Y(e, t, n) { for (var r, i = (ee.tweeners[t] || []).concat(ee.tweeners['*']), o = 0, a = i.length; o < a; o++) if (r = i[o].call(n, t, e)) return r; } function J(e, t, n) { let r; let i; let o; let a; let s; let l; let u; let c; const p = 'width' in t || 'height' in t; const f = this; const h = {}; const d = e.style; let m = e.nodeType && Ye(e); let g = He.get(e, 'fxshow'); n.queue || ((a = Ce._queueHooks(e, 'fx')).unqueued == null && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s(); }), a.unqueued++, f.always(() => { f.always(() => { a.unqueued--, Ce.queue(e, 'fx').length || a.empty.fire(); }); })); for (r in t) if (i = t[r], Tt.test(i)) { if (delete t[r], o = o || i === 'toggle', i === (m ? 'hide' : 'show')) { if (i !== 'show' || !g || void 0 === g[r]) continue; m = !0; }h[r] = g && g[r] || Ce.style(e, r); } if ((l = !Ce.isEmptyObject(t)) || !Ce.isEmptyObject(h)) { p && e.nodeType === 1 && (n.overflow = [d.overflow, d.overflowX, d.overflowY], (u = g && g.display) == null && (u = He.get(e, 'display')), (c = Ce.css(e, 'display')) === 'none' && (u ? c = u : (k([e], !0), u = e.style.display || u, c = Ce.css(e, 'display'), k([e]))), (c === 'inline' || c === 'inline-block' && u != null) && Ce.css(e, 'float') === 'none' && (l || (f.done(() => { d.display = u; }), u == null && (c = d.display, u = c === 'none' ? '' : c)), d.display = 'inline-block')), n.overflow && (d.overflow = 'hidden', f.always(() => { d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2]; })), l = !1; for (r in h)l || (g ? 'hidden' in g && (m = g.hidden) : g = He.access(e, 'fxshow', { display: u }), o && (g.hidden = !m), m && k([e], !0), f.done(() => { m || k([e]), He.remove(e, 'fxshow'); for (r in h)Ce.style(e, r, h[r]); })), l = Y(m ? g[r] : 0, r, f), r in g || (g[r] = l.start, m && (l.end = l.start, l.start = 0)); } } function Q(e, t) { let n; let r; let i; let o; let a; for (n in e) if (r = _(n), i = t[r], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = Ce.cssHooks[r]) && 'expand' in a) { o = a.expand(o), delete e[r]; for (n in o)n in e || (e[n] = o[n], t[n] = i); } else t[r] = i; } function ee(e, t, n) {
      let r; let i; let o = 0; const a = ee.prefilters.length; const s = Ce.Deferred().always(() => { delete l.elem; }); var l = function () { if (i) return !1; for (var t = wt || K(), n = Math.max(0, u.startTime + u.duration - t), r = 1 - (n / u.duration || 0), o = 0, a = u.tweens.length; o < a; o++)u.tweens[o].run(r); return s.notifyWith(e, [u, r, n]), r < 1 && a ? n : (a || s.notifyWith(e, [u, 1, 0]), s.resolveWith(e, [u]), !1); }; var u = s.promise({
        elem: e, props: Ce.extend({}, t), opts: Ce.extend(!0, { specialEasing: {}, easing: Ce.easing._default }, n), originalProperties: t, originalOptions: n, startTime: wt || K(), duration: n.duration, tweens: [], createTween(t, n) { const r = Ce.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing); return u.tweens.push(r), r; }, stop(t) { let n = 0; const r = t ? u.tweens.length : 0; if (i) return this; for (i = !0; n < r; n++)u.tweens[n].run(1); return t ? (s.notifyWith(e, [u, 1, 0]), s.resolveWith(e, [u, t])) : s.rejectWith(e, [u, t]), this; },
      }); const c = u.props; for (Q(c, u.opts.specialEasing); o < a; o++) if (r = ee.prefilters[o].call(u, e, c, u.opts)) return Ee(r.stop) && (Ce._queueHooks(u.elem, u.opts.queue).stop = r.stop.bind(r)), r; return Ce.map(c, Y, u), Ee(u.opts.start) && u.opts.start.call(e, u), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always), Ce.fx.timer(Ce.extend(l, { elem: e, anim: u, queue: u.opts.queue })), u;
    } function te(e) { return (e.match(Re) || []).join(' '); } function ne(e) { return e.getAttribute && e.getAttribute('class') || ''; } function re(e) { return Array.isArray(e) ? e : typeof e === 'string' ? e.match(Re) || [] : []; } function ie(e, t, n, r) { let i; if (Array.isArray(t))Ce.each(t, (t, i) => { n || zt.test(e) ? r(e, i) : ie(`${e}[${typeof i === 'object' && i != null ? t : ''}]`, i, n, r); }); else if (n || l(t) !== 'object')r(e, t); else for (i in t)ie(`${e}[${i}]`, t[i], n, r); } function oe(e) { return function (t, n) { typeof t !== 'string' && (n = t, t = '*'); let r; let i = 0; const o = t.toLowerCase().match(Re) || []; if (Ee(n)) for (;r = o[i++];)r[0] === '+' ? (r = r.slice(1) || '*', (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n); }; } function ae(e, t, n, r) { function i(s) { let l; return o[s] = !0, Ce.each(e[s] || [], (e, s) => { const u = s(t, n, r); return typeof u !== 'string' || a || o[u] ? a ? !(l = u) : void 0 : (t.dataTypes.unshift(u), i(u), !1); }), l; } var o = {}; var a = e === Zt; return i(t.dataTypes[0]) || !o['*'] && i('*'); } function se(e, t) { let n; let r; const i = Ce.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && Ce.extend(!0, e, r), e; } function le(e, t, n) { for (var r, i, o, a, s = e.contents, l = e.dataTypes; l[0] === '*';)l.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader('Content-Type')); if (r) for (i in s) if (s[i] && s[i].test(r)) { l.unshift(i); break; } if (l[0] in n)o = l[0]; else { for (i in n) { if (!l[0] || e.converters[`${i} ${l[0]}`]) { o = i; break; }a || (a = i); }o = o || a; } if (o) return o !== l[0] && l.unshift(o), n[o]; } function ue(e, t, n, r) { let i; let o; let a; let s; let l; const u = {}; const c = e.dataTypes.slice(); if (c[1]) for (a in e.converters)u[a.toLowerCase()] = e.converters[a]; for (o = c.shift(); o;) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift()) if (o === '*')o = l; else if (l !== '*' && l !== o) { if (!(a = u[`${l} ${o}`] || u[`* ${o}`])) for (i in u) if ((s = i.split(' '))[1] === o && (a = u[`${l} ${s[0]}`] || u[`* ${s[0]}`])) { !0 === a ? a = u[i] : !0 !== u[i] && (o = s[0], c.unshift(s[1])); break; } if (!0 !== a) if (a && e.throws)t = a(t); else try { t = a(t); } catch (e) { return { state: 'parsererror', error: a ? e : `No conversion from ${l} to ${o}` }; } } return { state: 'success', data: t }; } const ce = []; var pe = o.document; const fe = Object.getPrototypeOf; const he = ce.slice; var de = ce.concat; const me = ce.push; var ge = ce.indexOf; var ye = {}; var ve = ye.toString; const _e = ye.hasOwnProperty; const be = _e.toString; const xe = be.call(Object); var we = {}; var Ee = function (e) { return typeof e === 'function' && typeof e.nodeType !== 'number'; }; var Te = function (e) { return e != null && e === e.window; }; var ke = { type: !0, src: !0, noModule: !0 }; var Ce = function (e, t) { return new Ce.fn.init(e, t); }; const Se = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; Ce.fn = Ce.prototype = {
      jquery: '3.3.1', constructor: Ce, length: 0, toArray() { return he.call(this); }, get(e) { return e == null ? he.call(this) : e < 0 ? this[e + this.length] : this[e]; }, pushStack(e) { const t = Ce.merge(this.constructor(), e); return t.prevObject = this, t; }, each(e) { return Ce.each(this, e); }, map(e) { return this.pushStack(Ce.map(this, (t, n) => e.call(t, n, t))); }, slice() { return this.pushStack(he.apply(this, arguments)); }, first() { return this.eq(0); }, last() { return this.eq(-1); }, eq(e) { const t = this.length; const n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []); }, end() { return this.prevObject || this.constructor(); }, push: me, sort: ce.sort, splice: ce.splice,
    }, Ce.extend = Ce.fn.extend = function () { let e; let t; let n; let r; let i; let o; let a = arguments[0] || {}; let s = 1; const l = arguments.length; let u = !1; for (typeof a === 'boolean' && (u = a, a = arguments[s] || {}, s++), typeof a === 'object' || Ee(a) || (a = {}), s === l && (a = this, s--); s < l; s++) if ((e = arguments[s]) != null) for (t in e)n = a[t], a !== (r = e[t]) && (u && r && (Ce.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && Ce.isPlainObject(n) ? n : {}, a[t] = Ce.extend(u, o, r)) : void 0 !== r && (a[t] = r)); return a; }, Ce.extend({
      expando: `jQuery${(`3.3.1${Math.random()}`).replace(/\D/g, '')}`, isReady: !0, error(e) { throw new Error(e); }, noop() {}, isPlainObject(e) { let t; let n; return !(!e || ve.call(e) !== '[object Object]') && (!(t = fe(e)) || typeof (n = _e.call(t, 'constructor') && t.constructor) === 'function' && be.call(n) === xe); }, isEmptyObject(e) { let t; for (t in e) return !1; return !0; }, globalEval(e) { s(e); }, each(e, t) { let n; let r = 0; if (u(e)) for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++);else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e; }, trim(e) { return e == null ? '' : (`${e}`).replace(Se, ''); }, makeArray(e, t) { const n = t || []; return e != null && (u(Object(e)) ? Ce.merge(n, typeof e === 'string' ? [e] : e) : me.call(n, e)), n; }, inArray(e, t, n) { return t == null ? -1 : ge.call(t, e, n); }, merge(e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e; }, grep(e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r; }, map(e, t, n) { let r; let i; let o = 0; const a = []; if (u(e)) for (r = e.length; o < r; o++)(i = t(e[o], o, n)) != null && a.push(i); else for (o in e)(i = t(e[o], o, n)) != null && a.push(i); return de.apply([], a); }, guid: 1, support: we,
    }), typeof Symbol === 'function' && (Ce.fn[Symbol.iterator] = ce[Symbol.iterator]), Ce.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), (e, t) => { ye[`[object ${t}]`] = t.toLowerCase(); }); const Ae = (function (e) {
      function t(e, t, n, r) { let i; let o; let a; let s; let l; let c; let f; let h = t && t.ownerDocument; const d = t ? t.nodeType : 9; if (n = n || [], typeof e !== 'string' || !e || d !== 1 && d !== 9 && d !== 11) return n; if (!r && ((t ? t.ownerDocument || t : B) !== P && I(t), t = t || P, N)) { if (d !== 11 && (l = me.exec(e))) if (i = l[1]) { if (d === 9) { if (!(a = t.getElementById(i))) return n; if (a.id === i) return n.push(a), n; } else if (h && (a = h.getElementById(i)) && R(t, a) && a.id === i) return n.push(a), n; } else { if (l[2]) return X.apply(n, t.getElementsByTagName(e)), n; if ((i = l[3]) && b.getElementsByClassName && t.getElementsByClassName) return X.apply(n, t.getElementsByClassName(i)), n; } if (b.qsa && !H[`${e} `] && (!D || !D.test(e))) { if (d !== 1)h = t, f = e; else if (t.nodeName.toLowerCase() !== 'object') { for ((s = t.getAttribute('id')) ? s = s.replace(_e, be) : t.setAttribute('id', s = j), o = (c = T(e)).length; o--;)c[o] = `#${s} ${p(c[o])}`; f = c.join(','), h = ge.test(e) && u(t.parentNode) || t; } if (f) try { return X.apply(n, h.querySelectorAll(f)), n; } catch (e) {} finally { s === j && t.removeAttribute('id'); } } } return C(e.replace(oe, '$1'), t, n, r); } function n() { function e(n, r) { return t.push(`${n} `) > x.cacheLength && delete e[t.shift()], e[`${n} `] = r; } var t = []; return e; } function r(e) { return e[j] = !0, e; } function i(e) { let t = P.createElement('fieldset'); try { return !!e(t); } catch (e) { return !1; } finally { t.parentNode && t.parentNode.removeChild(t), t = null; } } function o(e, t) { for (let n = e.split('|'), r = n.length; r--;)x.attrHandle[n[r]] = t; } function a(e, t) { let n = t && e; const r = n && e.nodeType === 1 && t.nodeType === 1 && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) for (;n = n.nextSibling;) if (n === t) return -1; return e ? 1 : -1; } function s(e) { return function (t) { return 'form' in t ? t.parentNode && !1 === t.disabled ? 'label' in t ? 'label' in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && we(t) === e : t.disabled === e : 'label' in t && t.disabled === e; }; } function l(e) { return r(t => t = +t, r((n, r) => { for (var i, o = e([], n.length, t), a = o.length; a--;)n[i = o[a]] && (n[i] = !(r[i] = n[i])); })); } function u(e) { return e && typeof e.getElementsByTagName !== 'undefined' && e; } function c() {} function p(e) { for (var t = 0, n = e.length, r = ''; t < n; t++)r += e[t].value; return r; } function f(e, t, n) { const r = t.dir; const i = t.next; const o = i || r; const a = n && o === 'parentNode'; const s = U++; return t.first ? function (t, n, i) { for (;t = t[r];) if (t.nodeType === 1 || a) return e(t, n, i); return !1; } : function (t, n, l) { let u; let c; let p; const f = [F, s]; if (l) { for (;t = t[r];) if ((t.nodeType === 1 || a) && e(t, n, l)) return !0; } else for (;t = t[r];) if (t.nodeType === 1 || a) if (p = t[j] || (t[j] = {}), c = p[t.uniqueID] || (p[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase())t = t[r] || t; else { if ((u = c[o]) && u[0] === F && u[1] === s) return f[2] = u[2]; if (c[o] = f, f[2] = e(t, n, l)) return !0; } return !1; }; } function h(e) { return e.length > 1 ? function (t, n, r) { for (let i = e.length; i--;) if (!e[i](t, n, r)) return !1; return !0; } : e[0]; } function d(e, n, r) { for (let i = 0, o = n.length; i < o; i++)t(e, n[i], r); return r; } function m(e, t, n, r, i) { for (var o, a = [], s = 0, l = e.length, u = t != null; s < l; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), u && t.push(s))); return a; } function g(e, t, n, i, o, a) { return i && !i[j] && (i = g(i)), o && !o[j] && (o = g(o, a)), r((r, a, s, l) => { let u; let c; let p; const f = []; const h = []; const g = a.length; const y = r || d(t || '*', s.nodeType ? [s] : s, []); const v = !e || !r && t ? y : m(y, f, e, s, l); let _ = n ? o || (r ? e : g || i) ? [] : a : v; if (n && n(v, _, s, l), i) for (u = m(_, h), i(u, [], s, l), c = u.length; c--;)(p = u[c]) && (_[h[c]] = !(v[h[c]] = p)); if (r) { if (o || e) { if (o) { for (u = [], c = _.length; c--;)(p = _[c]) && u.push(v[c] = p); o(null, _ = [], u, l); } for (c = _.length; c--;)(p = _[c]) && (u = o ? J(r, p) : f[c]) > -1 && (r[u] = !(a[u] = p)); } } else _ = m(_ === a ? _.splice(g, _.length) : _), o ? o(null, a, _, l) : X.apply(a, _); }); } function y(e) { for (var t, n, r, i = e.length, o = x.relative[e[0].type], a = o || x.relative[' '], s = o ? 1 : 0, l = f(e => e === t, a, !0), u = f(e => J(t, e) > -1, a, !0), c = [function (e, n, r) { const i = !o && (r || n !== S) || ((t = n).nodeType ? l(e, n, r) : u(e, n, r)); return t = null, i; }]; s < i; s++) if (n = x.relative[e[s].type])c = [f(h(c), n)]; else { if ((n = x.filter[e[s].type].apply(null, e[s].matches))[j]) { for (r = ++s; r < i && !x.relative[e[r].type]; r++);return g(s > 1 && h(c), s > 1 && p(e.slice(0, s - 1).concat({ value: e[s - 2].type === ' ' ? '*' : '' })).replace(oe, '$1'), n, s < r && y(e.slice(s, r)), r < i && y(e = e.slice(r)), r < i && p(e)); }c.push(n); } return h(c); } function v(e, n) { const i = n.length > 0; const o = e.length > 0; const a = function (r, a, s, l, u) { let c; let p; let f; let h = 0; let d = '0'; const g = r && []; let y = []; const v = S; const _ = r || o && x.find.TAG('*', u); const b = F += v == null ? 1 : Math.random() || 0.1; const w = _.length; for (u && (S = a === P || a || u); d !== w && (c = _[d]) != null; d++) { if (o && c) { for (p = 0, a || c.ownerDocument === P || (I(c), s = !N); f = e[p++];) if (f(c, a || P, s)) { l.push(c); break; }u && (F = b); }i && ((c = !f && c) && h--, r && g.push(c)); } if (h += d, i && d !== h) { for (p = 0; f = n[p++];)f(g, y, a, s); if (r) { if (h > 0) for (;d--;)g[d] || y[d] || (y[d] = Z.call(l)); y = m(y); }X.apply(l, y), u && !r && y.length > 0 && h + n.length > 1 && t.uniqueSort(l); } return u && (F = b, S = v), g; }; return i ? r(a) : a; } let _; let b; let x; let w; let E; let T; let k; let C; let S; let A; let O; let I; let P; let M; let N; let D; let L; let z; let R; var j = `sizzle${1 * new Date()}`; var B = e.document; var F = 0; var U = 0; const V = n(); const q = n(); var H = n(); let W = function (e, t) { return e === t && (O = !0), 0; }; const $ = {}.hasOwnProperty; let G = []; var Z = G.pop; const K = G.push; var X = G.push; const Y = G.slice; var J = function (e, t) { for (let n = 0, r = e.length; n < r; n++) if (e[n] === t) return n; return -1; }; const Q = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped'; const ee = '[\\x20\\t\\r\\n\\f]'; const te = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+'; const ne = `\\[${ee}*(${te})(?:${ee}*([*^$|!~]?=)${ee}*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(${te}))|)${ee}*\\]`; const re = `:(${te})(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|${ne})*)|.*)\\)|)`; const ie = new RegExp(`${ee}+`, 'g'); var oe = new RegExp(`^${ee}+|((?:^|[^\\\\])(?:\\\\.)*)${ee}+$`, 'g'); const ae = new RegExp(`^${ee}*,${ee}*`); const se = new RegExp(`^${ee}*([>+~]|${ee})${ee}*`); const le = new RegExp(`=${ee}*([^\\]'"]*?)${ee}*\\]`, 'g'); const ue = new RegExp(re); const ce = new RegExp(`^${te}$`); const pe = {
        ID: new RegExp(`^#(${te})`), CLASS: new RegExp(`^\\.(${te})`), TAG: new RegExp(`^(${te}|[*])`), ATTR: new RegExp(`^${ne}`), PSEUDO: new RegExp(`^${re}`), CHILD: new RegExp(`^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(${ee}*(even|odd|(([+-]|)(\\d*)n|)${ee}*(?:([+-]|)${ee}*(\\d+)|))${ee}*\\)|)`, 'i'), bool: new RegExp(`^(?:${Q})$`, 'i'), needsContext: new RegExp(`^${ee}*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(${ee}*((?:-\\d)?\\d*)${ee}*\\)|)(?=[^-]|$)`, 'i'),
      }; const fe = /^(?:input|select|textarea|button)$/i; const he = /^h\d$/i; const de = /^[^{]+\{\s*\[native \w/; var me = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/; var ge = /[+~]/; const ye = new RegExp(`\\\\([\\da-f]{1,6}${ee}?|(${ee})|.)`, 'ig'); const ve = function (e, t, n) { const r = `0x${t}` - 65536; return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320); }; var _e = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g; var be = function (e, t) { return t ? e === '\0' ? '\ufffd' : `${e.slice(0, -1)}\\${e.charCodeAt(e.length - 1).toString(16)} ` : `\\${e}`; }; const xe = function () { I(); }; var we = f(e => !0 === e.disabled && ('form' in e || 'label' in e), { dir: 'parentNode', next: 'legend' }); try { X.apply(G = Y.call(B.childNodes), B.childNodes), G[B.childNodes.length].nodeType; } catch (e) { X = { apply: G.length ? function (e, t) { K.apply(e, Y.call(t)); } : function (e, t) { for (var n = e.length, r = 0; e[n++] = t[r++];);e.length = n - 1; } }; }b = t.support = {}, E = t.isXML = function (e) { const t = e && (e.ownerDocument || e).documentElement; return !!t && t.nodeName !== 'HTML'; }, I = t.setDocument = function (e) { let t; let n; const r = e ? e.ownerDocument || e : B; return r !== P && r.nodeType === 9 && r.documentElement ? (P = r, M = P.documentElement, N = !E(P), B !== P && (n = P.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener('unload', xe, !1) : n.attachEvent && n.attachEvent('onunload', xe)), b.attributes = i(e => e.className = 'i', !e.getAttribute('className')), b.getElementsByTagName = i(e => e.appendChild(P.createComment('')), !e.getElementsByTagName('*').length), b.getElementsByClassName = de.test(P.getElementsByClassName), b.getById = i(e => M.appendChild(e).id = j, !P.getElementsByName || !P.getElementsByName(j).length), b.getById ? (x.filter.ID = function (e) { const t = e.replace(ye, ve); return function (e) { return e.getAttribute('id') === t; }; }, x.find.ID = function (e, t) { if (typeof t.getElementById !== 'undefined' && N) { const n = t.getElementById(e); return n ? [n] : []; } }) : (x.filter.ID = function (e) { const t = e.replace(ye, ve); return function (e) { const n = typeof e.getAttributeNode !== 'undefined' && e.getAttributeNode('id'); return n && n.value === t; }; }, x.find.ID = function (e, t) { if (typeof t.getElementById !== 'undefined' && N) { let n; let r; let i; let o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode('id')) && n.value === e) return [o]; for (i = t.getElementsByName(e), r = 0; o = i[r++];) if ((n = o.getAttributeNode('id')) && n.value === e) return [o]; } return []; } }), x.find.TAG = b.getElementsByTagName ? function (e, t) { return typeof t.getElementsByTagName !== 'undefined' ? t.getElementsByTagName(e) : b.qsa ? t.querySelectorAll(e) : void 0; } : function (e, t) { let n; const r = []; let i = 0; const o = t.getElementsByTagName(e); if (e === '*') { for (;n = o[i++];)n.nodeType === 1 && r.push(n); return r; } return o; }, x.find.CLASS = b.getElementsByClassName && function (e, t) { if (typeof t.getElementsByClassName !== 'undefined' && N) return t.getElementsByClassName(e); }, L = [], D = [], (b.qsa = de.test(P.querySelectorAll)) && (i((e) => { M.appendChild(e).innerHTML = `<a id='${j}'></a><select id='${j}-\r\\' msallowcapture=''><option selected=''></option></select>`, e.querySelectorAll("[msallowcapture^='']").length && D.push(`[*^$]=${ee}*(?:''|"")`), e.querySelectorAll('[selected]').length || D.push(`\\[${ee}*(?:value|${Q})`), e.querySelectorAll(`[id~=${j}-]`).length || D.push('~='), e.querySelectorAll(':checked').length || D.push(':checked'), e.querySelectorAll(`a#${j}+*`).length || D.push('.#.+[+~]'); }), i((e) => { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; const t = P.createElement('input'); t.setAttribute('type', 'hidden'), e.appendChild(t).setAttribute('name', 'D'), e.querySelectorAll('[name=d]').length && D.push(`name${ee}*[*^$|!~]?=`), e.querySelectorAll(':enabled').length !== 2 && D.push(':enabled', ':disabled'), M.appendChild(e).disabled = !0, e.querySelectorAll(':disabled').length !== 2 && D.push(':enabled', ':disabled'), e.querySelectorAll('*,:x'), D.push(',.*:'); })), (b.matchesSelector = de.test(z = M.matches || M.webkitMatchesSelector || M.mozMatchesSelector || M.oMatchesSelector || M.msMatchesSelector)) && i((e) => { b.disconnectedMatch = z.call(e, '*'), z.call(e, "[s!='']:x"), L.push('!=', re); }), D = D.length && new RegExp(D.join('|')), L = L.length && new RegExp(L.join('|')), t = de.test(M.compareDocumentPosition), R = t || de.test(M.contains) ? function (e, t) { const n = e.nodeType === 9 ? e.documentElement : e; const r = t && t.parentNode; return e === r || !(!r || r.nodeType !== 1 || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))); } : function (e, t) { if (t) for (;t = t.parentNode;) if (t === e) return !0; return !1; }, W = t ? function (e, t) { if (e === t) return O = !0, 0; let n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !b.sortDetached && t.compareDocumentPosition(e) === n ? e === P || e.ownerDocument === B && R(B, e) ? -1 : t === P || t.ownerDocument === B && R(B, t) ? 1 : A ? J(A, e) - J(A, t) : 0 : 4 & n ? -1 : 1); } : function (e, t) { if (e === t) return O = !0, 0; let n; let r = 0; const i = e.parentNode; const o = t.parentNode; const s = [e]; const l = [t]; if (!i || !o) return e === P ? -1 : t === P ? 1 : i ? -1 : o ? 1 : A ? J(A, e) - J(A, t) : 0; if (i === o) return a(e, t); for (n = e; n = n.parentNode;)s.unshift(n); for (n = t; n = n.parentNode;)l.unshift(n); for (;s[r] === l[r];)r++; return r ? a(s[r], l[r]) : s[r] === B ? -1 : l[r] === B ? 1 : 0; }, P) : P; }, t.matches = function (e, n) { return t(e, null, null, n); }, t.matchesSelector = function (e, n) { if ((e.ownerDocument || e) !== P && I(e), n = n.replace(le, "='$1']"), b.matchesSelector && N && !H[`${n} `] && (!L || !L.test(n)) && (!D || !D.test(n))) try { const r = z.call(e, n); if (r || b.disconnectedMatch || e.document && e.document.nodeType !== 11) return r; } catch (e) {} return t(n, P, null, [e]).length > 0; }, t.contains = function (e, t) { return (e.ownerDocument || e) !== P && I(e), R(e, t); }, t.attr = function (e, t) { (e.ownerDocument || e) !== P && I(e); const n = x.attrHandle[t.toLowerCase()]; let r = n && $.call(x.attrHandle, t.toLowerCase()) ? n(e, t, !N) : void 0; return void 0 !== r ? r : b.attributes || !N ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null; }, t.escape = function (e) { return (`${e}`).replace(_e, be); }, t.error = function (e) { throw new Error(`Syntax error, unrecognized expression: ${e}`); }, t.uniqueSort = function (e) { let t; const n = []; let r = 0; let i = 0; if (O = !b.detectDuplicates, A = !b.sortStable && e.slice(0), e.sort(W), O) { for (;t = e[i++];)t === e[i] && (r = n.push(i)); for (;r--;)e.splice(n[r], 1); } return A = null, e; }, w = t.getText = function (e) { let t; let n = ''; let r = 0; const i = e.nodeType; if (i) { if (i === 1 || i === 9 || i === 11) { if (typeof e.textContent === 'string') return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += w(e); } else if (i === 3 || i === 4) return e.nodeValue; } else for (;t = e[r++];)n += w(t); return n; }, (x = t.selectors = {
        cacheLength: 50,
        createPseudo: r,
        match: pe,
        attrHandle: {},
        find: {},
        relative: {
          '>': { dir: 'parentNode', first: !0 }, ' ': { dir: 'parentNode' }, '+': { dir: 'previousSibling', first: !0 }, '~': { dir: 'previousSibling' },
        },
        preFilter: { ATTR(e) { return e[1] = e[1].replace(ye, ve), e[3] = (e[3] || e[4] || e[5] || '').replace(ye, ve), e[2] === '~=' && (e[3] = ` ${e[3]} `), e.slice(0, 4); }, CHILD(e) { return e[1] = e[1].toLowerCase(), e[1].slice(0, 3) === 'nth' ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * (e[3] === 'even' || e[3] === 'odd')), e[5] = +(e[7] + e[8] || e[3] === 'odd')) : e[3] && t.error(e[0]), e; }, PSEUDO(e) { let t; const n = !e[6] && e[2]; return pe.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || '' : n && ue.test(n) && (t = T(n, !0)) && (t = n.indexOf(')', n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)); } },
        filter: {
          TAG(e) { const t = e.replace(ye, ve).toLowerCase(); return e === '*' ? function () { return !0; } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t; }; }, CLASS(e) { let t = V[`${e} `]; return t || (t = new RegExp(`(^|${ee})${e}(${ee}|$)`)) && V(e, e => t.test(typeof e.className==='string' && e.className || typeof e.getAttribute !== 'undefined' && e.getAttribute('class') || '')); }, ATTR(e, n, r) { return function (i) { let o = t.attr(i, e); return o == null ? n === '!=' : !n || (o += '', n === '=' ? o === r : n === '!=' ? o !== r : n === '^=' ? r && o.indexOf(r) === 0 : n === '*=' ? r && o.indexOf(r) > -1 : n === '$=' ? r && o.slice(-r.length) === r : n === '~=' ? (` ${o.replace(ie, ' ')} `).indexOf(r) > -1 : n === '|=' && (o === r || o.slice(0, r.length + 1) === `${r}-`)); }; }, CHILD(e, t, n, r, i) { const o = e.slice(0, 3) !== 'nth'; const a = e.slice(-4) !== 'last'; const s = t === 'of-type'; return r === 1 && i === 0 ? function (e) { return !!e.parentNode; } : function (t, n, l) { let u; let c; let p; let f; let h; let d; let m = o !== a ? 'nextSibling' : 'previousSibling'; const g = t.parentNode; const y = s && t.nodeName.toLowerCase(); const v = !l && !s; let _ = !1; if (g) { if (o) { for (;m;) { for (f = t; f = f[m];) if (s ? f.nodeName.toLowerCase() === y : f.nodeType === 1) return !1; d = m = e === 'only' && !d && 'nextSibling'; } return !0; } if (d = [a ? g.firstChild : g.lastChild], a && v) { for (_ = (h = (u = (c = (p = (f = g)[j] || (f[j] = {}))[f.uniqueID] || (p[f.uniqueID] = {}))[e] || [])[0] === F && u[1]) && u[2], f = h && g.childNodes[h]; f = ++h && f && f[m] || (_ = h = 0) || d.pop();) if (f.nodeType === 1 && ++_ && f === t) { c[e] = [F, h, _]; break; } } else if (v && (_ = h = (u = (c = (p = (f = t)[j] || (f[j] = {}))[f.uniqueID] || (p[f.uniqueID] = {}))[e] || [])[0] === F && u[1]), !1 === _) for (;(f = ++h && f && f[m] || (_ = h = 0) || d.pop()) && ((s ? f.nodeName.toLowerCase() !== y : f.nodeType !== 1) || !++_ || (v && ((c = (p = f[j] || (f[j] = {}))[f.uniqueID] || (p[f.uniqueID] = {}))[e] = [F, _]), f !== t)););return (_ -= i) === r || _ % r == 0 && _ / r >= 0; } }; }, PSEUDO(e, n) { let i; const o = x.pseudos[e] || x.setFilters[e.toLowerCase()] || t.error(`unsupported pseudo: ${e}`); return o[j] ? o(n) : o.length > 1 ? (i = [e, e, '', n], x.setFilters.hasOwnProperty(e.toLowerCase()) ? r((e, t) => { for (var r, i = o(e, n), a = i.length; a--;)e[r = J(e, i[a])] = !(t[r] = i[a]); }) : function (e) { return o(e, 0, i); }) : o; },
        },
        pseudos: {
          not: r((e) => { const t = []; const n = []; const i = k(e.replace(oe, '$1')); return i[j] ? r((e, t, n, r) => { for (var o, a = i(e, null, r, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o)); }) : function (e, r, o) { return t[0] = e, i(t, null, o, n), t[0] = null, !n.pop(); }; }), has: r(e => function (n) { return t(e, n).length > 0; }), contains: r(e => e = e.replace(ye, ve), t => (t.textContent || t.innerText || w(t)).indexOf(e) > -1), lang: r(e => ce.test(e || '') || t.error(`unsupported lang: ${e}`), e = e.replace(ye, ve).toLowerCase(), (t) => { let n; do { if (n = N ? t.lang : t.getAttribute('xml:lang') || t.getAttribute('lang')) return (n = n.toLowerCase()) === e || n.indexOf(`${e}-`) === 0; } while ((t = t.parentNode) && t.nodeType === 1);return !1; }), target(t) { const n = e.location && e.location.hash; return n && n.slice(1) === t.id; }, root(e) { return e === M; }, focus(e) { return e === P.activeElement && (!P.hasFocus || P.hasFocus()) && !!(e.type || e.href || ~e.tabIndex); }, enabled: s(!1), disabled: s(!0), checked(e) { const t = e.nodeName.toLowerCase(); return t === 'input' && !!e.checked || t === 'option' && !!e.selected; }, selected(e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected; }, empty(e) { for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1; return !0; }, parent(e) { return !x.pseudos.empty(e); }, header(e) { return he.test(e.nodeName); }, input(e) { return fe.test(e.nodeName); }, button(e) { const t = e.nodeName.toLowerCase(); return t === 'input' && e.type === 'button' || t === 'button'; }, text(e) { let t; return e.nodeName.toLowerCase() === 'input' && e.type === 'text' && ((t = e.getAttribute('type')) == null || t.toLowerCase() === 'text'); }, first: l(() => [0]), last: l((e, t) => [t - 1]), eq: l((e, t, n) => [n < 0 ? n + t : n]), even: l((e, t) => { for (let n = 0; n < t; n += 2)e.push(n); return e; }), odd: l((e, t) => { for (let n = 1; n < t; n += 2)e.push(n); return e; }), lt: l((e, t, n) => { for (let r = n < 0 ? n + t : n; --r >= 0;)e.push(r); return e; }), gt: l((e, t, n) => { for (let r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e; }),
        },
      }).pseudos.nth = x.pseudos.eq; for (_ in {
        radio: !0, checkbox: !0, file: !0, password: !0, image: !0,
      })x.pseudos[_] = (function (e) { return function (t) { return t.nodeName.toLowerCase() === 'input' && t.type === e; }; }(_)); for (_ in { submit: !0, reset: !0 })x.pseudos[_] = (function (e) { return function (t) { const n = t.nodeName.toLowerCase(); return (n === 'input' || n === 'button') && t.type === e; }; }(_)); return c.prototype = x.filters = x.pseudos, x.setFilters = new c(), T = t.tokenize = function (e, n) { let r; let i; let o; let a; let s; let l; let u; const c = q[`${e} `]; if (c) return n ? 0 : c.slice(0); for (s = e, l = [], u = x.preFilter; s;) { r && !(i = ae.exec(s)) || (i && (s = s.slice(i[0].length) || s), l.push(o = [])), r = !1, (i = se.exec(s)) && (r = i.shift(), o.push({ value: r, type: i[0].replace(oe, ' ') }), s = s.slice(r.length)); for (a in x.filter)!(i = pe[a].exec(s)) || u[a] && !(i = u[a](i)) || (r = i.shift(), o.push({ value: r, type: a, matches: i }), s = s.slice(r.length)); if (!r) break; } return n ? s.length : s ? t.error(e) : q(e, l).slice(0); }, k = t.compile = function (e, t) { let n; const r = []; const i = []; let o = H[`${e} `]; if (!o) { for (t || (t = T(e)), n = t.length; n--;)(o = y(t[n]))[j] ? r.push(o) : i.push(o); (o = H(e, v(i, r))).selector = e; } return o; }, C = t.select = function (e, t, n, r) { let i; let o; let a; let s; let l; const c = typeof e === 'function' && e; const f = !r && T(e = c.selector || e); if (n = n || [], f.length === 1) { if ((o = f[0] = f[0].slice(0)).length > 2 && (a = o[0]).type === 'ID' && t.nodeType === 9 && N && x.relative[o[1].type]) { if (!(t = (x.find.ID(a.matches[0].replace(ye, ve), t) || [])[0])) return n; c && (t = t.parentNode), e = e.slice(o.shift().value.length); } for (i = pe.needsContext.test(e) ? 0 : o.length; i-- && (a = o[i], !x.relative[s = a.type]);) if ((l = x.find[s]) && (r = l(a.matches[0].replace(ye, ve), ge.test(o[0].type) && u(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && p(o))) return X.apply(n, r), n; break; } } return (c || k(e, f))(r, t, !N, n, !t || ge.test(e) && u(t.parentNode) || t), n; }, b.sortStable = j.split('').sort(W).join('') === j, b.detectDuplicates = !!O, I(), b.sortDetached = i(e => 1 & e.compareDocumentPosition(P.createElement('fieldset'))), i(e => e.innerHTML = "<a href='#'></a>", e.firstChild.getAttribute('href') === '#') || o('type|href|height|width', (e, t, n) => { if (!n) return e.getAttribute(t, t.toLowerCase() === 'type' ? 1 : 2); }), b.attributes && i(e => e.innerHTML = '<input/>', e.firstChild.setAttribute('value', ''), e.firstChild.getAttribute('value') === '') || o('value', (e, t, n) => { if (!n && e.nodeName.toLowerCase() === 'input') return e.defaultValue; }), i(e => e.getAttribute('disabled') == null) || o(Q, (e, t, n) => { let r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null; }), t;
    }(o)); Ce.find = Ae, Ce.expr = Ae.selectors, Ce.expr[':'] = Ce.expr.pseudos, Ce.uniqueSort = Ce.unique = Ae.uniqueSort, Ce.text = Ae.getText, Ce.isXMLDoc = Ae.isXML, Ce.contains = Ae.contains, Ce.escapeSelector = Ae.escape; const Oe = function (e, t, n) { for (var r = [], i = void 0 !== n; (e = e[t]) && e.nodeType !== 9;) if (e.nodeType === 1) { if (i && Ce(e).is(n)) break; r.push(e); } return r; }; const Ie = function (e, t) { for (var n = []; e; e = e.nextSibling)e.nodeType === 1 && e !== t && n.push(e); return n; }; const Pe = Ce.expr.match.needsContext; const Me = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; Ce.filter = function (e, t, n) { const r = t[0]; return n && (e = `:not(${e})`), t.length === 1 && r.nodeType === 1 ? Ce.find.matchesSelector(r, e) ? [r] : [] : Ce.find.matches(e, Ce.grep(t, e => e.nodeType === 1)); }, Ce.fn.extend({
      find(e) { let t; let n; const r = this.length; const i = this; if (typeof e !== 'string') return this.pushStack(Ce(e).filter(function () { for (t = 0; t < r; t++) if (Ce.contains(i[t], this)) return !0; })); for (n = this.pushStack([]), t = 0; t < r; t++)Ce.find(e, i[t], n); return r > 1 ? Ce.uniqueSort(n) : n; }, filter(e) { return this.pushStack(p(this, e || [], !1)); }, not(e) { return this.pushStack(p(this, e || [], !0)); }, is(e) { return !!p(this, typeof e === 'string' && Pe.test(e) ? Ce(e) : e || [], !1).length; },
    }); let Ne; const De = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (Ce.fn.init = function (e, t, n) { let r; let i; if (!e) return this; if (n = n || Ne, typeof e === 'string') { if (!(r = e[0] === '<' && e[e.length - 1] === '>' && e.length >= 3 ? [null, e, null] : De.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof Ce ? t[0] : t, Ce.merge(this, Ce.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : pe, !0)), Me.test(r[1]) && Ce.isPlainObject(t)) for (r in t)Ee(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this; } return (i = pe.getElementById(r[2])) && (this[0] = i, this.length = 1), this; } return e.nodeType ? (this[0] = e, this.length = 1, this) : Ee(e) ? void 0 !== n.ready ? n.ready(e) : e(Ce) : Ce.makeArray(e, this); }).prototype = Ce.fn, Ne = Ce(pe); const Le = /^(?:parents|prev(?:Until|All))/; const ze = {
      children: !0, contents: !0, next: !0, prev: !0,
    }; Ce.fn.extend({
      has(e) { const t = Ce(e, this); const n = t.length; return this.filter(function () { for (let e = 0; e < n; e++) if (Ce.contains(this, t[e])) return !0; }); }, closest(e, t) { let n; let r = 0; const i = this.length; const o = []; const a = typeof e !== 'string' && Ce(e); if (!Pe.test(e)) for (;r < i; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (a ? a.index(n) > -1 : n.nodeType === 1 && Ce.find.matchesSelector(n, e))) { o.push(n); break; } return this.pushStack(o.length > 1 ? Ce.uniqueSort(o) : o); }, index(e) { return e ? typeof e === 'string' ? ge.call(Ce(e), this[0]) : ge.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1; }, add(e, t) { return this.pushStack(Ce.uniqueSort(Ce.merge(this.get(), Ce(e, t)))); }, addBack(e) { return this.add(e == null ? this.prevObject : this.prevObject.filter(e)); },
    }), Ce.each({
      parent(e) { const t = e.parentNode; return t && t.nodeType !== 11 ? t : null; }, parents(e) { return Oe(e, 'parentNode'); }, parentsUntil(e, t, n) { return Oe(e, 'parentNode', n); }, next(e) { return f(e, 'nextSibling'); }, prev(e) { return f(e, 'previousSibling'); }, nextAll(e) { return Oe(e, 'nextSibling'); }, prevAll(e) { return Oe(e, 'previousSibling'); }, nextUntil(e, t, n) { return Oe(e, 'nextSibling', n); }, prevUntil(e, t, n) { return Oe(e, 'previousSibling', n); }, siblings(e) { return Ie((e.parentNode || {}).firstChild, e); }, children(e) { return Ie(e.firstChild); }, contents(e) { return c(e, 'iframe') ? e.contentDocument : (c(e, 'template') && (e = e.content || e), Ce.merge([], e.childNodes)); },
    }, (e, t) => { Ce.fn[e] = function (n, r) { let i = Ce.map(this, t, n); return e.slice(-5) !== 'Until' && (r = n), r && typeof r === 'string' && (i = Ce.filter(r, i)), this.length > 1 && (ze[e] || Ce.uniqueSort(i), Le.test(e) && i.reverse()), this.pushStack(i); }; }); var Re = /[^\x20\t\r\n\f]+/g; Ce.Callbacks = function (e) {
      e = typeof e === 'string' ? h(e) : Ce.extend({}, e); let t; let n; let r; let i; let o = []; let a = []; let s = -1; const u = function () { for (i = i || e.once, r = t = !0; a.length; s = -1) for (n = a.shift(); ++s < o.length;)!1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1); e.memory || (n = !1), t = !1, i && (o = n ? [] : ''); }; var c = {
        add() { return o && (n && !t && (s = o.length - 1, a.push(n)), (function t(n) { Ce.each(n, (n, r) => { Ee(r) ? e.unique && c.has(r) || o.push(r) : r && r.length && l(r) !== 'string' && t(r); }); }(arguments)), n && !t && u()), this; }, remove() { return Ce.each(arguments, (e, t) => { for (var n; (n = Ce.inArray(t, o, n)) > -1;)o.splice(n, 1), n <= s && s--; }), this; }, has(e) { return e ? Ce.inArray(e, o) > -1 : o.length > 0; }, empty() { return o && (o = []), this; }, disable() { return i = a = [], o = n = '', this; }, disabled() { return !o; }, lock() { return i = a = [], n || t || (o = n = ''), this; }, locked() { return !!i; }, fireWith(e, n) { return i || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || u()), this; }, fire() { return c.fireWith(this, arguments), this; }, fired() { return !!r; },
      }; return c;
    }, Ce.extend({
      Deferred(e) {
        const t = [['notify', 'progress', Ce.Callbacks('memory'), Ce.Callbacks('memory'), 2], ['resolve', 'done', Ce.Callbacks('once memory'), Ce.Callbacks('once memory'), 0, 'resolved'], ['reject', 'fail', Ce.Callbacks('once memory'), Ce.Callbacks('once memory'), 1, 'rejected']]; let n = 'pending'; var r = {
          state() { return n; }, always() { return i.done(arguments).fail(arguments), this; }, catch(e) { return r.then(null, e); }, pipe() { let e = arguments; return Ce.Deferred((n) => { Ce.each(t, (t, r) => { let o = Ee(e[r[4]]) && e[r[4]]; i[r[1]](function () { let e = o && o.apply(this, arguments); e && Ee(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[`${r[0]}With`](this, o ? [e] : arguments); }); }), e = null; }).promise(); }, then(e, n, r) { function i(e, t, n, r) { return function () { let s = this; let l = arguments; const u = function () { let o; let u; if (!(e < a)) { if ((o = n.apply(s, l)) === t.promise()) throw new TypeError('Thenable self-resolution'); u = o && (typeof o == 'object' || typeof o==='function') && o.then, Ee(u) ? r ? u.call(o, i(a, t, d, r), i(a, t, m, r)) : (a++, u.call(o, i(a, t, d, r), i(a, t, m, r), i(a, t, d, t.notifyWith))) : (n !== d && (s = void 0, l = [o]), (r || t.resolveWith)(s, l)); } }; var c = r ? u : function () { try { u(); } catch (r) { Ce.Deferred.exceptionHook && Ce.Deferred.exceptionHook(r, c.stackTrace), e + 1 >= a && (n !== m && (s = void 0, l = [r]), t.rejectWith(s, l)); } }; e ? c() : (Ce.Deferred.getStackHook && (c.stackTrace = Ce.Deferred.getStackHook()), o.setTimeout(c)); }; } var a = 0; return Ce.Deferred((o) => { t[0][3].add(i(0, o, Ee(r) ? r : d, o.notifyWith)), t[1][3].add(i(0, o, Ee(e) ? e : d)), t[2][3].add(i(0, o, Ee(n) ? n : m)); }).promise(); }, promise(e) { return e != null ? Ce.extend(e, r) : r; },
        }; var i = {}; return Ce.each(t, (e, o) => { const a = o[2]; const s = o[5]; r[o[1]] = a.add, s && a.add(() => { n = s; }, t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), a.add(o[3].fire), i[o[0]] = function () { return i[`${o[0]}With`](this === i ? void 0 : this, arguments), this; }, i[`${o[0]}With`] = a.fireWith; }), r.promise(i), e && e.call(i, i), i;
      },
      when(e) { let t = arguments.length; let n = t; const r = Array(n); const i = he.call(arguments); const o = Ce.Deferred(); const a = function (e) { return function (n) { r[e] = this, i[e] = arguments.length > 1 ? he.call(arguments) : n, --t || o.resolveWith(r, i); }; }; if (t <= 1 && (g(e, o.done(a(n)).resolve, o.reject, !t), o.state() === 'pending' || Ee(i[n] && i[n].then))) return o.then(); for (;n--;)g(i[n], a(n), o.reject); return o.promise(); },
    }); const je = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; Ce.Deferred.exceptionHook = function (e, t) { o.console && o.console.warn && e && je.test(e.name) && o.console.warn(`jQuery.Deferred exception: ${e.message}`, e.stack, t); }, Ce.readyException = function (e) { o.setTimeout(() => { throw e; }); }; const Be = Ce.Deferred(); Ce.fn.ready = function (e) { return Be.then(e).catch((e) => { Ce.readyException(e); }), this; }, Ce.extend({ isReady: !1, readyWait: 1, ready(e) { (!0 === e ? --Ce.readyWait : Ce.isReady) || (Ce.isReady = !0, !0 !== e && --Ce.readyWait > 0 || Be.resolveWith(pe, [Ce])); } }), Ce.ready.then = Be.then, pe.readyState === 'complete' || pe.readyState !== 'loading' && !pe.documentElement.doScroll ? o.setTimeout(Ce.ready) : (pe.addEventListener('DOMContentLoaded', y), o.addEventListener('load', y)); var Fe = function (e, t, n, r, i, o, a) { let s = 0; const u = e.length; let c = n == null; if (l(n) === 'object') { i = !0; for (s in n)Fe(e, t, s, n[s], !0, o, a); } else if (void 0 !== r && (i = !0, Ee(r) || (a = !0), c && (a ? (t.call(e, r), t = null) : (c = t, t = function (e, t, n) { return c.call(Ce(e), n); })), t)) for (;s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : c ? t.call(e) : u ? t(e[0], n) : o; }; var Ue = /^-ms-/; var Ve = /-([a-z])/g; const qe = function (e) { return e.nodeType === 1 || e.nodeType === 9 || !+e.nodeType; }; b.uid = 1, b.prototype = {
      cache(e) { let t = e[this.expando]; return t || (t = {}, qe(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t; }, set(e, t, n) { let r; const i = this.cache(e); if (typeof t === 'string')i[_(t)] = n; else for (r in t)i[_(r)] = t[r]; return i; }, get(e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][_(t)]; }, access(e, t, n) { return void 0 === t || t && typeof t === 'string' && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t); }, remove(e, t) { let n; const r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(_) : (t = _(t)) in r ? [t] : t.match(Re) || []).length; for (;n--;) delete r[t[n]]; }(void 0 === t || Ce.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]); } }, hasData(e) { const t = e[this.expando]; return void 0 !== t && !Ce.isEmptyObject(t); },
    }; var He = new b(); var We = new b();


    var $e = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;


    var Ge = /[A-Z]/g; Ce.extend({
      hasData(e) { return We.hasData(e) || He.hasData(e); }, data(e, t, n) { return We.access(e, t, n); }, removeData(e, t) { We.remove(e, t); }, _data(e, t, n) { return He.access(e, t, n); }, _removeData(e, t) { He.remove(e, t); },
    }), Ce.fn.extend({ data(e, t) { let n; let r; let i; const o = this[0]; const a = o && o.attributes; if (void 0 === e) { if (this.length && (i = We.get(o), o.nodeType === 1 && !He.get(o, 'hasDataAttrs'))) { for (n = a.length; n--;)a[n] && (r = a[n].name).indexOf('data-') === 0 && (r = _(r.slice(5)), w(o, r, i[r])); He.set(o, 'hasDataAttrs', !0); } return i; } return typeof e === 'object' ? this.each(function () { We.set(this, e); }) : Fe(this, function (t) { let n; if (o && void 0 === t) { if (void 0 !== (n = We.get(o, e))) return n; if (void 0 !== (n = w(o, e))) return n; } else this.each(function () { We.set(this, e, t); }); }, null, t, arguments.length > 1, null, !0); }, removeData(e) { return this.each(function () { We.remove(this, e); }); } }), Ce.extend({ queue(e, t, n) { let r; if (e) return t = `${t || 'fx'}queue`, r = He.get(e, t), n && (!r || Array.isArray(n) ? r = He.access(e, t, Ce.makeArray(n)) : r.push(n)), r || []; }, dequeue(e, t) { t = t || 'fx'; const n = Ce.queue(e, t); let r = n.length; let i = n.shift(); const o = Ce._queueHooks(e, t); const a = function () { Ce.dequeue(e, t); }; i === 'inprogress' && (i = n.shift(), r--), i && (t === 'fx' && n.unshift('inprogress'), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire(); }, _queueHooks(e, t) { const n = `${t}queueHooks`; return He.get(e, n) || He.access(e, n, { empty: Ce.Callbacks('once memory').add(() => { He.remove(e, [`${t}queue`, n]); }) }); } }), Ce.fn.extend({
      queue(e, t) { let n = 2; return typeof e !== 'string' && (t = e, e = 'fx', n--), arguments.length < n ? Ce.queue(this[0], e) : void 0 === t ? this : this.each(function () { const n = Ce.queue(this, e, t); Ce._queueHooks(this, e), e === 'fx' && n[0] !== 'inprogress' && Ce.dequeue(this, e); }); }, dequeue(e) { return this.each(function () { Ce.dequeue(this, e); }); }, clearQueue(e) { return this.queue(e || 'fx', []); }, promise(e, t) { let n; let r = 1; const i = Ce.Deferred(); const o = this; let a = this.length; const s = function () { --r || i.resolveWith(o, [o]); }; for (typeof e !== 'string' && (t = e, e = void 0), e = e || 'fx'; a--;)(n = He.get(o[a], `${e}queueHooks`)) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t); },
    }); const Ze = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source; var Ke = new RegExp(`^(?:([+-])=|)(${Ze})([a-z%]*)$`, 'i'); var Xe = ['Top', 'Right', 'Bottom', 'Left']; var Ye = function (e, t) { return (e = t || e).style.display === 'none' || e.style.display === '' && Ce.contains(e.ownerDocument, e) && Ce.css(e, 'display') === 'none'; }; const Je = function (e, t, n, r) { let i; let o; const a = {}; for (o in t)a[o] = e.style[o], e.style[o] = t[o]; i = n.apply(e, r || []); for (o in t)e.style[o] = a[o]; return i; }; var Qe = {}; Ce.fn.extend({ show() { return k(this, !0); }, hide() { return k(this); }, toggle(e) { return typeof e === 'boolean' ? e ? this.show() : this.hide() : this.each(function () { Ye(this) ? Ce(this).show() : Ce(this).hide(); }); } }); var et = /^(?:checkbox|radio)$/i; var tt = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i; var nt = /^$|^module$|\/(?:java|ecma)script/i; var rt = {
      option: [1, "<select multiple='multiple'>", '</select>'], thead: [1, '<table>', '</table>'], col: [2, '<table><colgroup>', '</colgroup></table>'], tr: [2, '<table><tbody>', '</tbody></table>'], td: [3, '<table><tbody><tr>', '</tr></tbody></table>'], _default: [0, '', ''],
    }; rt.optgroup = rt.option, rt.tbody = rt.tfoot = rt.colgroup = rt.caption = rt.thead, rt.th = rt.td; var it = /<|&#?\w+;/; !(function () { const e = pe.createDocumentFragment().appendChild(pe.createElement('div')); const t = pe.createElement('input'); t.setAttribute('type', 'radio'), t.setAttribute('checked', 'checked'), t.setAttribute('name', 't'), e.appendChild(t), we.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = '<textarea>x</textarea>', we.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue; }()); const ot = pe.documentElement; const at = /^key/; const st = /^(?:mouse|pointer|contextmenu|drag|drop)|click/; const lt = /^([^.]*)(?:\.(.+)|)/; Ce.event = {
      global: {},
      add(e, t, n, r, i) {
        let o; let a; let s; let l; let u; let c; let p; let f; let h; let d; let m; const g = He.get(e); if (g) {
          for (n.handler && (n = (o = n).handler, i = o.selector), i && Ce.find.matchesSelector(ot, i), n.guid || (n.guid = Ce.guid++), (l = g.events) || (l = g.events = {}), (a = g.handle) || (a = g.handle = function (t) { return typeof Ce !== 'undefined' && Ce.event.triggered !== t.type ? Ce.event.dispatch.apply(e, arguments) : void 0; }), u = (t = (t || '').match(Re) || ['']).length; u--;) {
            h = m = (s = lt.exec(t[u]) || [])[1], d = (s[2] || '').split('.').sort(), h && (p = Ce.event.special[h] || {}, h = (i ? p.delegateType : p.bindType) || h, p = Ce.event.special[h] || {}, c = Ce.extend({
              type: h, origType: m, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && Ce.expr.match.needsContext.test(i), namespace: d.join('.'),
            }, o), (f = l[h]) || ((f = l[h] = []).delegateCount = 0, p.setup && !1 !== p.setup.call(e, r, d, a) || e.addEventListener && e.addEventListener(h, a)), p.add && (p.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? f.splice(f.delegateCount++, 0, c) : f.push(c), Ce.event.global[h] = !0);
          }
        }
      },
      remove(e, t, n, r, i) { let o; let a; let s; let l; let u; let c; let p; let f; let h; let d; let m; const g = He.hasData(e) && He.get(e); if (g && (l = g.events)) { for (u = (t = (t || '').match(Re) || ['']).length; u--;) if (s = lt.exec(t[u]) || [], h = m = s[1], d = (s[2] || '').split('.').sort(), h) { for (p = Ce.event.special[h] || {}, f = l[h = (r ? p.delegateType : p.bindType) || h] || [], s = s[2] && new RegExp(`(^|\\.)${d.join('\\.(?:.*\\.|)')}(\\.|$)`), a = o = f.length; o--;)c = f[o], !i && m !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && (r !== '**' || !c.selector) || (f.splice(o, 1), c.selector && f.delegateCount--, p.remove && p.remove.call(e, c)); a && !f.length && (p.teardown && !1 !== p.teardown.call(e, d, g.handle) || Ce.removeEvent(e, h, g.handle), delete l[h]); } else for (h in l)Ce.event.remove(e, h + t[u], n, r, !0); Ce.isEmptyObject(l) && He.remove(e, 'handle events'); } },
      dispatch(e) { let t; let n; let r; let i; let o; let a; const s = Ce.event.fix(e); const l = new Array(arguments.length); const u = (He.get(this, 'events') || {})[s.type] || []; const c = Ce.event.special[s.type] || {}; for (l[0] = s, t = 1; t < arguments.length; t++)l[t] = arguments[t]; if (s.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, s)) { for (a = Ce.event.handlers.call(this, s, u), t = 0; (i = a[t++]) && !s.isPropagationStopped();) for (s.currentTarget = i.elem, n = 0; (o = i.handlers[n++]) && !s.isImmediatePropagationStopped();)s.rnamespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (r = ((Ce.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, l)) && !1 === (s.result = r) && (s.preventDefault(), s.stopPropagation())); return c.postDispatch && c.postDispatch.call(this, s), s.result; } },
      handlers(e, t) { let n; let r; let i; let o; let a; const s = []; const l = t.delegateCount; let u = e.target; if (l && u.nodeType && !(e.type === 'click' && e.button >= 1)) for (;u !== this; u = u.parentNode || this) if (u.nodeType === 1 && (e.type !== 'click' || !0 !== u.disabled)) { for (o = [], a = {}, n = 0; n < l; n++) void 0 === a[i = `${(r = t[n]).selector} `] && (a[i] = r.needsContext ? Ce(i, this).index(u) > -1 : Ce.find(i, this, null, [u]).length), a[i] && o.push(r); o.length && s.push({ elem: u, handlers: o }); } return u = this, l < t.length && s.push({ elem: u, handlers: t.slice(l) }), s; },
      addProp(e, t) {
        Object.defineProperty(Ce.Event.prototype, e, {
          enumerable: !0,
          configurable: !0,
          get: Ee(t) ? function () { if (this.originalEvent) return t(this.originalEvent); } : function () { if (this.originalEvent) return this.originalEvent[e]; },
          set(t) {
            Object.defineProperty(this, e, {
              enumerable: !0, configurable: !0, writable: !0, value: t,
            });
          },
        });
      },
      fix(e) { return e[Ce.expando] ? e : new Ce.Event(e); },
      special: {
        load: { noBubble: !0 }, focus: { trigger() { if (this !== P() && this.focus) return this.focus(), !1; }, delegateType: 'focusin' }, blur: { trigger() { if (this === P() && this.blur) return this.blur(), !1; }, delegateType: 'focusout' }, click: { trigger() { if (this.type === 'checkbox' && this.click && c(this, 'input')) return this.click(), !1; }, _default(e) { return c(e.target, 'a'); } }, beforeunload: { postDispatch(e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result); } },
      },
    }, Ce.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n); }, Ce.Event = function (e, t) { if (!(this instanceof Ce.Event)) return new Ce.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? O : I, this.target = e.target && e.target.nodeType === 3 ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && Ce.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[Ce.expando] = !0; }, Ce.Event.prototype = {
      constructor: Ce.Event, isDefaultPrevented: I, isPropagationStopped: I, isImmediatePropagationStopped: I, isSimulated: !1, preventDefault() { const e = this.originalEvent; this.isDefaultPrevented = O, e && !this.isSimulated && e.preventDefault(); }, stopPropagation() { const e = this.originalEvent; this.isPropagationStopped = O, e && !this.isSimulated && e.stopPropagation(); }, stopImmediatePropagation() { const e = this.originalEvent; this.isImmediatePropagationStopped = O, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation(); },
    }, Ce.each({
      altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which(e) { const t = e.button; return e.which == null && at.test(e.type) ? e.charCode != null ? e.charCode : e.keyCode : !e.which && void 0 !== t && st.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which; },
    }, Ce.event.addProp), Ce.each({
      mouseenter: 'mouseover', mouseleave: 'mouseout', pointerenter: 'pointerover', pointerleave: 'pointerout',
    }, (e, t) => { Ce.event.special[e] = { delegateType: t, bindType: t, handle(e) { let n; const r = this; const i = e.relatedTarget; const o = e.handleObj; return i && (i === r || Ce.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n; } }; }), Ce.fn.extend({ on(e, t, n, r) { return M(this, e, t, n, r); }, one(e, t, n, r) { return M(this, e, t, n, r, 1); }, off(e, t, n) { let r; let i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, Ce(e.delegateTarget).off(r.namespace ? `${r.origType}.${r.namespace}` : r.origType, r.selector, r.handler), this; if (typeof e === 'object') { for (i in e) this.off(i, t, e[i]); return this; } return !1 !== t && typeof t !== 'function' || (n = t, t = void 0), !1 === n && (n = I), this.each(function () { Ce.event.remove(this, e, n, t); }); } }); const ut = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi; const ct = /<script|<style|<link/i; var pt = /checked\s*(?:[^=]|=\s*.checked.)/i; var ft = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; Ce.extend({ htmlPrefilter(e) { return e.replace(ut, '<$1></$2>'); }, clone(e, t, n) { let r; let i; let o; let a; const s = e.cloneNode(!0); const l = Ce.contains(e.ownerDocument, e); if (!(we.noCloneChecked || e.nodeType !== 1 && e.nodeType !== 11 || Ce.isXMLDoc(e))) for (a = C(s), r = 0, i = (o = C(e)).length; r < i; r++)R(o[r], a[r]); if (t) if (n) for (o = o || C(e), a = a || C(s), r = 0, i = o.length; r < i; r++)z(o[r], a[r]); else z(e, s); return (a = C(s, 'script')).length > 0 && S(a, !l && C(e, 'script')), s; }, cleanData(e) { for (var t, n, r, i = Ce.event.special, o = 0; void 0 !== (n = e[o]); o++) if (qe(n)) { if (t = n[He.expando]) { if (t.events) for (r in t.events)i[r] ? Ce.event.remove(n, r) : Ce.removeEvent(n, r, t.handle); n[He.expando] = void 0; }n[We.expando] && (n[We.expando] = void 0); } } }), Ce.fn.extend({
      detach(e) { return B(this, e, !0); }, remove(e) { return B(this, e); }, text(e) { return Fe(this, function (e) { return void 0 === e ? Ce.text(this) : this.empty().each(function () { this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || (this.textContent = e); }); }, null, e, arguments.length); }, append() { return j(this, arguments, function (e) { this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || N(this, e).appendChild(e); }); }, prepend() { return j(this, arguments, function (e) { if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) { const t = N(this, e); t.insertBefore(e, t.firstChild); } }); }, before() { return j(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this); }); }, after() { return j(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling); }); }, empty() { for (var e, t = 0; (e = this[t]) != null; t++)e.nodeType === 1 && (Ce.cleanData(C(e, !1)), e.textContent = ''); return this; }, clone(e, t) { return e = e != null && e, t = t == null ? e : t, this.map(function () { return Ce.clone(this, e, t); }); }, html(e) { return Fe(this, function (e) { let t = this[0] || {}; let n = 0; const r = this.length; if (void 0 === e && t.nodeType === 1) return t.innerHTML; if (typeof e === 'string' && !ct.test(e) && !rt[(tt.exec(e) || ['', ''])[1].toLowerCase()]) { e = Ce.htmlPrefilter(e); try { for (;n < r; n++)(t = this[n] || {}).nodeType === 1 && (Ce.cleanData(C(t, !1)), t.innerHTML = e); t = 0; } catch (e) {} }t && this.empty().append(e); }, null, e, arguments.length); }, replaceWith() { const e = []; return j(this, arguments, function (t) { const n = this.parentNode; Ce.inArray(this, e) < 0 && (Ce.cleanData(C(this)), n && n.replaceChild(t, this)); }, e); },
    }), Ce.each({
      appendTo: 'append', prependTo: 'prepend', insertBefore: 'before', insertAfter: 'after', replaceAll: 'replaceWith',
    }, (e, t) => { Ce.fn[e] = function (e) { for (var n, r = [], i = Ce(e), o = i.length - 1, a = 0; a <= o; a++)n = a === o ? this : this.clone(!0), Ce(i[a])[t](n), me.apply(r, n.get()); return this.pushStack(r); }; }); var ht = new RegExp(`^(${Ze})(?!px)[a-z%]+$`, 'i'); var dt = function (e) { let t = e.ownerDocument.defaultView; return t && t.opener || (t = o), t.getComputedStyle(e); }; var mt = new RegExp(Xe.join('|'), 'i'); !(function () {
      function e() { if (u) { l.style.cssText = 'position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0', u.style.cssText = 'position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%', ot.appendChild(l).appendChild(u); const e = o.getComputedStyle(u); n = e.top !== '1%', s = t(e.marginLeft) === 12, u.style.right = '60%', a = t(e.right) === 36, r = t(e.width) === 36, u.style.position = 'absolute', i = u.offsetWidth === 36 || 'absolute', ot.removeChild(l), u = null; } } function t(e) { return Math.round(parseFloat(e)); } let n; let r; let i; let a; let s; var l = pe.createElement('div'); var u = pe.createElement('div'); u.style && (u.style.backgroundClip = 'content-box', u.cloneNode(!0).style.backgroundClip = '', we.clearCloneStyle = u.style.backgroundClip === 'content-box', Ce.extend(we, {
        boxSizingReliable() { return e(), r; }, pixelBoxStyles() { return e(), a; }, pixelPosition() { return e(), n; }, reliableMarginLeft() { return e(), s; }, scrollboxSize() { return e(), i; },
      }));
    }()); const gt = /^(none|table(?!-c[ea]).+)/; const yt = /^--/; const vt = { position: 'absolute', visibility: 'hidden', display: 'block' }; const _t = { letterSpacing: '0', fontWeight: '400' }; var bt = ['Webkit', 'Moz', 'ms']; var xt = pe.createElement('div').style; Ce.extend({
      cssHooks: { opacity: { get(e, t) { if (t) { const n = F(e, 'opacity'); return n === '' ? '1' : n; } } } },
      cssNumber: {
        animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0,
      },
      cssProps: {},
      style(e, t, n, r) { if (e && e.nodeType !== 3 && e.nodeType !== 8 && e.style) { let i; let o; let a; const s = _(t); const l = yt.test(t); const u = e.style; if (l || (t = q(s)), a = Ce.cssHooks[t] || Ce.cssHooks[s], void 0 === n) return a && 'get' in a && void 0 !== (i = a.get(e, !1, r)) ? i : u[t]; (o = typeof n) == 'string' && (i = Ke.exec(n)) && i[1] && (n = E(e, t, i), o = 'number'), n != null && n === n && (o === 'number' && (n += i && i[3] || (Ce.cssNumber[s] ? '' : 'px')), we.clearCloneStyle || n !== '' || t.indexOf('background') !== 0 || (u[t] = 'inherit'), a && 'set' in a && void 0 === (n = a.set(e, n, r)) || (l ? u.setProperty(t, n) : u[t] = n)); } },
      css(e, t, n, r) { let i; let o; let a; const s = _(t); return yt.test(t) || (t = q(s)), (a = Ce.cssHooks[t] || Ce.cssHooks[s]) && 'get' in a && (i = a.get(e, !0, n)), void 0 === i && (i = F(e, t, r)), i === 'normal' && t in _t && (i = _t[t]), n === '' || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i; },
    }), Ce.each(['height', 'width'], (e, t) => { Ce.cssHooks[t] = { get(e, n, r) { if (n) return !gt.test(Ce.css(e, 'display')) || e.getClientRects().length && e.getBoundingClientRect().width ? $(e, t, r) : Je(e, vt, () => $(e, t, r)); }, set(e, n, r) { let i; const o = dt(e); const a = Ce.css(e, 'boxSizing', !1, o) === 'border-box'; let s = r && W(e, t, r, a, o); return a && we.scrollboxSize() === o.position && (s -= Math.ceil(e[`offset${t[0].toUpperCase()}${t.slice(1)}`] - parseFloat(o[t]) - W(e, t, 'border', !1, o) - 0.5)), s && (i = Ke.exec(n)) && (i[3] || 'px') !== 'px' && (e.style[t] = n, n = Ce.css(e, t)), H(e, n, s); } }; }), Ce.cssHooks.marginLeft = U(we.reliableMarginLeft, (e, t) => { if (t) return `${parseFloat(F(e, 'marginLeft')) || e.getBoundingClientRect().left - Je(e, { marginLeft: 0 }, () => e.getBoundingClientRect().left)}px`; }), Ce.each({ margin: '', padding: '', border: 'Width' }, (e, t) => { Ce.cssHooks[e + t] = { expand(n) { for (var r = 0, i = {}, o = typeof n === 'string' ? n.split(' ') : [n]; r < 4; r++)i[e + Xe[r] + t] = o[r] || o[r - 2] || o[0]; return i; } }, e !== 'margin' && (Ce.cssHooks[e + t].set = H); }), Ce.fn.extend({ css(e, t) { return Fe(this, (e, t, n) => { let r; let i; const o = {}; let a = 0; if (Array.isArray(t)) { for (r = dt(e), i = t.length; a < i; a++)o[t[a]] = Ce.css(e, t[a], !1, r); return o; } return void 0 !== n ? Ce.style(e, t, n) : Ce.css(e, t); }, e, t, arguments.length > 1); } }), Ce.Tween = G, G.prototype = {
      constructor: G, init(e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || Ce.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (Ce.cssNumber[n] ? '' : 'px'); }, cur() { const e = G.propHooks[this.prop]; return e && e.get ? e.get(this) : G.propHooks._default.get(this); }, run(e) { let t; const n = G.propHooks[this.prop]; return this.options.duration ? this.pos = t = Ce.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : G.propHooks._default.set(this), this; },
    }, G.prototype.init.prototype = G.prototype, G.propHooks = { _default: { get(e) { let t; return e.elem.nodeType !== 1 || e.elem[e.prop] != null && e.elem.style[e.prop] == null ? e.elem[e.prop] : (t = Ce.css(e.elem, e.prop, '')) && t !== 'auto' ? t : 0; }, set(e) { Ce.fx.step[e.prop] ? Ce.fx.step[e.prop](e) : e.elem.nodeType !== 1 || e.elem.style[Ce.cssProps[e.prop]] == null && !Ce.cssHooks[e.prop] ? e.elem[e.prop] = e.now : Ce.style(e.elem, e.prop, e.now + e.unit); } } }, G.propHooks.scrollTop = G.propHooks.scrollLeft = { set(e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now); } }, Ce.easing = { linear(e) { return e; }, swing(e) { return 0.5 - Math.cos(e * Math.PI) / 2; }, _default: 'swing' }, Ce.fx = G.prototype.init, Ce.fx.step = {}; let wt; let Et; var Tt = /^(?:toggle|show|hide)$/; const kt = /queueHooks$/; Ce.Animation = Ce.extend(ee, {
      tweeners: { '*': [function (e, t) { const n = this.createTween(e, t); return E(n.elem, e, Ke.exec(t), n), n; }] }, tweener(e, t) { Ee(e) ? (t = e, e = ['*']) : e = e.match(Re); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], ee.tweeners[n] = ee.tweeners[n] || [], ee.tweeners[n].unshift(t); }, prefilters: [J], prefilter(e, t) { t ? ee.prefilters.unshift(e) : ee.prefilters.push(e); },
    }), Ce.speed = function (e, t, n) { const r = e && typeof e === 'object' ? Ce.extend({}, e) : { complete: n || !n && t || Ee(e) && e, duration: e, easing: n && t || t && !Ee(t) && t }; return Ce.fx.off ? r.duration = 0 : typeof r.duration !== 'number' && (r.duration in Ce.fx.speeds ? r.duration = Ce.fx.speeds[r.duration] : r.duration = Ce.fx.speeds._default), r.queue != null && !0 !== r.queue || (r.queue = 'fx'), r.old = r.complete, r.complete = function () { Ee(r.old) && r.old.call(this), r.queue && Ce.dequeue(this, r.queue); }, r; }, Ce.fn.extend({
      fadeTo(e, t, n, r) {
        return this.filter(Ye).css('opacity', 0).show().end()
          .animate({ opacity: t }, e, n, r);
      },
      animate(e, t, n, r) { const i = Ce.isEmptyObject(e); const o = Ce.speed(t, n, r); const a = function () { const t = ee(this, Ce.extend({}, e), o); (i || He.get(this, 'finish')) && t.stop(!0); }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a); },
      stop(e, t, n) { const r = function (e) { const t = e.stop; delete e.stop, t(n); }; return typeof e !== 'string' && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || 'fx', []), this.each(function () { let t = !0; let i = e != null && `${e}queueHooks`; const o = Ce.timers; const a = He.get(this); if (i)a[i] && a[i].stop && r(a[i]); else for (i in a)a[i] && a[i].stop && kt.test(i) && r(a[i]); for (i = o.length; i--;)o[i].elem !== this || e != null && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1)); !t && n || Ce.dequeue(this, e); }); },
      finish(e) { return !1 !== e && (e = e || 'fx'), this.each(function () { let t; const n = He.get(this); const r = n[`${e}queue`]; const i = n[`${e}queueHooks`]; const o = Ce.timers; const a = r ? r.length : 0; for (n.finish = !0, Ce.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;)o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; t < a; t++)r[t] && r[t].finish && r[t].finish.call(this); delete n.finish; }); },
    }), Ce.each(['toggle', 'show', 'hide'], (e, t) => { const n = Ce.fn[t]; Ce.fn[t] = function (e, r, i) { return e == null || typeof e === 'boolean' ? n.apply(this, arguments) : this.animate(X(t, !0), e, r, i); }; }), Ce.each({
      slideDown: X('show'), slideUp: X('hide'), slideToggle: X('toggle'), fadeIn: { opacity: 'show' }, fadeOut: { opacity: 'hide' }, fadeToggle: { opacity: 'toggle' },
    }, (e, t) => { Ce.fn[e] = function (e, n, r) { return this.animate(t, e, n, r); }; }), Ce.timers = [], Ce.fx.tick = function () { let e; let t = 0; const n = Ce.timers; for (wt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || Ce.fx.stop(), wt = void 0; }, Ce.fx.timer = function (e) { Ce.timers.push(e), Ce.fx.start(); }, Ce.fx.interval = 13, Ce.fx.start = function () { Et || (Et = !0, Z()); }, Ce.fx.stop = function () { Et = null; }, Ce.fx.speeds = { slow: 600, fast: 200, _default: 400 }, Ce.fn.delay = function (e, t) { return e = Ce.fx ? Ce.fx.speeds[e] || e : e, t = t || 'fx', this.queue(t, (t, n) => { const r = o.setTimeout(t, e); n.stop = function () { o.clearTimeout(r); }; }); }, (function () { let e = pe.createElement('input'); const t = pe.createElement('select').appendChild(pe.createElement('option')); e.type = 'checkbox', we.checkOn = e.value !== '', we.optSelected = t.selected, (e = pe.createElement('input')).value = 't', e.type = 'radio', we.radioValue = e.value === 't'; }()); let Ct; const St = Ce.expr.attrHandle; Ce.fn.extend({ attr(e, t) { return Fe(this, Ce.attr, e, t, arguments.length > 1); }, removeAttr(e) { return this.each(function () { Ce.removeAttr(this, e); }); } }), Ce.extend({ attr(e, t, n) { let r; let i; const o = e.nodeType; if (o !== 3 && o !== 8 && o !== 2) return typeof e.getAttribute === 'undefined' ? Ce.prop(e, t, n) : (o === 1 && Ce.isXMLDoc(e) || (i = Ce.attrHooks[t.toLowerCase()] || (Ce.expr.match.bool.test(t) ? Ct : void 0)), void 0 !== n ? n === null ? void Ce.removeAttr(e, t) : i && 'set' in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, `${n}`), n) : i && 'get' in i && (r = i.get(e, t)) !== null ? r : (r = Ce.find.attr(e, t)) == null ? void 0 : r); }, attrHooks: { type: { set(e, t) { if (!we.radioValue && t === 'radio' && c(e, 'input')) { const n = e.value; return e.setAttribute('type', t), n && (e.value = n), t; } } } }, removeAttr(e, t) { let n; let r = 0; const i = t && t.match(Re); if (i && e.nodeType === 1) for (;n = i[r++];)e.removeAttribute(n); } }), Ct = { set(e, t, n) { return !1 === t ? Ce.removeAttr(e, n) : e.setAttribute(n, n), n; } }, Ce.each(Ce.expr.match.bool.source.match(/\w+/g), (e, t) => { const n = St[t] || Ce.find.attr; St[t] = function (e, t, r) { let i; let o; const a = t.toLowerCase(); return r || (o = St[a], St[a] = i, i = n(e, t, r) != null ? a : null, St[a] = o), i; }; }); const At = /^(?:input|select|textarea|button)$/i; const Ot = /^(?:a|area)$/i; Ce.fn.extend({ prop(e, t) { return Fe(this, Ce.prop, e, t, arguments.length > 1); }, removeProp(e) { return this.each(function () { delete this[Ce.propFix[e] || e]; }); } }), Ce.extend({ prop(e, t, n) { let r; let i; const o = e.nodeType; if (o !== 3 && o !== 8 && o !== 2) return o === 1 && Ce.isXMLDoc(e) || (t = Ce.propFix[t] || t, i = Ce.propHooks[t]), void 0 !== n ? i && 'set' in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && 'get' in i && (r = i.get(e, t)) !== null ? r : e[t]; }, propHooks: { tabIndex: { get(e) { const t = Ce.find.attr(e, 'tabindex'); return t ? parseInt(t, 10) : At.test(e.nodeName) || Ot.test(e.nodeName) && e.href ? 0 : -1; } } }, propFix: { for: 'htmlFor', class: 'className' } }), we.optSelected || (Ce.propHooks.selected = { get(e) { const t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null; }, set(e) { const t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex); } }), Ce.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () { Ce.propFix[this.toLowerCase()] = this; }), Ce.fn.extend({
      addClass(e) { let t; let n; let r; let i; let o; let a; let s; let l = 0; if (Ee(e)) return this.each(function (t) { Ce(this).addClass(e.call(this, t, ne(this))); }); if ((t = re(e)).length) for (;n = this[l++];) if (i = ne(n), r = n.nodeType === 1 && ` ${te(i)} `) { for (a = 0; o = t[a++];)r.indexOf(` ${o} `) < 0 && (r += `${o} `); i !== (s = te(r)) && n.setAttribute('class', s); } return this; }, removeClass(e) { let t; let n; let r; let i; let o; let a; let s; let l = 0; if (Ee(e)) return this.each(function (t) { Ce(this).removeClass(e.call(this, t, ne(this))); }); if (!arguments.length) return this.attr('class', ''); if ((t = re(e)).length) for (;n = this[l++];) if (i = ne(n), r = n.nodeType === 1 && ` ${te(i)} `) { for (a = 0; o = t[a++];) for (;r.indexOf(` ${o} `) > -1;)r = r.replace(` ${o} `, ' '); i !== (s = te(r)) && n.setAttribute('class', s); } return this; }, toggleClass(e, t) { const n = typeof e; const r = n === 'string' || Array.isArray(e); return typeof t === 'boolean' && r ? t ? this.addClass(e) : this.removeClass(e) : Ee(e) ? this.each(function (n) { Ce(this).toggleClass(e.call(this, n, ne(this), t), t); }) : this.each(function () { let t; let i; let o; let a; if (r) for (i = 0, o = Ce(this), a = re(e); t = a[i++];)o.hasClass(t) ? o.removeClass(t) : o.addClass(t); else void 0 !== e && n !== 'boolean' || ((t = ne(this)) && He.set(this, '__className__', t), this.setAttribute && this.setAttribute('class', t || !1 === e ? '' : He.get(this, '__className__') || '')); }); }, hasClass(e) { let t; let n; let r = 0; for (t = ` ${e} `; n = this[r++];) if (n.nodeType === 1 && (` ${te(ne(n))} `).indexOf(t) > -1) return !0; return !1; },
    }); const It = /\r/g; Ce.fn.extend({ val(e) { let t; let n; let r; const i = this[0]; return arguments.length ? (r = Ee(e), this.each(function (n) { let i; this.nodeType === 1 && ((i = r ? e.call(this, n, Ce(this).val()) : e) == null ? i = '' : typeof i === 'number' ? i += '' : Array.isArray(i) && (i = Ce.map(i, e => (e == null ? '' : `${e}`))), (t = Ce.valHooks[this.type] || Ce.valHooks[this.nodeName.toLowerCase()]) && 'set' in t && void 0 !== t.set(this, i, 'value') || (this.value = i)); })) : i ? (t = Ce.valHooks[i.type] || Ce.valHooks[i.nodeName.toLowerCase()]) && 'get' in t && void 0 !== (n = t.get(i, 'value')) ? n : typeof (n = i.value) === 'string' ? n.replace(It, '') : n == null ? '' : n : void 0; } }), Ce.extend({ valHooks: { option: { get(e) { const t = Ce.find.attr(e, 'value'); return t != null ? t : te(Ce.text(e)); } }, select: { get(e) { let t; let n; let r; const i = e.options; const o = e.selectedIndex; const a = e.type === 'select-one'; const s = a ? null : []; const l = a ? o + 1 : i.length; for (r = o < 0 ? l : a ? o : 0; r < l; r++) if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !c(n.parentNode, 'optgroup'))) { if (t = Ce(n).val(), a) return t; s.push(t); } return s; }, set(e, t) { for (var n, r, i = e.options, o = Ce.makeArray(t), a = i.length; a--;)((r = i[a]).selected = Ce.inArray(Ce.valHooks.option.get(r), o) > -1) && (n = !0); return n || (e.selectedIndex = -1), o; } } } }), Ce.each(['radio', 'checkbox'], function () { Ce.valHooks[this] = { set(e, t) { if (Array.isArray(t)) return e.checked = Ce.inArray(Ce(e).val(), t) > -1; } }, we.checkOn || (Ce.valHooks[this].get = function (e) { return e.getAttribute('value') === null ? 'on' : e.value; }); }), we.focusin = 'onfocusin' in o; const Pt = /^(?:focusinfocus|focusoutblur)$/; const Mt = function (e) { e.stopPropagation(); }; Ce.extend(Ce.event, { trigger(e, t, n, r) { let i; let a; let s; let l; let u; let c; let p; let f; const h = [n || pe]; let d = _e.call(e, 'type') ? e.type : e; let m = _e.call(e, 'namespace') ? e.namespace.split('.') : []; if (a = f = s = n = n || pe, n.nodeType !== 3 && n.nodeType !== 8 && !Pt.test(d + Ce.event.triggered) && (d.indexOf('.') > -1 && (d = (m = d.split('.')).shift(), m.sort()), u = d.indexOf(':') < 0 && `on${d}`, e = e[Ce.expando] ? e : new Ce.Event(d, typeof e === 'object' && e), e.isTrigger = r ? 2 : 3, e.namespace = m.join('.'), e.rnamespace = e.namespace ? new RegExp(`(^|\\.)${m.join('\\.(?:.*\\.|)')}(\\.|$)`) : null, e.result = void 0, e.target || (e.target = n), t = t == null ? [e] : Ce.makeArray(t, [e]), p = Ce.event.special[d] || {}, r || !p.trigger || !1 !== p.trigger.apply(n, t))) { if (!r && !p.noBubble && !Te(n)) { for (l = p.delegateType || d, Pt.test(l + d) || (a = a.parentNode); a; a = a.parentNode)h.push(a), s = a; s === (n.ownerDocument || pe) && h.push(s.defaultView || s.parentWindow || o); } for (i = 0; (a = h[i++]) && !e.isPropagationStopped();)f = a, e.type = i > 1 ? l : p.bindType || d, (c = (He.get(a, 'events') || {})[e.type] && He.get(a, 'handle')) && c.apply(a, t), (c = u && a[u]) && c.apply && qe(a) && (e.result = c.apply(a, t), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || p._default && !1 !== p._default.apply(h.pop(), t) || !qe(n) || u && Ee(n[d]) && !Te(n) && ((s = n[u]) && (n[u] = null), Ce.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, Mt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, Mt), Ce.event.triggered = void 0, s && (n[u] = s)), e.result; } }, simulate(e, t, n) { const r = Ce.extend(new Ce.Event(), n, { type: e, isSimulated: !0 }); Ce.event.trigger(r, null, t); } }), Ce.fn.extend({ trigger(e, t) { return this.each(function () { Ce.event.trigger(e, t, this); }); }, triggerHandler(e, t) { const n = this[0]; if (n) return Ce.event.trigger(e, t, n, !0); } }), we.focusin || Ce.each({ focus: 'focusin', blur: 'focusout' }, (e, t) => { const n = function (e) { Ce.event.simulate(t, e.target, Ce.event.fix(e)); }; Ce.event.special[t] = { setup() { const r = this.ownerDocument || this; const i = He.access(r, t); i || r.addEventListener(e, n, !0), He.access(r, t, (i || 0) + 1); }, teardown() { const r = this.ownerDocument || this; const i = He.access(r, t) - 1; i ? He.access(r, t, i) : (r.removeEventListener(e, n, !0), He.remove(r, t)); } }; }); const Nt = o.location; let Dt = Date.now(); const Lt = /\?/; Ce.parseXML = function (e) { let t; if (!e || typeof e !== 'string') return null; try { t = (new o.DOMParser()).parseFromString(e, 'text/xml'); } catch (e) { t = void 0; } return t && !t.getElementsByTagName('parsererror').length || Ce.error(`Invalid XML: ${e}`), t; }; var zt = /\[\]$/; const Rt = /\r?\n/g; const jt = /^(?:submit|button|image|reset|file)$/i; const Bt = /^(?:input|select|textarea|keygen)/i; Ce.param = function (e, t) { let n; const r = []; const i = function (e, t) { const n = Ee(t) ? t() : t; r[r.length] = `${encodeURIComponent(e)}=${encodeURIComponent(n == null ? '' : n)}`; }; if (Array.isArray(e) || e.jquery && !Ce.isPlainObject(e))Ce.each(e, function () { i(this.name, this.value); }); else for (n in e)ie(n, e[n], t, i); return r.join('&'); }, Ce.fn.extend({ serialize() { return Ce.param(this.serializeArray()); }, serializeArray() { return this.map(function () { const e = Ce.prop(this, 'elements'); return e ? Ce.makeArray(e) : this; }).filter(function () { const e = this.type; return this.name && !Ce(this).is(':disabled') && Bt.test(this.nodeName) && !jt.test(e) && (this.checked || !et.test(e)); }).map(function (e, t) { const n = Ce(this).val(); return n == null ? null : Array.isArray(n) ? Ce.map(n, e => ({ name: t.name, value: e.replace(Rt, '\r\n') })) : { name: t.name, value: n.replace(Rt, '\r\n') }; }).get(); } }); const Ft = /%20/g; const Ut = /#.*$/; const Vt = /([?&])_=[^&]*/; const qt = /^(.*?):[ \t]*([^\r\n]*)$/gm; const Ht = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/; const Wt = /^(?:GET|HEAD)$/; const $t = /^\/\//; const Gt = {}; var Zt = {}; const Kt = '*/'.concat('*'); const Xt = pe.createElement('a'); Xt.href = Nt.href, Ce.extend({
      active: 0,
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: Nt.href,
        type: 'GET',
        isLocal: Ht.test(Nt.protocol),
        global: !0,
        processData: !0,
        async: !0,
        contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
        accepts: {
          '*': Kt, text: 'text/plain', html: 'text/html', xml: 'application/xml, text/xml', json: 'application/json, text/javascript',
        },
        contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ },
        responseFields: { xml: 'responseXML', text: 'responseText', json: 'responseJSON' },
        converters: {
          '* text': String, 'text html': !0, 'text json': JSON.parse, 'text xml': Ce.parseXML,
        },
        flatOptions: { url: !0, context: !0 },
      },
      ajaxSetup(e, t) { return t ? se(se(e, Ce.ajaxSettings), t) : se(Ce.ajaxSettings, e); },
      ajaxPrefilter: oe(Gt),
      ajaxTransport: oe(Zt),
      ajax(e, t) {
        function n(e, t, n, s) { let u; let f; let h; let b; let x; let w = t; c || (c = !0, l && o.clearTimeout(l), r = void 0, a = s || '', E.readyState = e > 0 ? 4 : 0, u = e >= 200 && e < 300 || e === 304, n && (b = le(d, E, n)), b = ue(d, b, E, u), u ? (d.ifModified && ((x = E.getResponseHeader('Last-Modified')) && (Ce.lastModified[i] = x), (x = E.getResponseHeader('etag')) && (Ce.etag[i] = x)), e === 204 || d.type === 'HEAD' ? w = 'nocontent' : e === 304 ? w = 'notmodified' : (w = b.state, f = b.data, u = !(h = b.error))) : (h = w, !e && w || (w = 'error', e < 0 && (e = 0))), E.status = e, E.statusText = `${t || w}`, u ? y.resolveWith(m, [f, w, E]) : y.rejectWith(m, [E, w, h]), E.statusCode(_), _ = void 0, p && g.trigger(u ? 'ajaxSuccess' : 'ajaxError', [E, d, u ? f : h]), v.fireWith(m, [E, w]), p && (g.trigger('ajaxComplete', [E, d]), --Ce.active || Ce.event.trigger('ajaxStop'))); } typeof e === 'object' && (t = e, e = void 0), t = t || {}; let r; let i; let a; let s; let l; let u; let c; let p; let f; let h; var d = Ce.ajaxSetup({}, t); var m = d.context || d; var g = d.context && (m.nodeType || m.jquery) ? Ce(m) : Ce.event; var y = Ce.Deferred(); var v = Ce.Callbacks('once memory'); var _ = d.statusCode || {}; const b = {}; const x = {}; let w = 'canceled'; var E = {
          readyState: 0, getResponseHeader(e) { let t; if (c) { if (!s) for (s = {}; t = qt.exec(a);)s[t[1].toLowerCase()] = t[2]; t = s[e.toLowerCase()]; } return t == null ? null : t; }, getAllResponseHeaders() { return c ? a : null; }, setRequestHeader(e, t) { return c == null && (e = x[e.toLowerCase()] = x[e.toLowerCase()] || e, b[e] = t), this; }, overrideMimeType(e) { return c == null && (d.mimeType = e), this; }, statusCode(e) { let t; if (e) if (c)E.always(e[E.status]); else for (t in e)_[t] = [_[t], e[t]]; return this; }, abort(e) { const t = e || w; return r && r.abort(t), n(0, t), this; },
        }; if (y.promise(E), d.url = (`${e || d.url || Nt.href}`).replace($t, `${Nt.protocol}//`), d.type = t.method || t.type || d.method || d.type, d.dataTypes = (d.dataType || '*').toLowerCase().match(Re) || [''], d.crossDomain == null) { u = pe.createElement('a'); try { u.href = d.url, u.href = u.href, d.crossDomain = `${Xt.protocol}//${Xt.host}` != `${u.protocol}//${u.host}`; } catch (e) { d.crossDomain = !0; } } if (d.data && d.processData && typeof d.data !== 'string' && (d.data = Ce.param(d.data, d.traditional)), ae(Gt, d, t, E), c) return E; (p = Ce.event && d.global) && Ce.active++ == 0 && Ce.event.trigger('ajaxStart'), d.type = d.type.toUpperCase(), d.hasContent = !Wt.test(d.type), i = d.url.replace(Ut, ''), d.hasContent ? d.data && d.processData && (d.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && (d.data = d.data.replace(Ft, '+')) : (h = d.url.slice(i.length), d.data && (d.processData || typeof d.data === 'string') && (i += (Lt.test(i) ? '&' : '?') + d.data, delete d.data), !1 === d.cache && (i = i.replace(Vt, '$1'), h = `${Lt.test(i) ? '&' : '?'}_=${Dt++}${h}`), d.url = i + h), d.ifModified && (Ce.lastModified[i] && E.setRequestHeader('If-Modified-Since', Ce.lastModified[i]), Ce.etag[i] && E.setRequestHeader('If-None-Match', Ce.etag[i])), (d.data && d.hasContent && !1 !== d.contentType || t.contentType) && E.setRequestHeader('Content-Type', d.contentType), E.setRequestHeader('Accept', d.dataTypes[0] && d.accepts[d.dataTypes[0]] ? d.accepts[d.dataTypes[0]] + (d.dataTypes[0] !== '*' ? `, ${Kt}; q=0.01` : '') : d.accepts['*']); for (f in d.headers)E.setRequestHeader(f, d.headers[f]); if (d.beforeSend && (!1 === d.beforeSend.call(m, E, d) || c)) return E.abort(); if (w = 'abort', v.add(d.complete), E.done(d.success), E.fail(d.error), r = ae(Zt, d, t, E)) { if (E.readyState = 1, p && g.trigger('ajaxSend', [E, d]), c) return E; d.async && d.timeout > 0 && (l = o.setTimeout(() => { E.abort('timeout'); }, d.timeout)); try { c = !1, r.send(b, n); } catch (e) { if (c) throw e; n(-1, e); } } else n(-1, 'No Transport'); return E;
      },
      getJSON(e, t, n) { return Ce.get(e, t, n, 'json'); },
      getScript(e, t) { return Ce.get(e, void 0, t, 'script'); },
    }), Ce.each(['get', 'post'], (e, t) => {
      Ce[t] = function (e, n, r, i) {
        return Ee(n) && (i = i || r, r = n, n = void 0), Ce.ajax(Ce.extend({
          url: e, type: t, dataType: i, data: n, success: r,
        }, Ce.isPlainObject(e) && e));
      };
    }), Ce._evalUrl = function (e) {
      return Ce.ajax({
        url: e, type: 'GET', dataType: 'script', cache: !0, async: !1, global: !1, throws: !0,
      });
    }, Ce.fn.extend({
      wrapAll(e) { let t; return this[0] && (Ee(e) && (e = e.call(this[0])), t = Ce(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { for (var e = this; e.firstElementChild;)e = e.firstElementChild; return e; }).append(this)), this; }, wrapInner(e) { return Ee(e) ? this.each(function (t) { Ce(this).wrapInner(e.call(this, t)); }) : this.each(function () { const t = Ce(this); const n = t.contents(); n.length ? n.wrapAll(e) : t.append(e); }); }, wrap(e) { const t = Ee(e); return this.each(function (n) { Ce(this).wrapAll(t ? e.call(this, n) : e); }); }, unwrap(e) { return this.parent(e).not('body').each(function () { Ce(this).replaceWith(this.childNodes); }), this; },
    }), Ce.expr.pseudos.hidden = function (e) { return !Ce.expr.pseudos.visible(e); }, Ce.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length); }, Ce.ajaxSettings.xhr = function () { try { return new o.XMLHttpRequest(); } catch (e) {} }; const Yt = { 0: 200, 1223: 204 }; let Jt = Ce.ajaxSettings.xhr(); we.cors = !!Jt && 'withCredentials' in Jt, we.ajax = Jt = !!Jt, Ce.ajaxTransport((e) => { let t; let n; if (we.cors || Jt && !e.crossDomain) return { send(r, i) { let a; const s = e.xhr(); if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (a in e.xhrFields)s[a] = e.xhrFields[a]; e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || r['X-Requested-With'] || (r['X-Requested-With'] = 'XMLHttpRequest'); for (a in r)s.setRequestHeader(a, r[a]); t = function (e) { return function () { t && (t = n = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, e === 'abort' ? s.abort() : e === 'error' ? typeof s.status !== 'number' ? i(0, 'error') : i(s.status, s.statusText) : i(Yt[s.status] || s.status, s.statusText, (s.responseType || 'text') !== 'text' || typeof s.responseText !== 'string' ? { binary: s.response } : { text: s.responseText }, s.getAllResponseHeaders())); }; }, s.onload = t(), n = s.onerror = s.ontimeout = t('error'), void 0 !== s.onabort ? s.onabort = n : s.onreadystatechange = function () { s.readyState === 4 && o.setTimeout(() => { t && n(); }); }, t = t('abort'); try { s.send(e.hasContent && e.data || null); } catch (e) { if (t) throw e; } }, abort() { t && t(); } }; }), Ce.ajaxPrefilter((e) => { e.crossDomain && (e.contents.script = !1); }), Ce.ajaxSetup({ accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { 'text script': function (e) { return Ce.globalEval(e), e; } } }), Ce.ajaxPrefilter('script', (e) => { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = 'GET'); }), Ce.ajaxTransport('script', (e) => { if (e.crossDomain) { let t; let n; return { send(r, i) { t = Ce('<script>').prop({ charset: e.scriptCharset, src: e.url }).on('load error', n = function (e) { t.remove(), n = null, e && i(e.type === 'error' ? 404 : 200, e.type); }), pe.head.appendChild(t[0]); }, abort() { n && n(); } }; } }); const Qt = []; const en = /(=)\?(?=&|$)|\?\?/; Ce.ajaxSetup({ jsonp: 'callback', jsonpCallback() { const e = Qt.pop() || `${Ce.expando}_${Dt++}`; return this[e] = !0, e; } }), Ce.ajaxPrefilter('json jsonp', (e, t, n) => { let r; let i; let a; const s = !1 !== e.jsonp && (en.test(e.url) ? 'url' : typeof e.data === 'string' && (e.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && en.test(e.data) && 'data'); if (s || e.dataTypes[0] === 'jsonp') return r = e.jsonpCallback = Ee(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, s ? e[s] = e[s].replace(en, `$1${r}`) : !1 !== e.jsonp && (e.url += `${(Lt.test(e.url) ? '&' : '?') + e.jsonp}=${r}`), e.converters['script json'] = function () { return a || Ce.error(`${r} was not called`), a[0]; }, e.dataTypes[0] = 'json', i = o[r], o[r] = function () { a = arguments; }, n.always(() => { void 0 === i ? Ce(o).removeProp(r) : o[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Qt.push(r)), a && Ee(i) && i(a[0]), a = i = void 0; }), 'script'; }), we.createHTMLDocument = (function () { const e = pe.implementation.createHTMLDocument('').body; return e.innerHTML = '<form></form><form></form>', e.childNodes.length === 2; }()), Ce.parseHTML = function (e, t, n) { if (typeof e !== 'string') return []; typeof t === 'boolean' && (n = t, t = !1); let r; let i; let o; return t || (we.createHTMLDocument ? ((r = (t = pe.implementation.createHTMLDocument('')).createElement('base')).href = pe.location.href, t.head.appendChild(r)) : t = pe), i = Me.exec(e), o = !n && [], i ? [t.createElement(i[1])] : (i = A([e], t, o), o && o.length && Ce(o).remove(), Ce.merge([], i.childNodes)); }, Ce.fn.load = function (e, t, n) {
      let r; let i; let o; const a = this; const s = e.indexOf(' '); return s > -1 && (r = te(e.slice(s)), e = e.slice(0, s)), Ee(t) ? (n = t, t = void 0) : t && typeof t === 'object' && (i = 'POST'), a.length > 0 && Ce.ajax({
        url: e, type: i || 'GET', dataType: 'html', data: t,
      }).done(function (e) { o = arguments, a.html(r ? Ce('<div>').append(Ce.parseHTML(e)).find(r) : e); }).always(n && ((e, t) => { a.each(function () { n.apply(this, o || [e.responseText, t, e]); }); })), this;
    }, Ce.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], (e, t) => { Ce.fn[t] = function (e) { return this.on(t, e); }; }), Ce.expr.pseudos.animated = function (e) { return Ce.grep(Ce.timers, t => e === t.elem).length; }, Ce.offset = { setOffset(e, t, n) { let r; let i; let o; let a; let s; let l; const u = Ce.css(e, 'position'); const c = Ce(e); const p = {}; u === 'static' && (e.style.position = 'relative'), s = c.offset(), o = Ce.css(e, 'top'), l = Ce.css(e, 'left'), (u === 'absolute' || u === 'fixed') && (o + l).indexOf('auto') > -1 ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(l) || 0), Ee(t) && (t = t.call(e, n, Ce.extend({}, s))), t.top != null && (p.top = t.top - s.top + a), t.left != null && (p.left = t.left - s.left + i), 'using' in t ? t.using.call(e, p) : c.css(p); } }, Ce.fn.extend({ offset(e) { if (arguments.length) return void 0 === e ? this : this.each(function (t) { Ce.offset.setOffset(this, e, t); }); let t; let n; const r = this[0]; return r ? r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0; }, position() { if (this[0]) { let e; let t; let n; const r = this[0]; let i = { top: 0, left: 0 }; if (Ce.css(r, 'position') === 'fixed')t = r.getBoundingClientRect(); else { for (t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && Ce.css(e, 'position') === 'static';)e = e.parentNode; e && e !== r && e.nodeType === 1 && ((i = Ce(e).offset()).top += Ce.css(e, 'borderTopWidth', !0), i.left += Ce.css(e, 'borderLeftWidth', !0)); } return { top: t.top - i.top - Ce.css(r, 'marginTop', !0), left: t.left - i.left - Ce.css(r, 'marginLeft', !0) }; } }, offsetParent() { return this.map(function () { for (var e = this.offsetParent; e && Ce.css(e, 'position') === 'static';)e = e.offsetParent; return e || ot; }); } }), Ce.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, (e, t) => { const n = t === 'pageYOffset'; Ce.fn[e] = function (r) { return Fe(this, (e, r, i) => { let o; if (Te(e) ? o = e : e.nodeType === 9 && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r]; o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i; }, e, r, arguments.length); }; }), Ce.each(['top', 'left'], (e, t) => { Ce.cssHooks[t] = U(we.pixelPosition, (e, n) => { if (n) return n = F(e, t), ht.test(n) ? `${Ce(e).position()[t]}px` : n; }); }), Ce.each({ Height: 'height', Width: 'width' }, (e, t) => { Ce.each({ padding: `inner${e}`, content: t, '': `outer${e}` }, (n, r) => { Ce.fn[r] = function (i, o) { const a = arguments.length && (n || typeof i !== 'boolean'); const s = n || (!0 === i || !0 === o ? 'margin' : 'border'); return Fe(this, (t, n, i) => { let o; return Te(t) ? r.indexOf('outer') === 0 ? t[`inner${e}`] : t.document.documentElement[`client${e}`] : t.nodeType === 9 ? (o = t.documentElement, Math.max(t.body[`scroll${e}`], o[`scroll${e}`], t.body[`offset${e}`], o[`offset${e}`], o[`client${e}`])) : void 0 === i ? Ce.css(t, n, s) : Ce.style(t, n, i, s); }, t, a ? i : void 0, a); }; }); }), Ce.each('blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split(' '), (e, t) => { Ce.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t); }; }), Ce.fn.extend({ hover(e, t) { return this.mouseenter(e).mouseleave(t || e); } }), Ce.fn.extend({
      bind(e, t, n) { return this.on(e, null, t, n); }, unbind(e, t) { return this.off(e, null, t); }, delegate(e, t, n, r) { return this.on(t, e, n, r); }, undelegate(e, t, n) { return arguments.length === 1 ? this.off(e, '**') : this.off(t, e || '**', n); },
    }), Ce.proxy = function (e, t) { let n; let r; let i; if (typeof t === 'string' && (n = e[t], t = e, e = n), Ee(e)) return r = he.call(arguments, 2), i = function () { return e.apply(t || this, r.concat(he.call(arguments))); }, i.guid = e.guid = e.guid || Ce.guid++, i; }, Ce.holdReady = function (e) { e ? Ce.readyWait++ : Ce.ready(!0); }, Ce.isArray = Array.isArray, Ce.parseJSON = JSON.parse, Ce.nodeName = c, Ce.isFunction = Ee, Ce.isWindow = Te, Ce.camelCase = _, Ce.type = l, Ce.now = Date.now, Ce.isNumeric = function (e) { const t = Ce.type(e); return (t === 'number' || t === 'string') && !isNaN(e - parseFloat(e)); }, n(118) && (r = [], void 0 !== (i = function () { return Ce; }.apply(t, r)) && (e.exports = i)); const tn = o.jQuery; const nn = o.$; return Ce.noConflict = function (e) { return o.$ === Ce && (o.$ = nn), e && o.jQuery === Ce && (o.jQuery = tn), Ce; }, a || (o.jQuery = o.$ = Ce), Ce;
  }));
}, function (e, t) { (function (t) { e.exports = t; }).call(t, {}); }, function (e, t, n) {
  !(function (e, r) { r(t, n(120), n(29)); }(0, (e, t, n) => {
    function r(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, r.key, r); } } function i(e, t, n) { return t && r(e.prototype, t), n && r(e, n), e; } function o(e) {
      for (let t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {}; let r = Object.keys(n); typeof Object.getOwnPropertySymbols === 'function' && (r = r.concat(Object.getOwnPropertySymbols(n).filter(e => Object.getOwnPropertyDescriptor(n, e).enumerable))), r.forEach((t) => {
          let r; let i; let o; r = e, o = n[i = t], i in r ? Object.defineProperty(r, i, {
            value: o, enumerable: !0, configurable: !0, writable: !0,
          }) : r[i] = o;
        });
      } return e;
    }t = t && t.hasOwnProperty('default') ? t.default : t, n = n && n.hasOwnProperty('default') ? n.default : n; let a; let s; let l; let u; let c; let p; let f; let h; let d; let m; let g; let y; let v; let _; let b; let x; let w; let E; let T; let k; let C; let S; let A; let O; let I; let P; let M; let N; let D; let L; let z; let R; let j; let B; let F; let U; let V; let q; let H; let W; let $; let G; let Z; let K; let X; let Y; let J; let Q; let ee; let te; let ne; let re; let ie; let oe; let ae; let se; let le; let ue; let ce; let pe; let fe; let he; let de; let me; let ge; let ye; let ve; let _e; let be; let xe; let we; let Ee; let Te; let ke; let Ce; let Se; let Ae; let Oe; let Ie; let Pe; let Me; let Ne; let De; let Le; let ze; let Re; let je; let Be; let Fe; let Ue; let Ve; let qe; let He; let We; let $e; let Ge; let Ze; let Ke; let Xe; let Ye; let Je; let Qe; let et; let tt; let nt; let rt; let it; let ot; let at; let st; let lt; let ut; let ct; let pt; let ft; let ht; let dt; let mt; let gt; let yt; let vt; let _t; let bt; let xt; let wt; let Et; let Tt; let kt; let Ct; let St; let At; let Ot; let It; let Pt; let Mt; let Nt; let Dt; let Lt; let zt; let Rt; let jt; let Bt; let Ft; let Ut; let Vt; let qt; let Ht; let Wt; let $t; let Gt; let Zt; let Kt; let Xt; let Yt; let Jt; let Qt; let en; let tn; let nn; let rn; let on; let an; let sn; let ln; let un; let cn; let pn; let fn; let hn; let dn; let mn; let gn; let yn; let vn; let _n; let bn; let xn; const wn = (function (e) {
      function t(t) { const n = this; let i = !1; return e(this).one(r.TRANSITION_END, () => { i = !0; }), setTimeout(() => { i || r.triggerTransitionEnd(n); }, t), this; } const n = 'transitionend'; var r = {
        TRANSITION_END: 'bsTransitionEnd', getUID(e) { for (;e += ~~(1e6 * Math.random()), document.getElementById(e););return e; }, getSelectorFromElement(t) { let n = t.getAttribute('data-target'); n && n !== '#' || (n = t.getAttribute('href') || ''); try { return e(document).find(n).length > 0 ? n : null; } catch (t) { return null; } }, getTransitionDurationFromElement(t) { if (!t) return 0; let n = e(t).css('transition-duration'); return parseFloat(n) ? (n = n.split(',')[0], 1e3 * parseFloat(n)) : 0; }, reflow(e) { return e.offsetHeight; }, triggerTransitionEnd(t) { e(t).trigger(n); }, supportsTransitionEnd() { return Boolean(n); }, isElement(e) { return (e[0] || e).nodeType; }, typeCheckConfig(e, t, n) { for (const i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { const o = n[i]; const a = t[i]; const s = a && r.isElement(a) ? 'element' : (l = a, {}.toString.call(l).match(/\s([a-z]+)/i)[1].toLowerCase()); if (!new RegExp(o).test(s)) throw new Error(`${e.toUpperCase()}: Option "${i}" provided type "${s}" but expected type "${o}".`); } let l; },
      }; return e.fn.emulateTransitionEnd = t, e.event.special[r.TRANSITION_END] = { bindType: n, delegateType: n, handle(t) { if (e(t.target).is(this)) return t.handleObj.handler.apply(this, arguments); } }, r;
    }(t)); const En = (s = 'alert', u = `.${l = 'bs.alert'}`, c = (a = t).fn[s], p = { CLOSE: `close${u}`, CLOSED: `closed${u}`, CLICK_DATA_API: `click${u}.data-api` }, f = 'alert', h = 'fade', d = 'show', m = (function () { function e(e) { this._element = e; } const t = e.prototype; return t.close = function (e) { let t = this._element; e && (t = this._getRootElement(e)), this._triggerCloseEvent(t).isDefaultPrevented() || this._removeElement(t); }, t.dispose = function () { a.removeData(this._element, l), this._element = null; }, t._getRootElement = function (e) { const t = wn.getSelectorFromElement(e); let n = !1; return t && (n = a(t)[0]), n || (n = a(e).closest(`.${f}`)[0]), n; }, t._triggerCloseEvent = function (e) { const t = a.Event(p.CLOSE); return a(e).trigger(t), t; }, t._removeElement = function (e) { const t = this; if (a(e).removeClass(d), a(e).hasClass(h)) { const n = wn.getTransitionDurationFromElement(e); a(e).one(wn.TRANSITION_END, n => t._destroyElement(e, n)).emulateTransitionEnd(n); } else this._destroyElement(e); }, t._destroyElement = function (e) { a(e).detach().trigger(p.CLOSED).remove(); }, e._jQueryInterface = function (t) { return this.each(function () { const n = a(this); let r = n.data(l); r || (r = new e(this), n.data(l, r)), t === 'close' && r[t](this); }); }, e._handleDismiss = function (e) { return function (t) { t && t.preventDefault(), e.close(this); }; }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }]), e; }()), a(document).on(p.CLICK_DATA_API, '[data-dismiss="alert"]', m._handleDismiss(new m())), a.fn[s] = m._jQueryInterface, a.fn[s].Constructor = m, a.fn[s].noConflict = function () { return a.fn[s] = c, m._jQueryInterface; }, m); const Tn = (y = 'button', _ = `.${v = 'bs.button'}`, b = '.data-api', x = (g = t).fn[y], w = 'active', E = 'btn', k = '[data-toggle^="button"]', C = '[data-toggle="buttons"]', S = 'input', A = '.active', O = '.btn', I = { CLICK_DATA_API: `click${_}${b}`, FOCUS_BLUR_DATA_API: `${(T = 'focus') + _ + b} blur${_}${b}` }, P = (function () { function e(e) { this._element = e; } const t = e.prototype; return t.toggle = function () { let e = !0; let t = !0; const n = g(this._element).closest(C)[0]; if (n) { const r = g(this._element).find(S)[0]; if (r) { if (r.type === 'radio') if (r.checked && g(this._element).hasClass(w))e = !1; else { const i = g(n).find(A)[0]; i && g(i).removeClass(w); } if (e) { if (r.hasAttribute('disabled') || n.hasAttribute('disabled') || r.classList.contains('disabled') || n.classList.contains('disabled')) return; r.checked = !g(this._element).hasClass(w), g(r).trigger('change'); }r.focus(), t = !1; } }t && this._element.setAttribute('aria-pressed', !g(this._element).hasClass(w)), e && g(this._element).toggleClass(w); }, t.dispose = function () { g.removeData(this._element, v), this._element = null; }, e._jQueryInterface = function (t) { return this.each(function () { let n = g(this).data(v); n || (n = new e(this), g(this).data(v, n)), t === 'toggle' && n[t](); }); }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }]), e; }()), g(document).on(I.CLICK_DATA_API, k, (e) => { e.preventDefault(); let t = e.target; g(t).hasClass(E) || (t = g(t).closest(O)), P._jQueryInterface.call(g(t), 'toggle'); }).on(I.FOCUS_BLUR_DATA_API, k, (e) => { const t = g(e.target).closest(O)[0]; g(t).toggleClass(T, /^focus(in)?$/.test(e.type)); }), g.fn[y] = P._jQueryInterface, g.fn[y].Constructor = P, g.fn[y].noConflict = function () { return g.fn[y] = x, P._jQueryInterface; }, P); const kn = (N = 'carousel', L = `.${D = 'bs.carousel'}`, z = '.data-api', R = (M = t).fn[N], j = {
      interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0,
    }, B = {
      interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean',
    }, F = 'next', U = 'prev', V = 'left', q = 'right', H = {
      SLIDE: `slide${L}`, SLID: `slid${L}`, KEYDOWN: `keydown${L}`, MOUSEENTER: `mouseenter${L}`, MOUSELEAVE: `mouseleave${L}`, TOUCHEND: `touchend${L}`, LOAD_DATA_API: `load${L}${z}`, CLICK_DATA_API: `click${L}${z}`,
    }, W = 'carousel', $ = 'active', G = 'slide', Z = 'carousel-item-right', K = 'carousel-item-left', X = 'carousel-item-next', Y = 'carousel-item-prev', J = {
      ACTIVE: '.active', ACTIVE_ITEM: '.active.carousel-item', ITEM: '.carousel-item', NEXT_PREV: '.carousel-item-next, .carousel-item-prev', INDICATORS: '.carousel-indicators', DATA_SLIDE: '[data-slide], [data-slide-to]', DATA_RIDE: '[data-ride="carousel"]',
    }, Q = (function () {
      function e(e, t) { this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this._config = this._getConfig(t), this._element = M(e)[0], this._indicatorsElement = M(this._element).find(J.INDICATORS)[0], this._addEventListeners(); } const t = e.prototype; return t.next = function () { this._isSliding || this._slide(F); }, t.nextWhenVisible = function () { !document.hidden && M(this._element).is(':visible') && M(this._element).css('visibility') !== 'hidden' && this.next(); }, t.prev = function () { this._isSliding || this._slide(U); }, t.pause = function (e) { e || (this._isPaused = !0), M(this._element).find(J.NEXT_PREV)[0] && (wn.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null; }, t.cycle = function (e) { e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)); }, t.to = function (e) { const t = this; this._activeElement = M(this._element).find(J.ACTIVE_ITEM)[0]; const n = this._getItemIndex(this._activeElement); if (!(e > this._items.length - 1 || e < 0)) if (this._isSliding)M(this._element).one(H.SLID, () => t.to(e)); else { if (n === e) return this.pause(), void this.cycle(); const r = n < e ? F : U; this._slide(r, this._items[e]); } }, t.dispose = function () { M(this._element).off(L), M.removeData(this._element, D), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null; }, t._getConfig = function (e) { return e = o({}, j, e), wn.typeCheckConfig(N, e, B), e; }, t._addEventListeners = function () { const e = this; this._config.keyboard && M(this._element).on(H.KEYDOWN, t => e._keydown(t)), this._config.pause === 'hover' && (M(this._element).on(H.MOUSEENTER, t => e.pause(t)).on(H.MOUSELEAVE, t => e.cycle(t)), 'ontouchstart' in document.documentElement && M(this._element).on(H.TOUCHEND, () => { e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout(t => e.cycle(t), 500 + e._config.interval); })); }, t._keydown = function (e) { if (!/input|textarea/i.test(e.target.tagName)) switch (e.which) { case 37: e.preventDefault(), this.prev(); break; case 39: e.preventDefault(), this.next(); } }, t._getItemIndex = function (e) { return this._items = M.makeArray(M(e).parent().find(J.ITEM)), this._items.indexOf(e); }, t._getItemByDirection = function (e, t) { const n = e === F; const r = e === U; const i = this._getItemIndex(t); const o = this._items.length - 1; if ((r && i === 0 || n && i === o) && !this._config.wrap) return t; const a = (i + (e === U ? -1 : 1)) % this._items.length; return a === -1 ? this._items[this._items.length - 1] : this._items[a]; }, t._triggerSlideEvent = function (e, t) {
        const n = this._getItemIndex(e); const r = this._getItemIndex(M(this._element).find(J.ACTIVE_ITEM)[0]); const i = M.Event(H.SLIDE, {
          relatedTarget: e, direction: t, from: r, to: n,
        }); return M(this._element).trigger(i), i;
      }, t._setActiveIndicatorElement = function (e) { if (this._indicatorsElement) { M(this._indicatorsElement).find(J.ACTIVE).removeClass($); const t = this._indicatorsElement.children[this._getItemIndex(e)]; t && M(t).addClass($); } }, t._slide = function (e, t) {
        let n; let r; let i; const o = this; const a = M(this._element).find(J.ACTIVE_ITEM)[0]; const s = this._getItemIndex(a); const l = t || a && this._getItemByDirection(e, a); const u = this._getItemIndex(l); const c = Boolean(this._interval); if (e === F ? (n = K, r = X, i = V) : (n = Z, r = Y, i = q), l && M(l).hasClass($)) this._isSliding = !1; else if (!this._triggerSlideEvent(l, i).isDefaultPrevented() && a && l) {
          this._isSliding = !0, c && this.pause(), this._setActiveIndicatorElement(l); const p = M.Event(H.SLID, {
            relatedTarget: l, direction: i, from: s, to: u,
          }); if (M(this._element).hasClass(G)) { M(l).addClass(r), wn.reflow(l), M(a).addClass(n), M(l).addClass(n); const f = wn.getTransitionDurationFromElement(a); M(a).one(wn.TRANSITION_END, () => { M(l).removeClass(`${n} ${r}`).addClass($), M(a).removeClass(`${$} ${r} ${n}`), o._isSliding = !1, setTimeout(() => M(o._element).trigger(p), 0); }).emulateTransitionEnd(f); } else M(a).removeClass($), M(l).addClass($), this._isSliding = !1, M(this._element).trigger(p); c && this.cycle();
        }
      }, e._jQueryInterface = function (t) { return this.each(function () { let n = M(this).data(D); let r = o({}, j, M(this).data()); typeof t === 'object' && (r = o({}, r, t)); const i = typeof t === 'string' ? t : r.slide; if (n || (n = new e(this, r), M(this).data(D, n)), typeof t === 'number')n.to(t); else if (typeof i === 'string') { if (typeof n[i] === 'undefined') throw new TypeError(`No method named "${i}"`); n[i](); } else r.interval && (n.pause(), n.cycle()); }); }, e._dataApiClickHandler = function (t) { const n = wn.getSelectorFromElement(this); if (n) { const r = M(n)[0]; if (r && M(r).hasClass(W)) { const i = o({}, M(r).data(), M(this).data()); const a = this.getAttribute('data-slide-to'); a && (i.interval = !1), e._jQueryInterface.call(M(r), i), a && M(r).data(D).to(a), t.preventDefault(); } } }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }, { key: 'Default', get() { return j; } }]), e;
    }()), M(document).on(H.CLICK_DATA_API, J.DATA_SLIDE, Q._dataApiClickHandler), M(window).on(H.LOAD_DATA_API, () => { M(J.DATA_RIDE).each(function () { const e = M(this); Q._jQueryInterface.call(e, e.data()); }); }), M.fn[N] = Q._jQueryInterface, M.fn[N].Constructor = Q, M.fn[N].noConflict = function () { return M.fn[N] = R, Q._jQueryInterface; }, Q); const Cn = (te = 'collapse', re = `.${ne = 'bs.collapse'}`, ie = (ee = t).fn[te], oe = { toggle: !0, parent: '' }, ae = { toggle: 'boolean', parent: '(string|element)' }, se = {
      SHOW: `show${re}`, SHOWN: `shown${re}`, HIDE: `hide${re}`, HIDDEN: `hidden${re}`, CLICK_DATA_API: `click${re}.data-api`,
    }, le = 'show', ue = 'collapse', ce = 'collapsing', pe = 'collapsed', fe = 'width', he = 'height', de = { ACTIVES: '.show, .collapsing', DATA_TOGGLE: '[data-toggle="collapse"]' }, me = (function () { function e(e, t) { this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = ee.makeArray(ee(`[data-toggle="collapse"][href="#${e.id}"],[data-toggle="collapse"][data-target="#${e.id}"]`)); for (let n = ee(de.DATA_TOGGLE), r = 0; r < n.length; r++) { const i = n[r]; const o = wn.getSelectorFromElement(i); o !== null && ee(o).filter(e).length > 0 && (this._selector = o, this._triggerArray.push(i)); } this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle(); } const t = e.prototype; return t.toggle = function () { ee(this._element).hasClass(le) ? this.hide() : this.show(); }, t.show = function () { let t; let n; const r = this; if (!this._isTransitioning && !ee(this._element).hasClass(le) && (this._parent && (t = ee.makeArray(ee(this._parent).find(de.ACTIVES).filter(`[data-parent="${this._config.parent}"]`))).length === 0 && (t = null), !(t && (n = ee(t).not(this._selector).data(ne)) && n._isTransitioning))) { const i = ee.Event(se.SHOW); if (ee(this._element).trigger(i), !i.isDefaultPrevented()) { t && (e._jQueryInterface.call(ee(t).not(this._selector), 'hide'), n || ee(t).data(ne, null)); const o = this._getDimension(); ee(this._element).removeClass(ue).addClass(ce), (this._element.style[o] = 0) < this._triggerArray.length && ee(this._triggerArray).removeClass(pe).attr('aria-expanded', !0), this.setTransitioning(!0); const a = `scroll${o[0].toUpperCase() + o.slice(1)}`; const s = wn.getTransitionDurationFromElement(this._element); ee(this._element).one(wn.TRANSITION_END, () => { ee(r._element).removeClass(ce).addClass(ue).addClass(le), r._element.style[o] = '', r.setTransitioning(!1), ee(r._element).trigger(se.SHOWN); }).emulateTransitionEnd(s), this._element.style[o] = `${this._element[a]}px`; } } }, t.hide = function () { const e = this; if (!this._isTransitioning && ee(this._element).hasClass(le)) { const t = ee.Event(se.HIDE); if (ee(this._element).trigger(t), !t.isDefaultPrevented()) { const n = this._getDimension(); if (this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, wn.reflow(this._element), ee(this._element).addClass(ce).removeClass(ue).removeClass(le), this._triggerArray.length > 0) for (let r = 0; r < this._triggerArray.length; r++) { const i = this._triggerArray[r]; const o = wn.getSelectorFromElement(i); o !== null && (ee(o).hasClass(le) || ee(i).addClass(pe).attr('aria-expanded', !1)); } this.setTransitioning(!0), this._element.style[n] = ''; const a = wn.getTransitionDurationFromElement(this._element); ee(this._element).one(wn.TRANSITION_END, () => { e.setTransitioning(!1), ee(e._element).removeClass(ce).addClass(ue).trigger(se.HIDDEN); }).emulateTransitionEnd(a); } } }, t.setTransitioning = function (e) { this._isTransitioning = e; }, t.dispose = function () { ee.removeData(this._element, ne), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null; }, t._getConfig = function (e) { return (e = o({}, oe, e)).toggle = Boolean(e.toggle), wn.typeCheckConfig(te, e, ae), e; }, t._getDimension = function () { return ee(this._element).hasClass(fe) ? fe : he; }, t._getParent = function () { const t = this; let n = null; wn.isElement(this._config.parent) ? (n = this._config.parent, typeof this._config.parent.jquery !== 'undefined' && (n = this._config.parent[0])) : n = ee(this._config.parent)[0]; const r = `[data-toggle="collapse"][data-parent="${this._config.parent}"]`; return ee(n).find(r).each((n, r) => { t._addAriaAndCollapsedClass(e._getTargetFromElement(r), [r]); }), n; }, t._addAriaAndCollapsedClass = function (e, t) { if (e) { const n = ee(e).hasClass(le); t.length > 0 && ee(t).toggleClass(pe, !n).attr('aria-expanded', n); } }, e._getTargetFromElement = function (e) { const t = wn.getSelectorFromElement(e); return t ? ee(t)[0] : null; }, e._jQueryInterface = function (t) { return this.each(function () { const n = ee(this); let r = n.data(ne); const i = o({}, oe, n.data(), typeof t === 'object' && t ? t : {}); if (!r && i.toggle && /show|hide/.test(t) && (i.toggle = !1), r || (r = new e(this, i), n.data(ne, r)), typeof t === 'string') { if (typeof r[t] === 'undefined') throw new TypeError(`No method named "${t}"`); r[t](); } }); }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }, { key: 'Default', get() { return oe; } }]), e; }()), ee(document).on(se.CLICK_DATA_API, de.DATA_TOGGLE, function (e) { e.currentTarget.tagName === 'A' && e.preventDefault(); const t = ee(this); const n = wn.getSelectorFromElement(this); ee(n).each(function () { const e = ee(this); const n = e.data(ne) ? 'toggle' : t.data(); me._jQueryInterface.call(e, n); }); }), ee.fn[te] = me._jQueryInterface, ee.fn[te].Constructor = me, ee.fn[te].noConflict = function () { return ee.fn[te] = ie, me._jQueryInterface; }, me); const Sn = (ye = 'dropdown', _e = `.${ve = 'bs.dropdown'}`, be = '.data-api', xe = (ge = t).fn[ye], we = new RegExp('38|40|27'), Ee = {
      HIDE: `hide${_e}`, HIDDEN: `hidden${_e}`, SHOW: `show${_e}`, SHOWN: `shown${_e}`, CLICK: `click${_e}`, CLICK_DATA_API: `click${_e}${be}`, KEYDOWN_DATA_API: `keydown${_e}${be}`, KEYUP_DATA_API: `keyup${_e}${be}`,
    }, Te = 'disabled', ke = 'show', Ce = 'dropup', Se = 'dropright', Ae = 'dropleft', Oe = 'dropdown-menu-right', Ie = 'position-static', Pe = '[data-toggle="dropdown"]', Me = '.dropdown form', Ne = '.dropdown-menu', De = '.navbar-nav', Le = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)', ze = 'top-start', Re = 'top-end', je = 'bottom-start', Be = 'bottom-end', Fe = 'right-start', Ue = 'left-start', Ve = {
      offset: 0, flip: !0, boundary: 'scrollParent', reference: 'toggle', display: 'dynamic',
    }, qe = {
      offset: '(number|string|function)', flip: 'boolean', boundary: '(string|element)', reference: '(string|element)', display: 'string',
    }, He = (function () { function e(e, t) { this._element = e, this._popper = null, this._config = this._getConfig(t), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners(); } const t = e.prototype; return t.toggle = function () { if (!this._element.disabled && !ge(this._element).hasClass(Te)) { const t = e._getParentFromElement(this._element); const r = ge(this._menu).hasClass(ke); if (e._clearMenus(), !r) { const i = { relatedTarget: this._element }; const o = ge.Event(Ee.SHOW, i); if (ge(t).trigger(o), !o.isDefaultPrevented()) { if (!this._inNavbar) { if (typeof n === 'undefined') throw new TypeError('Bootstrap dropdown require Popper.js (https://popper.js.org)'); let a = this._element; this._config.reference === 'parent' ? a = t : wn.isElement(this._config.reference) && (a = this._config.reference, typeof this._config.reference.jquery !== 'undefined' && (a = this._config.reference[0])), this._config.boundary !== 'scrollParent' && ge(t).addClass(Ie), this._popper = new n(a, this._menu, this._getPopperConfig()); }'ontouchstart' in document.documentElement && ge(t).closest(De).length === 0 && ge(document.body).children().on('mouseover', null, ge.noop), this._element.focus(), this._element.setAttribute('aria-expanded', !0), ge(this._menu).toggleClass(ke), ge(t).toggleClass(ke).trigger(ge.Event(Ee.SHOWN, i)); } } } }, t.dispose = function () { ge.removeData(this._element, ve), ge(this._element).off(_e), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null); }, t.update = function () { this._inNavbar = this._detectNavbar(), this._popper !== null && this._popper.scheduleUpdate(); }, t._addEventListeners = function () { const e = this; ge(this._element).on(Ee.CLICK, (t) => { t.preventDefault(), t.stopPropagation(), e.toggle(); }); }, t._getConfig = function (e) { return e = o({}, this.constructor.Default, ge(this._element).data(), e), wn.typeCheckConfig(ye, e, this.constructor.DefaultType), e; }, t._getMenuElement = function () { if (!this._menu) { const t = e._getParentFromElement(this._element); this._menu = ge(t).find(Ne)[0]; } return this._menu; }, t._getPlacement = function () { const e = ge(this._element).parent(); let t = je; return e.hasClass(Ce) ? (t = ze, ge(this._menu).hasClass(Oe) && (t = Re)) : e.hasClass(Se) ? t = Fe : e.hasClass(Ae) ? t = Ue : ge(this._menu).hasClass(Oe) && (t = Be), t; }, t._detectNavbar = function () { return ge(this._element).closest('.navbar').length > 0; }, t._getPopperConfig = function () { const e = this; const t = {}; typeof this._config.offset === 'function' ? t.fn = function (t) { return t.offsets = o({}, t.offsets, e._config.offset(t.offsets) || {}), t; } : t.offset = this._config.offset; const n = { placement: this._getPlacement(), modifiers: { offset: t, flip: { enabled: this._config.flip }, preventOverflow: { boundariesElement: this._config.boundary } } }; return this._config.display === 'static' && (n.modifiers.applyStyle = { enabled: !1 }), n; }, e._jQueryInterface = function (t) { return this.each(function () { let n = ge(this).data(ve); if (n || (n = new e(this, typeof t === 'object' ? t : null), ge(this).data(ve, n)), typeof t === 'string') { if (typeof n[t] === 'undefined') throw new TypeError(`No method named "${t}"`); n[t](); } }); }, e._clearMenus = function (t) { if (!t || t.which !== 3 && (t.type !== 'keyup' || t.which === 9)) for (let n = ge.makeArray(ge(Pe)), r = 0; r < n.length; r++) { const i = e._getParentFromElement(n[r]); const o = ge(n[r]).data(ve); const a = { relatedTarget: n[r] }; if (o) { const s = o._menu; if (ge(i).hasClass(ke) && !(t && (t.type === 'click' && /input|textarea/i.test(t.target.tagName) || t.type === 'keyup' && t.which === 9) && ge.contains(i, t.target))) { const l = ge.Event(Ee.HIDE, a); ge(i).trigger(l), l.isDefaultPrevented() || ('ontouchstart' in document.documentElement && ge(document.body).children().off('mouseover', null, ge.noop), n[r].setAttribute('aria-expanded', 'false'), ge(s).removeClass(ke), ge(i).removeClass(ke).trigger(ge.Event(Ee.HIDDEN, a))); } } } }, e._getParentFromElement = function (e) { let t; const n = wn.getSelectorFromElement(e); return n && (t = ge(n)[0]), t || e.parentNode; }, e._dataApiKeydownHandler = function (t) { if ((/input|textarea/i.test(t.target.tagName) ? !(t.which === 32 || t.which !== 27 && (t.which !== 40 && t.which !== 38 || ge(t.target).closest(Ne).length)) : we.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !ge(this).hasClass(Te))) { const n = e._getParentFromElement(this); const r = ge(n).hasClass(ke); if ((r || t.which === 27 && t.which === 32) && (!r || t.which !== 27 && t.which !== 32)) { const i = ge(n).find(Le).get(); if (i.length !== 0) { let o = i.indexOf(t.target); t.which === 38 && o > 0 && o--, t.which === 40 && o < i.length - 1 && o++, o < 0 && (o = 0), i[o].focus(); } } else { if (t.which === 27) { const a = ge(n).find(Pe)[0]; ge(a).trigger('focus'); }ge(this).trigger('click'); } } }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }, { key: 'Default', get() { return Ve; } }, { key: 'DefaultType', get() { return qe; } }]), e; }()), ge(document).on(Ee.KEYDOWN_DATA_API, Pe, He._dataApiKeydownHandler).on(Ee.KEYDOWN_DATA_API, Ne, He._dataApiKeydownHandler).on(`${Ee.CLICK_DATA_API} ${Ee.KEYUP_DATA_API}`, He._clearMenus)
      .on(Ee.CLICK_DATA_API, Pe, function (e) { e.preventDefault(), e.stopPropagation(), He._jQueryInterface.call(ge(this), 'toggle'); })
      .on(Ee.CLICK_DATA_API, Me, (e) => { e.stopPropagation(); }), ge.fn[ye] = He._jQueryInterface, ge.fn[ye].Constructor = He, ge.fn[ye].noConflict = function () { return ge.fn[ye] = xe, He._jQueryInterface; }, He); const An = ($e = 'modal', Ze = `.${Ge = 'bs.modal'}`, Ke = (We = t).fn[$e], Xe = {
      backdrop: !0, keyboard: !0, focus: !0, show: !0,
    }, Ye = {
      backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean', show: 'boolean',
    }, Je = {
      HIDE: `hide${Ze}`, HIDDEN: `hidden${Ze}`, SHOW: `show${Ze}`, SHOWN: `shown${Ze}`, FOCUSIN: `focusin${Ze}`, RESIZE: `resize${Ze}`, CLICK_DISMISS: `click.dismiss${Ze}`, KEYDOWN_DISMISS: `keydown.dismiss${Ze}`, MOUSEUP_DISMISS: `mouseup.dismiss${Ze}`, MOUSEDOWN_DISMISS: `mousedown.dismiss${Ze}`, CLICK_DATA_API: `click${Ze}.data-api`,
    }, Qe = 'modal-scrollbar-measure', et = 'modal-backdrop', tt = 'modal-open', nt = 'fade', rt = 'show', it = {
      DIALOG: '.modal-dialog', DATA_TOGGLE: '[data-toggle="modal"]', DATA_DISMISS: '[data-dismiss="modal"]', FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top', STICKY_CONTENT: '.sticky-top', NAVBAR_TOGGLER: '.navbar-toggler',
    }, ot = (function () { function e(e, t) { this._config = this._getConfig(t), this._element = e, this._dialog = We(e).find(it.DIALOG)[0], this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._scrollbarWidth = 0; } const t = e.prototype; return t.toggle = function (e) { return this._isShown ? this.hide() : this.show(e); }, t.show = function (e) { const t = this; if (!this._isTransitioning && !this._isShown) { We(this._element).hasClass(nt) && (this._isTransitioning = !0); const n = We.Event(Je.SHOW, { relatedTarget: e }); We(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), We(document.body).addClass(tt), this._setEscapeEvent(), this._setResizeEvent(), We(this._element).on(Je.CLICK_DISMISS, it.DATA_DISMISS, e => t.hide(e)), We(this._dialog).on(Je.MOUSEDOWN_DISMISS, () => { We(t._element).one(Je.MOUSEUP_DISMISS, (e) => { We(e.target).is(t._element) && (t._ignoreBackdropClick = !0); }); }), this._showBackdrop(() => t._showElement(e))); } }, t.hide = function (e) { const t = this; if (e && e.preventDefault(), !this._isTransitioning && this._isShown) { const n = We.Event(Je.HIDE); if (We(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) { this._isShown = !1; const r = We(this._element).hasClass(nt); if (r && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), We(document).off(Je.FOCUSIN), We(this._element).removeClass(rt), We(this._element).off(Je.CLICK_DISMISS), We(this._dialog).off(Je.MOUSEDOWN_DISMISS), r) { const i = wn.getTransitionDurationFromElement(this._element); We(this._element).one(wn.TRANSITION_END, e => t._hideModal(e)).emulateTransitionEnd(i); } else this._hideModal(); } } }, t.dispose = function () { We.removeData(this._element, Ge), We(window, document, this._element, this._backdrop).off(Ze), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._scrollbarWidth = null; }, t.handleUpdate = function () { this._adjustDialog(); }, t._getConfig = function (e) { return e = o({}, Xe, e), wn.typeCheckConfig($e, e, Ye), e; }, t._showElement = function (e) { const t = this; const n = We(this._element).hasClass(nt); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.scrollTop = 0, n && wn.reflow(this._element), We(this._element).addClass(rt), this._config.focus && this._enforceFocus(); const r = We.Event(Je.SHOWN, { relatedTarget: e }); const i = function () { t._config.focus && t._element.focus(), t._isTransitioning = !1, We(t._element).trigger(r); }; if (n) { const o = wn.getTransitionDurationFromElement(this._element); We(this._dialog).one(wn.TRANSITION_END, i).emulateTransitionEnd(o); } else i(); }, t._enforceFocus = function () { const e = this; We(document).off(Je.FOCUSIN).on(Je.FOCUSIN, (t) => { document !== t.target && e._element !== t.target && We(e._element).has(t.target).length === 0 && e._element.focus(); }); }, t._setEscapeEvent = function () { const e = this; this._isShown && this._config.keyboard ? We(this._element).on(Je.KEYDOWN_DISMISS, (t) => { t.which === 27 && (t.preventDefault(), e.hide()); }) : this._isShown || We(this._element).off(Je.KEYDOWN_DISMISS); }, t._setResizeEvent = function () { const e = this; this._isShown ? We(window).on(Je.RESIZE, t => e.handleUpdate(t)) : We(window).off(Je.RESIZE); }, t._hideModal = function () { const e = this; this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._isTransitioning = !1, this._showBackdrop(() => { We(document.body).removeClass(tt), e._resetAdjustments(), e._resetScrollbar(), We(e._element).trigger(Je.HIDDEN); }); }, t._removeBackdrop = function () { this._backdrop && (We(this._backdrop).remove(), this._backdrop = null); }, t._showBackdrop = function (e) { const t = this; const n = We(this._element).hasClass(nt) ? nt : ''; if (this._isShown && this._config.backdrop) { if (this._backdrop = document.createElement('div'), this._backdrop.className = et, n && We(this._backdrop).addClass(n), We(this._backdrop).appendTo(document.body), We(this._element).on(Je.CLICK_DISMISS, (e) => { t._ignoreBackdropClick ? t._ignoreBackdropClick = !1 : e.target === e.currentTarget && (t._config.backdrop === 'static' ? t._element.focus() : t.hide()); }), n && wn.reflow(this._backdrop), We(this._backdrop).addClass(rt), !e) return; if (!n) return void e(); const r = wn.getTransitionDurationFromElement(this._backdrop); We(this._backdrop).one(wn.TRANSITION_END, e).emulateTransitionEnd(r); } else if (!this._isShown && this._backdrop) { We(this._backdrop).removeClass(rt); const i = function () { t._removeBackdrop(), e && e(); }; if (We(this._element).hasClass(nt)) { const o = wn.getTransitionDurationFromElement(this._backdrop); We(this._backdrop).one(wn.TRANSITION_END, i).emulateTransitionEnd(o); } else i(); } else e && e(); }, t._adjustDialog = function () { const e = this._element.scrollHeight > document.documentElement.clientHeight; !this._isBodyOverflowing && e && (this._element.style.paddingLeft = `${this._scrollbarWidth}px`), this._isBodyOverflowing && !e && (this._element.style.paddingRight = `${this._scrollbarWidth}px`); }, t._resetAdjustments = function () { this._element.style.paddingLeft = '', this._element.style.paddingRight = ''; }, t._checkScrollbar = function () { const e = document.body.getBoundingClientRect(); this._isBodyOverflowing = e.left + e.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth(); }, t._setScrollbar = function () { const e = this; if (this._isBodyOverflowing) { We(it.FIXED_CONTENT).each((t, n) => { const r = We(n)[0].style.paddingRight; const i = We(n).css('padding-right'); We(n).data('padding-right', r).css('padding-right', `${parseFloat(i) + e._scrollbarWidth}px`); }), We(it.STICKY_CONTENT).each((t, n) => { const r = We(n)[0].style.marginRight; const i = We(n).css('margin-right'); We(n).data('margin-right', r).css('margin-right', `${parseFloat(i) - e._scrollbarWidth}px`); }), We(it.NAVBAR_TOGGLER).each((t, n) => { const r = We(n)[0].style.marginRight; const i = We(n).css('margin-right'); We(n).data('margin-right', r).css('margin-right', `${parseFloat(i) + e._scrollbarWidth}px`); }); const t = document.body.style.paddingRight; const n = We(document.body).css('padding-right'); We(document.body).data('padding-right', t).css('padding-right', `${parseFloat(n) + this._scrollbarWidth}px`); } }, t._resetScrollbar = function () { We(it.FIXED_CONTENT).each((e, t) => { const n = We(t).data('padding-right'); typeof n !== 'undefined' && We(t).css('padding-right', n).removeData('padding-right'); }), We(`${it.STICKY_CONTENT}, ${it.NAVBAR_TOGGLER}`).each((e, t) => { const n = We(t).data('margin-right'); typeof n !== 'undefined' && We(t).css('margin-right', n).removeData('margin-right'); }); const e = We(document.body).data('padding-right'); typeof e !== 'undefined' && We(document.body).css('padding-right', e).removeData('padding-right'); }, t._getScrollbarWidth = function () { const e = document.createElement('div'); e.className = Qe, document.body.appendChild(e); const t = e.getBoundingClientRect().width - e.clientWidth; return document.body.removeChild(e), t; }, e._jQueryInterface = function (t, n) { return this.each(function () { let r = We(this).data(Ge); const i = o({}, Xe, We(this).data(), typeof t === 'object' && t ? t : {}); if (r || (r = new e(this, i), We(this).data(Ge, r)), typeof t === 'string') { if (typeof r[t] === 'undefined') throw new TypeError(`No method named "${t}"`); r[t](n); } else i.show && r.show(n); }); }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }, { key: 'Default', get() { return Xe; } }]), e; }()), We(document).on(Je.CLICK_DATA_API, it.DATA_TOGGLE, function (e) { let t; const n = this; const r = wn.getSelectorFromElement(this); r && (t = We(r)[0]); const i = We(t).data(Ge) ? 'toggle' : o({}, We(t).data(), We(this).data()); this.tagName !== 'A' && this.tagName !== 'AREA' || e.preventDefault(); var a = We(t).one(Je.SHOW, (e) => { e.isDefaultPrevented() || a.one(Je.HIDDEN, () => { We(n).is(':visible') && n.focus(); }); }); ot._jQueryInterface.call(We(t), i, this); }), We.fn[$e] = ot._jQueryInterface, We.fn[$e].Constructor = ot, We.fn[$e].noConflict = function () { return We.fn[$e] = Ke, ot._jQueryInterface; }, ot); const On = (st = 'tooltip', ut = `.${lt = 'bs.tooltip'}`, ct = (at = t).fn[st], pt = 'bs-tooltip', ft = new RegExp(`(^|\\s)${pt}\\S+`, 'g'), mt = {
      animation: !0,
      template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
      trigger: 'hover focus',
      title: '',
      delay: 0,
      html: !(dt = {
        AUTO: 'auto', TOP: 'top', RIGHT: 'right', BOTTOM: 'bottom', LEFT: 'left',
      }),
      selector: !(ht = {
        animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(number|string)', container: '(string|element|boolean)', fallbackPlacement: '(string|array)', boundary: '(string|element)',
      }),
      placement: 'top',
      offset: 0,
      container: !1,
      fallbackPlacement: 'flip',
      boundary: 'scrollParent',
    }, yt = 'out', vt = {
      HIDE: `hide${ut}`, HIDDEN: `hidden${ut}`, SHOW: (gt = 'show') + ut, SHOWN: `shown${ut}`, INSERTED: `inserted${ut}`, CLICK: `click${ut}`, FOCUSIN: `focusin${ut}`, FOCUSOUT: `focusout${ut}`, MOUSEENTER: `mouseenter${ut}`, MOUSELEAVE: `mouseleave${ut}`,
    }, _t = 'fade', bt = 'show', xt = '.tooltip-inner', wt = '.arrow', Et = 'hover', Tt = 'focus', kt = 'click', Ct = 'manual', St = (function () {
      function e(e, t) { if (typeof n === 'undefined') throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)'); this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this.element = e, this.config = this._getConfig(t), this.tip = null, this._setListeners(); } const t = e.prototype; return t.enable = function () { this._isEnabled = !0; }, t.disable = function () { this._isEnabled = !1; }, t.toggleEnabled = function () { this._isEnabled = !this._isEnabled; }, t.toggle = function (e) { if (this._isEnabled) if (e) { const t = this.constructor.DATA_KEY; let n = at(e.currentTarget).data(t); n || (n = new this.constructor(e.currentTarget, this._getDelegateConfig()), at(e.currentTarget).data(t, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n); } else { if (at(this.getTipElement()).hasClass(bt)) return void this._leave(null, this); this._enter(null, this); } }, t.dispose = function () { clearTimeout(this._timeout), at.removeData(this.element, this.constructor.DATA_KEY), at(this.element).off(this.constructor.EVENT_KEY), at(this.element).closest('.modal').off('hide.bs.modal'), this.tip && at(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null; }, t.show = function () {
        const e = this; if (at(this.element).css('display') === 'none') throw new Error('Please use show on visible elements'); const t = at.Event(this.constructor.Event.SHOW); if (this.isWithContent() && this._isEnabled) {
          at(this.element).trigger(t); const r = at.contains(this.element.ownerDocument.documentElement, this.element); if (t.isDefaultPrevented() || !r) return; const i = this.getTipElement(); const o = wn.getUID(this.constructor.NAME); i.setAttribute('id', o), this.element.setAttribute('aria-describedby', o), this.setContent(), this.config.animation && at(i).addClass(_t); const a = typeof this.config.placement === 'function' ? this.config.placement.call(this, i, this.element) : this.config.placement; const s = this._getAttachment(a); this.addAttachmentClass(s); const l = !1 === this.config.container ? document.body : at(this.config.container); at(i).data(this.constructor.DATA_KEY, this), at.contains(this.element.ownerDocument.documentElement, this.tip) || at(i).appendTo(l), at(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new n(this.element, i, {
            placement: s,
            modifiers: {
              offset: { offset: this.config.offset }, flip: { behavior: this.config.fallbackPlacement }, arrow: { element: wt }, preventOverflow: { boundariesElement: this.config.boundary },
            },
            onCreate(t) { t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t); },
            onUpdate(t) { e._handlePopperPlacementChange(t); },
          }), at(i).addClass(bt), 'ontouchstart' in document.documentElement && at(document.body).children().on('mouseover', null, at.noop); const u = function () { e.config.animation && e._fixTransition(); const t = e._hoverState; e._hoverState = null, at(e.element).trigger(e.constructor.Event.SHOWN), t === yt && e._leave(null, e); }; if (at(this.tip).hasClass(_t)) { const c = wn.getTransitionDurationFromElement(this.tip); at(this.tip).one(wn.TRANSITION_END, u).emulateTransitionEnd(c); } else u();
        }
      }, t.hide = function (e) { const t = this; const n = this.getTipElement(); const r = at.Event(this.constructor.Event.HIDE); const i = function () { t._hoverState !== gt && n.parentNode && n.parentNode.removeChild(n), t._cleanTipClass(), t.element.removeAttribute('aria-describedby'), at(t.element).trigger(t.constructor.Event.HIDDEN), t._popper !== null && t._popper.destroy(), e && e(); }; if (at(this.element).trigger(r), !r.isDefaultPrevented()) { if (at(n).removeClass(bt), 'ontouchstart' in document.documentElement && at(document.body).children().off('mouseover', null, at.noop), this._activeTrigger[kt] = !1, this._activeTrigger[Tt] = !1, this._activeTrigger[Et] = !1, at(this.tip).hasClass(_t)) { const o = wn.getTransitionDurationFromElement(n); at(n).one(wn.TRANSITION_END, i).emulateTransitionEnd(o); } else i(); this._hoverState = ''; } }, t.update = function () { this._popper !== null && this._popper.scheduleUpdate(); }, t.isWithContent = function () { return Boolean(this.getTitle()); }, t.addAttachmentClass = function (e) { at(this.getTipElement()).addClass(`${pt}-${e}`); }, t.getTipElement = function () { return this.tip = this.tip || at(this.config.template)[0], this.tip; }, t.setContent = function () { const e = at(this.getTipElement()); this.setElementContent(e.find(xt), this.getTitle()), e.removeClass(`${_t} ${bt}`); }, t.setElementContent = function (e, t) { const n = this.config.html; typeof t === 'object' && (t.nodeType || t.jquery) ? n ? at(t).parent().is(e) || e.empty().append(t) : e.text(at(t).text()) : e[n ? 'html' : 'text'](t); }, t.getTitle = function () { let e = this.element.getAttribute('data-original-title'); return e || (e = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title), e; }, t._getAttachment = function (e) { return dt[e.toUpperCase()]; }, t._setListeners = function () { const e = this; this.config.trigger.split(' ').forEach((t) => { if (t === 'click')at(e.element).on(e.constructor.Event.CLICK, e.config.selector, t => e.toggle(t)); else if (t !== Ct) { const n = t === Et ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN; const r = t === Et ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT; at(e.element).on(n, e.config.selector, t => e._enter(t)).on(r, e.config.selector, t => e._leave(t)); }at(e.element).closest('.modal').on('hide.bs.modal', () => e.hide()); }), this.config.selector ? this.config = o({}, this.config, { trigger: 'manual', selector: '' }) : this._fixTitle(); }, t._fixTitle = function () { const e = typeof this.element.getAttribute('data-original-title'); (this.element.getAttribute('title') || e !== 'string') && (this.element.setAttribute('data-original-title', this.element.getAttribute('title') || ''), this.element.setAttribute('title', '')); }, t._enter = function (e, t) { const n = this.constructor.DATA_KEY; (t = t || at(e.currentTarget).data(n)) || (t = new this.constructor(e.currentTarget, this._getDelegateConfig()), at(e.currentTarget).data(n, t)), e && (t._activeTrigger[e.type === 'focusin' ? Tt : Et] = !0), at(t.getTipElement()).hasClass(bt) || t._hoverState === gt ? t._hoverState = gt : (clearTimeout(t._timeout), t._hoverState = gt, t.config.delay && t.config.delay.show ? t._timeout = setTimeout(() => { t._hoverState === gt && t.show(); }, t.config.delay.show) : t.show()); }, t._leave = function (e, t) { const n = this.constructor.DATA_KEY; (t = t || at(e.currentTarget).data(n)) || (t = new this.constructor(e.currentTarget, this._getDelegateConfig()), at(e.currentTarget).data(n, t)), e && (t._activeTrigger[e.type === 'focusout' ? Tt : Et] = !1), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = yt, t.config.delay && t.config.delay.hide ? t._timeout = setTimeout(() => { t._hoverState === yt && t.hide(); }, t.config.delay.hide) : t.hide()); }, t._isWithActiveTrigger = function () { for (const e in this._activeTrigger) if (this._activeTrigger[e]) return !0; return !1; }, t._getConfig = function (e) { return typeof (e = o({}, this.constructor.Default, at(this.element).data(), typeof e === 'object' && e ? e : {})).delay === 'number' && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title === 'number' && (e.title = e.title.toString()), typeof e.content === 'number' && (e.content = e.content.toString()), wn.typeCheckConfig(st, e, this.constructor.DefaultType), e; }, t._getDelegateConfig = function () { const e = {}; if (this.config) for (const t in this.config) this.constructor.Default[t] !== this.config[t] && (e[t] = this.config[t]); return e; }, t._cleanTipClass = function () { const e = at(this.getTipElement()); const t = e.attr('class').match(ft); t !== null && t.length > 0 && e.removeClass(t.join('')); }, t._handlePopperPlacementChange = function (e) { this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(e.placement)); }, t._fixTransition = function () { const e = this.getTipElement(); const t = this.config.animation; e.getAttribute('x-placement') === null && (at(e).removeClass(_t), this.config.animation = !1, this.hide(), this.show(), this.config.animation = t); }, e._jQueryInterface = function (t) { return this.each(function () { let n = at(this).data(lt); const r = typeof t === 'object' && t; if ((n || !/dispose|hide/.test(t)) && (n || (n = new e(this, r), at(this).data(lt, n)), typeof t === 'string')) { if (typeof n[t] === 'undefined') throw new TypeError(`No method named "${t}"`); n[t](); } }); }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }, { key: 'Default', get() { return mt; } }, { key: 'NAME', get() { return st; } }, { key: 'DATA_KEY', get() { return lt; } }, { key: 'Event', get() { return vt; } }, { key: 'EVENT_KEY', get() { return ut; } }, { key: 'DefaultType', get() { return ht; } }]), e;
    }()), at.fn[st] = St._jQueryInterface, at.fn[st].Constructor = St, at.fn[st].noConflict = function () { return at.fn[st] = ct, St._jQueryInterface; }, St); const In = (Ot = 'popover', Pt = `.${It = 'bs.popover'}`, Mt = (At = t).fn[Ot], Nt = 'bs-popover', Dt = new RegExp(`(^|\\s)${Nt}\\S+`, 'g'), Lt = o({}, On.Default, {
      placement: 'right', trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    }), zt = o({}, On.DefaultType, { content: '(string|element|function)' }), Rt = 'fade', Bt = '.popover-header', Ft = '.popover-body', Ut = {
      HIDE: `hide${Pt}`, HIDDEN: `hidden${Pt}`, SHOW: (jt = 'show') + Pt, SHOWN: `shown${Pt}`, INSERTED: `inserted${Pt}`, CLICK: `click${Pt}`, FOCUSIN: `focusin${Pt}`, FOCUSOUT: `focusout${Pt}`, MOUSEENTER: `mouseenter${Pt}`, MOUSELEAVE: `mouseleave${Pt}`,
    }, Vt = (function (e) { function t() { return e.apply(this, arguments) || this; } let n; let r; r = e, (n = t).prototype = Object.create(r.prototype), (n.prototype.constructor = n).__proto__ = r; const o = t.prototype; return o.isWithContent = function () { return this.getTitle() || this._getContent(); }, o.addAttachmentClass = function (e) { At(this.getTipElement()).addClass(`${Nt}-${e}`); }, o.getTipElement = function () { return this.tip = this.tip || At(this.config.template)[0], this.tip; }, o.setContent = function () { const e = At(this.getTipElement()); this.setElementContent(e.find(Bt), this.getTitle()); let t = this._getContent(); typeof t === 'function' && (t = t.call(this.element)), this.setElementContent(e.find(Ft), t), e.removeClass(`${Rt} ${jt}`); }, o._getContent = function () { return this.element.getAttribute('data-content') || this.config.content; }, o._cleanTipClass = function () { const e = At(this.getTipElement()); const t = e.attr('class').match(Dt); t !== null && t.length > 0 && e.removeClass(t.join('')); }, t._jQueryInterface = function (e) { return this.each(function () { let n = At(this).data(It); const r = typeof e === 'object' ? e : null; if ((n || !/destroy|hide/.test(e)) && (n || (n = new t(this, r), At(this).data(It, n)), typeof e === 'string')) { if (typeof n[e] === 'undefined') throw new TypeError(`No method named "${e}"`); n[e](); } }); }, i(t, null, [{ key: 'VERSION', get() { return '4.1.1'; } }, { key: 'Default', get() { return Lt; } }, { key: 'NAME', get() { return Ot; } }, { key: 'DATA_KEY', get() { return It; } }, { key: 'Event', get() { return Ut; } }, { key: 'EVENT_KEY', get() { return Pt; } }, { key: 'DefaultType', get() { return zt; } }]), t; }(On)), At.fn[Ot] = Vt._jQueryInterface, At.fn[Ot].Constructor = Vt, At.fn[Ot].noConflict = function () { return At.fn[Ot] = Mt, Vt._jQueryInterface; }, Vt); const Pn = (Ht = 'scrollspy', $t = `.${Wt = 'bs.scrollspy'}`, Gt = (qt = t).fn[Ht], Zt = { offset: 10, method: 'auto', target: '' }, Kt = { offset: 'number', method: 'string', target: '(string|element)' }, Xt = { ACTIVATE: `activate${$t}`, SCROLL: `scroll${$t}`, LOAD_DATA_API: `load${$t}.data-api` }, Yt = 'dropdown-item', Jt = 'active', Qt = {
      DATA_SPY: '[data-spy="scroll"]', ACTIVE: '.active', NAV_LIST_GROUP: '.nav, .list-group', NAV_LINKS: '.nav-link', NAV_ITEMS: '.nav-item', LIST_ITEMS: '.list-group-item', DROPDOWN: '.dropdown', DROPDOWN_ITEMS: '.dropdown-item', DROPDOWN_TOGGLE: '.dropdown-toggle',
    }, en = 'offset', tn = 'position', nn = (function () {
      function e(e, t) { const n = this; this._element = e, this._scrollElement = e.tagName === 'BODY' ? window : e, this._config = this._getConfig(t), this._selector = `${this._config.target} ${Qt.NAV_LINKS},${this._config.target} ${Qt.LIST_ITEMS},${this._config.target} ${Qt.DROPDOWN_ITEMS}`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, qt(this._scrollElement).on(Xt.SCROLL, e => n._process(e)), this.refresh(), this._process(); } const t = e.prototype; return t.refresh = function () {
        const e = this; const t = this._scrollElement === this._scrollElement.window ? en : tn; const n = this._config.method === 'auto' ? t : this._config.method; const r = n === tn ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), qt.makeArray(qt(this._selector)).map((e) => { let t; const i = wn.getSelectorFromElement(e); if (i && (t = qt(i)[0]), t) { const o = t.getBoundingClientRect(); if (o.width || o.height) return [qt(t)[n]().top + r, i]; } return null; }).filter(e => e).sort((e, t) => e[0] - t[0])
          .forEach((t) => { e._offsets.push(t[0]), e._targets.push(t[1]); });
      }, t.dispose = function () { qt.removeData(this._element, Wt), qt(this._scrollElement).off($t), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null; }, t._getConfig = function (e) { if (typeof (e = o({}, Zt, typeof e === 'object' && e ? e : {})).target !== 'string') { let t = qt(e.target).attr('id'); t || (t = wn.getUID(Ht), qt(e.target).attr('id', t)), e.target = `#${t}`; } return wn.typeCheckConfig(Ht, e, Kt), e; }, t._getScrollTop = function () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop; }, t._getScrollHeight = function () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight); }, t._getOffsetHeight = function () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height; }, t._process = function () { const e = this._getScrollTop() + this._config.offset; const t = this._getScrollHeight(); const n = this._config.offset + t - this._getOffsetHeight(); if (this._scrollHeight !== t && this.refresh(), n <= e) { const r = this._targets[this._targets.length - 1]; this._activeTarget !== r && this._activate(r); } else { if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let i = this._offsets.length; i--;) this._activeTarget !== this._targets[i] && e >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || e < this._offsets[i + 1]) && this._activate(this._targets[i]); } }, t._activate = function (e) { this._activeTarget = e, this._clear(); let t = this._selector.split(','); t = t.map(t => `${t}[data-target="${e}"],${t}[href="${e}"]`); const n = qt(t.join(',')); n.hasClass(Yt) ? (n.closest(Qt.DROPDOWN).find(Qt.DROPDOWN_TOGGLE).addClass(Jt), n.addClass(Jt)) : (n.addClass(Jt), n.parents(Qt.NAV_LIST_GROUP).prev(`${Qt.NAV_LINKS}, ${Qt.LIST_ITEMS}`).addClass(Jt), n.parents(Qt.NAV_LIST_GROUP).prev(Qt.NAV_ITEMS).children(Qt.NAV_LINKS).addClass(Jt)), qt(this._scrollElement).trigger(Xt.ACTIVATE, { relatedTarget: e }); }, t._clear = function () { qt(this._selector).filter(Qt.ACTIVE).removeClass(Jt); }, e._jQueryInterface = function (t) { return this.each(function () { let n = qt(this).data(Wt); if (n || (n = new e(this, typeof t === 'object' && t), qt(this).data(Wt, n)), typeof t === 'string') { if (typeof n[t] === 'undefined') throw new TypeError(`No method named "${t}"`); n[t](); } }); }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }, { key: 'Default', get() { return Zt; } }]), e;
    }()), qt(window).on(Xt.LOAD_DATA_API, () => { for (let e = qt.makeArray(qt(Qt.DATA_SPY)), t = e.length; t--;) { const n = qt(e[t]); nn._jQueryInterface.call(n, n.data()); } }), qt.fn[Ht] = nn._jQueryInterface, qt.fn[Ht].Constructor = nn, qt.fn[Ht].noConflict = function () { return qt.fn[Ht] = Gt, nn._jQueryInterface; }, nn); const Mn = (an = `.${on = 'bs.tab'}`, sn = (rn = t).fn.tab, ln = {
      HIDE: `hide${an}`, HIDDEN: `hidden${an}`, SHOW: `show${an}`, SHOWN: `shown${an}`, CLICK_DATA_API: `click${an}.data-api`,
    }, un = 'dropdown-menu', cn = 'active', pn = 'disabled', fn = 'fade', hn = 'show', dn = '.dropdown', mn = '.nav, .list-group', gn = '.active', yn = '> li > .active', vn = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', _n = '.dropdown-toggle', bn = '> .dropdown-menu .active', xn = (function () { function e(e) { this._element = e; } const t = e.prototype; return t.show = function () { const e = this; if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && rn(this._element).hasClass(cn) || rn(this._element).hasClass(pn))) { let t; let n; const r = rn(this._element).closest(mn)[0]; const i = wn.getSelectorFromElement(this._element); if (r) { const o = r.nodeName === 'UL' ? yn : gn; n = (n = rn.makeArray(rn(r).find(o)))[n.length - 1]; } const a = rn.Event(ln.HIDE, { relatedTarget: this._element }); const s = rn.Event(ln.SHOW, { relatedTarget: n }); if (n && rn(n).trigger(a), rn(this._element).trigger(s), !s.isDefaultPrevented() && !a.isDefaultPrevented()) { i && (t = rn(i)[0]), this._activate(this._element, r); const l = function () { const t = rn.Event(ln.HIDDEN, { relatedTarget: e._element }); const r = rn.Event(ln.SHOWN, { relatedTarget: n }); rn(n).trigger(t), rn(e._element).trigger(r); }; t ? this._activate(t, t.parentNode, l) : l(); } } }, t.dispose = function () { rn.removeData(this._element, on), this._element = null; }, t._activate = function (e, t, n) { const r = this; const i = (t.nodeName === 'UL' ? rn(t).find(yn) : rn(t).children(gn))[0]; const o = n && i && rn(i).hasClass(fn); const a = function () { return r._transitionComplete(e, i, n); }; if (i && o) { const s = wn.getTransitionDurationFromElement(i); rn(i).one(wn.TRANSITION_END, a).emulateTransitionEnd(s); } else a(); }, t._transitionComplete = function (e, t, n) { if (t) { rn(t).removeClass(`${hn} ${cn}`); const r = rn(t.parentNode).find(bn)[0]; r && rn(r).removeClass(cn), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !1); } if (rn(e).addClass(cn), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !0), wn.reflow(e), rn(e).addClass(hn), e.parentNode && rn(e.parentNode).hasClass(un)) { const i = rn(e).closest(dn)[0]; i && rn(i).find(_n).addClass(cn), e.setAttribute('aria-expanded', !0); }n && n(); }, e._jQueryInterface = function (t) { return this.each(function () { const n = rn(this); let r = n.data(on); if (r || (r = new e(this), n.data(on, r)), typeof t === 'string') { if (typeof r[t] === 'undefined') throw new TypeError(`No method named "${t}"`); r[t](); } }); }, i(e, null, [{ key: 'VERSION', get() { return '4.1.1'; } }]), e; }()), rn(document).on(ln.CLICK_DATA_API, vn, function (e) { e.preventDefault(), xn._jQueryInterface.call(rn(this), 'show'); }), rn.fn.tab = xn._jQueryInterface, rn.fn.tab.Constructor = xn, rn.fn.tab.noConflict = function () { return rn.fn.tab = sn, xn._jQueryInterface; }, xn); !(function (e) { if (typeof e === 'undefined') throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript."); const t = e.fn.jquery.split(' ')[0].split('.'); if (t[0] < 2 && t[1] < 9 || t[0] === 1 && t[1] === 9 && t[2] < 1 || t[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0"); }(t)), e.Util = wn, e.Alert = En, e.Button = Tn, e.Carousel = kn, e.Collapse = Cn, e.Dropdown = Sn, e.Modal = An, e.Popover = In, e.Scrollspy = Pn, e.Tab = Mn, e.Tooltip = On, Object.defineProperty(e, '__esModule', { value: !0 });
  }));
}, function (e, t, n) {
  let r; let i; !(function (t, n) {
    typeof e === 'object' && typeof e.exports === 'object' ? e.exports = t.document ? n(t, !0) : function (e) { if (!e.document) throw new Error('jQuery requires a window with a document'); return n(e); } : n(t);
  }(typeof window !== 'undefined' ? window : this, (n, o) => {
    function a(e, t, n) { t = t || ce; let r; const i = t.createElement('script'); if (i.text = e, n) for (r in Te)n[r] && (i[r] = n[r]); t.head.appendChild(i).parentNode.removeChild(i); } function s(e) { return e == null ? `${e}` : typeof e === 'object' || typeof e === 'function' ? ge[ye.call(e)] || 'object' : typeof e; } function l(e) { const t = !!e && 'length' in e && e.length; const n = s(e); return !we(e) && !Ee(e) && (n === 'array' || t === 0 || typeof t === 'number' && t > 0 && t - 1 in e); } function u(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase(); } function c(e, t, n) { return we(t) ? ke.grep(e, (e, r) => !!t.call(e, r, e) !== n) : t.nodeType ? ke.grep(e, e => e === t !== n) : typeof t !== 'string' ? ke.grep(e, e => me.call(t, e) > -1 !== n) : ke.filter(t, e, n); } function p(e, t) { for (;(e = e[t]) && e.nodeType !== 1;);return e; } function f(e) { const t = {}; return ke.each(e.match(ze) || [], (e, n) => { t[n] = !0; }), t; } function h(e) { return e; } function d(e) { throw e; } function m(e, t, n, r) { let i; try { e && we(i = e.promise) ? i.call(e).done(t).fail(n) : e && we(i = e.then) ? i.call(e, t, n) : t(...[e].slice(r)); } catch (e) { n.apply(void 0, [e]); } } function g() { ce.removeEventListener('DOMContentLoaded', g), n.removeEventListener('load', g), ke.ready(); } function y(e, t) { return t.toUpperCase(); } function v(e) { return e.replace(Fe, 'ms-').replace(Ue, y); } function _() { this.expando = ke.expando + _.uid++; } function b(e) { return e === 'true' || e !== 'false' && (e === 'null' ? null : e === `${+e}` ? +e : We.test(e) ? JSON.parse(e) : e); } function x(e, t, n) { let r; if (void 0 === n && e.nodeType === 1) if (r = `data-${t.replace($e, '-$&').toLowerCase()}`, typeof (n = e.getAttribute(r)) === 'string') { try { n = b(n); } catch (e) {}He.set(e, t, n); } else n = void 0; return n; } function w(e, t, n, r) { let i; let o; let a = 20; const s = r ? function () { return r.cur(); } : function () { return ke.css(e, t, ''); }; let l = s(); let u = n && n[3] || (ke.cssNumber[t] ? '' : 'px'); let c = (ke.cssNumber[t] || u !== 'px' && +l) && Ze.exec(ke.css(e, t)); if (c && c[3] !== u) { for (l /= 2, u = u || c[3], c = +l || 1; a--;)ke.style(e, t, c + u), (1 - o) * (1 - (o = s() / l || 0.5)) <= 0 && (a = 0), c /= o; c *= 2, ke.style(e, t, c + u), n = n || []; } return n && (c = +c || +l || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = u, r.start = c, r.end = i)), i; } function E(e) { let t; const n = e.ownerDocument; const r = e.nodeName; let i = Je[r]; return i || (t = n.body.appendChild(n.createElement(r)), i = ke.css(t, 'display'), t.parentNode.removeChild(t), i === 'none' && (i = 'block'), Je[r] = i, i); } function T(e, t) { for (var n, r, i = [], o = 0, a = e.length; o < a; o++)r = e[o], r.style && (n = r.style.display, t ? (n === 'none' && (i[o] = qe.get(r, 'display') || null, i[o] || (r.style.display = '')), r.style.display === '' && Xe(r) && (i[o] = E(r))) : n !== 'none' && (i[o] = 'none', qe.set(r, 'display', n))); for (o = 0; o < a; o++)i[o] != null && (e[o].style.display = i[o]); return e; } function k(e, t) { let n; return n = typeof e.getElementsByTagName !== 'undefined' ? e.getElementsByTagName(t || '*') : typeof e.querySelectorAll !== 'undefined' ? e.querySelectorAll(t || '*') : [], void 0 === t || t && u(e, t) ? ke.merge([e], n) : n; } function C(e, t) { for (let n = 0, r = e.length; n < r; n++)qe.set(e[n], 'globalEval', !t || qe.get(t[n], 'globalEval')); } function S(e, t, n, r, i) { for (var o, a, l, u, c, p, f = t.createDocumentFragment(), h = [], d = 0, m = e.length; d < m; d++) if ((o = e[d]) || o === 0) if (s(o) === 'object')ke.merge(h, o.nodeType ? [o] : o); else if (rt.test(o)) { for (a = a || f.appendChild(t.createElement('div')), l = (et.exec(o) || ['', ''])[1].toLowerCase(), u = nt[l] || nt._default, a.innerHTML = u[1] + ke.htmlPrefilter(o) + u[2], p = u[0]; p--;)a = a.lastChild; ke.merge(h, a.childNodes), a = f.firstChild, a.textContent = ''; } else h.push(t.createTextNode(o)); for (f.textContent = '', d = 0; o = h[d++];) if (r && ke.inArray(o, r) > -1)i && i.push(o); else if (c = ke.contains(o.ownerDocument, o), a = k(f.appendChild(o), 'script'), c && C(a), n) for (p = 0; o = a[p++];)tt.test(o.type || '') && n.push(o); return f; } function A() { return !0; } function O() { return !1; } function I() { try { return ce.activeElement; } catch (e) {} } function P(e, t, n, r, i, o) { let a; let s; if (typeof t === 'object') { typeof n !== 'string' && (r = r || n, n = void 0); for (s in t)P(e, s, n, r, t[s], o); return e; } if (r == null && i == null ? (i = n, r = n = void 0) : i == null && (typeof n === 'string' ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i)i = O; else if (!i) return e; return o === 1 && (a = i, i = function (e) { return ke().off(e), a.apply(this, arguments); }, i.guid = a.guid || (a.guid = ke.guid++)), e.each(function () { ke.event.add(this, t, i, r, n); }); } function M(e, t) { return u(e, 'table') && u(t.nodeType !== 11 ? t : t.firstChild, 'tr') ? ke(e).children('tbody')[0] || e : e; } function N(e) { return e.type = `${e.getAttribute('type') !== null}/${e.type}`, e; } function D(e) { return (e.type || '').slice(0, 5) === 'true/' ? e.type = e.type.slice(5) : e.removeAttribute('type'), e; } function L(e, t) { let n; let r; let i; let o; let a; let s; let l; let u; if (t.nodeType === 1) { if (qe.hasData(e) && (o = qe.access(e), a = qe.set(t, o), u = o.events)) { delete a.handle, a.events = {}; for (i in u) for (n = 0, r = u[i].length; n < r; n++)ke.event.add(t, i, u[i][n]); }He.hasData(e) && (s = He.access(e), l = ke.extend({}, s), He.set(t, l)); } } function z(e, t) { const n = t.nodeName.toLowerCase(); n === 'input' && Qe.test(e.type) ? t.checked = e.checked : n !== 'input' && n !== 'textarea' || (t.defaultValue = e.defaultValue); } function R(e, t, n, r) { t = he.apply([], t); let i; let o; let s; let l; let u; let c; let p = 0; const f = e.length; const h = f - 1; const d = t[0]; const m = we(d); if (m || f > 1 && typeof d === 'string' && !xe.checkClone && ct.test(d)) return e.each(function (i) { const o = e.eq(i); m && (t[0] = d.call(this, i, o.html())), R(o, t, n, r); }); if (f && (i = S(t, e[0].ownerDocument, !1, e, r), o = i.firstChild, i.childNodes.length === 1 && (i = o), o || r)) { for (s = ke.map(k(i, 'script'), N), l = s.length; p < f; p++)u = i, p !== h && (u = ke.clone(u, !0, !0), l && ke.merge(s, k(u, 'script'))), n.call(e[p], u, p); if (l) for (c = s[s.length - 1].ownerDocument, ke.map(s, D), p = 0; p < l; p++)u = s[p], tt.test(u.type || '') && !qe.access(u, 'globalEval') && ke.contains(c, u) && (u.src && (u.type || '').toLowerCase() !== 'module' ? ke._evalUrl && ke._evalUrl(u.src) : a(u.textContent.replace(pt, ''), c, u)); } return e; } function j(e, t, n) { for (var r, i = t ? ke.filter(t, e) : e, o = 0; (r = i[o]) != null; o++)n || r.nodeType !== 1 || ke.cleanData(k(r)), r.parentNode && (n && ke.contains(r.ownerDocument, r) && C(k(r, 'script')), r.parentNode.removeChild(r)); return e; } function B(e, t, n) { let r; let i; let o; let a; const s = e.style; return n = n || ht(e), n && (a = n.getPropertyValue(t) || n[t], a !== '' || ke.contains(e.ownerDocument, e) || (a = ke.style(e, t)), !xe.pixelBoxStyles() && ft.test(a) && dt.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? `${a}` : a; } function F(e, t) { return { get() { return e() ? void delete this.get : (this.get = t).apply(this, arguments); } }; } function U(e) { if (e in bt) return e; for (let t = e[0].toUpperCase() + e.slice(1), n = _t.length; n--;) if ((e = _t[n] + t) in bt) return e; } function V(e) { let t = ke.cssProps[e]; return t || (t = ke.cssProps[e] = U(e) || e), t; } function q(e, t, n) { const r = Ze.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || 'px') : t; } function H(e, t, n, r, i, o) { let a = t === 'width' ? 1 : 0; let s = 0; let l = 0; if (n === (r ? 'border' : 'content')) return 0; for (;a < 4; a += 2)n === 'margin' && (l += ke.css(e, n + Ke[a], !0, i)), r ? (n === 'content' && (l -= ke.css(e, `padding${Ke[a]}`, !0, i)), n !== 'margin' && (l -= ke.css(e, `border${Ke[a]}Width`, !0, i))) : (l += ke.css(e, `padding${Ke[a]}`, !0, i), n !== 'padding' ? l += ke.css(e, `border${Ke[a]}Width`, !0, i) : s += ke.css(e, `border${Ke[a]}Width`, !0, i)); return !r && o >= 0 && (l += Math.max(0, Math.ceil(e[`offset${t[0].toUpperCase()}${t.slice(1)}`] - o - l - s - 0.5))), l; } function W(e, t, n) { const r = ht(e); let i = B(e, t, r); const o = ke.css(e, 'boxSizing', !1, r) === 'border-box'; let a = o; if (ft.test(i)) { if (!n) return i; i = 'auto'; } return a = a && (xe.boxSizingReliable() || i === e.style[t]), (i === 'auto' || !parseFloat(i) && ke.css(e, 'display', !1, r) === 'inline') && (i = e[`offset${t[0].toUpperCase()}${t.slice(1)}`], a = !0), `${(i = parseFloat(i) || 0) + H(e, t, n || (o ? 'border' : 'content'), a, r, i)}px`; } function $(e, t, n, r, i) { return new $.prototype.init(e, t, n, r, i); } function G() { wt && (!1 === ce.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(G) : n.setTimeout(G, ke.fx.interval), ke.fx.tick()); } function Z() { return n.setTimeout(() => { xt = void 0; }), xt = Date.now(); } function K(e, t) { let n; let r = 0; const i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)n = Ke[r], i[`margin${n}`] = i[`padding${n}`] = e; return t && (i.opacity = i.width = e), i; } function X(e, t, n) { for (var r, i = (Q.tweeners[t] || []).concat(Q.tweeners['*']), o = 0, a = i.length; o < a; o++) if (r = i[o].call(n, t, e)) return r; } function Y(e, t, n) { let r; let i; let o; let a; let s; let l; let u; let c; const p = 'width' in t || 'height' in t; const f = this; const h = {}; const d = e.style; let m = e.nodeType && Xe(e); let g = qe.get(e, 'fxshow'); n.queue || (a = ke._queueHooks(e, 'fx'), a.unqueued == null && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s(); }), a.unqueued++, f.always(() => { f.always(() => { a.unqueued--, ke.queue(e, 'fx').length || a.empty.fire(); }); })); for (r in t) if (i = t[r], Et.test(i)) { if (delete t[r], o = o || i === 'toggle', i === (m ? 'hide' : 'show')) { if (i !== 'show' || !g || void 0 === g[r]) continue; m = !0; }h[r] = g && g[r] || ke.style(e, r); } if ((l = !ke.isEmptyObject(t)) || !ke.isEmptyObject(h)) { p && e.nodeType === 1 && (n.overflow = [d.overflow, d.overflowX, d.overflowY], u = g && g.display, u == null && (u = qe.get(e, 'display')), c = ke.css(e, 'display'), c === 'none' && (u ? c = u : (T([e], !0), u = e.style.display || u, c = ke.css(e, 'display'), T([e]))), (c === 'inline' || c === 'inline-block' && u != null) && ke.css(e, 'float') === 'none' && (l || (f.done(() => { d.display = u; }), u == null && (c = d.display, u = c === 'none' ? '' : c)), d.display = 'inline-block')), n.overflow && (d.overflow = 'hidden', f.always(() => { d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2]; })), l = !1; for (r in h)l || (g ? 'hidden' in g && (m = g.hidden) : g = qe.access(e, 'fxshow', { display: u }), o && (g.hidden = !m), m && T([e], !0), f.done(() => { m || T([e]), qe.remove(e, 'fxshow'); for (r in h)ke.style(e, r, h[r]); })), l = X(m ? g[r] : 0, r, f), r in g || (g[r] = l.start, m && (l.end = l.start, l.start = 0)); } } function J(e, t) { let n; let r; let i; let o; let a; for (n in e) if (r = v(n), i = t[r], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = ke.cssHooks[r]) && 'expand' in a) { o = a.expand(o), delete e[r]; for (n in o)n in e || (e[n] = o[n], t[n] = i); } else t[r] = i; } function Q(e, t, n) {
      let r; let i; let o = 0; const a = Q.prefilters.length; const s = ke.Deferred().always(() => { delete l.elem; }); var l = function () { if (i) return !1; for (var t = xt || Z(), n = Math.max(0, u.startTime + u.duration - t), r = n / u.duration || 0, o = 1 - r, a = 0, l = u.tweens.length; a < l; a++)u.tweens[a].run(o); return s.notifyWith(e, [u, o, n]), o < 1 && l ? n : (l || s.notifyWith(e, [u, 1, 0]), s.resolveWith(e, [u]), !1); }; var u = s.promise({
        elem: e, props: ke.extend({}, t), opts: ke.extend(!0, { specialEasing: {}, easing: ke.easing._default }, n), originalProperties: t, originalOptions: n, startTime: xt || Z(), duration: n.duration, tweens: [], createTween(t, n) { const r = ke.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing); return u.tweens.push(r), r; }, stop(t) { let n = 0; const r = t ? u.tweens.length : 0; if (i) return this; for (i = !0; n < r; n++)u.tweens[n].run(1); return t ? (s.notifyWith(e, [u, 1, 0]), s.resolveWith(e, [u, t])) : s.rejectWith(e, [u, t]), this; },
      }); const c = u.props; for (J(c, u.opts.specialEasing); o < a; o++) if (r = Q.prefilters[o].call(u, e, c, u.opts)) return we(r.stop) && (ke._queueHooks(u.elem, u.opts.queue).stop = r.stop.bind(r)), r; return ke.map(c, X, u), we(u.opts.start) && u.opts.start.call(e, u), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always), ke.fx.timer(ke.extend(l, { elem: e, anim: u, queue: u.opts.queue })), u;
    } function ee(e) { return (e.match(ze) || []).join(' '); } function te(e) { return e.getAttribute && e.getAttribute('class') || ''; } function ne(e) { return Array.isArray(e) ? e : typeof e === 'string' ? e.match(ze) || [] : []; } function re(e, t, n, r) { let i; if (Array.isArray(t))ke.each(t, (t, i) => { n || Lt.test(e) ? r(e, i) : re(`${e}[${typeof i === 'object' && i != null ? t : ''}]`, i, n, r); }); else if (n || s(t) !== 'object')r(e, t); else for (i in t)re(`${e}[${i}]`, t[i], n, r); } function ie(e) { return function (t, n) { typeof t !== 'string' && (n = t, t = '*'); let r; let i = 0; const o = t.toLowerCase().match(ze) || []; if (we(n)) for (;r = o[i++];)r[0] === '+' ? (r = r.slice(1) || '*', (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n); }; } function oe(e, t, n, r) { function i(s) { let l; return o[s] = !0, ke.each(e[s] || [], (e, s) => { const u = s(t, n, r); return typeof u !== 'string' || a || o[u] ? a ? !(l = u) : void 0 : (t.dataTypes.unshift(u), i(u), !1); }), l; } var o = {}; var a = e === Gt; return i(t.dataTypes[0]) || !o['*'] && i('*'); } function ae(e, t) { let n; let r; const i = ke.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && ke.extend(!0, e, r), e; } function se(e, t, n) { for (var r, i, o, a, s = e.contents, l = e.dataTypes; l[0] === '*';)l.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader('Content-Type')); if (r) for (i in s) if (s[i] && s[i].test(r)) { l.unshift(i); break; } if (l[0] in n)o = l[0]; else { for (i in n) { if (!l[0] || e.converters[`${i} ${l[0]}`]) { o = i; break; }a || (a = i); }o = o || a; } if (o) return o !== l[0] && l.unshift(o), n[o]; } function le(e, t, n, r) { let i; let o; let a; let s; let l; const u = {}; const c = e.dataTypes.slice(); if (c[1]) for (a in e.converters)u[a.toLowerCase()] = e.converters[a]; for (o = c.shift(); o;) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift()) if (o === '*')o = l; else if (l !== '*' && l !== o) { if (!(a = u[`${l} ${o}`] || u[`* ${o}`])) for (i in u) if (s = i.split(' '), s[1] === o && (a = u[`${l} ${s[0]}`] || u[`* ${s[0]}`])) { !0 === a ? a = u[i] : !0 !== u[i] && (o = s[0], c.unshift(s[1])); break; } if (!0 !== a) if (a && e.throws)t = a(t); else try { t = a(t); } catch (e) { return { state: 'parsererror', error: a ? e : `No conversion from ${l} to ${o}` }; } } return { state: 'success', data: t }; } const ue = []; var ce = n.document; const pe = Object.getPrototypeOf; const fe = ue.slice; var he = ue.concat; const de = ue.push; var me = ue.indexOf; var ge = {}; var ye = ge.toString; const ve = ge.hasOwnProperty; const _e = ve.toString; const be = _e.call(Object); var xe = {}; var we = function (e) { return typeof e === 'function' && typeof e.nodeType !== 'number'; }; var Ee = function (e) { return e != null && e === e.window; }; var Te = { type: !0, src: !0, noModule: !0 }; var ke = function (e, t) { return new ke.fn.init(e, t); }; const Ce = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; ke.fn = ke.prototype = {
      jquery: '3.3.1', constructor: ke, length: 0, toArray() { return fe.call(this); }, get(e) { return e == null ? fe.call(this) : e < 0 ? this[e + this.length] : this[e]; }, pushStack(e) { const t = ke.merge(this.constructor(), e); return t.prevObject = this, t; }, each(e) { return ke.each(this, e); }, map(e) { return this.pushStack(ke.map(this, (t, n) => e.call(t, n, t))); }, slice() { return this.pushStack(fe.apply(this, arguments)); }, first() { return this.eq(0); }, last() { return this.eq(-1); }, eq(e) { const t = this.length; const n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []); }, end() { return this.prevObject || this.constructor(); }, push: de, sort: ue.sort, splice: ue.splice,
    }, ke.extend = ke.fn.extend = function () { let e; let t; let n; let r; let i; let o; let a = arguments[0] || {}; let s = 1; const l = arguments.length; let u = !1; for (typeof a === 'boolean' && (u = a, a = arguments[s] || {}, s++), typeof a === 'object' || we(a) || (a = {}), s === l && (a = this, s--); s < l; s++) if ((e = arguments[s]) != null) for (t in e)n = a[t], r = e[t], a !== r && (u && r && (ke.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && ke.isPlainObject(n) ? n : {}, a[t] = ke.extend(u, o, r)) : void 0 !== r && (a[t] = r)); return a; }, ke.extend({
      expando: `jQuery${(`3.3.1${Math.random()}`).replace(/\D/g, '')}`, isReady: !0, error(e) { throw new Error(e); }, noop() {}, isPlainObject(e) { let t; let n; return !(!e || ye.call(e) !== '[object Object]') && (!(t = pe(e)) || typeof (n = ve.call(t, 'constructor') && t.constructor) === 'function' && _e.call(n) === be); }, isEmptyObject(e) { let t; for (t in e) return !1; return !0; }, globalEval(e) { a(e); }, each(e, t) { let n; let r = 0; if (l(e)) for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++);else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e; }, trim(e) { return e == null ? '' : (`${e}`).replace(Ce, ''); }, makeArray(e, t) { const n = t || []; return e != null && (l(Object(e)) ? ke.merge(n, typeof e === 'string' ? [e] : e) : de.call(n, e)), n; }, inArray(e, t, n) { return t == null ? -1 : me.call(t, e, n); }, merge(e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e; }, grep(e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r; }, map(e, t, n) { let r; let i; let o = 0; const a = []; if (l(e)) for (r = e.length; o < r; o++)(i = t(e[o], o, n)) != null && a.push(i); else for (o in e)(i = t(e[o], o, n)) != null && a.push(i); return he.apply([], a); }, guid: 1, support: xe,
    }), typeof Symbol === 'function' && (ke.fn[Symbol.iterator] = ue[Symbol.iterator]), ke.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), (e, t) => { ge[`[object ${t}]`] = t.toLowerCase(); }); const Se = (function (e) {
      function t(e, t, n, r) { let i; let o; let a; let s; let l; let c; let f; let h = t && t.ownerDocument; const d = t ? t.nodeType : 9; if (n = n || [], typeof e !== 'string' || !e || d !== 1 && d !== 9 && d !== 11) return n; if (!r && ((t ? t.ownerDocument || t : B) !== P && I(t), t = t || P, N)) { if (d !== 11 && (l = me.exec(e))) if (i = l[1]) { if (d === 9) { if (!(a = t.getElementById(i))) return n; if (a.id === i) return n.push(a), n; } else if (h && (a = h.getElementById(i)) && R(t, a) && a.id === i) return n.push(a), n; } else { if (l[2]) return X.apply(n, t.getElementsByTagName(e)), n; if ((i = l[3]) && b.getElementsByClassName && t.getElementsByClassName) return X.apply(n, t.getElementsByClassName(i)), n; } if (b.qsa && !H[`${e} `] && (!D || !D.test(e))) { if (d !== 1)h = t, f = e; else if (t.nodeName.toLowerCase() !== 'object') { for ((s = t.getAttribute('id')) ? s = s.replace(_e, be) : t.setAttribute('id', s = j), c = T(e), o = c.length; o--;)c[o] = `#${s} ${p(c[o])}`; f = c.join(','), h = ge.test(e) && u(t.parentNode) || t; } if (f) try { return X.apply(n, h.querySelectorAll(f)), n; } catch (e) {} finally { s === j && t.removeAttribute('id'); } } } return C(e.replace(oe, '$1'), t, n, r); } function n() { function e(n, r) { return t.push(`${n} `) > x.cacheLength && delete e[t.shift()], e[`${n} `] = r; } var t = []; return e; } function r(e) { return e[j] = !0, e; } function i(e) { let t = P.createElement('fieldset'); try { return !!e(t); } catch (e) { return !1; } finally { t.parentNode && t.parentNode.removeChild(t), t = null; } } function o(e, t) { for (let n = e.split('|'), r = n.length; r--;)x.attrHandle[n[r]] = t; } function a(e, t) { let n = t && e; const r = n && e.nodeType === 1 && t.nodeType === 1 && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) for (;n = n.nextSibling;) if (n === t) return -1; return e ? 1 : -1; } function s(e) { return function (t) { return 'form' in t ? t.parentNode && !1 === t.disabled ? 'label' in t ? 'label' in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && we(t) === e : t.disabled === e : 'label' in t && t.disabled === e; }; } function l(e) { return r(t => t = +t, r((n, r) => { for (var i, o = e([], n.length, t), a = o.length; a--;)n[i = o[a]] && (n[i] = !(r[i] = n[i])); })); } function u(e) { return e && typeof e.getElementsByTagName !== 'undefined' && e; } function c() {} function p(e) { for (var t = 0, n = e.length, r = ''; t < n; t++)r += e[t].value; return r; } function f(e, t, n) { const r = t.dir; const i = t.next; const o = i || r; const a = n && o === 'parentNode'; const s = U++; return t.first ? function (t, n, i) { for (;t = t[r];) if (t.nodeType === 1 || a) return e(t, n, i); return !1; } : function (t, n, l) { let u; let c; let p; const f = [F, s]; if (l) { for (;t = t[r];) if ((t.nodeType === 1 || a) && e(t, n, l)) return !0; } else for (;t = t[r];) if (t.nodeType === 1 || a) if (p = t[j] || (t[j] = {}), c = p[t.uniqueID] || (p[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase())t = t[r] || t; else { if ((u = c[o]) && u[0] === F && u[1] === s) return f[2] = u[2]; if (c[o] = f, f[2] = e(t, n, l)) return !0; } return !1; }; } function h(e) { return e.length > 1 ? function (t, n, r) { for (let i = e.length; i--;) if (!e[i](t, n, r)) return !1; return !0; } : e[0]; } function d(e, n, r) { for (let i = 0, o = n.length; i < o; i++)t(e, n[i], r); return r; } function m(e, t, n, r, i) { for (var o, a = [], s = 0, l = e.length, u = t != null; s < l; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), u && t.push(s))); return a; } function g(e, t, n, i, o, a) { return i && !i[j] && (i = g(i)), o && !o[j] && (o = g(o, a)), r((r, a, s, l) => { let u; let c; let p; const f = []; const h = []; const g = a.length; const y = r || d(t || '*', s.nodeType ? [s] : s, []); const v = !e || !r && t ? y : m(y, f, e, s, l); let _ = n ? o || (r ? e : g || i) ? [] : a : v; if (n && n(v, _, s, l), i) for (u = m(_, h), i(u, [], s, l), c = u.length; c--;)(p = u[c]) && (_[h[c]] = !(v[h[c]] = p)); if (r) { if (o || e) { if (o) { for (u = [], c = _.length; c--;)(p = _[c]) && u.push(v[c] = p); o(null, _ = [], u, l); } for (c = _.length; c--;)(p = _[c]) && (u = o ? J(r, p) : f[c]) > -1 && (r[u] = !(a[u] = p)); } } else _ = m(_ === a ? _.splice(g, _.length) : _), o ? o(null, a, _, l) : X.apply(a, _); }); } function y(e) { for (var t, n, r, i = e.length, o = x.relative[e[0].type], a = o || x.relative[' '], s = o ? 1 : 0, l = f(e => e === t, a, !0), u = f(e => J(t, e) > -1, a, !0), c = [function (e, n, r) { const i = !o && (r || n !== S) || ((t = n).nodeType ? l(e, n, r) : u(e, n, r)); return t = null, i; }]; s < i; s++) if (n = x.relative[e[s].type])c = [f(h(c), n)]; else { if (n = x.filter[e[s].type].apply(null, e[s].matches), n[j]) { for (r = ++s; r < i && !x.relative[e[r].type]; r++);return g(s > 1 && h(c), s > 1 && p(e.slice(0, s - 1).concat({ value: e[s - 2].type === ' ' ? '*' : '' })).replace(oe, '$1'), n, s < r && y(e.slice(s, r)), r < i && y(e = e.slice(r)), r < i && p(e)); }c.push(n); } return h(c); } function v(e, n) { const i = n.length > 0; const o = e.length > 0; const a = function (r, a, s, l, u) { let c; let p; let f; let h = 0; let d = '0'; const g = r && []; let y = []; const v = S; const _ = r || o && x.find.TAG('*', u); const b = F += v == null ? 1 : Math.random() || 0.1; const w = _.length; for (u && (S = a === P || a || u); d !== w && (c = _[d]) != null; d++) { if (o && c) { for (p = 0, a || c.ownerDocument === P || (I(c), s = !N); f = e[p++];) if (f(c, a || P, s)) { l.push(c); break; }u && (F = b); }i && ((c = !f && c) && h--, r && g.push(c)); } if (h += d, i && d !== h) { for (p = 0; f = n[p++];)f(g, y, a, s); if (r) { if (h > 0) for (;d--;)g[d] || y[d] || (y[d] = Z.call(l)); y = m(y); }X.apply(l, y), u && !r && y.length > 0 && h + n.length > 1 && t.uniqueSort(l); } return u && (F = b, S = v), g; }; return i ? r(a) : a; } let _; let b; let x; let w; let E; let T; let k; let C; let S; let A; let O; let I; let P; let M; let N; let D; let L; let z; let R; var j = `sizzle${1 * new Date()}`; var B = e.document; var F = 0; var U = 0; const V = n(); const q = n(); var H = n(); let W = function (e, t) { return e === t && (O = !0), 0; }; const $ = {}.hasOwnProperty; let G = []; var Z = G.pop; const K = G.push; var X = G.push; const Y = G.slice; var J = function (e, t) { for (let n = 0, r = e.length; n < r; n++) if (e[n] === t) return n; return -1; }; const Q = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped'; const ee = '[\\x20\\t\\r\\n\\f]'; const te = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+'; const ne = `\\[${ee}*(${te})(?:${ee}*([*^$|!~]?=)${ee}*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(${te}))|)${ee}*\\]`; const re = `:(${te})(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|${ne})*)|.*)\\)|)`; const ie = new RegExp(`${ee}+`, 'g'); var oe = new RegExp(`^${ee}+|((?:^|[^\\\\])(?:\\\\.)*)${ee}+$`, 'g'); const ae = new RegExp(`^${ee}*,${ee}*`); const se = new RegExp(`^${ee}*([>+~]|${ee})${ee}*`); const le = new RegExp(`=${ee}*([^\\]'"]*?)${ee}*\\]`, 'g'); const ue = new RegExp(re); const ce = new RegExp(`^${te}$`); const pe = {
        ID: new RegExp(`^#(${te})`), CLASS: new RegExp(`^\\.(${te})`), TAG: new RegExp(`^(${te}|[*])`), ATTR: new RegExp(`^${ne}`), PSEUDO: new RegExp(`^${re}`), CHILD: new RegExp(`^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(${ee}*(even|odd|(([+-]|)(\\d*)n|)${ee}*(?:([+-]|)${ee}*(\\d+)|))${ee}*\\)|)`, 'i'), bool: new RegExp(`^(?:${Q})$`, 'i'), needsContext: new RegExp(`^${ee}*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(${ee}*((?:-\\d)?\\d*)${ee}*\\)|)(?=[^-]|$)`, 'i'),
      }; const fe = /^(?:input|select|textarea|button)$/i; const he = /^h\d$/i; const de = /^[^{]+\{\s*\[native \w/; var me = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/; var ge = /[+~]/; const ye = new RegExp(`\\\\([\\da-f]{1,6}${ee}?|(${ee})|.)`, 'ig'); const ve = function (e, t, n) { const r = `0x${t}` - 65536; return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320); }; var _e = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g; var be = function (e, t) { return t ? e === '\0' ? '\ufffd' : `${e.slice(0, -1)}\\${e.charCodeAt(e.length - 1).toString(16)} ` : `\\${e}`; }; const xe = function () { I(); }; var we = f(e => !0 === e.disabled && ('form' in e || 'label' in e), { dir: 'parentNode', next: 'legend' }); try { X.apply(G = Y.call(B.childNodes), B.childNodes), G[B.childNodes.length].nodeType; } catch (e) { X = { apply: G.length ? function (e, t) { K.apply(e, Y.call(t)); } : function (e, t) { for (var n = e.length, r = 0; e[n++] = t[r++];);e.length = n - 1; } }; }b = t.support = {}, E = t.isXML = function (e) { const t = e && (e.ownerDocument || e).documentElement; return !!t && t.nodeName !== 'HTML'; }, I = t.setDocument = function (e) { let t; let n; const r = e ? e.ownerDocument || e : B; return r !== P && r.nodeType === 9 && r.documentElement ? (P = r, M = P.documentElement, N = !E(P), B !== P && (n = P.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener('unload', xe, !1) : n.attachEvent && n.attachEvent('onunload', xe)), b.attributes = i(e => e.className = 'i', !e.getAttribute('className')), b.getElementsByTagName = i(e => e.appendChild(P.createComment('')), !e.getElementsByTagName('*').length), b.getElementsByClassName = de.test(P.getElementsByClassName), b.getById = i(e => M.appendChild(e).id = j, !P.getElementsByName || !P.getElementsByName(j).length), b.getById ? (x.filter.ID = function (e) { const t = e.replace(ye, ve); return function (e) { return e.getAttribute('id') === t; }; }, x.find.ID = function (e, t) { if (typeof t.getElementById !== 'undefined' && N) { const n = t.getElementById(e); return n ? [n] : []; } }) : (x.filter.ID = function (e) { const t = e.replace(ye, ve); return function (e) { const n = typeof e.getAttributeNode !== 'undefined' && e.getAttributeNode('id'); return n && n.value === t; }; }, x.find.ID = function (e, t) { if (typeof t.getElementById !== 'undefined' && N) { let n; let r; let i; let o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode('id')) && n.value === e) return [o]; for (i = t.getElementsByName(e), r = 0; o = i[r++];) if ((n = o.getAttributeNode('id')) && n.value === e) return [o]; } return []; } }), x.find.TAG = b.getElementsByTagName ? function (e, t) { return typeof t.getElementsByTagName !== 'undefined' ? t.getElementsByTagName(e) : b.qsa ? t.querySelectorAll(e) : void 0; } : function (e, t) { let n; const r = []; let i = 0; const o = t.getElementsByTagName(e); if (e === '*') { for (;n = o[i++];)n.nodeType === 1 && r.push(n); return r; } return o; }, x.find.CLASS = b.getElementsByClassName && function (e, t) { if (typeof t.getElementsByClassName !== 'undefined' && N) return t.getElementsByClassName(e); }, L = [], D = [], (b.qsa = de.test(P.querySelectorAll)) && (i((e) => { M.appendChild(e).innerHTML = `<a id='${j}'></a><select id='${j}-\r\\' msallowcapture=''><option selected=''></option></select>`, e.querySelectorAll("[msallowcapture^='']").length && D.push(`[*^$]=${ee}*(?:''|"")`), e.querySelectorAll('[selected]').length || D.push(`\\[${ee}*(?:value|${Q})`), e.querySelectorAll(`[id~=${j}-]`).length || D.push('~='), e.querySelectorAll(':checked').length || D.push(':checked'), e.querySelectorAll(`a#${j}+*`).length || D.push('.#.+[+~]'); }), i((e) => { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; const t = P.createElement('input'); t.setAttribute('type', 'hidden'), e.appendChild(t).setAttribute('name', 'D'), e.querySelectorAll('[name=d]').length && D.push(`name${ee}*[*^$|!~]?=`), e.querySelectorAll(':enabled').length !== 2 && D.push(':enabled', ':disabled'), M.appendChild(e).disabled = !0, e.querySelectorAll(':disabled').length !== 2 && D.push(':enabled', ':disabled'), e.querySelectorAll('*,:x'), D.push(',.*:'); })), (b.matchesSelector = de.test(z = M.matches || M.webkitMatchesSelector || M.mozMatchesSelector || M.oMatchesSelector || M.msMatchesSelector)) && i((e) => { b.disconnectedMatch = z.call(e, '*'), z.call(e, "[s!='']:x"), L.push('!=', re); }), D = D.length && new RegExp(D.join('|')), L = L.length && new RegExp(L.join('|')), t = de.test(M.compareDocumentPosition), R = t || de.test(M.contains) ? function (e, t) { const n = e.nodeType === 9 ? e.documentElement : e; const r = t && t.parentNode; return e === r || !(!r || r.nodeType !== 1 || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))); } : function (e, t) { if (t) for (;t = t.parentNode;) if (t === e) return !0; return !1; }, W = t ? function (e, t) { if (e === t) return O = !0, 0; let n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & n || !b.sortDetached && t.compareDocumentPosition(e) === n ? e === P || e.ownerDocument === B && R(B, e) ? -1 : t === P || t.ownerDocument === B && R(B, t) ? 1 : A ? J(A, e) - J(A, t) : 0 : 4 & n ? -1 : 1); } : function (e, t) { if (e === t) return O = !0, 0; let n; let r = 0; const i = e.parentNode; const o = t.parentNode; const s = [e]; const l = [t]; if (!i || !o) return e === P ? -1 : t === P ? 1 : i ? -1 : o ? 1 : A ? J(A, e) - J(A, t) : 0; if (i === o) return a(e, t); for (n = e; n = n.parentNode;)s.unshift(n); for (n = t; n = n.parentNode;)l.unshift(n); for (;s[r] === l[r];)r++; return r ? a(s[r], l[r]) : s[r] === B ? -1 : l[r] === B ? 1 : 0; }, P) : P; }, t.matches = function (e, n) { return t(e, null, null, n); }, t.matchesSelector = function (e, n) { if ((e.ownerDocument || e) !== P && I(e), n = n.replace(le, "='$1']"), b.matchesSelector && N && !H[`${n} `] && (!L || !L.test(n)) && (!D || !D.test(n))) try { const r = z.call(e, n); if (r || b.disconnectedMatch || e.document && e.document.nodeType !== 11) return r; } catch (e) {} return t(n, P, null, [e]).length > 0; }, t.contains = function (e, t) { return (e.ownerDocument || e) !== P && I(e), R(e, t); }, t.attr = function (e, t) { (e.ownerDocument || e) !== P && I(e); const n = x.attrHandle[t.toLowerCase()]; let r = n && $.call(x.attrHandle, t.toLowerCase()) ? n(e, t, !N) : void 0; return void 0 !== r ? r : b.attributes || !N ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null; }, t.escape = function (e) { return (`${e}`).replace(_e, be); }, t.error = function (e) { throw new Error(`Syntax error, unrecognized expression: ${e}`); }, t.uniqueSort = function (e) { let t; const n = []; let r = 0; let i = 0; if (O = !b.detectDuplicates, A = !b.sortStable && e.slice(0), e.sort(W), O) { for (;t = e[i++];)t === e[i] && (r = n.push(i)); for (;r--;)e.splice(n[r], 1); } return A = null, e; }, w = t.getText = function (e) { let t; let n = ''; let r = 0; const i = e.nodeType; if (i) { if (i === 1 || i === 9 || i === 11) { if (typeof e.textContent === 'string') return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += w(e); } else if (i === 3 || i === 4) return e.nodeValue; } else for (;t = e[r++];)n += w(t); return n; }, x = t.selectors = {
        cacheLength: 50,
        createPseudo: r,
        match: pe,
        attrHandle: {},
        find: {},
        relative: {
          '>': { dir: 'parentNode', first: !0 }, ' ': { dir: 'parentNode' }, '+': { dir: 'previousSibling', first: !0 }, '~': { dir: 'previousSibling' },
        },
        preFilter: { ATTR(e) { return e[1] = e[1].replace(ye, ve), e[3] = (e[3] || e[4] || e[5] || '').replace(ye, ve), e[2] === '~=' && (e[3] = ` ${e[3]} `), e.slice(0, 4); }, CHILD(e) { return e[1] = e[1].toLowerCase(), e[1].slice(0, 3) === 'nth' ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * (e[3] === 'even' || e[3] === 'odd')), e[5] = +(e[7] + e[8] || e[3] === 'odd')) : e[3] && t.error(e[0]), e; }, PSEUDO(e) { let t; const n = !e[6] && e[2]; return pe.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || '' : n && ue.test(n) && (t = T(n, !0)) && (t = n.indexOf(')', n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)); } },
        filter: {
          TAG(e) { const t = e.replace(ye, ve).toLowerCase(); return e === '*' ? function () { return !0; } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t; }; }, CLASS(e) { let t = V[`${e} `]; return t || (t = new RegExp(`(^|${ee})${e}(${ee}|$)`)) && V(e, e => t.test(typeof e.className === 'string' && e.className || typeof e.getAttribute !== 'undefined' && e.getAttribute('class') || '')); }, ATTR(e, n, r) { return function (i) { let o = t.attr(i, e); return o == null ? n === '!=' : !n || (o += '', n === '=' ? o === r : n === '!=' ? o !== r : n === '^=' ? r && o.indexOf(r) === 0 : n === '*=' ? r && o.indexOf(r) > -1 : n === '$=' ? r && o.slice(-r.length) === r : n === '~=' ? (` ${o.replace(ie, ' ')} `).indexOf(r) > -1 : n === '|=' && (o === r || o.slice(0, r.length + 1) === `${r}-`)); }; }, CHILD(e, t, n, r, i) { const o = e.slice(0, 3) !== 'nth'; const a = e.slice(-4) !== 'last'; const s = t === 'of-type'; return r === 1 && i === 0 ? function (e) { return !!e.parentNode; } : function (t, n, l) { let u; let c; let p; let f; let h; let d; let m = o !== a ? 'nextSibling' : 'previousSibling'; const g = t.parentNode; const y = s && t.nodeName.toLowerCase(); const v = !l && !s; let _ = !1; if (g) { if (o) { for (;m;) { for (f = t; f = f[m];) if (s ? f.nodeName.toLowerCase() === y : f.nodeType === 1) return !1; d = m = e === 'only' && !d && 'nextSibling'; } return !0; } if (d = [a ? g.firstChild : g.lastChild], a && v) { for (f = g, p = f[j] || (f[j] = {}), c = p[f.uniqueID] || (p[f.uniqueID] = {}), u = c[e] || [], h = u[0] === F && u[1], _ = h && u[2], f = h && g.childNodes[h]; f = ++h && f && f[m] || (_ = h = 0) || d.pop();) if (f.nodeType === 1 && ++_ && f === t) { c[e] = [F, h, _]; break; } } else if (v && (f = t, p = f[j] || (f[j] = {}), c = p[f.uniqueID] || (p[f.uniqueID] = {}), u = c[e] || [], h = u[0] === F && u[1], _ = h), !1 === _) for (;(f = ++h && f && f[m] || (_ = h = 0) || d.pop()) && ((s ? f.nodeName.toLowerCase() !== y : f.nodeType !== 1) || !++_ || (v && (p = f[j] || (f[j] = {}), c = p[f.uniqueID] || (p[f.uniqueID] = {}), c[e] = [F, _]), f !== t)););return (_ -= i) === r || _ % r === 0 && _ / r >= 0; } }; }, PSEUDO(e, n) { let i; const o = x.pseudos[e] || x.setFilters[e.toLowerCase()] || t.error(`unsupported pseudo: ${e}`); return o[j] ? o(n) : o.length > 1 ? (i = [e, e, '', n], x.setFilters.hasOwnProperty(e.toLowerCase()) ? r((e, t) => { for (var r, i = o(e, n), a = i.length; a--;)r = J(e, i[a]), e[r] = !(t[r] = i[a]); }) : function (e) { return o(e, 0, i); }) : o; },
        },
        pseudos: {
          not: r((e) => { const t = []; const n = []; const i = k(e.replace(oe, '$1')); return i[j] ? r((e, t, n, r) => { for (var o, a = i(e, null, r, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o)); }) : function (e, r, o) { return t[0] = e, i(t, null, o, n), t[0] = null, !n.pop(); }; }), has: r(e => function (n) { return t(e, n).length > 0; }), contains: r(e => e = e.replace(ye, ve), t => (t.textContent || t.innerText || w(t)).indexOf(e) > -1), lang: r(e => ce.test(e || '') || t.error(`unsupported lang: ${e}`), e = e.replace(ye, ve).toLowerCase(), (t) => { let n; do { if (n = N ? t.lang : t.getAttribute('xml:lang') || t.getAttribute('lang')) return (n = n.toLowerCase()) === e || n.indexOf(`${e}-`) === 0; } while ((t = t.parentNode) && t.nodeType === 1);return !1; }), target(t) { const n = e.location && e.location.hash; return n && n.slice(1) === t.id; }, root(e) { return e === M; }, focus(e) { return e === P.activeElement && (!P.hasFocus || P.hasFocus()) && !!(e.type || e.href || ~e.tabIndex); }, enabled: s(!1), disabled: s(!0), checked(e) { const t = e.nodeName.toLowerCase(); return t === 'input' && !!e.checked || t === 'option' && !!e.selected; }, selected(e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected; }, empty(e) { for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1; return !0; }, parent(e) { return !x.pseudos.empty(e); }, header(e) { return he.test(e.nodeName); }, input(e) { return fe.test(e.nodeName); }, button(e) { const t = e.nodeName.toLowerCase(); return t === 'input' && e.type === 'button' || t === 'button'; }, text(e) { let t; return e.nodeName.toLowerCase() === 'input' && e.type === 'text' && ((t = e.getAttribute('type')) == null || t.toLowerCase() === 'text'); }, first: l(() => [0]), last: l((e, t) => [t - 1]), eq: l((e, t, n) => [n < 0 ? n + t : n]), even: l((e, t) => { for (let n = 0; n < t; n += 2)e.push(n); return e; }), odd: l((e, t) => { for (let n = 1; n < t; n += 2)e.push(n); return e; }), lt: l((e, t, n) => { for (let r = n < 0 ? n + t : n; --r >= 0;)e.push(r); return e; }), gt: l((e, t, n) => { for (let r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e; }),
        },
      }, x.pseudos.nth = x.pseudos.eq; for (_ in {
        radio: !0, checkbox: !0, file: !0, password: !0, image: !0,
      })x.pseudos[_] = (function (e) { return function (t) { return t.nodeName.toLowerCase() === 'input' && t.type === e; }; }(_)); for (_ in { submit: !0, reset: !0 })x.pseudos[_] = (function (e) { return function (t) { const n = t.nodeName.toLowerCase(); return (n === 'input' || n === 'button') && t.type === e; }; }(_)); return c.prototype = x.filters = x.pseudos, x.setFilters = new c(), T = t.tokenize = function (e, n) { let r; let i; let o; let a; let s; let l; let u; const c = q[`${e} `]; if (c) return n ? 0 : c.slice(0); for (s = e, l = [], u = x.preFilter; s;) { r && !(i = ae.exec(s)) || (i && (s = s.slice(i[0].length) || s), l.push(o = [])), r = !1, (i = se.exec(s)) && (r = i.shift(), o.push({ value: r, type: i[0].replace(oe, ' ') }), s = s.slice(r.length)); for (a in x.filter)!(i = pe[a].exec(s)) || u[a] && !(i = u[a](i)) || (r = i.shift(), o.push({ value: r, type: a, matches: i }), s = s.slice(r.length)); if (!r) break; } return n ? s.length : s ? t.error(e) : q(e, l).slice(0); }, k = t.compile = function (e, t) { let n; const r = []; const i = []; let o = H[`${e} `]; if (!o) { for (t || (t = T(e)), n = t.length; n--;)o = y(t[n]), o[j] ? r.push(o) : i.push(o); o = H(e, v(i, r)), o.selector = e; } return o; }, C = t.select = function (e, t, n, r) { let i; let o; let a; let s; let l; const c = typeof e === 'function' && e; const f = !r && T(e = c.selector || e); if (n = n || [], f.length === 1) { if (o = f[0] = f[0].slice(0), o.length > 2 && (a = o[0]).type === 'ID' && t.nodeType === 9 && N && x.relative[o[1].type]) { if (!(t = (x.find.ID(a.matches[0].replace(ye, ve), t) || [])[0])) return n; c && (t = t.parentNode), e = e.slice(o.shift().value.length); } for (i = pe.needsContext.test(e) ? 0 : o.length; i-- && (a = o[i], !x.relative[s = a.type]);) if ((l = x.find[s]) && (r = l(a.matches[0].replace(ye, ve), ge.test(o[0].type) && u(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && p(o))) return X.apply(n, r), n; break; } } return (c || k(e, f))(r, t, !N, n, !t || ge.test(e) && u(t.parentNode) || t), n; }, b.sortStable = j.split('').sort(W).join('') === j, b.detectDuplicates = !!O, I(), b.sortDetached = i(e => 1 & e.compareDocumentPosition(P.createElement('fieldset'))), i(e => e.innerHTML = "<a href='#'></a>", e.firstChild.getAttribute('href') === '#') || o('type|href|height|width', (e, t, n) => { if (!n) return e.getAttribute(t, t.toLowerCase() === 'type' ? 1 : 2); }), b.attributes && i(e => e.innerHTML = '<input/>', e.firstChild.setAttribute('value', ''), e.firstChild.getAttribute('value') === '') || o('value', (e, t, n) => { if (!n && e.nodeName.toLowerCase() === 'input') return e.defaultValue; }), i(e => e.getAttribute('disabled') == null) || o(Q, (e, t, n) => { let r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null; }), t;
    }(n)); ke.find = Se, ke.expr = Se.selectors, ke.expr[':'] = ke.expr.pseudos, ke.uniqueSort = ke.unique = Se.uniqueSort, ke.text = Se.getText, ke.isXMLDoc = Se.isXML, ke.contains = Se.contains, ke.escapeSelector = Se.escape; const Ae = function (e, t, n) { for (var r = [], i = void 0 !== n; (e = e[t]) && e.nodeType !== 9;) if (e.nodeType === 1) { if (i && ke(e).is(n)) break; r.push(e); } return r; }; const Oe = function (e, t) { for (var n = []; e; e = e.nextSibling)e.nodeType === 1 && e !== t && n.push(e); return n; }; const Ie = ke.expr.match.needsContext; const Pe = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; ke.filter = function (e, t, n) { const r = t[0]; return n && (e = `:not(${e})`), t.length === 1 && r.nodeType === 1 ? ke.find.matchesSelector(r, e) ? [r] : [] : ke.find.matches(e, ke.grep(t, e => e.nodeType === 1)); }, ke.fn.extend({
      find(e) { let t; let n; const r = this.length; const i = this; if (typeof e !== 'string') return this.pushStack(ke(e).filter(function () { for (t = 0; t < r; t++) if (ke.contains(i[t], this)) return !0; })); for (n = this.pushStack([]), t = 0; t < r; t++)ke.find(e, i[t], n); return r > 1 ? ke.uniqueSort(n) : n; }, filter(e) { return this.pushStack(c(this, e || [], !1)); }, not(e) { return this.pushStack(c(this, e || [], !0)); }, is(e) { return !!c(this, typeof e === 'string' && Ie.test(e) ? ke(e) : e || [], !1).length; },
    }); let Me; const Ne = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (ke.fn.init = function (e, t, n) { let r; let i; if (!e) return this; if (n = n || Me, typeof e === 'string') { if (!(r = e[0] === '<' && e[e.length - 1] === '>' && e.length >= 3 ? [null, e, null] : Ne.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof ke ? t[0] : t, ke.merge(this, ke.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : ce, !0)), Pe.test(r[1]) && ke.isPlainObject(t)) for (r in t)we(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this; } return i = ce.getElementById(r[2]), i && (this[0] = i, this.length = 1), this; } return e.nodeType ? (this[0] = e, this.length = 1, this) : we(e) ? void 0 !== n.ready ? n.ready(e) : e(ke) : ke.makeArray(e, this); }).prototype = ke.fn, Me = ke(ce); const De = /^(?:parents|prev(?:Until|All))/; const Le = {
      children: !0, contents: !0, next: !0, prev: !0,
    }; ke.fn.extend({
      has(e) { const t = ke(e, this); const n = t.length; return this.filter(function () { for (let e = 0; e < n; e++) if (ke.contains(this, t[e])) return !0; }); }, closest(e, t) { let n; let r = 0; const i = this.length; const o = []; const a = typeof e !== 'string' && ke(e); if (!Ie.test(e)) for (;r < i; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (a ? a.index(n) > -1 : n.nodeType === 1 && ke.find.matchesSelector(n, e))) { o.push(n); break; } return this.pushStack(o.length > 1 ? ke.uniqueSort(o) : o); }, index(e) { return e ? typeof e === 'string' ? me.call(ke(e), this[0]) : me.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1; }, add(e, t) { return this.pushStack(ke.uniqueSort(ke.merge(this.get(), ke(e, t)))); }, addBack(e) { return this.add(e == null ? this.prevObject : this.prevObject.filter(e)); },
    }), ke.each({
      parent(e) { const t = e.parentNode; return t && t.nodeType !== 11 ? t : null; }, parents(e) { return Ae(e, 'parentNode'); }, parentsUntil(e, t, n) { return Ae(e, 'parentNode', n); }, next(e) { return p(e, 'nextSibling'); }, prev(e) { return p(e, 'previousSibling'); }, nextAll(e) { return Ae(e, 'nextSibling'); }, prevAll(e) { return Ae(e, 'previousSibling'); }, nextUntil(e, t, n) { return Ae(e, 'nextSibling', n); }, prevUntil(e, t, n) { return Ae(e, 'previousSibling', n); }, siblings(e) { return Oe((e.parentNode || {}).firstChild, e); }, children(e) { return Oe(e.firstChild); }, contents(e) { return u(e, 'iframe') ? e.contentDocument : (u(e, 'template') && (e = e.content || e), ke.merge([], e.childNodes)); },
    }, (e, t) => { ke.fn[e] = function (n, r) { let i = ke.map(this, t, n); return e.slice(-5) !== 'Until' && (r = n), r && typeof r === 'string' && (i = ke.filter(r, i)), this.length > 1 && (Le[e] || ke.uniqueSort(i), De.test(e) && i.reverse()), this.pushStack(i); }; }); var ze = /[^\x20\t\r\n\f]+/g; ke.Callbacks = function (e) {
      e = typeof e === 'string' ? f(e) : ke.extend({}, e); let t; let n; let r; let i; let o = []; let a = []; let l = -1; const u = function () { for (i = i || e.once, r = t = !0; a.length; l = -1) for (n = a.shift(); ++l < o.length;)!1 === o[l].apply(n[0], n[1]) && e.stopOnFalse && (l = o.length, n = !1); e.memory || (n = !1), t = !1, i && (o = n ? [] : ''); }; var c = {
        add() { return o && (n && !t && (l = o.length - 1, a.push(n)), (function t(n) { ke.each(n, (n, r) => { we(r) ? e.unique && c.has(r) || o.push(r) : r && r.length && s(r) !== 'string' && t(r); }); }(arguments)), n && !t && u()), this; }, remove() { return ke.each(arguments, (e, t) => { for (var n; (n = ke.inArray(t, o, n)) > -1;)o.splice(n, 1), n <= l && l--; }), this; }, has(e) { return e ? ke.inArray(e, o) > -1 : o.length > 0; }, empty() { return o && (o = []), this; }, disable() { return i = a = [], o = n = '', this; }, disabled() { return !o; }, lock() { return i = a = [], n || t || (o = n = ''), this; }, locked() { return !!i; }, fireWith(e, n) { return i || (n = n || [], n = [e, n.slice ? n.slice() : n], a.push(n), t || u()), this; }, fire() { return c.fireWith(this, arguments), this; }, fired() { return !!r; },
      }; return c;
    }, ke.extend({
      Deferred(e) {
        const t = [['notify', 'progress', ke.Callbacks('memory'), ke.Callbacks('memory'), 2], ['resolve', 'done', ke.Callbacks('once memory'), ke.Callbacks('once memory'), 0, 'resolved'], ['reject', 'fail', ke.Callbacks('once memory'), ke.Callbacks('once memory'), 1, 'rejected']]; let r = 'pending'; var i = {
          state() { return r; }, always() { return o.done(arguments).fail(arguments), this; }, catch(e) { return i.then(null, e); }, pipe() { let e = arguments; return ke.Deferred((n) => { ke.each(t, (t, r) => { let i = we(e[r[4]]) && e[r[4]]; o[r[1]](function () { let e = i && i.apply(this, arguments); e && we(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[`${r[0]}With`](this, i ? [e] : arguments); }); }), e = null; }).promise(); }, then(e, r, i) { function o(e, t, r, i) { return function () { let s = this; let l = arguments; const u = function () { let n; let u; if (!(e < a)) { if ((n = r.apply(s, l)) === t.promise()) throw new TypeError('Thenable self-resolution'); u = n && (typeof n === 'object' || typeof n === 'function') && n.then, we(u) ? i ? u.call(n, o(a, t, h, i), o(a, t, d, i)) : (a++, u.call(n, o(a, t, h, i), o(a, t, d, i), o(a, t, h, t.notifyWith))) : (r !== h && (s = void 0, l = [n]), (i || t.resolveWith)(s, l)); } }; var c = i ? u : function () { try { u(); } catch (n) { ke.Deferred.exceptionHook && ke.Deferred.exceptionHook(n, c.stackTrace), e + 1 >= a && (r !== d && (s = void 0, l = [n]), t.rejectWith(s, l)); } }; e ? c() : (ke.Deferred.getStackHook && (c.stackTrace = ke.Deferred.getStackHook()), n.setTimeout(c)); }; } var a = 0; return ke.Deferred((n) => { t[0][3].add(o(0, n, we(i) ? i : h, n.notifyWith)), t[1][3].add(o(0, n, we(e) ? e : h)), t[2][3].add(o(0, n, we(r) ? r : d)); }).promise(); }, promise(e) { return e != null ? ke.extend(e, i) : i; },
        }; var o = {}; return ke.each(t, (e, n) => { const a = n[2]; const s = n[5]; i[n[1]] = a.add, s && a.add(() => { r = s; }, t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), a.add(n[3].fire), o[n[0]] = function () { return o[`${n[0]}With`](this === o ? void 0 : this, arguments), this; }, o[`${n[0]}With`] = a.fireWith; }), i.promise(o), e && e.call(o, o), o;
      },
      when(e) { let t = arguments.length; let n = t; const r = Array(n); const i = fe.call(arguments); const o = ke.Deferred(); const a = function (e) { return function (n) { r[e] = this, i[e] = arguments.length > 1 ? fe.call(arguments) : n, --t || o.resolveWith(r, i); }; }; if (t <= 1 && (m(e, o.done(a(n)).resolve, o.reject, !t), o.state() === 'pending' || we(i[n] && i[n].then))) return o.then(); for (;n--;)m(i[n], a(n), o.reject); return o.promise(); },
    }); const Re = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; ke.Deferred.exceptionHook = function (e, t) { n.console && n.console.warn && e && Re.test(e.name) && n.console.warn(`jQuery.Deferred exception: ${e.message}`, e.stack, t); }, ke.readyException = function (e) { n.setTimeout(() => { throw e; }); }; const je = ke.Deferred(); ke.fn.ready = function (e) { return je.then(e).catch((e) => { ke.readyException(e); }), this; }, ke.extend({ isReady: !1, readyWait: 1, ready(e) { (!0 === e ? --ke.readyWait : ke.isReady) || (ke.isReady = !0, !0 !== e && --ke.readyWait > 0 || je.resolveWith(ce, [ke])); } }), ke.ready.then = je.then, ce.readyState === 'complete' || ce.readyState !== 'loading' && !ce.documentElement.doScroll ? n.setTimeout(ke.ready) : (ce.addEventListener('DOMContentLoaded', g), n.addEventListener('load', g)); var Be = function (e, t, n, r, i, o, a) { let l = 0; const u = e.length; let c = n == null; if (s(n) === 'object') { i = !0; for (l in n)Be(e, t, l, n[l], !0, o, a); } else if (void 0 !== r && (i = !0, we(r) || (a = !0), c && (a ? (t.call(e, r), t = null) : (c = t, t = function (e, t, n) { return c.call(ke(e), n); })), t)) for (;l < u; l++)t(e[l], n, a ? r : r.call(e[l], l, t(e[l], n))); return i ? e : c ? t.call(e) : u ? t(e[0], n) : o; }; var Fe = /^-ms-/; var Ue = /-([a-z])/g; const Ve = function (e) { return e.nodeType === 1 || e.nodeType === 9 || !+e.nodeType; }; _.uid = 1, _.prototype = {
      cache(e) { let t = e[this.expando]; return t || (t = {}, Ve(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t; }, set(e, t, n) { let r; const i = this.cache(e); if (typeof t === 'string')i[v(t)] = n; else for (r in t)i[v(r)] = t[r]; return i; }, get(e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][v(t)]; }, access(e, t, n) { return void 0 === t || t && typeof t === 'string' && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t); }, remove(e, t) { let n; const r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { Array.isArray(t) ? t = t.map(v) : (t = v(t), t = t in r ? [t] : t.match(ze) || []), n = t.length; for (;n--;) delete r[t[n]]; }(void 0 === t || ke.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]); } }, hasData(e) { const t = e[this.expando]; return void 0 !== t && !ke.isEmptyObject(t); },
    }; var qe = new _(); var He = new _();


    var We = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;


    var $e = /[A-Z]/g; ke.extend({
      hasData(e) { return He.hasData(e) || qe.hasData(e); }, data(e, t, n) { return He.access(e, t, n); }, removeData(e, t) { He.remove(e, t); }, _data(e, t, n) { return qe.access(e, t, n); }, _removeData(e, t) { qe.remove(e, t); },
    }), ke.fn.extend({ data(e, t) { let n; let r; let i; const o = this[0]; const a = o && o.attributes; if (void 0 === e) { if (this.length && (i = He.get(o), o.nodeType === 1 && !qe.get(o, 'hasDataAttrs'))) { for (n = a.length; n--;)a[n] && (r = a[n].name, r.indexOf('data-') === 0 && (r = v(r.slice(5)), x(o, r, i[r]))); qe.set(o, 'hasDataAttrs', !0); } return i; } return typeof e === 'object' ? this.each(function () { He.set(this, e); }) : Be(this, function (t) { let n; if (o && void 0 === t) { if (void 0 !== (n = He.get(o, e))) return n; if (void 0 !== (n = x(o, e))) return n; } else this.each(function () { He.set(this, e, t); }); }, null, t, arguments.length > 1, null, !0); }, removeData(e) { return this.each(function () { He.remove(this, e); }); } }), ke.extend({ queue(e, t, n) { let r; if (e) return t = `${t || 'fx'}queue`, r = qe.get(e, t), n && (!r || Array.isArray(n) ? r = qe.access(e, t, ke.makeArray(n)) : r.push(n)), r || []; }, dequeue(e, t) { t = t || 'fx'; const n = ke.queue(e, t); let r = n.length; let i = n.shift(); const o = ke._queueHooks(e, t); const a = function () { ke.dequeue(e, t); }; i === 'inprogress' && (i = n.shift(), r--), i && (t === 'fx' && n.unshift('inprogress'), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire(); }, _queueHooks(e, t) { const n = `${t}queueHooks`; return qe.get(e, n) || qe.access(e, n, { empty: ke.Callbacks('once memory').add(() => { qe.remove(e, [`${t}queue`, n]); }) }); } }), ke.fn.extend({
      queue(e, t) { let n = 2; return typeof e !== 'string' && (t = e, e = 'fx', n--), arguments.length < n ? ke.queue(this[0], e) : void 0 === t ? this : this.each(function () { const n = ke.queue(this, e, t); ke._queueHooks(this, e), e === 'fx' && n[0] !== 'inprogress' && ke.dequeue(this, e); }); }, dequeue(e) { return this.each(function () { ke.dequeue(this, e); }); }, clearQueue(e) { return this.queue(e || 'fx', []); }, promise(e, t) { let n; let r = 1; const i = ke.Deferred(); const o = this; let a = this.length; const s = function () { --r || i.resolveWith(o, [o]); }; for (typeof e !== 'string' && (t = e, e = void 0), e = e || 'fx'; a--;)(n = qe.get(o[a], `${e}queueHooks`)) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t); },
    }); const Ge = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source; var Ze = new RegExp(`^(?:([+-])=|)(${Ge})([a-z%]*)$`, 'i'); var Ke = ['Top', 'Right', 'Bottom', 'Left']; var Xe = function (e, t) { return e = t || e, e.style.display === 'none' || e.style.display === '' && ke.contains(e.ownerDocument, e) && ke.css(e, 'display') === 'none'; }; const Ye = function (e, t, n, r) { let i; let o; const a = {}; for (o in t)a[o] = e.style[o], e.style[o] = t[o]; i = n.apply(e, r || []); for (o in t)e.style[o] = a[o]; return i; }; var Je = {}; ke.fn.extend({ show() { return T(this, !0); }, hide() { return T(this); }, toggle(e) { return typeof e === 'boolean' ? e ? this.show() : this.hide() : this.each(function () { Xe(this) ? ke(this).show() : ke(this).hide(); }); } }); var Qe = /^(?:checkbox|radio)$/i; var et = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i; var tt = /^$|^module$|\/(?:java|ecma)script/i; var nt = {
      option: [1, "<select multiple='multiple'>", '</select>'], thead: [1, '<table>', '</table>'], col: [2, '<table><colgroup>', '</colgroup></table>'], tr: [2, '<table><tbody>', '</tbody></table>'], td: [3, '<table><tbody><tr>', '</tr></tbody></table>'], _default: [0, '', ''],
    }; nt.optgroup = nt.option, nt.tbody = nt.tfoot = nt.colgroup = nt.caption = nt.thead, nt.th = nt.td; var rt = /<|&#?\w+;/; !(function () { const e = ce.createDocumentFragment(); const t = e.appendChild(ce.createElement('div')); const n = ce.createElement('input'); n.setAttribute('type', 'radio'), n.setAttribute('checked', 'checked'), n.setAttribute('name', 't'), t.appendChild(n), xe.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = '<textarea>x</textarea>', xe.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue; }()); const it = ce.documentElement; const ot = /^key/; const at = /^(?:mouse|pointer|contextmenu|drag|drop)|click/; const st = /^([^.]*)(?:\.(.+)|)/; ke.event = {
      global: {},
      add(e, t, n, r, i) {
        let o; let a; let s; let l; let u; let c; let p; let f; let h; let d; let m; const g = qe.get(e); if (g) {
          for (n.handler && (o = n, n = o.handler, i = o.selector), i && ke.find.matchesSelector(it, i), n.guid || (n.guid = ke.guid++), (l = g.events) || (l = g.events = {}), (a = g.handle) || (a = g.handle = function (t) { return typeof ke !== 'undefined' && ke.event.triggered !== t.type ? ke.event.dispatch.apply(e, arguments) : void 0; }), t = (t || '').match(ze) || [''], u = t.length; u--;) {
 s = st.exec(t[u]) || [], h = m = s[1], d = (s[2] || '').split('.').sort(), h && (p = ke.event.special[h] || {}, h = (i ? p.delegateType : p.bindType) || h, p = ke.event.special[h] || {}, c = ke.extend({
            type: h, origType: m, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && ke.expr.match.needsContext.test(i), namespace: d.join('.'),
          }, o), (f = l[h]) || (f = l[h] = [], f.delegateCount = 0, p.setup && !1 !== p.setup.call(e, r, d, a) || e.addEventListener && e.addEventListener(h, a)), p.add && (p.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? f.splice(f.delegateCount++, 0, c) : f.push(c), ke.event.global[h] = !0);
          } 
}
      },
      remove(e, t, n, r, i) { let o; let a; let s; let l; let u; let c; let p; let f; let h; let d; let m; const g = qe.hasData(e) && qe.get(e); if (g && (l = g.events)) { for (t = (t || '').match(ze) || [''], u = t.length; u--;) if (s = st.exec(t[u]) || [], h = m = s[1], d = (s[2] || '').split('.').sort(), h) { for (p = ke.event.special[h] || {}, h = (r ? p.delegateType : p.bindType) || h, f = l[h] || [], s = s[2] && new RegExp(`(^|\\.)${d.join('\\.(?:.*\\.|)')}(\\.|$)`), a = o = f.length; o--;)c = f[o], !i && m !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && (r !== '**' || !c.selector) || (f.splice(o, 1), c.selector && f.delegateCount--, p.remove && p.remove.call(e, c)); a && !f.length && (p.teardown && !1 !== p.teardown.call(e, d, g.handle) || ke.removeEvent(e, h, g.handle), delete l[h]); } else for (h in l)ke.event.remove(e, h + t[u], n, r, !0); ke.isEmptyObject(l) && qe.remove(e, 'handle events'); } },
      dispatch(e) { let t; let n; let r; let i; let o; let a; const s = ke.event.fix(e); const l = new Array(arguments.length); const u = (qe.get(this, 'events') || {})[s.type] || []; const c = ke.event.special[s.type] || {}; for (l[0] = s, t = 1; t < arguments.length; t++)l[t] = arguments[t]; if (s.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, s)) { for (a = ke.event.handlers.call(this, s, u), t = 0; (i = a[t++]) && !s.isPropagationStopped();) for (s.currentTarget = i.elem, n = 0; (o = i.handlers[n++]) && !s.isImmediatePropagationStopped();)s.rnamespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (r = ((ke.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, l)) && !1 === (s.result = r) && (s.preventDefault(), s.stopPropagation())); return c.postDispatch && c.postDispatch.call(this, s), s.result; } },
      handlers(e, t) { let n; let r; let i; let o; let a; const s = []; const l = t.delegateCount; let u = e.target; if (l && u.nodeType && !(e.type === 'click' && e.button >= 1)) for (;u !== this; u = u.parentNode || this) if (u.nodeType === 1 && (e.type !== 'click' || !0 !== u.disabled)) { for (o = [], a = {}, n = 0; n < l; n++)r = t[n], i = `${r.selector} `, void 0 === a[i] && (a[i] = r.needsContext ? ke(i, this).index(u) > -1 : ke.find(i, this, null, [u]).length), a[i] && o.push(r); o.length && s.push({ elem: u, handlers: o }); } return u = this, l < t.length && s.push({ elem: u, handlers: t.slice(l) }), s; },
      addProp(e, t) {
        Object.defineProperty(ke.Event.prototype, e, {
          enumerable: !0,
          configurable: !0,
          get: we(t) ? function () { if (this.originalEvent) return t(this.originalEvent); } : function () { if (this.originalEvent) return this.originalEvent[e]; },
          set(t) {
            Object.defineProperty(this, e, {
              enumerable: !0, configurable: !0, writable: !0, value: t,
            });
          },
        });
      },
      fix(e) { return e[ke.expando] ? e : new ke.Event(e); },
      special: {
        load: { noBubble: !0 }, focus: { trigger() { if (this !== I() && this.focus) return this.focus(), !1; }, delegateType: 'focusin' }, blur: { trigger() { if (this === I() && this.blur) return this.blur(), !1; }, delegateType: 'focusout' }, click: { trigger() { if (this.type === 'checkbox' && this.click && u(this, 'input')) return this.click(), !1; }, _default(e) { return u(e.target, 'a'); } }, beforeunload: { postDispatch(e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result); } },
      },
    }, ke.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n); }, ke.Event = function (e, t) { if (!(this instanceof ke.Event)) return new ke.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? A : O, this.target = e.target && e.target.nodeType === 3 ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && ke.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[ke.expando] = !0; }, ke.Event.prototype = {
      constructor: ke.Event, isDefaultPrevented: O, isPropagationStopped: O, isImmediatePropagationStopped: O, isSimulated: !1, preventDefault() { const e = this.originalEvent; this.isDefaultPrevented = A, e && !this.isSimulated && e.preventDefault(); }, stopPropagation() { const e = this.originalEvent; this.isPropagationStopped = A, e && !this.isSimulated && e.stopPropagation(); }, stopImmediatePropagation() { const e = this.originalEvent; this.isImmediatePropagationStopped = A, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation(); },
    }, ke.each({
      altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which(e) { const t = e.button; return e.which == null && ot.test(e.type) ? e.charCode != null ? e.charCode : e.keyCode : !e.which && void 0 !== t && at.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which; },
    }, ke.event.addProp), ke.each({
      mouseenter: 'mouseover', mouseleave: 'mouseout', pointerenter: 'pointerover', pointerleave: 'pointerout',
    }, (e, t) => { ke.event.special[e] = { delegateType: t, bindType: t, handle(e) { let n; const r = this; const i = e.relatedTarget; const o = e.handleObj; return i && (i === r || ke.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n; } }; }), ke.fn.extend({ on(e, t, n, r) { return P(this, e, t, n, r); }, one(e, t, n, r) { return P(this, e, t, n, r, 1); }, off(e, t, n) { let r; let i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, ke(e.delegateTarget).off(r.namespace ? `${r.origType}.${r.namespace}` : r.origType, r.selector, r.handler), this; if (typeof e === 'object') { for (i in e) this.off(i, t, e[i]); return this; } return !1 !== t && typeof t !== 'function' || (n = t, t = void 0), !1 === n && (n = O), this.each(function () { ke.event.remove(this, e, n, t); }); } }); const lt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi; const ut = /<script|<style|<link/i; var ct = /checked\s*(?:[^=]|=\s*.checked.)/i; var pt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; ke.extend({ htmlPrefilter(e) { return e.replace(lt, '<$1></$2>'); }, clone(e, t, n) { let r; let i; let o; let a; const s = e.cloneNode(!0); const l = ke.contains(e.ownerDocument, e); if (!xe.noCloneChecked && (e.nodeType === 1 || e.nodeType === 11) && !ke.isXMLDoc(e)) for (a = k(s), o = k(e), r = 0, i = o.length; r < i; r++)z(o[r], a[r]); if (t) if (n) for (o = o || k(e), a = a || k(s), r = 0, i = o.length; r < i; r++)L(o[r], a[r]); else L(e, s); return a = k(s, 'script'), a.length > 0 && C(a, !l && k(e, 'script')), s; }, cleanData(e) { for (var t, n, r, i = ke.event.special, o = 0; void 0 !== (n = e[o]); o++) if (Ve(n)) { if (t = n[qe.expando]) { if (t.events) for (r in t.events)i[r] ? ke.event.remove(n, r) : ke.removeEvent(n, r, t.handle); n[qe.expando] = void 0; }n[He.expando] && (n[He.expando] = void 0); } } }), ke.fn.extend({
      detach(e) { return j(this, e, !0); }, remove(e) { return j(this, e); }, text(e) { return Be(this, function (e) { return void 0 === e ? ke.text(this) : this.empty().each(function () { this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || (this.textContent = e); }); }, null, e, arguments.length); }, append() { return R(this, arguments, function (e) { if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) { M(this, e).appendChild(e); } }); }, prepend() { return R(this, arguments, function (e) { if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) { const t = M(this, e); t.insertBefore(e, t.firstChild); } }); }, before() { return R(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this); }); }, after() { return R(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling); }); }, empty() { for (var e, t = 0; (e = this[t]) != null; t++)e.nodeType === 1 && (ke.cleanData(k(e, !1)), e.textContent = ''); return this; }, clone(e, t) { return e = e != null && e, t = t == null ? e : t, this.map(function () { return ke.clone(this, e, t); }); }, html(e) { return Be(this, function (e) { let t = this[0] || {}; let n = 0; const r = this.length; if (void 0 === e && t.nodeType === 1) return t.innerHTML; if (typeof e === 'string' && !ut.test(e) && !nt[(et.exec(e) || ['', ''])[1].toLowerCase()]) { e = ke.htmlPrefilter(e); try { for (;n < r; n++)t = this[n] || {}, t.nodeType === 1 && (ke.cleanData(k(t, !1)), t.innerHTML = e); t = 0; } catch (e) {} }t && this.empty().append(e); }, null, e, arguments.length); }, replaceWith() { const e = []; return R(this, arguments, function (t) { const n = this.parentNode; ke.inArray(this, e) < 0 && (ke.cleanData(k(this)), n && n.replaceChild(t, this)); }, e); },
    }), ke.each({
      appendTo: 'append', prependTo: 'prepend', insertBefore: 'before', insertAfter: 'after', replaceAll: 'replaceWith',
    }, (e, t) => { ke.fn[e] = function (e) { for (var n, r = [], i = ke(e), o = i.length - 1, a = 0; a <= o; a++)n = a === o ? this : this.clone(!0), ke(i[a])[t](n), de.apply(r, n.get()); return this.pushStack(r); }; }); var ft = new RegExp(`^(${Ge})(?!px)[a-z%]+$`, 'i'); var ht = function (e) { let t = e.ownerDocument.defaultView; return t && t.opener || (t = n), t.getComputedStyle(e); }; var dt = new RegExp(Ke.join('|'), 'i'); !(function () {
      function e() { if (u) { l.style.cssText = 'position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0', u.style.cssText = 'position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%', it.appendChild(l).appendChild(u); const e = n.getComputedStyle(u); r = e.top !== '1%', s = t(e.marginLeft) === 12, u.style.right = '60%', a = t(e.right) === 36, i = t(e.width) === 36, u.style.position = 'absolute', o = u.offsetWidth === 36 || 'absolute', it.removeChild(l), u = null; } } function t(e) { return Math.round(parseFloat(e)); } let r; let i; let o; let a; let s; var l = ce.createElement('div'); var u = ce.createElement('div'); u.style && (u.style.backgroundClip = 'content-box', u.cloneNode(!0).style.backgroundClip = '', xe.clearCloneStyle = u.style.backgroundClip === 'content-box', ke.extend(xe, {
        boxSizingReliable() { return e(), i; }, pixelBoxStyles() { return e(), a; }, pixelPosition() { return e(), r; }, reliableMarginLeft() { return e(), s; }, scrollboxSize() { return e(), o; },
      }));
    }()); const mt = /^(none|table(?!-c[ea]).+)/; const gt = /^--/; const yt = { position: 'absolute', visibility: 'hidden', display: 'block' }; const vt = { letterSpacing: '0', fontWeight: '400' }; var _t = ['Webkit', 'Moz', 'ms']; var bt = ce.createElement('div').style; ke.extend({
      cssHooks: { opacity: { get(e, t) { if (t) { const n = B(e, 'opacity'); return n === '' ? '1' : n; } } } },
      cssNumber: {
        animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0,
      },
      cssProps: {},
      style(e, t, n, r) { if (e && e.nodeType !== 3 && e.nodeType !== 8 && e.style) { let i; let o; let a; const s = v(t); const l = gt.test(t); const u = e.style; if (l || (t = V(s)), a = ke.cssHooks[t] || ke.cssHooks[s], void 0 === n) return a && 'get' in a && void 0 !== (i = a.get(e, !1, r)) ? i : u[t]; o = typeof n, o === 'string' && (i = Ze.exec(n)) && i[1] && (n = w(e, t, i), o = 'number'), n != null && n === n && (o === 'number' && (n += i && i[3] || (ke.cssNumber[s] ? '' : 'px')), xe.clearCloneStyle || n !== '' || t.indexOf('background') !== 0 || (u[t] = 'inherit'), a && 'set' in a && void 0 === (n = a.set(e, n, r)) || (l ? u.setProperty(t, n) : u[t] = n)); } },
      css(e, t, n, r) { let i; let o; let a; const s = v(t); return gt.test(t) || (t = V(s)), a = ke.cssHooks[t] || ke.cssHooks[s], a && 'get' in a && (i = a.get(e, !0, n)), void 0 === i && (i = B(e, t, r)), i === 'normal' && t in vt && (i = vt[t]), n === '' || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i; },
    }), ke.each(['height', 'width'], (e, t) => { ke.cssHooks[t] = { get(e, n, r) { if (n) return !mt.test(ke.css(e, 'display')) || e.getClientRects().length && e.getBoundingClientRect().width ? W(e, t, r) : Ye(e, yt, () => W(e, t, r)); }, set(e, n, r) { let i; const o = ht(e); const a = ke.css(e, 'boxSizing', !1, o) === 'border-box'; let s = r && H(e, t, r, a, o); return a && xe.scrollboxSize() === o.position && (s -= Math.ceil(e[`offset${t[0].toUpperCase()}${t.slice(1)}`] - parseFloat(o[t]) - H(e, t, 'border', !1, o) - 0.5)), s && (i = Ze.exec(n)) && (i[3] || 'px') !== 'px' && (e.style[t] = n, n = ke.css(e, t)), q(e, n, s); } }; }), ke.cssHooks.marginLeft = F(xe.reliableMarginLeft, (e, t) => { if (t) return `${parseFloat(B(e, 'marginLeft')) || e.getBoundingClientRect().left - Ye(e, { marginLeft: 0 }, () => e.getBoundingClientRect().left)}px`; }), ke.each({ margin: '', padding: '', border: 'Width' }, (e, t) => { ke.cssHooks[e + t] = { expand(n) { for (var r = 0, i = {}, o = typeof n === 'string' ? n.split(' ') : [n]; r < 4; r++)i[e + Ke[r] + t] = o[r] || o[r - 2] || o[0]; return i; } }, e !== 'margin' && (ke.cssHooks[e + t].set = q); }), ke.fn.extend({ css(e, t) { return Be(this, (e, t, n) => { let r; let i; const o = {}; let a = 0; if (Array.isArray(t)) { for (r = ht(e), i = t.length; a < i; a++)o[t[a]] = ke.css(e, t[a], !1, r); return o; } return void 0 !== n ? ke.style(e, t, n) : ke.css(e, t); }, e, t, arguments.length > 1); } }), ke.Tween = $, $.prototype = {
      constructor: $, init(e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || ke.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (ke.cssNumber[n] ? '' : 'px'); }, cur() { const e = $.propHooks[this.prop]; return e && e.get ? e.get(this) : $.propHooks._default.get(this); }, run(e) { let t; const n = $.propHooks[this.prop]; return this.options.duration ? this.pos = t = ke.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : $.propHooks._default.set(this), this; },
    }, $.prototype.init.prototype = $.prototype, $.propHooks = { _default: { get(e) { let t; return e.elem.nodeType !== 1 || e.elem[e.prop] != null && e.elem.style[e.prop] == null ? e.elem[e.prop] : (t = ke.css(e.elem, e.prop, ''), t && t !== 'auto' ? t : 0); }, set(e) { ke.fx.step[e.prop] ? ke.fx.step[e.prop](e) : e.elem.nodeType !== 1 || e.elem.style[ke.cssProps[e.prop]] == null && !ke.cssHooks[e.prop] ? e.elem[e.prop] = e.now : ke.style(e.elem, e.prop, e.now + e.unit); } } }, $.propHooks.scrollTop = $.propHooks.scrollLeft = { set(e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now); } }, ke.easing = { linear(e) { return e; }, swing(e) { return 0.5 - Math.cos(e * Math.PI) / 2; }, _default: 'swing' }, ke.fx = $.prototype.init, ke.fx.step = {}; let xt; let wt; var Et = /^(?:toggle|show|hide)$/; const Tt = /queueHooks$/; ke.Animation = ke.extend(Q, {
      tweeners: { '*': [function (e, t) { const n = this.createTween(e, t); return w(n.elem, e, Ze.exec(t), n), n; }] }, tweener(e, t) { we(e) ? (t = e, e = ['*']) : e = e.match(ze); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], Q.tweeners[n] = Q.tweeners[n] || [], Q.tweeners[n].unshift(t); }, prefilters: [Y], prefilter(e, t) { t ? Q.prefilters.unshift(e) : Q.prefilters.push(e); },
    }), ke.speed = function (e, t, n) { const r = e && typeof e === 'object' ? ke.extend({}, e) : { complete: n || !n && t || we(e) && e, duration: e, easing: n && t || t && !we(t) && t }; return ke.fx.off ? r.duration = 0 : typeof r.duration !== 'number' && (r.duration in ke.fx.speeds ? r.duration = ke.fx.speeds[r.duration] : r.duration = ke.fx.speeds._default), r.queue != null && !0 !== r.queue || (r.queue = 'fx'), r.old = r.complete, r.complete = function () { we(r.old) && r.old.call(this), r.queue && ke.dequeue(this, r.queue); }, r; }, ke.fn.extend({
      fadeTo(e, t, n, r) {
        return this.filter(Xe).css('opacity', 0).show().end()
          .animate({ opacity: t }, e, n, r);
      },
      animate(e, t, n, r) { const i = ke.isEmptyObject(e); const o = ke.speed(t, n, r); const a = function () { const t = Q(this, ke.extend({}, e), o); (i || qe.get(this, 'finish')) && t.stop(!0); }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a); },
      stop(e, t, n) { const r = function (e) { const t = e.stop; delete e.stop, t(n); }; return typeof e !== 'string' && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || 'fx', []), this.each(function () { let t = !0; let i = e != null && `${e}queueHooks`; const o = ke.timers; const a = qe.get(this); if (i)a[i] && a[i].stop && r(a[i]); else for (i in a)a[i] && a[i].stop && Tt.test(i) && r(a[i]); for (i = o.length; i--;)o[i].elem !== this || e != null && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1)); !t && n || ke.dequeue(this, e); }); },
      finish(e) { return !1 !== e && (e = e || 'fx'), this.each(function () { let t; const n = qe.get(this); const r = n[`${e}queue`]; const i = n[`${e}queueHooks`]; const o = ke.timers; const a = r ? r.length : 0; for (n.finish = !0, ke.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;)o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; t < a; t++)r[t] && r[t].finish && r[t].finish.call(this); delete n.finish; }); },
    }), ke.each(['toggle', 'show', 'hide'], (e, t) => { const n = ke.fn[t]; ke.fn[t] = function (e, r, i) { return e == null || typeof e === 'boolean' ? n.apply(this, arguments) : this.animate(K(t, !0), e, r, i); }; }), ke.each({
      slideDown: K('show'), slideUp: K('hide'), slideToggle: K('toggle'), fadeIn: { opacity: 'show' }, fadeOut: { opacity: 'hide' }, fadeToggle: { opacity: 'toggle' },
    }, (e, t) => { ke.fn[e] = function (e, n, r) { return this.animate(t, e, n, r); }; }), ke.timers = [], ke.fx.tick = function () { let e; let t = 0; const n = ke.timers; for (xt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || ke.fx.stop(), xt = void 0; }, ke.fx.timer = function (e) { ke.timers.push(e), ke.fx.start(); }, ke.fx.interval = 13, ke.fx.start = function () { wt || (wt = !0, G()); }, ke.fx.stop = function () { wt = null; }, ke.fx.speeds = { slow: 600, fast: 200, _default: 400 }, ke.fn.delay = function (e, t) { return e = ke.fx ? ke.fx.speeds[e] || e : e, t = t || 'fx', this.queue(t, (t, r) => { const i = n.setTimeout(t, e); r.stop = function () { n.clearTimeout(i); }; }); }, (function () { let e = ce.createElement('input'); const t = ce.createElement('select'); const n = t.appendChild(ce.createElement('option')); e.type = 'checkbox', xe.checkOn = e.value !== '', xe.optSelected = n.selected, e = ce.createElement('input'), e.value = 't', e.type = 'radio', xe.radioValue = e.value === 't'; }()); let kt; const Ct = ke.expr.attrHandle; ke.fn.extend({ attr(e, t) { return Be(this, ke.attr, e, t, arguments.length > 1); }, removeAttr(e) { return this.each(function () { ke.removeAttr(this, e); }); } }), ke.extend({ attr(e, t, n) { let r; let i; const o = e.nodeType; if (o !== 3 && o !== 8 && o !== 2) return typeof e.getAttribute === 'undefined' ? ke.prop(e, t, n) : (o === 1 && ke.isXMLDoc(e) || (i = ke.attrHooks[t.toLowerCase()] || (ke.expr.match.bool.test(t) ? kt : void 0)), void 0 !== n ? n === null ? void ke.removeAttr(e, t) : i && 'set' in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, `${n}`), n) : i && 'get' in i && (r = i.get(e, t)) !== null ? r : (r = ke.find.attr(e, t), r == null ? void 0 : r)); }, attrHooks: { type: { set(e, t) { if (!xe.radioValue && t === 'radio' && u(e, 'input')) { const n = e.value; return e.setAttribute('type', t), n && (e.value = n), t; } } } }, removeAttr(e, t) { let n; let r = 0; const i = t && t.match(ze); if (i && e.nodeType === 1) for (;n = i[r++];)e.removeAttribute(n); } }), kt = { set(e, t, n) { return !1 === t ? ke.removeAttr(e, n) : e.setAttribute(n, n), n; } }, ke.each(ke.expr.match.bool.source.match(/\w+/g), (e, t) => { const n = Ct[t] || ke.find.attr; Ct[t] = function (e, t, r) { let i; let o; const a = t.toLowerCase(); return r || (o = Ct[a], Ct[a] = i, i = n(e, t, r) != null ? a : null, Ct[a] = o), i; }; }); const St = /^(?:input|select|textarea|button)$/i; const At = /^(?:a|area)$/i; ke.fn.extend({ prop(e, t) { return Be(this, ke.prop, e, t, arguments.length > 1); }, removeProp(e) { return this.each(function () { delete this[ke.propFix[e] || e]; }); } }), ke.extend({ prop(e, t, n) { let r; let i; const o = e.nodeType; if (o !== 3 && o !== 8 && o !== 2) return o === 1 && ke.isXMLDoc(e) || (t = ke.propFix[t] || t, i = ke.propHooks[t]), void 0 !== n ? i && 'set' in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && 'get' in i && (r = i.get(e, t)) !== null ? r : e[t]; }, propHooks: { tabIndex: { get(e) { const t = ke.find.attr(e, 'tabindex'); return t ? parseInt(t, 10) : St.test(e.nodeName) || At.test(e.nodeName) && e.href ? 0 : -1; } } }, propFix: { for: 'htmlFor', class: 'className' } }), xe.optSelected || (ke.propHooks.selected = { get(e) { const t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null; }, set(e) { const t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex); } }), ke.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () { ke.propFix[this.toLowerCase()] = this; }), ke.fn.extend({
      addClass(e) { let t; let n; let r; let i; let o; let a; let s; let l = 0; if (we(e)) return this.each(function (t) { ke(this).addClass(e.call(this, t, te(this))); }); if (t = ne(e), t.length) for (;n = this[l++];) if (i = te(n), r = n.nodeType === 1 && ` ${ee(i)} `) { for (a = 0; o = t[a++];)r.indexOf(` ${o} `) < 0 && (r += `${o} `); s = ee(r), i !== s && n.setAttribute('class', s); } return this; }, removeClass(e) { let t; let n; let r; let i; let o; let a; let s; let l = 0; if (we(e)) return this.each(function (t) { ke(this).removeClass(e.call(this, t, te(this))); }); if (!arguments.length) return this.attr('class', ''); if (t = ne(e), t.length) for (;n = this[l++];) if (i = te(n), r = n.nodeType === 1 && ` ${ee(i)} `) { for (a = 0; o = t[a++];) for (;r.indexOf(` ${o} `) > -1;)r = r.replace(` ${o} `, ' '); s = ee(r), i !== s && n.setAttribute('class', s); } return this; }, toggleClass(e, t) { const n = typeof e; const r = n === 'string' || Array.isArray(e); return typeof t === 'boolean' && r ? t ? this.addClass(e) : this.removeClass(e) : we(e) ? this.each(function (n) { ke(this).toggleClass(e.call(this, n, te(this), t), t); }) : this.each(function () { let t; let i; let o; let a; if (r) for (i = 0, o = ke(this), a = ne(e); t = a[i++];)o.hasClass(t) ? o.removeClass(t) : o.addClass(t); else void 0 !== e && n !== 'boolean' || (t = te(this), t && qe.set(this, '__className__', t), this.setAttribute && this.setAttribute('class', t || !1 === e ? '' : qe.get(this, '__className__') || '')); }); }, hasClass(e) { let t; let n; let r = 0; for (t = ` ${e} `; n = this[r++];) if (n.nodeType === 1 && (` ${ee(te(n))} `).indexOf(t) > -1) return !0; return !1; },
    }); const Ot = /\r/g; ke.fn.extend({ val(e) { let t; let n; let r; const i = this[0]; { if (arguments.length) return r = we(e), this.each(function (n) { let i; this.nodeType === 1 && (i = r ? e.call(this, n, ke(this).val()) : e, i == null ? i = '' : typeof i === 'number' ? i += '' : Array.isArray(i) && (i = ke.map(i, e => (e == null ? '' : `${e}`))), (t = ke.valHooks[this.type] || ke.valHooks[this.nodeName.toLowerCase()]) && 'set' in t && void 0 !== t.set(this, i, 'value') || (this.value = i)); }); if (i) return (t = ke.valHooks[i.type] || ke.valHooks[i.nodeName.toLowerCase()]) && 'get' in t && void 0 !== (n = t.get(i, 'value')) ? n : (n = i.value, typeof n === 'string' ? n.replace(Ot, '') : n == null ? '' : n); } } }), ke.extend({ valHooks: { option: { get(e) { const t = ke.find.attr(e, 'value'); return t != null ? t : ee(ke.text(e)); } }, select: { get(e) { let t; let n; let r; const i = e.options; const o = e.selectedIndex; const a = e.type === 'select-one'; const s = a ? null : []; const l = a ? o + 1 : i.length; for (r = o < 0 ? l : a ? o : 0; r < l; r++) if (n = i[r], (n.selected || r === o) && !n.disabled && (!n.parentNode.disabled || !u(n.parentNode, 'optgroup'))) { if (t = ke(n).val(), a) return t; s.push(t); } return s; }, set(e, t) { for (var n, r, i = e.options, o = ke.makeArray(t), a = i.length; a--;)r = i[a], (r.selected = ke.inArray(ke.valHooks.option.get(r), o) > -1) && (n = !0); return n || (e.selectedIndex = -1), o; } } } }), ke.each(['radio', 'checkbox'], function () { ke.valHooks[this] = { set(e, t) { if (Array.isArray(t)) return e.checked = ke.inArray(ke(e).val(), t) > -1; } }, xe.checkOn || (ke.valHooks[this].get = function (e) { return e.getAttribute('value') === null ? 'on' : e.value; }); }), xe.focusin = 'onfocusin' in n; const It = /^(?:focusinfocus|focusoutblur)$/; const Pt = function (e) { e.stopPropagation(); }; ke.extend(ke.event, { trigger(e, t, r, i) { let o; let a; let s; let l; let u; let c; let p; let f; const h = [r || ce]; let d = ve.call(e, 'type') ? e.type : e; let m = ve.call(e, 'namespace') ? e.namespace.split('.') : []; if (a = f = s = r = r || ce, r.nodeType !== 3 && r.nodeType !== 8 && !It.test(d + ke.event.triggered) && (d.indexOf('.') > -1 && (m = d.split('.'), d = m.shift(), m.sort()), u = d.indexOf(':') < 0 && `on${d}`, e = e[ke.expando] ? e : new ke.Event(d, typeof e === 'object' && e), e.isTrigger = i ? 2 : 3, e.namespace = m.join('.'), e.rnamespace = e.namespace ? new RegExp(`(^|\\.)${m.join('\\.(?:.*\\.|)')}(\\.|$)`) : null, e.result = void 0, e.target || (e.target = r), t = t == null ? [e] : ke.makeArray(t, [e]), p = ke.event.special[d] || {}, i || !p.trigger || !1 !== p.trigger.apply(r, t))) { if (!i && !p.noBubble && !Ee(r)) { for (l = p.delegateType || d, It.test(l + d) || (a = a.parentNode); a; a = a.parentNode)h.push(a), s = a; s === (r.ownerDocument || ce) && h.push(s.defaultView || s.parentWindow || n); } for (o = 0; (a = h[o++]) && !e.isPropagationStopped();)f = a, e.type = o > 1 ? l : p.bindType || d, c = (qe.get(a, 'events') || {})[e.type] && qe.get(a, 'handle'), c && c.apply(a, t), (c = u && a[u]) && c.apply && Ve(a) && (e.result = c.apply(a, t), !1 === e.result && e.preventDefault()); return e.type = d, i || e.isDefaultPrevented() || p._default && !1 !== p._default.apply(h.pop(), t) || !Ve(r) || u && we(r[d]) && !Ee(r) && (s = r[u], s && (r[u] = null), ke.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, Pt), r[d](), e.isPropagationStopped() && f.removeEventListener(d, Pt), ke.event.triggered = void 0, s && (r[u] = s)), e.result; } }, simulate(e, t, n) { const r = ke.extend(new ke.Event(), n, { type: e, isSimulated: !0 }); ke.event.trigger(r, null, t); } }), ke.fn.extend({ trigger(e, t) { return this.each(function () { ke.event.trigger(e, t, this); }); }, triggerHandler(e, t) { const n = this[0]; if (n) return ke.event.trigger(e, t, n, !0); } }), xe.focusin || ke.each({ focus: 'focusin', blur: 'focusout' }, (e, t) => { const n = function (e) { ke.event.simulate(t, e.target, ke.event.fix(e)); }; ke.event.special[t] = { setup() { const r = this.ownerDocument || this; const i = qe.access(r, t); i || r.addEventListener(e, n, !0), qe.access(r, t, (i || 0) + 1); }, teardown() { const r = this.ownerDocument || this; const i = qe.access(r, t) - 1; i ? qe.access(r, t, i) : (r.removeEventListener(e, n, !0), qe.remove(r, t)); } }; }); const Mt = n.location; let Nt = Date.now(); const Dt = /\?/; ke.parseXML = function (e) { let t; if (!e || typeof e !== 'string') return null; try { t = (new n.DOMParser()).parseFromString(e, 'text/xml'); } catch (e) { t = void 0; } return t && !t.getElementsByTagName('parsererror').length || ke.error(`Invalid XML: ${e}`), t; }; var Lt = /\[\]$/; const zt = /\r?\n/g; const Rt = /^(?:submit|button|image|reset|file)$/i; const jt = /^(?:input|select|textarea|keygen)/i; ke.param = function (e, t) { let n; const r = []; const i = function (e, t) { const n = we(t) ? t() : t; r[r.length] = `${encodeURIComponent(e)}=${encodeURIComponent(n == null ? '' : n)}`; }; if (Array.isArray(e) || e.jquery && !ke.isPlainObject(e))ke.each(e, function () { i(this.name, this.value); }); else for (n in e)re(n, e[n], t, i); return r.join('&'); }, ke.fn.extend({ serialize() { return ke.param(this.serializeArray()); }, serializeArray() { return this.map(function () { const e = ke.prop(this, 'elements'); return e ? ke.makeArray(e) : this; }).filter(function () { const e = this.type; return this.name && !ke(this).is(':disabled') && jt.test(this.nodeName) && !Rt.test(e) && (this.checked || !Qe.test(e)); }).map(function (e, t) { const n = ke(this).val(); return n == null ? null : Array.isArray(n) ? ke.map(n, e => ({ name: t.name, value: e.replace(zt, '\r\n') })) : { name: t.name, value: n.replace(zt, '\r\n') }; }).get(); } }); const Bt = /%20/g; const Ft = /#.*$/; const Ut = /([?&])_=[^&]*/; const Vt = /^(.*?):[ \t]*([^\r\n]*)$/gm; const qt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/; const Ht = /^(?:GET|HEAD)$/; const Wt = /^\/\//; const $t = {}; var Gt = {}; const Zt = '*/'.concat('*'); const Kt = ce.createElement('a'); Kt.href = Mt.href, ke.extend({
      active: 0,
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: Mt.href,
        type: 'GET',
        isLocal: qt.test(Mt.protocol),
        global: !0,
        processData: !0,
        async: !0,
        contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
        accepts: {
          '*': Zt, text: 'text/plain', html: 'text/html', xml: 'application/xml, text/xml', json: 'application/json, text/javascript',
        },
        contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ },
        responseFields: { xml: 'responseXML', text: 'responseText', json: 'responseJSON' },
        converters: {
          '* text': String, 'text html': !0, 'text json': JSON.parse, 'text xml': ke.parseXML,
        },
        flatOptions: { url: !0, context: !0 },
      },
      ajaxSetup(e, t) { return t ? ae(ae(e, ke.ajaxSettings), t) : ae(ke.ajaxSettings, e); },
      ajaxPrefilter: ie($t),
      ajaxTransport: ie(Gt),
      ajax(e, t) {
        function r(e, t, r, s) { let u; let f; let h; let b; let x; let w = t; c || (c = !0, l && n.clearTimeout(l), i = void 0, a = s || '', E.readyState = e > 0 ? 4 : 0, u = e >= 200 && e < 300 || e === 304, r && (b = se(d, E, r)), b = le(d, b, E, u), u ? (d.ifModified && (x = E.getResponseHeader('Last-Modified'), x && (ke.lastModified[o] = x), (x = E.getResponseHeader('etag')) && (ke.etag[o] = x)), e === 204 || d.type === 'HEAD' ? w = 'nocontent' : e === 304 ? w = 'notmodified' : (w = b.state, f = b.data, h = b.error, u = !h)) : (h = w, !e && w || (w = 'error', e < 0 && (e = 0))), E.status = e, E.statusText = `${t || w}`, u ? y.resolveWith(m, [f, w, E]) : y.rejectWith(m, [E, w, h]), E.statusCode(_), _ = void 0, p && g.trigger(u ? 'ajaxSuccess' : 'ajaxError', [E, d, u ? f : h]), v.fireWith(m, [E, w]), p && (g.trigger('ajaxComplete', [E, d]), --ke.active || ke.event.trigger('ajaxStop'))); } typeof e === 'object' && (t = e, e = void 0), t = t || {}; let i; let o; let a; let s; let l; let u; let c; let p; let f; let h; var d = ke.ajaxSetup({}, t); var m = d.context || d; var g = d.context && (m.nodeType || m.jquery) ? ke(m) : ke.event; var y = ke.Deferred(); var v = ke.Callbacks('once memory'); var _ = d.statusCode || {}; const b = {}; const x = {}; let w = 'canceled'; var E = {
          readyState: 0, getResponseHeader(e) { let t; if (c) { if (!s) for (s = {}; t = Vt.exec(a);)s[t[1].toLowerCase()] = t[2]; t = s[e.toLowerCase()]; } return t == null ? null : t; }, getAllResponseHeaders() { return c ? a : null; }, setRequestHeader(e, t) { return c == null && (e = x[e.toLowerCase()] = x[e.toLowerCase()] || e, b[e] = t), this; }, overrideMimeType(e) { return c == null && (d.mimeType = e), this; }, statusCode(e) { let t; if (e) if (c)E.always(e[E.status]); else for (t in e)_[t] = [_[t], e[t]]; return this; }, abort(e) { const t = e || w; return i && i.abort(t), r(0, t), this; },
        }; if (y.promise(E), d.url = (`${e || d.url || Mt.href}`).replace(Wt, `${Mt.protocol}//`), d.type = t.method || t.type || d.method || d.type, d.dataTypes = (d.dataType || '*').toLowerCase().match(ze) || [''], d.crossDomain == null) { u = ce.createElement('a'); try { u.href = d.url, u.href = u.href, d.crossDomain = `${Kt.protocol}//${Kt.host}` !== `${u.protocol}//${u.host}`; } catch (e) { d.crossDomain = !0; } } if (d.data && d.processData && typeof d.data !== 'string' && (d.data = ke.param(d.data, d.traditional)), oe($t, d, t, E), c) return E; p = ke.event && d.global, p && ke.active++ === 0 && ke.event.trigger('ajaxStart'), d.type = d.type.toUpperCase(), d.hasContent = !Ht.test(d.type), o = d.url.replace(Ft, ''), d.hasContent ? d.data && d.processData && (d.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && (d.data = d.data.replace(Bt, '+')) : (h = d.url.slice(o.length), d.data && (d.processData || typeof d.data === 'string') && (o += (Dt.test(o) ? '&' : '?') + d.data, delete d.data), !1 === d.cache && (o = o.replace(Ut, '$1'), h = `${Dt.test(o) ? '&' : '?'}_=${Nt++}${h}`), d.url = o + h), d.ifModified && (ke.lastModified[o] && E.setRequestHeader('If-Modified-Since', ke.lastModified[o]), ke.etag[o] && E.setRequestHeader('If-None-Match', ke.etag[o])), (d.data && d.hasContent && !1 !== d.contentType || t.contentType) && E.setRequestHeader('Content-Type', d.contentType), E.setRequestHeader('Accept', d.dataTypes[0] && d.accepts[d.dataTypes[0]] ? d.accepts[d.dataTypes[0]] + (d.dataTypes[0] !== '*' ? `, ${Zt}; q=0.01` : '') : d.accepts['*']); for (f in d.headers)E.setRequestHeader(f, d.headers[f]); if (d.beforeSend && (!1 === d.beforeSend.call(m, E, d) || c)) return E.abort(); if (w = 'abort', v.add(d.complete), E.done(d.success), E.fail(d.error), i = oe(Gt, d, t, E)) { if (E.readyState = 1, p && g.trigger('ajaxSend', [E, d]), c) return E; d.async && d.timeout > 0 && (l = n.setTimeout(() => { E.abort('timeout'); }, d.timeout)); try { c = !1, i.send(b, r); } catch (e) { if (c) throw e; r(-1, e); } } else r(-1, 'No Transport'); return E;
      },
      getJSON(e, t, n) { return ke.get(e, t, n, 'json'); },
      getScript(e, t) { return ke.get(e, void 0, t, 'script'); },
    }), ke.each(['get', 'post'], (e, t) => {
      ke[t] = function (e, n, r, i) {
        return we(n) && (i = i || r, r = n, n = void 0), ke.ajax(ke.extend({
          url: e, type: t, dataType: i, data: n, success: r,
        }, ke.isPlainObject(e) && e));
      };
    }), ke._evalUrl = function (e) {
      return ke.ajax({
        url: e, type: 'GET', dataType: 'script', cache: !0, async: !1, global: !1, throws: !0,
      });
    }, ke.fn.extend({
      wrapAll(e) { let t; return this[0] && (we(e) && (e = e.call(this[0])), t = ke(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { for (var e = this; e.firstElementChild;)e = e.firstElementChild; return e; }).append(this)), this; }, wrapInner(e) { return we(e) ? this.each(function (t) { ke(this).wrapInner(e.call(this, t)); }) : this.each(function () { const t = ke(this); const n = t.contents(); n.length ? n.wrapAll(e) : t.append(e); }); }, wrap(e) { const t = we(e); return this.each(function (n) { ke(this).wrapAll(t ? e.call(this, n) : e); }); }, unwrap(e) { return this.parent(e).not('body').each(function () { ke(this).replaceWith(this.childNodes); }), this; },
    }), ke.expr.pseudos.hidden = function (e) { return !ke.expr.pseudos.visible(e); }, ke.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length); }, ke.ajaxSettings.xhr = function () { try { return new n.XMLHttpRequest(); } catch (e) {} }; const Xt = { 0: 200, 1223: 204 }; let Yt = ke.ajaxSettings.xhr(); xe.cors = !!Yt && 'withCredentials' in Yt, xe.ajax = Yt = !!Yt, ke.ajaxTransport((e) => { let t; let r; if (xe.cors || Yt && !e.crossDomain) return { send(i, o) { let a; const s = e.xhr(); if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (a in e.xhrFields)s[a] = e.xhrFields[a]; e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || i['X-Requested-With'] || (i['X-Requested-With'] = 'XMLHttpRequest'); for (a in i)s.setRequestHeader(a, i[a]); t = function (e) { return function () { t && (t = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, e === 'abort' ? s.abort() : e === 'error' ? typeof s.status !== 'number' ? o(0, 'error') : o(s.status, s.statusText) : o(Xt[s.status] || s.status, s.statusText, (s.responseType || 'text') !== 'text' || typeof s.responseText !== 'string' ? { binary: s.response } : { text: s.responseText }, s.getAllResponseHeaders())); }; }, s.onload = t(), r = s.onerror = s.ontimeout = t('error'), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function () { s.readyState === 4 && n.setTimeout(() => { t && r(); }); }, t = t('abort'); try { s.send(e.hasContent && e.data || null); } catch (e) { if (t) throw e; } }, abort() { t && t(); } }; }), ke.ajaxPrefilter((e) => { e.crossDomain && (e.contents.script = !1); }), ke.ajaxSetup({ accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { 'text script': function (e) { return ke.globalEval(e), e; } } }), ke.ajaxPrefilter('script', (e) => { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = 'GET'); }), ke.ajaxTransport('script', (e) => { if (e.crossDomain) { let t; let n; return { send(r, i) { t = ke('<script>').prop({ charset: e.scriptCharset, src: e.url }).on('load error', n = function (e) { t.remove(), n = null, e && i(e.type === 'error' ? 404 : 200, e.type); }), ce.head.appendChild(t[0]); }, abort() { n && n(); } }; } }); const Jt = []; const Qt = /(=)\?(?=&|$)|\?\?/; ke.ajaxSetup({ jsonp: 'callback', jsonpCallback() { const e = Jt.pop() || `${ke.expando}_${Nt++}`; return this[e] = !0, e; } }), ke.ajaxPrefilter('json jsonp', (e, t, r) => { let i; let o; let a; const s = !1 !== e.jsonp && (Qt.test(e.url) ? 'url' : typeof e.data === 'string' && (e.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && Qt.test(e.data) && 'data'); if (s || e.dataTypes[0] === 'jsonp') return i = e.jsonpCallback = we(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, s ? e[s] = e[s].replace(Qt, `$1${i}`) : !1 !== e.jsonp && (e.url += `${(Dt.test(e.url) ? '&' : '?') + e.jsonp}=${i}`), e.converters['script json'] = function () { return a || ke.error(`${i} was not called`), a[0]; }, e.dataTypes[0] = 'json', o = n[i], n[i] = function () { a = arguments; }, r.always(() => { void 0 === o ? ke(n).removeProp(i) : n[i] = o, e[i] && (e.jsonpCallback = t.jsonpCallback, Jt.push(i)), a && we(o) && o(a[0]), a = o = void 0; }), 'script'; }), xe.createHTMLDocument = (function () { const e = ce.implementation.createHTMLDocument('').body; return e.innerHTML = '<form></form><form></form>', e.childNodes.length === 2; }()), ke.parseHTML = function (e, t, n) { if (typeof e !== 'string') return []; typeof t === 'boolean' && (n = t, t = !1); let r; let i; let o; return t || (xe.createHTMLDocument ? (t = ce.implementation.createHTMLDocument(''), r = t.createElement('base'), r.href = ce.location.href, t.head.appendChild(r)) : t = ce), i = Pe.exec(e), o = !n && [], i ? [t.createElement(i[1])] : (i = S([e], t, o), o && o.length && ke(o).remove(), ke.merge([], i.childNodes)); }, ke.fn.load = function (e, t, n) {
      let r; let i; let o; const a = this; const s = e.indexOf(' '); return s > -1 && (r = ee(e.slice(s)), e = e.slice(0, s)), we(t) ? (n = t, t = void 0) : t && typeof t === 'object' && (i = 'POST'), a.length > 0 && ke.ajax({
        url: e, type: i || 'GET', dataType: 'html', data: t,
      }).done(function (e) { o = arguments, a.html(r ? ke('<div>').append(ke.parseHTML(e)).find(r) : e); }).always(n && ((e, t) => { a.each(function () { n.apply(this, o || [e.responseText, t, e]); }); })), this;
    }, ke.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], (e, t) => { ke.fn[t] = function (e) { return this.on(t, e); }; }), ke.expr.pseudos.animated = function (e) { return ke.grep(ke.timers, t => e === t.elem).length; }, ke.offset = { setOffset(e, t, n) { let r; let i; let o; let a; let s; let l; let u; const c = ke.css(e, 'position'); const p = ke(e); const f = {}; c === 'static' && (e.style.position = 'relative'), s = p.offset(), o = ke.css(e, 'top'), l = ke.css(e, 'left'), u = (c === 'absolute' || c === 'fixed') && (o + l).indexOf('auto') > -1, u ? (r = p.position(), a = r.top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(l) || 0), we(t) && (t = t.call(e, n, ke.extend({}, s))), t.top != null && (f.top = t.top - s.top + a), t.left != null && (f.left = t.left - s.left + i), 'using' in t ? t.using.call(e, f) : p.css(f); } }, ke.fn.extend({ offset(e) { if (arguments.length) return void 0 === e ? this : this.each(function (t) { ke.offset.setOffset(this, e, t); }); let t; let n; const r = this[0]; if (r) return r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 }; }, position() { if (this[0]) { let e; let t; let n; const r = this[0]; let i = { top: 0, left: 0 }; if (ke.css(r, 'position') === 'fixed')t = r.getBoundingClientRect(); else { for (t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && ke.css(e, 'position') === 'static';)e = e.parentNode; e && e !== r && e.nodeType === 1 && (i = ke(e).offset(), i.top += ke.css(e, 'borderTopWidth', !0), i.left += ke.css(e, 'borderLeftWidth', !0)); } return { top: t.top - i.top - ke.css(r, 'marginTop', !0), left: t.left - i.left - ke.css(r, 'marginLeft', !0) }; } }, offsetParent() { return this.map(function () { for (var e = this.offsetParent; e && ke.css(e, 'position') === 'static';)e = e.offsetParent; return e || it; }); } }), ke.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, (e, t) => { const n = t === 'pageYOffset'; ke.fn[e] = function (r) { return Be(this, (e, r, i) => { let o; if (Ee(e) ? o = e : e.nodeType === 9 && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r]; o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i; }, e, r, arguments.length); }; }), ke.each(['top', 'left'], (e, t) => { ke.cssHooks[t] = F(xe.pixelPosition, (e, n) => { if (n) return n = B(e, t), ft.test(n) ? `${ke(e).position()[t]}px` : n; }); }), ke.each({ Height: 'height', Width: 'width' }, (e, t) => { ke.each({ padding: `inner${e}`, content: t, '': `outer${e}` }, (n, r) => { ke.fn[r] = function (i, o) { const a = arguments.length && (n || typeof i !== 'boolean'); const s = n || (!0 === i || !0 === o ? 'margin' : 'border'); return Be(this, (t, n, i) => { let o; return Ee(t) ? r.indexOf('outer') === 0 ? t[`inner${e}`] : t.document.documentElement[`client${e}`] : t.nodeType === 9 ? (o = t.documentElement, Math.max(t.body[`scroll${e}`], o[`scroll${e}`], t.body[`offset${e}`], o[`offset${e}`], o[`client${e}`])) : void 0 === i ? ke.css(t, n, s) : ke.style(t, n, i, s); }, t, a ? i : void 0, a); }; }); }), ke.each('blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split(' '), (e, t) => { ke.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t); }; }), ke.fn.extend({ hover(e, t) { return this.mouseenter(e).mouseleave(t || e); } }), ke.fn.extend({
      bind(e, t, n) { return this.on(e, null, t, n); }, unbind(e, t) { return this.off(e, null, t); }, delegate(e, t, n, r) { return this.on(t, e, n, r); }, undelegate(e, t, n) { return arguments.length === 1 ? this.off(e, '**') : this.off(t, e || '**', n); },
    }), ke.proxy = function (e, t) { let n; let r; let i; if (typeof t === 'string' && (n = e[t], t = e, e = n), we(e)) return r = fe.call(arguments, 2), i = function () { return e.apply(t || this, r.concat(fe.call(arguments))); }, i.guid = e.guid = e.guid || ke.guid++, i; }, ke.holdReady = function (e) { e ? ke.readyWait++ : ke.ready(!0); }, ke.isArray = Array.isArray, ke.parseJSON = JSON.parse, ke.nodeName = u, ke.isFunction = we, ke.isWindow = Ee, ke.camelCase = v, ke.type = s, ke.now = Date.now, ke.isNumeric = function (e) { const t = ke.type(e); return (t === 'number' || t === 'string') && !isNaN(e - parseFloat(e)); }, r = [], void 0 !== (i = function () { return ke; }.apply(t, r)) && (e.exports = i); const en = n.jQuery; const tn = n.$; return ke.noConflict = function (e) { return n.$ === ke && (n.$ = tn), e && n.jQuery === ke && (n.jQuery = en), ke; }, o || (n.jQuery = n.$ = ke), ke;
  }));
}, function (e, t) {}, function (e, t) {}, function (e, t) {}]));
// # sourceMappingURL=main.3703ba6e.js.map
